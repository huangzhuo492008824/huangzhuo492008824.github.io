<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python中单例模式实现</title>
    <url>/2015-04-13.html</url>
    <content><![CDATA[<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># wrapper</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    format=<span class="string">'%(asctime)s %(name)-12s %(levelname)-8s %(message)s'</span>,</span><br><span class="line">                    datefmt=<span class="string">'%m-%d %H:%M'</span>)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'tts'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_func</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">'warning'</span>:</span><br><span class="line">                logger.warning(<span class="string">'enter func:&#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.info(<span class="string">'enter func:&#123;&#125;'</span>.format(func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log_func(level="warning")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name=<span class="string">'foo'</span>, k=<span class="string">'88'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'i am foo:&#123;&#125; k:&#123;&#125;'</span>.format(name, k)</span><br><span class="line">foo(name=<span class="string">'oo'</span>, k=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h4><h2 id="1-cls单例模式实现"><a href="#1-cls单例模式实现" class="headerlink" title="1. cls单例模式实现"></a>1. cls单例模式实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># singleton</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line">    <span class="keyword">return</span> innerr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls1 = Cls()</span><br><span class="line">cls2 = Cls()</span><br><span class="line"></span><br><span class="line">print(id(cls1) == id(cls2))</span><br></pre></td></tr></table></figure>

<h2 id="2-call实现"><a href="#2-call实现" class="headerlink" title="2. call实现"></a>2. <strong>call</strong>实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. __call__</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cls)</span>:</span></span><br><span class="line">        self._cls = cls</span><br><span class="line">        self._instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._cls <span class="keyword">not</span> <span class="keyword">in</span> self._instance:</span><br><span class="line">            self._instance[self._cls] = self._cls()</span><br><span class="line">        <span class="keyword">return</span> self._instance[self._cls]</span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">cls1 = Cls()</span><br><span class="line">cls2 = Cls()</span><br><span class="line">print(id(cls1) == id(cls2))</span><br></pre></td></tr></table></figure>

<h2 id="3-new实现单例"><a href="#3-new实现单例" class="headerlink" title="3. new实现单例"></a>3. <strong>new</strong>实现单例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonNew</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">single1 = SingletonNew()</span><br><span class="line">single2 = SingletonNew()</span><br><span class="line"><span class="keyword">print</span> id(single1) == id(single2)</span><br></pre></td></tr></table></figure>

<h1 id="4-metaclass单例实现"><a href="#4-metaclass单例实现" class="headerlink" title="4. metaclass单例实现"></a>4. metaclass单例实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span><span class="params">(type)</span>:</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instance:</span><br><span class="line">            cls._instance[cls] = super(Single, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance[cls]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = Single</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls1, cls2 = Cls(), Cls()</span><br><span class="line"><span class="keyword">print</span> id(cls1) == id(cls2)</span><br></pre></td></tr></table></figure>

<ul>
<li>个人比较推荐第一种和第二种实现方式:代码量较少，并且简单易懂</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>python四舍五入精度问题</title>
    <url>/2015-04-15.html</url>
    <content><![CDATA[<h3 id="python四舍五入中的坑"><a href="#python四舍五入中的坑" class="headerlink" title="python四舍五入中的坑"></a>python四舍五入中的坑</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(round(<span class="number">1.113</span>, <span class="number">2</span>))</span><br><span class="line">print(round(<span class="number">1.115</span>, <span class="number">2</span>))</span><br><span class="line">print(round(<span class="number">1.125</span>, <span class="number">2</span>))</span><br><span class="line">print(round(<span class="number">1.375</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">1.11</span></span><br><span class="line"><span class="number">1.11</span></span><br><span class="line"><span class="number">1.12</span></span><br><span class="line"><span class="number">1.38</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>round四舍五入时遇到进位为5的情况，就会导致不准确的情况，归根结底是计算机存储浮点数的问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">print(Decimal(<span class="number">1.113</span>))</span><br><span class="line">print(Decimal(<span class="number">1.115</span>))</span><br><span class="line">print(Decimal(<span class="number">1.125</span>))</span><br><span class="line">print(Decimal(<span class="number">1.375</span>))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">1.112999999999999989341858963598497211933135986328125</span></span><br><span class="line"><span class="number">1.1149999999999999911182158029987476766109466552734375</span></span><br><span class="line"><span class="number">1.125</span></span><br><span class="line"><span class="number">1.375</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方法：加上一个不影响四舍五入的小数</p>
<figure class="highlight plain"><figcaption><span>python</span></figcaption><table><tr><td class="code"><pre><span class="line">print(round(1.113+0.00000001, 2))</span><br><span class="line">print(round(1.115+0.00000001, 2))</span><br><span class="line">print(round(1.125+0.00000001, 2))</span><br><span class="line">print(round(1.375+0.00000001, 2))</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">1.11</span><br><span class="line">1.12</span><br><span class="line">1.13</span><br><span class="line">1.38</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>requests库请求报SSLError</title>
    <url>/2015-04-18.html</url>
    <content><![CDATA[<h3 id="requests库请求报SSLError-SSL-CERTIFICATE-VERIFY-FAILED-certificate-verify-failed-ssl-c-590"><a href="#requests库请求报SSLError-SSL-CERTIFICATE-VERIFY-FAILED-certificate-verify-failed-ssl-c-590" class="headerlink" title="requests库请求报SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)"></a>requests库请求报SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2019-04-18 14:14:46,594] ERROR in utils: Traceback (most recent call last):</span><br><span class="line">  File "/Users/higgs/PycharmProjects/workdir2/app_platform/utils.py", line 44, in fin</span><br><span class="line">    res['data'] = f(*args, **kw)</span><br><span class="line">  File "api.py", line 354, in prod_question</span><br><span class="line">    url = upload_prod(save_file, json.dumps(res))</span><br><span class="line">  File "/Users/higgs/PycharmProjects/workdir2/app_platform/utils.py", line 107, in upload_prod</span><br><span class="line">    _, info = put_data(token, key, data=f)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/qiniu/services/storage/uploader.py", line 31, in put_data</span><br><span class="line">    return _form_put(up_token, key, data, params, mime_type, crc, progress_handler, fname)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/qiniu/services/storage/uploader.py", line 81, in _form_put</span><br><span class="line">    url = config.get_default('default_zone').get_up_host_by_token(up_token) + '/'</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/qiniu/zone.py", line 31, in get_up_host_by_token</span><br><span class="line">    up_hosts = self.get_up_host(ak, bucket)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/qiniu/zone.py", line 50, in get_up_host</span><br><span class="line">    bucket_hosts = self.get_bucket_hosts(ak, bucket)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/qiniu/zone.py", line 76, in get_bucket_hosts</span><br><span class="line">    hosts = compat.json.loads(self.bucket_hosts(ak, bucket))</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/qiniu/zone.py", line 128, in bucket_hosts</span><br><span class="line">    ret = requests.get(url)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/requests/api.py", line 72, in get</span><br><span class="line">    return request('get', url, params=params, **kwargs)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/requests/api.py", line 58, in request</span><br><span class="line">    return session.request(method=method, url=url, **kwargs)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/requests/sessions.py", line 502, in request</span><br><span class="line">    resp = self.send(prep, **send_kwargs)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/requests/sessions.py", line 612, in send</span><br><span class="line">    r = adapter.send(request, **kwargs)</span><br><span class="line">  File "/Users/higgs/.pyenv/versions/app_platform/lib/python2.7/site-packages/requests/adapters.py", line 514, in send</span><br><span class="line">    raise SSLError(e, request=request)</span><br><span class="line">SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)</span><br><span class="line"></span><br><span class="line">127.0.0.1 - - [18/Apr/2019 14:14:46] "GET /questions/prod?channel=1000 HTTP/1.1" 200 160</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip uninstall -y certifi</span><br><span class="line">pip install certifi</span><br></pre></td></tr></table></figure>
</li>
<li><p>推测可能是本地证书过期了，所以ssl验证失败导致的；</p>
</li>
<li><p>深挖一下发现certifi库也是requests项目组维护的，并且从requests项目中独立出来了，原文如下：<br>Certifi CA Bundle<br>Certifi is a carefully curated collection of Root Certificates for validating the trustworthiness of SSL certificates while verifying the identity of TLS hosts. It has been extracted from the Requests project.<a href="http://docs.python-requests.org/en/latest/community/recommended/" target="_blank" rel="noopener">原文链接</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>flask设置永久访问token</title>
    <url>/2015-04-4.html</url>
    <content><![CDATA[<h3 id="flask设置永久访问token"><a href="#flask设置永久访问token" class="headerlink" title="flask设置永久访问token"></a>flask设置永久访问token</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_httpauth <span class="keyword">import</span> HTTPTokenAuth</span><br><span class="line">auth = HTTPTokenAuth(scheme=<span class="string">'Bearer'</span>)</span><br><span class="line"> </span><br><span class="line"> tokens = &#123;</span><br><span class="line">     <span class="string">"12aaa0c64bc5dbc2026be1071df5c0db47659d45"</span>: <span class="string">"user1"</span>,</span><br><span class="line">     <span class="string">"23370cec94ddc0dc2a50432a90500b2bc55d014e"</span>: <span class="string">"user2"</span>,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta"> @auth.verify_token</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">verify_token</span><span class="params">(token)</span>:</span></span><br><span class="line">     g.user = <span class="literal">None</span></span><br><span class="line">     <span class="keyword">if</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">         g.user = tokens[token]</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactOcr</span><span class="params">(Resource)</span>:</span></span><br><span class="line"><span class="meta">    @auth.login_required</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        logger.info(<span class="string">u'user:&#123;&#125; reconginzed: &#123;&#125;'</span>.format(g.user, res))</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'res'</span>: res&#125;, <span class="number">200</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>django migrate</title>
    <url>/2015-06-14.html</url>
    <content><![CDATA[<h3 id="django-migrate"><a href="#django-migrate" class="headerlink" title="django migrate"></a>django migrate</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除本地migrate文件</span></span><br><span class="line">rm apps/*/migrations/*.py</span><br><span class="line">python manage.py migrate recruitment --fake-initial</span><br><span class="line">python manage.py makemigrations recruitment</span><br><span class="line">python manage.py migrate recruitment</span><br></pre></td></tr></table></figure>

<ul>
<li>–fake-inital 会在数据库中的 migrations表中记录当前这个app 执行到 0001_initial.py ，但是它不会真的执行该文件中的 代码。 这样就做到了，既不对现有的数据库改动，而又可以重置 migraion 文件</li>
</ul>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django python migrate</tag>
      </tags>
  </entry>
  <entry>
    <title>django oauth2认证模块django-oauth-toolkit</title>
    <url>/2015-09-02.html</url>
    <content><![CDATA[<h3 id="oauth2"><a href="#oauth2" class="headerlink" title="oauth2"></a>oauth2</h3><p>OAuth 2.0是行业标准的授权协议。 OAuth 2.0取代了2006年创建的原始OAuth协议所做的工作.OAuth 2.0专注于客户端开发人员的简单性，同时为Web应用程序，桌面应用程序，移动电话和客厅设备提供特定的授权流程。该规范及其扩展正在IETF OAuth工作组内开发。</p>
<ul>
<li>oauth2授权类型有：</li>
</ul>
<ul>
<li>Authorization Code</li>
<li>Implicit</li>
<li>Password</li>
<li>Client Credentials<h3 id="django-oauth-toolkit"><a href="#django-oauth-toolkit" class="headerlink" title="django-oauth-toolkit"></a>django-oauth-toolkit</h3></li>
</ul>
<ol>
<li><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install django-oauth-toolkit</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：</p>
</li>
</ol>
<ul>
<li><p>Add oauth2_provider to your INSTALLED_APPS</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'oauth2_provider'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>add oauth2 urls to your urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    url(<span class="string">r'^o/'</span>, include(<span class="string">'oauth2_provider.urls'</span>, namespace=<span class="string">'oauth2_provider'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Sync your database</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> python manage.py migrate oauth2_provider</span><br></pre></td></tr></table></figure>
</li>
<li><p>other params config<br>in settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OAUTH2_PROVIDER = &#123;</span><br><span class="line">    <span class="string">'SCOPES'</span>: &#123;</span><br><span class="line">        <span class="string">'read'</span>: <span class="string">'Read scope'</span>,</span><br><span class="line">        <span class="string">'write'</span>: <span class="string">'Write scope'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'CLIENT_ID_GENERATOR_CLASS'</span>: <span class="string">'oauth2_provider.generators.ClientIdGenerator'</span>,</span><br><span class="line">    <span class="string">'AUTHORIZATION_CODE_EXPIRE_SECONDS'</span>: <span class="number">120</span>, <span class="comment"># grant code过期时间</span></span><br><span class="line">    <span class="string">'ACCESS_TOKEN_EXPIRE_SECONDS'</span>: <span class="number">60</span>, <span class="comment"># 访问token过期时间</span></span><br><span class="line">&#125;</span><br><span class="line">OAUTH2_PROVIDER_ACCESS_TOKEN_MODEL = <span class="string">'oauth2_provider.MAccessToken'</span> <span class="comment"># 重载access_token model</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>in new models.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> oauth2_provider.models <span class="keyword">import</span> AbstractAccessToken</span><br><span class="line"><span class="keyword">from</span> common.db.cache_service <span class="keyword">import</span> set_token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAccessToken</span><span class="params">(AbstractAccessToken)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(MAccessToken, self).save(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 下面可以自定义一些其他的定制化操作</span></span><br><span class="line">        self.user.profile.gmt_expires = self.expires <span class="comment"># </span></span><br><span class="line">        self.user.profile.save()</span><br><span class="line">        set_token(self.token, self.user)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(AbstractAccessToken.Meta)</span>:</span></span><br><span class="line">        db_table = <span class="string">'oauth2_provider_accesstoken'</span> <span class="comment"># 保持与原token model同名</span></span><br><span class="line">        app_label = <span class="string">'oauth2_provider'</span>  <span class="comment"># 指定app名称，貌似不能指定其他的，</span></span><br><span class="line">        swappable = <span class="string">"OAUTH2_PROVIDER_ACCESS_TOKEN_MODEL"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>还需要自定义一个/accounts/login/ 的url，访问/o/authorize/检测到未登陆状态，会跳转到/accounts/login/路径，提示登录</li>
</ul>
<ul>
<li>add /accounts/login/ url<br>in urls.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> Authenticate2View</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^login/$'</span>, Authenticate2View.as_view(), name=<span class="string">"login"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>in views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> TemplateView</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.mixins <span class="keyword">import</span> LoginRequiredMixin</span><br><span class="line"><span class="keyword">from</span> oauth2_provider.oauth2_backends <span class="keyword">import</span> OAuthLibCore</span><br><span class="line"><span class="keyword">from</span> urlparse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authenticate2View</span><span class="params">(TemplateView, LoginRequiredMixin)</span>:</span></span><br><span class="line">    template_name = <span class="string">"oauth/login.html"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        context = &#123;<span class="string">'info'</span>: <span class="string">'login'</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> self.render_to_response(context)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用户授权给APP登陆</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 验证post过来的用户名密码</span></span><br><span class="line">        ...</span><br><span class="line">        user = authenticate(username=username, password=password)</span><br><span class="line">        log.info(<span class="string">'before user:'</span>)</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">and</span> user.is_active:</span><br><span class="line">            redirect_to = urllib.unquote(context.get(<span class="string">"next"</span>, <span class="string">"/"</span>))</span><br><span class="line">            next_data = parse_qs(redirect_to)</span><br><span class="line">            payload = &#123;</span><br><span class="line">                    <span class="string">'redirect_uri'</span>: next_data.get(<span class="string">'redirect_uri'</span>, [<span class="string">'/'</span>])[<span class="number">0</span>],</span><br><span class="line">                    <span class="string">'client_id'</span>: next_data.get(<span class="string">'client_id'</span>, [<span class="literal">None</span>])[<span class="number">0</span>],</span><br><span class="line">                    <span class="string">'state'</span>: next_data.get(<span class="string">'state'</span>, [<span class="string">''</span>])[<span class="number">0</span>],</span><br><span class="line">                    <span class="string">'response_type'</span>: next_data.get(<span class="string">'response_type'</span>, [<span class="string">'code'</span>])[<span class="number">0</span>],</span><br><span class="line">                &#125;</span><br><span class="line">            scopes = [<span class="string">u'read'</span>, <span class="string">u'write'</span>]</span><br><span class="line">            setattr(request, <span class="string">'user'</span>, user)</span><br><span class="line">            uri, headers, body, status = OAuthLibCore().create_authorization_response(request, allow=<span class="literal">True</span>, scopes=scopes, credentials=payload)</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(uri)</span><br><span class="line">        context[<span class="string">'error'</span>] = <span class="literal">True</span></span><br><span class="line">        context[<span class="string">'error_msg'</span>] = <span class="string">'无效的用户名或密码'</span></span><br><span class="line">        <span class="keyword">return</span> self.render_to_response(context)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>举个腻子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">oauth_url = <span class="string">'http://localhost:8000/accounts/login/?next=/o/authorize/%3Fresponse_type%3Dcode%26client_id%3D4QM7Jeom33SwvXX2Tn4F74JgHIugXZjrliR1AlSe%26redirect_uri%3Dhttps%3A//www.baidu.com/'</span></span><br><span class="line"><span class="comment"># 首先：get oauth_url ;</span></span><br><span class="line"><span class="comment"># 然后：post oauth_url 返回code码 ;</span></span><br><span class="line"><span class="comment"># 然后：用下面参数post to /o/token  ;</span></span><br><span class="line">o_token_post = &#123;</span><br><span class="line">    <span class="string">'grant_type'</span>: <span class="string">'authorization_code'</span>,</span><br><span class="line">    <span class="string">'client_id'</span>: <span class="string">'4QM7Jeom33SwvXX2Tn4F74JgHIugXZjrliR1AlSe'</span>,</span><br><span class="line">    <span class="string">'code'</span>: <span class="string">'AU95GBaLoN4PgFKyBKQ9nk2dcUnzbu'</span>,</span><br><span class="line">    <span class="string">'redirect_uri'</span>: <span class="string">'https://www.baidu.com/'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 返回access_token和refresh_token ;</span></span><br><span class="line"><span class="comment"># 刷新token：post to /o/token ;</span></span><br><span class="line">refresh_token_post = &#123;</span><br><span class="line">    <span class="string">'grant_type'</span>: <span class="string">'refresh_token'</span>,</span><br><span class="line">    <span class="string">'client_id'</span>: <span class="string">'4QM7Jeom33SwvXX2Tn4F74JgHIugXZjrliR1AlSe'</span>,</span><br><span class="line">    <span class="string">'refresh_token'</span>: <span class="string">'YtyBvQJKFXVCmdqciMZ9KVu9psosUb'</span>,</span><br><span class="line">    <span class="string">'redirect_uri'</span>: <span class="string">'https://www.baidu.com/'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的client_id等信息来自于在django—admin登录以后创建的applications，发现一个问题貌似application只能通过django-admin来创建，自己直接用接口调用/o/applications/register/总是报403的错误，如果你有不通过django-admin来创建application的方法请告诉我，目前我的解决办法是直接通过数据库来创建，感觉有点蠢，桑心！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>oauth2</tag>
        <tag>django-oauth-toolkit</tag>
      </tags>
  </entry>
  <entry>
    <title>揭秘首位登月乘客日本富豪前泽友作，曾经放弃上大学</title>
    <url>/2015-09-18.html</url>
    <content><![CDATA[<h3 id="spaceX宣布首位登月乘客为前泽友作"><a href="#spaceX宣布首位登月乘客为前泽友作" class="headerlink" title="spaceX宣布首位登月乘客为前泽友作"></a>spaceX宣布首位登月乘客为前泽友作</h3><ul>
<li>9月18日，SpaceX公司CEO埃隆·马斯克宣布，该公司签署的首位环月飞行的私人客户是43岁前泽友作。他于2004年创立了在线时尚零售网站Zozotown。根据《福布斯》杂志估计，截至2017年5月，他的净资产为36亿美元，在日本富豪中排名第14位。<br>艾隆·马斯克和前泽有作一同出席了发布会。马斯克表示，他不会披露前泽有作此程的费用，只表示BFR运载火箭的开发成本约为50亿美元。<br><img src="/uploads/news/20180918/spacex.png" alt></li>
</ul>
<h3 id="前泽友作："><a href="#前泽友作：" class="headerlink" title="前泽友作："></a>前泽友作：</h3><p>前泽友作，1975年11月22日，出生于日本千叶县镰谷市（Kamagaya，Chiba）。他回忆幼年时说，本身从小对读书的兴趣不高，倒是很有生意头脑。小学时，最热衷的事情就是抓昆虫，最喜欢抓大甲虫，然后再卖给朋友。他说：“想想当时，自己就已从事买卖事业了。</p>
<p>该火箭长118米，分两部分，载重100吨，可循环使用。<br><img src="/uploads/news/20180918/spacex1.png" alt></p>
<p>之前有机构估算这趟旅程的价格为1.75亿美元。而去年，前泽友作购买让－米歇尔·巴斯奎特的一幅涂鸦《无题》，花了1.105亿美元。</p>
<p>前泽表示他可能会携带自己收藏的一些画作飞行。</p>
<p>宇宙飞船全长55米，内部空间高达1000立方米，超过了一些空间站，装有7个Raptor发动机。<br><img src="/uploads/news/20180918/spacex2.png" alt></p>
<p>虽然载人飞船内部自动化程度很高，但前沢友作会接受系统而严格的训练后，才能成行。</p>
<p>“地球是人类的摇篮，但人类不可能永远被束缚在摇篮里。”</p>
<p>发布会最后，马斯克引用火箭理论之父齐奥尔科夫斯基的名言说道。</p>
<p>前泽友作曾是一名摇滚歌手，后来创办了日本最大的潮牌电商网站。</p>
<p>据福布斯网站最新的数据，他的财富净值达27亿美元，在日本富豪榜上位居第18位，去年为14位。</p>
<p>前泽友作交往过一些著名的女星。曾与纱荣子公开恋情，目前正与26岁的刚力彩芽交往。<br><img src="/uploads/news/20180918/spacex4.png" alt></p>
<p>刚力彩芽说：“友作君啊，就像小孩子一样单纯……有些地方和我父亲很相像。我不知不觉就被他吸引住了。”</p>
<p>前泽有作的家位于东京，公司总部位于他的家乡千叶，这两个地方都被艺术品包围着……</p>
<p>“你应该买你喜欢的东西”</p>
<p><img src="/uploads/news/20180918/spacex5.png" alt></p>
<p>前泽友作大约在十年前开始收藏艺术，主要是当代艺术。</p>
<p>他没有雇佣艺术顾问，对于购买艺术品，他说自己从不会寻求其他人的意见。</p>
<p>“你应该买你喜欢的东西。”</p>
<p>“如果我认为艺术作品对我真的很有价值，我愿意投入我所有的资产。”<br><img src="/uploads/news/20180918/spacex6.gif" alt></p>
<p>他计划在千叶市开设一座私人美术馆，这个美术馆会参考他最钟爱的美国路易斯安那现代艺术馆和瑞士拜尔勒基金会美术馆。</p>
<p>但他拒绝透露完工的时间和建筑师。如果他想说，他会通过自己的社交账号来发布。</p>
<p>五月纽约春拍季，苏富比的当代艺术拍卖场上发生了“黑天鹅事件”：日本企业家和收藏家前泽友作以1.105亿美元（落槌价9800万美元，加买方佣金后为110487500美元，约7.6亿人民币），拍下了让•米切尔•巴斯奎特1982年的作品“无题”，比这名艺术家之前在拍卖市场的最高纪录5730万美元（约3.73亿人民币，也是由前泽友作去年5月在佳士得拍得）翻了一倍！<br><img src="/uploads/news/20180918/spacex7.jpg" alt></p>
<p>他认为，只有不断的花钱，自己和公司才能不断成长。</p>
<p>前泽友作的原则是：</p>
<p>1.在眼下，要尽可能的花掉自己手中的钱</p>
<p>2.从花钱的经验中，促使自己再成长</p>
<p>3.因为只有自己成长了，才会赚更多的钱<br><img src="/uploads/news/20180918/spacex7.jpg" alt></p>
<p>前泽友作成功诀窍：</p>
<p>做和别人不一样的事情</p>
<p>说起自己和公司成功的诀窍，他说：</p>
<p>“就是和别人做不一样的事情。这样一来，也就没有了竞争。我从很早就开始这样做了。本来我就很讨厌跟别人争来争去。小时候，看到什么学习成绩排名的，自己就很讨厌。”</p>
<p>“和其他人保持不同，去打破一些别人以为是‘常识’的东西，这样就会引起人们的关注，新的事业也就出现。然后用手头聚集的资本和人力，去打破更大的常识，以此类推。”<br><img src="/uploads/news/20180918/spacex8.png" alt><br>前泽友作成了首位月球旅客，他在今天同时发起了dearMoon计划，将于2023年邀请6-8名艺术家和他一同前往月球。</p>
<p>他说：“从小我就向往月球，我不能错过这个机会，也想拥有这次绝妙的体验，但我不喜欢孤独，所以我要和大家分享这次经历。”</p>
<p>前泽友作的成功经历告诉我们会花钱的人才会发现更多的机会去挣钱，正是印证了那句话：做喜欢的事顺便把钱挣了，前泽友作的经历值得我们深思。</p>
]]></content>
      <categories>
        <category>新闻</category>
      </categories>
      <tags>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql创建数据库并指定编码</title>
    <url>/2015-12-06.html</url>
    <content><![CDATA[<h3 id="mysql创建数据库并指定编码："><a href="#mysql创建数据库并指定编码：" class="headerlink" title="mysql创建数据库并指定编码："></a>mysql创建数据库并指定编码：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE `yourdb` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; # 创建数据库并制定编码为utf8mb4(支持表情，扩展性好)</span><br><span class="line">GRANT ALL ON `yourdb`.* TO `username`@localhost IDENTIFIED BY 'password'; # 给用户授权</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>requests.exceptions.ConnectionError-Connection-aborted</title>
    <url>/2015-12-13.html</url>
    <content><![CDATA[<p>###使用requests库抓取https的页面报如下错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    r = s.get(url=url, verify=<span class="literal">False</span>, headers=headers)</span><br><span class="line">  File <span class="string">"/Users/higgs/.virtualenvs/spider/lib/python2.7/site-packages/requests/sessions.py"</span>, line <span class="number">501</span>, <span class="keyword">in</span> get</span><br><span class="line">    <span class="keyword">return</span> self.request(<span class="string">'GET'</span>, url, **kwargs)</span><br><span class="line">  File <span class="string">"/Users/higgs/.virtualenvs/spider/lib/python2.7/site-packages/requests/sessions.py"</span>, line <span class="number">488</span>, <span class="keyword">in</span> request</span><br><span class="line">    resp = self.send(prep, **send_kwargs)</span><br><span class="line">  File <span class="string">"/Users/higgs/.virtualenvs/spider/lib/python2.7/site-packages/requests/sessions.py"</span>, line <span class="number">609</span>, <span class="keyword">in</span> send</span><br><span class="line">    r = adapter.send(request, **kwargs)</span><br><span class="line">  File <span class="string">"/Users/higgs/.virtualenvs/spider/lib/python2.7/site-packages/requests/adapters.py"</span>, line <span class="number">473</span>, <span class="keyword">in</span> send</span><br><span class="line">    <span class="keyword">raise</span> ConnectionError(err, request=request)</span><br><span class="line">requests.exceptions.ConnectionError: (<span class="string">'Connection aborted.'</span>, error(<span class="number">54</span>, <span class="string">'Connection reset by peer'</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>相关issue的讨论链接：<a href="https://github.com/requests/requests/issues/3883" target="_blank" rel="noopener">https://github.com/requests/requests/issues/3883</a></li>
<li>本地直接通过安装 pyopenssl和idna解决问题<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pyopenssl idna</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>requests</category>
      </categories>
      <tags>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令总结</title>
    <url>/2015-7-21.html</url>
    <content><![CDATA[<h2 id="版本控制系统（VCS）"><a href="#版本控制系统（VCS）" class="headerlink" title="版本控制系统（VCS）"></a>版本控制系统（VCS）</h2><ul>
<li>版本控制系统（Version Control System）是一种记录一个或若干文件内容变化历史的系统。<br><img src="/uploads/git-cmd-summary/one-center.jpg" alt="集中式VCS"></li>
<li>集中化的版本控制系统(CVS，SVN)*</li>
</ul>
<p><img src="/uploads/git-cmd-summary/distribute.jpg" alt="分布式VCS"><br><em>分布式版本控制系统（Git)</em></p>
<h2 id="Git-的诞生"><a href="#Git-的诞生" class="headerlink" title="Git 的诞生"></a>Git 的诞生</h2><ul>
<li>Git是目前世界上最先进的分布式版本控制系统（没有之一）</li>
<li>好不好用，看看它的开发者是谁就知道了：Linux之父 Linus Torvalds </li>
<li>Linux内核社区原本使用的是名为BitKeeper的商业化版本控制工具，2005年，因为社区内有人试图破解BitKeeper的协议，BitMover公司收回了免费使用BitKeeper的权力；</li>
<li>Linus原本可以出面道个歉，继续使用BitKeeper，然而并没有… Linus大神仅用了两周时间，自已用C写了一个分布式版本控制系统，于是Git诞生了！</li>
</ul>
<h2 id="Git-与GitHub"><a href="#Git-与GitHub" class="headerlink" title="Git 与GitHub"></a>Git 与GitHub</h2><ul>
<li>Git： 是一种开源的版本控制系统，可以高效的管理项目版本，同时也是一种协议；</li>
<li>GitHub： 是一个面向开源及私有软件项目的托管平台, 私有项目收费；</li>
<li>GitLab： 社区版相当于私有版的github，可以自己搭建GitLab仓库服务器，企业版收费；</li>
<li>Gitee：码云(gitee.com)是开源中国推出的代码托管平台,支持 Git 和 SVN,提供免费的私有仓库托管；<br><img src="/uploads/git-cmd-summary/linus.jpg" alt="linus大叔pic"></li>
<li>linus大叔*</li>
</ul>
<h2 id="Git基本原理"><a href="#Git基本原理" class="headerlink" title="Git基本原理"></a>Git基本原理</h2><p><img src="/uploads/git-cmd-summary/git-basic1.png" alt></p>
<ul>
<li>git add files 把当前文件放入暂存区域。</li>
<li>git commit 给暂存区域生成快照并提交。</li>
<li>git reset – files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li>
<li>git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。<br><img src="/uploads/git-cmd-summary/git-basic2.png" alt></li>
<li>git commit -a 相当于运行 git add 把所有当前目录下的文件加入暂存区域再运行git commit.</li>
<li>git commit files 进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。</li>
<li>git checkout HEAD – files 回滚到复制最后一次提交。</li>
</ul>
<h2 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status 查看代码修改状态</span><br><span class="line">git clone 克隆代码</span><br><span class="line">git diff 查看差异部分</span><br><span class="line">git pull origin &lt;branch&gt;	拉取</span><br><span class="line">git push origin &lt;branch&gt; 推送</span><br><span class="line">git checkout &lt;本地分支名&gt; 切换到指定分支</span><br><span class="line">git checkout –b &lt;new_branch&gt; 基于当前分支切换到指定分支</span><br><span class="line">git merge &lt;other_branch&gt; 合并其他分支到当前分支(多了一次merge信息)</span><br><span class="line">git rebase &lt;other_branch&gt; 基于其他分支应用合并</span><br></pre></td></tr></table></figure>

<h2 id="git常见冲突解决"><a href="#git常见冲突解决" class="headerlink" title="git常见冲突解决"></a>git常见冲突解决</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict in readme.md</span><br><span class="line">git merge中：</span><br><span class="line">git add .   </span><br><span class="line">git commit –m ””</span><br><span class="line"></span><br><span class="line">git rebase :</span><br><span class="line">git rebase –continue</span><br></pre></td></tr></table></figure>

<h2 id="紧急bug修复"><a href="#紧急bug修复" class="headerlink" title="紧急bug修复"></a>紧急bug修复</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash :暂存当前编辑的代码</span><br><span class="line">git checkout hotfix</span><br><span class="line">git stash pop :切换到bug修复前的工作目录</span><br></pre></td></tr></table></figure>

<h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><ul>
<li><p>经常使用git命令,设置快捷键会方便很多,设置方式如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者:</p>
</li>
<li><p>修改~/.gitconfig,加入以下部分:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">co = checkout</span><br><span class="line">ci = commit</span><br><span class="line">st = status</span><br><span class="line">br = branch</span><br><span class="line">sh = stash</span><br><span class="line">sp = stash pop</span><br><span class="line">pu = push</span><br><span class="line">pr = pull -r</span><br><span class="line">rb = rebase</span><br><span class="line">lg = log -p</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>###git 命令搜集</p>
<h2 id="下载git项目下某个目录下的文件例如：想下载链接https-github-com-grpc-grpc-tree-master-examples-python-helloworld这个目录"><a href="#下载git项目下某个目录下的文件例如：想下载链接https-github-com-grpc-grpc-tree-master-examples-python-helloworld这个目录" class="headerlink" title="下载git项目下某个目录下的文件例如：想下载链接https://github.com/grpc/grpc/tree/master/examples/python/helloworld这个目录"></a>下载git项目下某个目录下的文件例如：想下载链接<a href="https://github.com/grpc/grpc/tree/master/examples/python/helloworld这个目录" target="_blank" rel="noopener">https://github.com/grpc/grpc/tree/master/examples/python/helloworld这个目录</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree/master 改为 trunk</span><br><span class="line">svn checkout https://github.com/grpc/grpc/trunk/examples/python/helloworld</span><br></pre></td></tr></table></figure>

<ul>
<li>更多命令：git help</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>cmd</tag>
        <tag>VCS</tag>
      </tags>
  </entry>
  <entry>
    <title>python的魔法二:开发的&#39;坑&#39;</title>
    <url>/2016-01-16.html</url>
    <content><![CDATA[<h4 id="有了第一篇python的魔法-之基础知识"><a href="#有了第一篇python的魔法-之基础知识" class="headerlink" title="有了第一篇python的魔法(-)之基础知识,"></a>有了第一篇<a href="http://www.dongwm.com/archives/pythonde-mo-fa/" target="_blank" rel="noopener">python的魔法(-)之基础知识</a>,</h4><p>我们再来说说python开发中的坑</p>
<h4 id="不要使用可变对象作为函数默认值"><a href="#不要使用可变对象作为函数默认值" class="headerlink" title="不要使用可变对象作为函数默认值"></a>不要使用可变对象作为函数默认值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">append_to_list</span><span class="params">(value, def_list=[])</span>:</span>  </span><br><span class="line">   ...:         def_list.append(value)  </span><br><span class="line">   ...:         <span class="keyword">return</span> def_list  </span><br><span class="line">   ...:   </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: my_list = append_to_list(<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: my_list  </span><br><span class="line">Out[<span class="number">3</span>]: [<span class="number">1</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: my_other_list = append_to_list(<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: my_other_list  </span><br><span class="line">Out[<span class="number">5</span>]: [<span class="number">1</span>, <span class="number">2</span>] <span class="comment"># 看到了吧，其实我们本来只想生成[2] 但是却把第一次运行的效果页带了进来  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: <span class="function"><span class="keyword">def</span> <span class="title">report_arg</span><span class="params">(my_default=time.time<span class="params">()</span>)</span>:</span>  </span><br><span class="line">   ...:         print(my_default)  </span><br><span class="line">   ...:       </span><br><span class="line">  </span><br><span class="line">In [<span class="number">8</span>]: report_arg() <span class="comment"># 第一次执行  </span></span><br><span class="line"><span class="number">1399562371.32</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">9</span>]: time.sleep(<span class="number">2</span>) <span class="comment"># 隔了2秒  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">10</span>]: report_arg()  </span><br><span class="line"><span class="number">1399562371.32</span> <span class="comment"># 时间竟然没有变</span></span><br></pre></td></tr></table></figure>


<p>这2个例子说明了什么? 字典,集合,列表等等对象是不适合作为函数默认值的. 因为这个默认值实在函数建立的时候就生成了, 每次调用都是用了这个对象的”缓存”.<br>我在上段时间的分享[python高级编程](<a href="http://dongweiming.github.io/Expert-" target="_blank" rel="noopener">http://dongweiming.github.io/Expert-</a><br>Python/)也说到了这个问题,这个是实际开发遇到的问题，好好检查你学过的代码, 也许只是问题没有暴露<br>可以这样改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_to_list</span><span class="params">(element, to=None)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> to <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">        to = []  </span><br><span class="line">    to.append(element)  </span><br><span class="line">    <span class="keyword">return</span> to</span><br></pre></td></tr></table></figure>


<h4 id="生成器不保留迭代过后的结果"><a href="#生成器不保留迭代过后的结果" class="headerlink" title="生成器不保留迭代过后的结果"></a>生成器不保留迭代过后的结果</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">13</span>]: <span class="number">2</span> <span class="keyword">in</span> gen  </span><br><span class="line">Out[<span class="number">13</span>]: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">14</span>]: <span class="number">3</span> <span class="keyword">in</span> gen  </span><br><span class="line">Out[<span class="number">14</span>]: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">15</span>]: <span class="number">1</span> <span class="keyword">in</span> gen  </span><br><span class="line">Out[<span class="number">15</span>]: <span class="literal">False</span> <span class="comment"># 1为什么不在gen里面了? 因为调用1-&gt;2,这个时候1已经不在迭代器里面了,被按需生成过了  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">20</span>]: gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">21</span>]: a_list = list(gen) <span class="comment"># 可以转化成列表，当然a_tuple = tuple(gen) 也可以  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">22</span>]: <span class="number">2</span> <span class="keyword">in</span> a_list  </span><br><span class="line">Out[<span class="number">22</span>]: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">23</span>]: <span class="number">3</span> <span class="keyword">in</span> a_list  </span><br><span class="line">Out[<span class="number">23</span>]: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">24</span>]: <span class="number">1</span> <span class="keyword">in</span> a_list <span class="comment"># 就算循环过,值还在  </span></span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h4 id="lambda在闭包中会保存局部变量"><a href="#lambda在闭包中会保存局部变量" class="headerlink" title="lambda在闭包中会保存局部变量"></a>lambda在闭包中会保存局部变量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: my_list = [<span class="keyword">lambda</span>: i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">30</span>]: <span class="keyword">for</span> l <span class="keyword">in</span> my_list:  </span><br><span class="line">   ....:         print(l())  </span><br><span class="line">   ....:</span><br></pre></td></tr></table></figure>


<p>这个问题还是上面说的<a href="http://dongweiming.github.io/Expert-Python/" target="_blank" rel="noopener">python高级编程</a>中说过具体原因.<br>其实就是当我赋值给my_list的时候,lambda表达式就执行了i会循环,直到 i =4,i会保留<br>但是可以用生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: my_gen = (<span class="keyword">lambda</span>: n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">5</span>))  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">32</span>]: <span class="keyword">for</span> l <span class="keyword">in</span> my_gen:  </span><br><span class="line">   ....:         print(l())  </span><br><span class="line">   ....:</span><br></pre></td></tr></table></figure>


<p>也可以坚持用list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: my_list = [<span class="keyword">lambda</span> x=i: x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)] <span class="comment"># 看我给每个lambda表达式赋了默认值  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">34</span>]: <span class="keyword">for</span> l <span class="keyword">in</span> my_list:  </span><br><span class="line">   ....:         print(l())  </span><br><span class="line">   ....:</span><br></pre></td></tr></table></figure>


<p>有点不好懂是吧,在看看python的另外一个魔法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: <span class="function"><span class="keyword">def</span> <span class="title">groupby</span><span class="params">(items, size)</span>:</span>  </span><br><span class="line">   ....:     <span class="keyword">return</span> zip(*[iter(items)]*size)  </span><br><span class="line">   ....:   </span><br><span class="line">  </span><br><span class="line">In [<span class="number">36</span>]: groupby(range(<span class="number">9</span>), <span class="number">3</span>)  </span><br><span class="line">Out[<span class="number">36</span>]: [(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]</span><br></pre></td></tr></table></figure>


<p>一个分组的函数,看起来很不好懂,对吧? 我们来解析下这里</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: [iter(items)]*<span class="number">3</span>  </span><br><span class="line">Out[<span class="number">39</span>]:   </span><br><span class="line">[&lt;listiterator at <span class="number">0x10e155fd0</span>&gt;,  </span><br><span class="line"> &lt;listiterator at <span class="number">0x10e155fd0</span>&gt;,  </span><br><span class="line"> &lt;listiterator at <span class="number">0x10e155fd0</span>&gt;] <span class="comment"># 看到了吧, 其实就是把items变成可迭代的, 重复三回（同一个对象哦）, 但是别忘了,每次都.next(), 所以起到了分组的作用  </span></span><br><span class="line"> In [<span class="number">40</span>]: [<span class="keyword">lambda</span> x=i: x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]  </span><br><span class="line">Out[<span class="number">40</span>]:   </span><br><span class="line">[&lt;function __main__.&lt;<span class="keyword">lambda</span>&gt;&gt;,  </span><br><span class="line"> &lt;function __main__.&lt;<span class="keyword">lambda</span>&gt;&gt;,  </span><br><span class="line"> &lt;function __main__.&lt;<span class="keyword">lambda</span>&gt;&gt;,  </span><br><span class="line"> &lt;function __main__.&lt;<span class="keyword">lambda</span>&gt;&gt;,  </span><br><span class="line"> &lt;function __main__.&lt;<span class="keyword">lambda</span>&gt;&gt;] <span class="comment"># 看懂了吗?</span></span><br></pre></td></tr></table></figure>


<h4 id="在循环中修改列表项"><a href="#在循环中修改列表项" class="headerlink" title="在循环中修改列表项"></a>在循环中修改列表项</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">45</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> a:  </span><br><span class="line">   ....:     <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">2</span>:  </span><br><span class="line">   ....:         a.remove(i)  </span><br><span class="line">   ....:           </span><br><span class="line">  </span><br><span class="line">In [<span class="number">46</span>]: a  </span><br><span class="line">Out[<span class="number">46</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>] <span class="comment"># 没有问题  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">50</span>]: b = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">51</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> b:  </span><br><span class="line">   ....:      <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">2</span>:  </span><br><span class="line">   ....:          b.remove(i)  </span><br><span class="line">   ....:           </span><br><span class="line">  </span><br><span class="line">In [<span class="number">52</span>]: b  </span><br><span class="line">Out[<span class="number">52</span>]: [<span class="number">4</span>, <span class="number">5</span>] <span class="comment"># 本来我想要的结果应该是去除偶数的列表</span></span><br></pre></td></tr></table></figure>


<p>思考一下,为什么 – 是因为你对列表的remove,影响了它的index</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: b = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">54</span>]: <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(b):  </span><br><span class="line">   ....:     print(index, item)  </span><br><span class="line">   ....:     <span class="keyword">if</span> <span class="keyword">not</span> item % <span class="number">2</span>:  </span><br><span class="line">   ....:         b.remove(item)  </span><br><span class="line">   ....:           </span><br><span class="line">(<span class="number">0</span>, <span class="number">2</span>) <span class="comment"># 这里没有问题 2被删除了  </span></span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>) <span class="comment"># 因为2被删除目前的列表是[4, 5, 6], 所以索引list[1]直接去找5, 忽略了4  </span></span><br><span class="line">(<span class="number">2</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>


<h4 id="IndexError-列表取值超出了他的索引数"><a href="#IndexError-列表取值超出了他的索引数" class="headerlink" title="IndexError - 列表取值超出了他的索引数"></a>IndexError - 列表取值超出了他的索引数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">56</span>]: my_list[<span class="number">5</span>] <span class="comment"># 根本没有这个元素  </span></span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">IndexError                                Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-56</span><span class="number">-037</span>d00de8360&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 my_list[5]  </span><br><span class="line">  </span><br><span class="line">IndexError: list index out of range <span class="comment"># 抛异常了  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">57</span>]: my_list[<span class="number">5</span>:] <span class="comment"># 但是可以这样， 一定要注意, 用好了是trick,用错了就是坑啊  </span></span><br><span class="line">Out[<span class="number">57</span>]: []</span><br></pre></td></tr></table></figure>


<h4 id="重用全局变量"><a href="#重用全局变量" class="headerlink" title="重用全局变量"></a>重用全局变量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: <span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span>  </span><br><span class="line">   ....:         print(var) <span class="comment"># 我可以先调用一个未定义的变量  </span></span><br><span class="line">   ....:       </span><br><span class="line">  </span><br><span class="line">In [<span class="number">59</span>]: var = <span class="string">'global'</span> <span class="comment"># 后赋值  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">60</span>]: my_func() <span class="comment"># 反正只要调用函数时候变量被定义了就可以了  </span></span><br><span class="line"><span class="keyword">global</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">61</span>]: <span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span>  </span><br><span class="line">   ....:     var = <span class="string">'locally changed'</span>  </span><br><span class="line">   ....:       </span><br><span class="line">  </span><br><span class="line">In [<span class="number">62</span>]: var = <span class="string">'global'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">63</span>]: my_func()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">64</span>]: print(var)  </span><br><span class="line"><span class="keyword">global</span> <span class="comment"># 局部变量没有影响到全局变量  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">65</span>]: <span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span>  </span><br><span class="line">   ....:         print(var) <span class="comment"># 虽然你全局设置这个变量, 但是局部变量有同名的, python以为你忘了定义本地变量了  </span></span><br><span class="line">   ....:         var = <span class="string">'locally changed'</span>  </span><br><span class="line">   ....:           </span><br><span class="line">  </span><br><span class="line">In [<span class="number">66</span>]: var = <span class="string">'global'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">67</span>]: my_func()  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">UnboundLocalError                         Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-67</span>-d82eda95de40&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 my_func()  </span><br><span class="line">  </span><br><span class="line">&lt;ipython-input<span class="number">-65</span><span class="number">-0</span>ad11d690936&gt; <span class="keyword">in</span> my_func()  </span><br><span class="line">      <span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span>  </span><br><span class="line">----&gt; 2         print(var)  </span><br><span class="line">      <span class="number">3</span>         var = <span class="string">'locally changed'</span>  </span><br><span class="line">      <span class="number">4</span>   </span><br><span class="line">  </span><br><span class="line">UnboundLocalError: local variable <span class="string">'var'</span> referenced before assignment  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">68</span>]: <span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span>  </span><br><span class="line">   ....:         <span class="keyword">global</span> var <span class="comment"># 这个时候得加全局了  </span></span><br><span class="line">   ....:         print(var) <span class="comment"># 这样就能正常使用  </span></span><br><span class="line">   ....:         var = <span class="string">'locally changed'</span>   </span><br><span class="line">   ....:       </span><br><span class="line">  </span><br><span class="line">In [<span class="number">69</span>]: var = <span class="string">'global'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">70</span>]:   </span><br><span class="line">  </span><br><span class="line">In [<span class="number">70</span>]: my_func()  </span><br><span class="line"><span class="keyword">global</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">71</span>]: print(var)  </span><br><span class="line">locally changed <span class="comment"># 但是使用了global就改变了全局变量</span></span><br></pre></td></tr></table></figure>


<h4 id="拷贝可变对象"><a href="#拷贝可变对象" class="headerlink" title="拷贝可变对象"></a>拷贝可变对象</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: my_list1 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]] * <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">73</span>]: my_list1  </span><br><span class="line">Out[<span class="number">73</span>]: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">74</span>]: my_list1[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">'a'</span> <span class="comment"># 我只修改子列表中的一项  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">75</span>]: my_list1  </span><br><span class="line">Out[<span class="number">75</span>]: [[<span class="string">'a'</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">'a'</span>, <span class="number">2</span>, <span class="number">3</span>]] <span class="comment"># 但是都影响到了  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">76</span>]: my_list2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="comment"># 用这种循环生成不同对象的方法就不影响了  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">77</span>]: my_list2[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">'a'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">78</span>]: my_list2  </span><br><span class="line">Out[<span class="number">78</span>]: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">'a'</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，技术博客转载采用 <a href>保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>我维护的colout</title>
    <url>/2016-01-17.html</url>
    <content><![CDATA[<p>####前言<br>一直在努力进步，其实也在想做点项目，也作了一些东西，最近的计划就是看<a href="https://github.com/celery/celery" target="_blank" rel="noopener">celery</a>,<a href="https://github.com/getpelican/pelican" target="_blank" rel="noopener">pelican</a>,然后开始看django，看<a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">requests</a>,<br>其实任务还是很重的。<br>上段时间github转悠，发现一个挺有意思的东西<a href="https://github.com/nojhan/colout" target="_blank" rel="noopener">colout</a>：一个python的命令行显示彩色字符的软件，支持正则，支持各种语法的插件，但是作者呢..怎么说呢<br>也算是我为了练手,给他维护这个项目,<br>####我维护的内容<br>正如我给它修改的README</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Pypi(the Python Package Index)  </span><br><span class="line">  </span><br><span class="line">    sudo pip install colout  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">or</span>  </span><br><span class="line">  </span><br><span class="line">    sudo easy_install colout  </span><br><span class="line">  </span><br><span class="line">Ubuntu <span class="number">13.04</span><span class="string">'s ppa  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    sudo add-apt-repository ppa:ciici123/colout  </span></span><br><span class="line"><span class="string">    sudo apt-get update  </span></span><br><span class="line"><span class="string">    sudo apt-get/aptitude install colout  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">Gentoo overlay  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    1. Install layman  </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">    echo "app-portage/layman git" &gt;&gt; $EPREFIX/etc/portage/package.Use  </span></span><br><span class="line"><span class="string">    sudo emerge layman  </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">    2. Edit `$EPREFIX/etc/layman/layman.cfg`. Add a line after  </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">    overlays   : http://www.gentoo.org/proj/en/overlays/repositories.xml  </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">    so that it becomes  </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">    overlays   : http://www.gentoo.org/proj/en/overlays/repositories.xml  </span></span><br><span class="line"><span class="string">                 file://$EPREFIX/var/lib/layman/my-list.xml  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    3. Edit `$EPREFIX/var/lib/layman/my-list.xml`.  The content of this file should be:  </span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">    &lt;?xml version="1.0" ?&gt;  </span></span><br><span class="line"><span class="string">    &lt;repositories version="1.0"&gt;  </span></span><br><span class="line"><span class="string">    &lt;repo priority="50" quality="experimental" status="unofficial"&gt;  </span></span><br><span class="line"><span class="string">        &lt;name&gt;dongwm-overlay&lt;/name&gt;  </span></span><br><span class="line">        &lt;description&gt;dongweiming's gentoo overlay&lt;/description&gt;  </span><br><span class="line">        &lt;homepage&gt;https://github.com/dongweiming/dongwm-overlay.git&lt;/homepage&gt;  </span><br><span class="line">        &lt;owner&gt;  </span><br><span class="line">            &lt;email&gt;ciici1234@hotmail.com&lt;/email&gt;  </span><br><span class="line">        &lt;/owner&gt;  </span><br><span class="line">        &lt;source type="git"&gt;git://github.com/dongweiming/dongwm-overlay.git&lt;/source&gt;  </span><br><span class="line">    &lt;/repo&gt;  </span><br><span class="line">    &lt;/repositories&gt;  </span><br><span class="line">  </span><br><span class="line">    <span class="number">4.</span> Add this overlay <span class="keyword">and</span> installation  </span><br><span class="line">      </span><br><span class="line">    layman -a dongwm-overlay &amp;&amp; sudo emerge colout</span><br></pre></td></tr></table></figure>


<p>其实现在已经放到了gentoo的portage主干，你可以直接安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo emerge colout</span><br></pre></td></tr></table></figure>


<p>####也就是说我维护了pypi，ubuntu’s ppa和gentoo<br>这个经验讲起来，很多很多，时间有点长了…</p>
<ul>
<li>pypi<br>我这部分源码是从作者项目拿下来的分支<a href="https://github.com/dongweiming/colout" target="_blank" rel="noopener">colout</a>,<br>里面加了一些必要的东西，还有setup.py的格式<br>其中的’classifiers’是从官网文档分析的<a href="https://pypi.python.org/pypi?:action=list_classifiers" target="_blank" rel="noopener">classifiers</a>,<br>而且要注意的是,根据<br>最近的<a href="http://www.python.org/dev/peps/pep-0438/" target="_blank" rel="noopener">PEP438</a>,<br>以后的pypi不要容许来自外部软件的网站连接，直接使用pypi的地址已加快速度<br>#####流程</li>
</ul>
<ol>
<li>注册pypi,你可以去网站 也可以python setup.py register</li>
<li>添加相关文件和setup.py</li>
<li>python setup.py sdist upload #上传到pypi<br>技巧:<br>你可以写.pypirc配置文件就不用每次输入帐号密码了</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[distutils]  </span><br><span class="line">index-servers = pypi  </span><br><span class="line">  </span><br><span class="line">[pypi]  </span><br><span class="line">username:xxx  </span><br><span class="line">password:xxx</span><br></pre></td></tr></table></figure>


<p>表示构建dist包后并且上传，当然你还能再加’bdist_egg’ 构建eggs</p>
<ul>
<li>gentoo 本来就是我的一个layman,但是看来gentoo的开发者也挺喜欢这个小玩意，后来把它放在了主干<br>流程:</li>
</ul>
<ol>
<li>写ebuild脚本 请参看我的<a href="https://github.com/dongweiming/dongwm-overlay" target="_blank" rel="noopener">overlay for Gentoo</a></li>
<li>假如你想用第三方的overlay，上面README有安装方法，假如你想放到gentoo主干，继续…</li>
<li>建立一个Bugzilla帐号</li>
<li>创建一个bug，填写表单，附件加入你写的那个ebuild脚本，看我的例子<a href="https://bugs.gentoo.org/show_bug.cgi?id=469562" target="_blank" rel="noopener">app-misc/colout - a simple command to add colors to a text stream in your terminal</a><br>技巧:</li>
</ol>
<ul>
<li>ubuntu ppa 是最闹残，最无奈的，源文件在我虚拟机里面，有时间我再补</li>
</ul>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>仿Djangobook的Markdown文章评注系统</title>
    <url>/2016-01-19.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写这个评注系统是因为最新写书, 想找个更顺畅的和编辑沟通的方式, 提高工作效率。<br>学Django的同学应该都访问过: <a href="http://djangobook.py3k.cn/" target="_blank" rel="noopener">http://djangobook.py3k.cn/</a> ,<br>它和<a href="http://www.djangobook.com/en/2.0/index.html" target="_blank" rel="noopener">Djangobook官网</a><br>有个很重要的功能: 评注系统。在这里先向<a href="http://djangopeople.com/vcc/" target="_blank" rel="noopener">VCC</a>致敬,<br>虽然很久没有继续维护，但是这个评注的功能还是很不错的。<br>我也翻了Djangobook的Git提交记录, 没有找到实现的方式。 而且最重要的是, 它是通过ReStructuredText生成的静态页面,<br>不符合我的需求。所以有了今天说的<a href="https://github.com/dongweiming/aiglos" target="_blank" rel="noopener">Aiglos</a><br>可以看<a href="https://dry-castle-71587.herokuapp.com/" target="_blank" rel="noopener">Heroku上的Demo</a>看看效果, 其中的文档使用了<br><a href="https://github.com/GitbookIO/markdown" target="_blank" rel="noopener">https://github.com/GitbookIO/markdown</a></p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li>在线浏览渲染的本地Markdown文件。</li>
<li>提供 <a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="noopener">http://djangobook.py3k.cn/2.0/</a> 那样的评注系统。</li>
<li>评注支持Markdown语法。<h3 id="使用的技术"><a href="#使用的技术" class="headerlink" title="使用的技术"></a>使用的技术</h3><a href="https://github.com/mitsuhiko/flask" target="_blank" rel="noopener">Flask</a>: Web框架<br><a href="makotemplates.org">Mako</a>: 模板语言<br><a href="https://github.com/benselme/flask-mako" target="_blank" rel="noopener">Flask-Mako</a>: Mako支持的Flask扩展<br><a href="https://github.com/mitsuhiko/flask-sqlalchemy" target="_blank" rel="noopener">Flask-SQLAlchemy</a>:<br>SQLAlchemy的Flask扩展<br><a href="https://github.com/lepture/mistune" target="_blank" rel="noopener">mistune</a>: Markdown渲染<br><a href="https://github.com/cython/cython" target="_blank" rel="noopener">cython</a>: Python转化到C的编译器, 可以让mistune渲染更快<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ git clone https://github.com/dongweiming/aiglos  </span><br><span class="line">❯ cd aiglos  </span><br><span class="line">❯ virtualenv<span class="number">-2.7</span> venv  </span><br><span class="line">❯ source venv/bin/activate  </span><br><span class="line">❯ pip install -r requirements.txt  </span><br><span class="line">❯ touch local_settings.py  <span class="comment"># 增加BOOK_DIR (Markdown文件存放目录), SQLALCHEMY_DATABASE_URI等配置  </span></span><br><span class="line">❯ gunicorn -w <span class="number">3</span> run:app -b <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让类中的方法不需要提供self参数</title>
    <url>/2016-01-18.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在我初学Python的时候，对方法/函数2种叫法如何区分产生或疑惑。所谓函数，是一段代码，通过名字来进行调用。它能将一些数据（参数）传递进去进行处理，然后返回一些数据（当然也可能并不需要返回）。而方法是一种定义在类里面的函数，它的特殊之处是和对象相关，必须有一个额外的第一个参数名称，但是在调用这个方法的时候开发者并不需要为这个参数赋值，Python会自动提供这个值。这个特别的变量指对象本身，按照惯例它的名称是self。我们先通过一个例子感受下Python是如何自动给这个参数赋值的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hi!'</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">p = Person()  </span><br><span class="line">p.sayHi()  </span><br><span class="line">  </span><br><span class="line">p = Person()  </span><br><span class="line">Person.sayHi(p)</span><br></pre></td></tr></table></figure>


<p>这2种方式都是正确的。注意第二种，sayHi中传递了一个Person对象p进去，相当于我们「人工」来赋值。而第一种（也是我们日常用的这种）是由Python隐式的这样转换的罢了。再想一个更复杂的例子，假如你有一个类称为MyClass和这个类的一个实例MyObject。当你调用这个对象的方法MyObject.method(arg1,<br>arg2)的时候，这会由Python自动转为MyClass.method(MyObject, arg1, arg2) - 这就是self的原理了。<br>假如我们不传递这个self试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">()</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hi!'</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">p = Person()  </span><br><span class="line">p.sayHi()</span><br></pre></td></tr></table></figure>


<p>执行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Traceback (most recent call last):  </span><br><span class="line">  File <span class="string">"self_demo.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> &lt;module&gt;  </span><br><span class="line">    p.sayHi()  </span><br><span class="line">TypeError: sayHi() takes no arguments (<span class="number">1</span> given)</span><br></pre></td></tr></table></figure>


<p>可见Python解释器要求我们必须额外的给类的方法的参数中的第一位加一个self。那么有什么办法就是不加呢？也是可以的，不过要周折一些。</p>
<h3 id="先讲一下思路"><a href="#先讲一下思路" class="headerlink" title="先讲一下思路"></a>先讲一下思路</h3><p>如上例，我们希望写代码的时候不再写self：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">()</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hi!'</span></span><br></pre></td></tr></table></figure>


<p>实现的步骤是：</p>
<ol>
<li>首先给每个类中的方法的参数都加上self参数。</li>
<li>在方法内的命名空间中加上对应的赋值，比如存在self.x, 那么方法内就要可以直接使用x，这个x的值就是self.x…</li>
<li>给旧的方法注入代码之后，基于它创建同名新的方法。</li>
<li>实现一个元类，应用上述对类中方法的处理。<br>我们分步骤实现：<h4 id="1-加self参数"><a href="#1-加self参数" class="headerlink" title="1. 加self参数"></a>1. 加self参数</h4>为了易于演示，假设方法后面的参数都放在一行，原理很简单，就是找左括号，然后在对应位置加上self：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_self_in_header</span><span class="params">(header)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> header[<span class="number">0</span>:header.find(<span class="string">"("</span>) + <span class="number">1</span>] + <span class="string">"self, "</span> + \  </span><br><span class="line">        header[header.find(<span class="string">"("</span>) + <span class="number">1</span>:]</span><br></pre></td></tr></table></figure>


<h4 id="2-方法命名空间内赋值"><a href="#2-方法命名空间内赋值" class="headerlink" title="2. 方法命名空间内赋值"></a>2. 方法命名空间内赋值</h4><p>这个思路就是借用sys._getframe找到对应方法内部的self，然后通过inspect.getmembers找到self的全部属性，在其中找到符合的属性然后赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">magic</span><span class="params">()</span>:</span>  </span><br><span class="line">    s = <span class="string">""</span>  </span><br><span class="line">    <span class="keyword">for</span> var, value <span class="keyword">in</span> inspect.getmembers(sys._getframe(<span class="number">1</span>).f_locals[<span class="string">"self"</span>]):  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (var.startswith(<span class="string">"__"</span>) <span class="keyword">and</span> var.endswith(<span class="string">"__"</span>)) \  </span><br><span class="line">           <span class="keyword">and</span> var <span class="keyword">not</span> <span class="keyword">in</span> f_locals:  </span><br><span class="line">            s += var + <span class="string">" = self."</span> + var + <span class="string">"\n"</span>  </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>


<p>我介绍下sys._getframe参数的意义：</p>
<ol>
<li><code>sys._getframe(0)</code> 当前函数</li>
<li><code>sys._getframe(1)</code> 调用该函数的函数<br>需要注意<code>var not in f_locals</code>这句，如果本地变量中已经有了xxx, 就不能执行<code>xxx = self.xxx</code>来污染了。<br>需要注意sys._getframe返回的是调用栈的对象，所以需要在运行期间使用。另外没事翻翻标准库源码，inspect.getmembers也不是什么黑科技，其实就是dir一下，然后对每个属性getattr获取对应的属性值，不过大家以后有这种需求的时候可以直接使用这个方法而不是自己造啦：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getmembers</span><span class="params">(object, predicate=None)</span>:</span>  </span><br><span class="line">    <span class="string">"""Return all members of an object as (name, value) pairs sorted by name.  </span></span><br><span class="line"><span class="string">    Optionally, only return members that satisfy a given predicate."""</span>  </span><br><span class="line">    results = []  </span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dir(object):  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            value = getattr(object, key)  </span><br><span class="line">        <span class="keyword">except</span> AttributeError:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate <span class="keyword">or</span> predicate(value):  </span><br><span class="line">            results.append((key, value))  </span><br><span class="line">    results.sort()  </span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>


<h4 id="3-更新方法内容"><a href="#3-更新方法内容" class="headerlink" title="3. 更新方法内容"></a>3. 更新方法内容</h4><p>上例中的生成sayHi方法的代码应该是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    exec(magic())  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Hi!'</span></span><br></pre></td></tr></table></figure>


<p>由于Python语法对代码是要求缩进的，首先我们要处理缩进问题，缩进问题分2步：</p>
<ol>
<li>去掉方法相对于行首的空格都去掉，sayHi并让它不缩进，从：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        exec(magic())  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hi!'</span></span><br></pre></td></tr></table></figure>


<p>抽取处理后成为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    exec(magic())  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Hi!'</span></span><br></pre></td></tr></table></figure>


<p>代码这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outdent_lines</span><span class="params">(lines)</span>:</span>  </span><br><span class="line">    outer_ws_count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> lines[<span class="number">0</span>]:  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ch.isspace():  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        outer_ws_count += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> [line[outer_ws_count:] <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>获取缩进的字符串，因为注入的<code>exec(magic())</code>前面也要正确的缩进:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_indent_string</span><span class="params">(srcline)</span>:</span>  </span><br><span class="line">    indent = <span class="string">''</span>  </span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> srcline:  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ch.isspace():  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        indent += ch  </span><br><span class="line">    <span class="keyword">return</span> indent</span><br></pre></td></tr></table></figure>


<p>把上述工作串起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rework</span><span class="params">(func)</span>:</span>  </span><br><span class="line">    srclines, line_num = inspect.getsourcelines(func)  </span><br><span class="line">    srclines = outdent_lines(srclines)  </span><br><span class="line">    dst = insert_self_in_header(srclines[<span class="number">0</span>])  </span><br><span class="line">    <span class="keyword">if</span> len(srclines) &gt; <span class="number">1</span>:  </span><br><span class="line">        dst += get_indent_string(srclines[<span class="number">1</span>]) + <span class="string">'exec(magic())\n'</span>  </span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> srclines[<span class="number">1</span>:]:  </span><br><span class="line">            dst += line  </span><br><span class="line">    dst += <span class="string">'new_func = eval(func.__name__)\n'</span>  </span><br><span class="line">    exec(dst)  </span><br><span class="line">    <span class="keyword">return</span> new_func</span><br></pre></td></tr></table></figure>


<p>其中inspect.getsourcelines非常有用，它可以动态获取源代码。通过它，在IPython中能通过<code>??</code>获得对应函数/方法源代码。<br>另外<code>new_func = eval(func.__name__)</code>最后会被exec，函数本地变量中就包含了基于原来func生成的new_func了。</p>
<h4 id="4-实现元类"><a href="#4-实现元类" class="headerlink" title="4. 实现元类"></a>4. 实现元类</h4><p>也就是在创建类的时候动态的改变类的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithoutSelf</span><span class="params">(type)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attrs)</span>:</span>  </span><br><span class="line">        super(WithoutSelf, self).__init__(name, bases, attrs)  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">for</span> attr, value <span class="keyword">in</span> attrs.items():  </span><br><span class="line">                <span class="keyword">if</span> isinstance(value, FunctionType):  </span><br><span class="line">                    setattr(self, attr, rework(value))  </span><br><span class="line">        <span class="keyword">except</span> IOError:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Couldn't read source code - it wont work."</span>  </span><br><span class="line">            sys.exit()</span><br></pre></td></tr></table></figure>


<p>如果是一个FunctionType类型的属性，就用rework包装一下。</p>
<h3 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h3><p>到了检验的时候了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    __metaclass__ = WithoutSelf  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(name=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hi &#123;&#125;!'</span>.format(name <span class="keyword">or</span> self.name)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">p = Person(<span class="string">'World'</span>)  </span><br><span class="line">p.sayHi()  </span><br><span class="line">p.sayHi(<span class="string">'Python'</span>)</span><br></pre></td></tr></table></figure>


<p>执行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python demo_without_self.py  </span><br><span class="line">Hi World!  </span><br><span class="line">Hi Python!</span><br></pre></td></tr></table></figure>


<p>初步实现了。</p>
<h3 id="这篇文章并不是真的让你不写self"><a href="#这篇文章并不是真的让你不写self" class="headerlink" title="这篇文章并不是真的让你不写self"></a>这篇文章并不是真的让你不写self</h3><p>虽然我们可以通过指定使用上面这个元类的方式不再需要指定self，但事实上只是这个元类帮你去指定罢了。而且这个例子并没有考虑到property等场景，就算实现了这样的元类也不应该在生产环境中使用它。其实在很久之前，有人就提交过一个[在Python<br>3中去掉这个self的草案](<a href="https://mail.python.org/pipermail/python-" target="_blank" rel="noopener">https://mail.python.org/pipermail/python-</a><br>dev/2006-January/059446.html)，不过被核心开发者拒绝了，有兴趣的可以去深入的看看。Python之禅里面说过：</p>
<blockquote>
<p>Explicit is better than implicit.<br>我在知乎回答「为什么Python里类中方法self是显式的，而C++中this是隐式的？」中也说过，Python不希望基于规则而是希望把它明确出来，显式的写self的这种方式就很好。<br>那这篇文章的意义是什么呢？其实就是给大家展示一下Python动态修改源代码的能力，希望读者同学们把这样的玩法应用到有实际意义的地方。<br>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2017-07-05" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到。</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[MAKING SELF IMPLICIT IN<br>OBJECTS](<a href="http://code.activestate.com/recipes/362305-making-self-implicit-in-" target="_blank" rel="noopener">http://code.activestate.com/recipes/362305-making-self-implicit-in-</a><br>objects/)<br><a href="https://mail.python.org/pipermail/python-dev/2006-January/059446.html" target="_blank" rel="noopener">Draft proposal: Implicit self in Python<br>3.0</a></p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python几个特别的__开头的方法</title>
    <url>/2016-01-21.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><a href="http://www.rafekettler.com/magicmethods.html" target="_blank" rel="noopener">A Guide to Python’s Magic<br>Methods</a>python的绝大多数这样的特殊方法都<br>在这里面被提到了. 今天我来说3个他没有提到的[<strong>dir</strong>, <strong>slots</strong>, <strong>weakref</strong>],<br>再强调下他提到的2个[<strong>missing</strong>, <strong>contains</strong>]</p>
<h5 id="dir-gt-看个小例子就知道了"><a href="#dir-gt-看个小例子就知道了" class="headerlink" title="dir -&gt; 看个小例子就知道了"></a><strong>dir</strong> -&gt; 看个小例子就知道了</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">T</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...:     <span class="keyword">pass</span>  </span><br><span class="line">   ...:  </span><br><span class="line">In [<span class="number">2</span>]: t = T()  </span><br><span class="line">In [<span class="number">3</span>]: t.&lt;Tab&gt;  </span><br><span class="line">啥也没有...</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="class"><span class="keyword">class</span> <span class="title">T2</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">__dir__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">   ...:         <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>]  </span><br><span class="line">   ...:  </span><br><span class="line">In [<span class="number">5</span>]: t = T2()  </span><br><span class="line">In [<span class="number">6</span>]: t.  </span><br><span class="line">t.a  t.b  </span><br><span class="line">In [<span class="number">7</span>]: dir(t)  </span><br><span class="line">Out[<span class="number">7</span>]: [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>


<p>看出来了把, 不解释, 但是这个<strong>dir</strong>是相对于类的实例有效果的.</p>
<h5 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h5><p>这个在我初学python的时候就被模糊了, 原来的理解是它的出现替代了<strong>dict</strong>，也就是说你只能给<strong>slots</strong><br>这个变量列表项的属性赋值. 对外的接口减少了,也安全了. 后来看了这篇<a href="http://tech.oyster.com/save-ram-with-python-slots/" target="_blank" rel="noopener">Saving 9 GB of RAM with Python’s<br><strong>slots</strong></a>.<br>好久不做运维了,在生产环境究竟怎么样我无法定论, 也提到了,在对象实例很多的时候他能帮助减少内存,<br>详见&lt;<a href="https://www.safaribooksonline.com/library/view/python-" target="_blank" rel="noopener">https://www.safaribooksonline.com/library/view/python-</a><br>cookbook-3rd/9781449357337/ch08s04.html&gt;.<br>这里来个小实验(在Hacker News也被讨论过<a href="https://news.ycombinator.com/item?id=6750187" target="_blank" rel="noopener">https://news.ycombinator.com/item?id=6750187</a>)<br>代码例子(我对细节做注释):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> starmap, product  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotTest</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="comment"># __slots__ = ['x', 'y', 'z'] 主要对比去掉这句和包含这句程序内存占用  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y, z)</span>:</span>  </span><br><span class="line">            self.x = x  </span><br><span class="line">                    self.y = y  </span><br><span class="line">                            self.z = z  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#123;&#125; &#123;&#125; &#123;&#125;"</span>.format(self.x, self.y, self.z)  </span><br><span class="line">  </span><br><span class="line">p = product(range(<span class="number">10000</span>), range(<span class="number">20</span>), [<span class="number">4</span>]) <span class="comment"># 创建0-1000 &amp; 0-20 &amp; 4 的笛卡尔积  </span></span><br><span class="line">a = list(starmap(SlotTest, p)) <span class="comment"># 相当于对每个SlotTest实例化,实例化的格式是p的长度  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> a[<span class="number">0</span>]  </span><br><span class="line">sys.stdin.read(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<p>结果对比:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$pmap -x `ps -ef|grep test_slot.py|grep -v grep|awk <span class="string">'&#123;print $2&#125;'</span>`|grep total <span class="comment"># 未使用__slots__  </span></span><br><span class="line">  total kB          <span class="number">103496</span>   <span class="number">76480</span>   <span class="number">73728</span>  </span><br><span class="line">$pmap -x `ps -ef|grep test_slot.py|grep -v grep|awk <span class="string">'&#123;print $2&#125;'</span>`|grep total <span class="comment"># 使用了__slots__  </span></span><br><span class="line">  total kB           <span class="number">49960</span>   <span class="number">22888</span>   <span class="number">20136</span></span><br></pre></td></tr></table></figure>


<p>结果很明显,内存占用减少了很多…</p>
<h5 id="weakref-弱引用"><a href="#weakref-弱引用" class="headerlink" title="weakref 弱引用"></a><strong>weakref</strong> 弱引用</h5><p>首先先说下<a href="http://zh.wikipedia.org/wiki/%E5%BC%B1%E5%BC%95%E7%94%A8" target="_blank" rel="noopener">weakref</a>:<br>弱引用，与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收.<br>在Python中,当一个对象的引用数目为0的时候，才会被从内存中回收. 但是被循环引用呢?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> weakref  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> gc  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: <span class="class"><span class="keyword">class</span> <span class="title">Obj</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self)</span>:</span>  </span><br><span class="line">   ...:         <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">   ...:  </span><br><span class="line">In [<span class="number">4</span>]: obj = Obj()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: s = obj  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">6</span>]: gc.collect() <span class="comment"># 不可达引用对象的数量  </span></span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: <span class="keyword">print</span> s <span class="keyword">is</span> obj  </span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">8</span>]: obj = <span class="number">1</span> <span class="comment"># 最初的被引用的对象改变了.  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">9</span>]: gc.collect()  </span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">10</span>]: s <span class="keyword">is</span> <span class="literal">None</span> <span class="comment"># s还是指向了Obj 引用计数为1  </span></span><br><span class="line">Out[<span class="number">10</span>]: <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">11</span>]: s  </span><br><span class="line">Out[<span class="number">11</span>]: &lt;__main__.Obj at <span class="number">0x2b36510</span>&gt;  </span><br><span class="line">  </span><br><span class="line">----华丽的分割一下  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">12</span>]: obj = Obj()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">13</span>]: r = weakref.ref(obj) <span class="comment"># 让obj变成那个弱引用  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">14</span>]: gc.collect()  </span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">211</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">15</span>]: r() <span class="keyword">is</span> obj  </span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">16</span>]: obj = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">17</span>]: gc.collect()  </span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">18</span>]: r() <span class="keyword">is</span> <span class="literal">None</span> <span class="comment"># 弱引用计数器没有增加，所以当obj不在引用Obj的时候，Obj对象就被释放了  </span></span><br><span class="line">Out[<span class="number">18</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<p>好吧, 我的总结是弱引用是个好东西, 但是加了<strong>slots</strong>就不支持弱引用了. 所以需要<strong>weakref</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: <span class="class"><span class="keyword">class</span> <span class="title">T3</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...:     __slots__ = []  </span><br><span class="line">      ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">10</span>]: <span class="class"><span class="keyword">class</span> <span class="title">T4</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ....:     __slots__ = <span class="string">'__weakref__'</span>  <span class="comment"># 这样就支持了weakref  </span></span><br><span class="line">      ....:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">11</span>]:  <span class="keyword">import</span> weakref  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">12</span>]: t3 = T3()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">13</span>]: t4 = T4()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">14</span>]: weakref.ref(t3)  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-14</span>-bdb7ab7ac3bc&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 weakref.ref(t3)  </span><br><span class="line">  </span><br><span class="line">TypeError: cannot create weak reference to <span class="string">'T3'</span> object  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">15</span>]: weakref.ref(t4)  </span><br><span class="line">Out[<span class="number">15</span>]: &lt;weakref at <span class="number">0x2766f70</span>; to <span class="string">'T4'</span> at <span class="number">0x2586fd8</span>&gt;</span><br></pre></td></tr></table></figure>


<h5 id="contains-判断某值-in-not-in-实例"><a href="#contains-判断某值-in-not-in-实例" class="headerlink" title="contains 判断某值 in/not in 实例"></a><strong>contains</strong> 判断某值 in/not in 实例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">NewList</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self, values)</span>:</span>  </span><br><span class="line">   ...:         self.values = values  </span><br><span class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, value)</span>:</span>  </span><br><span class="line">   ...:         <span class="keyword">return</span> value <span class="keyword">in</span> self.values  </span><br><span class="line">   ...:  </span><br><span class="line">In [<span class="number">2</span>]: l = NewList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: <span class="number">4</span> <span class="keyword">in</span> l  </span><br><span class="line">Out[<span class="number">3</span>]: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: <span class="number">10</span> <span class="keyword">in</span> l  </span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h5 id="missing"><a href="#missing" class="headerlink" title="missing"></a><strong>missing</strong></h5><p>最初看这个特殊方法是看python标准库的源码的时候(collections#L421):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span><span class="params">(dict)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span>  </span><br><span class="line">        <span class="string">'The count of elements not in the Counter is zero.'</span>  </span><br><span class="line">        <span class="comment"># Needed so that self[missing_item] does not raise KeyError  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>什么意思呢?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: c = collections.Counter(&#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: c[<span class="string">'b'</span>] <span class="comment"># 没有键的count设置默认值0  </span></span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>很多人可能看过这个(关于defaultdict的ppt)[<a href="http://discorporate.us/jek/talks/defaultdict/]" target="_blank" rel="noopener">http://discorporate.us/jek/talks/defaultdict/]</a>.<br>内容就不说了, 讲的非常好.</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2017年度Python榜单</title>
    <url>/2016-01-22.html</url>
    <content><![CDATA[<p><strong>一起见证全世界Python的这一年</strong><br>非常抱歉这个榜单到现在才发出来，主要有2个原因：1. 本来准备起用 <a href="http://ipython.io" target="_blank" rel="noopener">http://ipython.io</a> 这个域名；2.<br>域名备案时间长，造成后续事情都等；3. 对榜单运营的数据需要的精力和时间预估不够。好在赶在1月的尾巴上线了。<br>话不多说，之后我们详聊。地址是 <a href="https://annual2017.pycourses.com/" target="_blank" rel="noopener">https://annual2017.pycourses.com/</a><br>榜单内容如下：</p>
<ol>
<li>开始页</li>
<li>2017年Star最多的Python项目</li>
<li>2017年最受关注的Python项目</li>
<li>2017年最受关注的中国开发者Python项目</li>
<li>项目/文章介绍 系统设计入门</li>
<li>2017年最受欢迎的Web框架</li>
<li>2017年最受欢迎的爬虫框架</li>
<li>项目/文章介绍 不建议使用的Python Web框架</li>
<li>2017年最受欢迎的pycon视频<br>10.2017年必备的Python工具</li>
<li>2017年要熟悉的Python项目</li>
<li>项目/文章介绍 知乎响应这么慢是因为使用了 Python 语言吗？</li>
<li>2017年最受欢迎的Python开发者</li>
<li>2017年最知名的中国Python开发者</li>
<li>项目/文章介绍 Code Like a Pythonista: Idiomatic Python</li>
<li>2017年最受欢迎的Python英文文章</li>
<li>2017年最受欢迎的Python中文文章</li>
<li>项目/文章介绍 Reddit Python节点</li>
<li>2017年最受欢迎的Django英文文章</li>
<li>2017年最受欢迎的Django中文文章</li>
<li>项目/文章介绍 [英]给Django贡献代码比你想得简单</li>
<li>2017年最受关注的podcast</li>
<li>2017年最受关注的英文技术博客</li>
<li>2017年最受关注的中文技术博客</li>
<li>项目/文章介绍 10 books Python developers should be reading(podcast)</li>
<li>2017年最受关注的Python英文书籍</li>
<li>2017年最受关注的Python中文书籍</li>
<li>2017年最受关注的Python开源书籍</li>
<li>项目/文章介绍 10分钟速成Python 3</li>
<li>2017年最值得关注的知乎Python回答</li>
<li>项目/文章介绍 关于Python的面试题</li>
<li>StackOverflow上最受关注的10个Python问题</li>
<li>StackOverflow上最受关注的10个Python回答</li>
<li>2017年StackOverflow上最受关注的10个Python回答</li>
<li>项目/文章介绍 Python 2 和 Python 3 有哪些主要区别？</li>
<li>2017年最受关注的Python新闻渠道</li>
<li>2017年Reddit热议话题</li>
<li>项目/文章介绍 [视频]Python高级编程</li>
<li>2017年1月最受关注的内容（文章，项目等）</li>
<li>2017年2月最受关注的内容（文章，项目等）</li>
<li>项目/文章介绍 python-koans</li>
<li>2017年3月最受关注的内容（文章，项目等）</li>
<li>2017年4月最受关注的内容（文章，项目等）</li>
<li>项目/文章介绍 Python最佳实践 (BOBP)</li>
<li>2017年5月最受关注的内容（文章，项目等）</li>
<li>2017年6月最受关注的内容（文章，项目等）</li>
<li>项目/文章介绍 使用Python来挑战算法和数据结构</li>
<li>2017年7月最受关注的内容（文章，项目等)</li>
<li>2017年8月最受关注的内容（文章，项目等）</li>
<li>项目/文章介绍 Sanic（asyncio）暂时不适合生产环境</li>
<li>2017年9月最受关注的内容（文章，项目等)</li>
<li>2017年10月最受关注的内容（文章，项目等）</li>
<li>项目/文章介绍 FreeCodeCamp</li>
<li>2017年11月最受关注的内容（文章，项目等）</li>
<li>2017年12月最受关注的内容（文章，项目等）</li>
<li>项目/文章介绍 选择python 2/3 ？</li>
<li>2017年发生的重大事件时间线</li>
<li>感谢那些Python幻灯片</li>
<li>感谢那些老书</li>
<li>感谢那些不再更新的博客和它的作者们</li>
<li>缅怀去世web.py作者</li>
<li>2018年最值得期待的Python书籍</li>
<li>结束页<br>话不多说，之后我们详聊。地址是 <a href="https://annual2017.pycourses.com/" target="_blank" rel="noopener">https://annual2017.pycourses.com/</a><br>需要注意几点：</li>
<li>Web端默认自动开启背景音乐（嗯，曲子都是抖音里面的），主要不要被吓到</li>
<li>移动设备由于有适配问题可能效果不佳，非常推荐在PC端浏览</li>
<li>这个榜单非常长（一共62页），有很多图片，预计需要花费20M，非wifi下请谨慎打开，另外由于内容太多，第一次打开可能会慢</li>
<li>Web端可以玩弹幕</li>
<li>同样是榜单太长的缘故，可以点击右上角的「目录」了解目前的进度，以及直接跳到对应的榜单</li>
<li>同学如果看榜单过程中发现样式问题，欢迎截图戳我<br>明天我会介绍为什么要做这个榜单，以及榜单数据是怎么定的</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python进行并发编程-asyncio篇(一)</title>
    <url>/2016-01-20.html</url>
    <content><![CDATA[<p>由于asyncio有非常多的内容，且对Python工程师非常重要，我将分为三篇文章来介绍它。本篇还不是 <strong>关于使用asyncio进行网络编程</strong><br>的文章，而是继续并发主题，看看使用asyncio怎么实现高效的并发程序。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Python<br>2的时代，高性能的网络编程主要是使用Twisted、Tornado和Gevent这三个库，但是它们的异步代码相互之间既不兼容也不能移植。如上一节说的，Gvanrossum希望在Python<br>3 实现一个原生的基于生成器的协程库，其中直接内置了对异步IO的支持，这就是asyncio，它在Python 3.4被引入到标准库。<br>Python 3.5添加了async和await这两个关键字，分别用来替换<code>asyncio.coroutine</code>和<code>yield
from</code>。自此，协程成为新的语法，而不再是一种生成器类型了。事件循环与协程的引入，可以极大提高高负载下程序的I/O性能。除此之外还增加了<code>async
with</code>(异步上下文管理)、<code>async for</code>(异步迭代器)语法。特别说的是，在新发布的Python<br>3.6里面终于可以用<a href="https://www.python.org/dev/peps/pep-0525/" target="_blank" rel="noopener">异步生成器</a>了！<br>/<br>顺便说一下Twisted。虽然在之前的公司Twisted使用的还挺广泛，它的Reactor、Factory、Deferred、Protocol等编程的思想很有启发性，在当时已经非常先进了，而asyncio也借鉴了一部分。但是它太重、大量的回调（Javascript工程师很容易接受，比如Deferred，小明我不喜欢）、没有及时更新的中文相关的技术文档和书籍所以学习曲线较高、没有更多的公司出来分享对应的实践，再加上协程的冲击，最近1-2年已经很少看到它的身影，不建议新人再去学习它了。</p>
<h3 id="并发哪家强"><a href="#并发哪家强" class="headerlink" title="并发哪家强"></a>并发哪家强</h3><p>首先需要明确一点，asyncio使用单线程、单个进程的方式切换（通常程序等待读或写数据时就是切换上下文的时机），那这样效率高嘛？<br>实践是检验真理的唯一标准。我们用之前介绍的concurrent.futures和asyncio分别试验下。当然下面例子的结果仅供参考，因为无法保证被请求的网站的服务水平，这会造成对结果或多或少有影响，可以多跑几次综合的来看。</p>
<h4 id="requests-ThreadPoolExecutor"><a href="#requests-ThreadPoolExecutor" class="headerlink" title="requests + ThreadPoolExecutor"></a>requests + ThreadPoolExecutor</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">12</span>)  </span><br><span class="line">URL = <span class="string">'http://httpbin.org/get?a=&#123;&#125;'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(a)</span>:</span>  </span><br><span class="line">    r = requests.get(URL.format(a))  </span><br><span class="line">    <span class="keyword">return</span> r.json()[<span class="string">'args'</span>][<span class="string">'a'</span>]  </span><br><span class="line">  </span><br><span class="line">start = time.time()  </span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(fetch, NUMBERS)):  </span><br><span class="line">        print(<span class="string">'fetch(&#123;&#125;) = &#123;&#125;'</span>.format(num, result))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Use requests+ThreadPoolExecutor cost: &#123;&#125;'</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>


<p>非常正统的方式，运行的效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 scraper_thread.py  </span><br><span class="line">fetch(<span class="number">0</span>) = <span class="number">0</span>  </span><br><span class="line">fetch(<span class="number">1</span>) = <span class="number">1</span>  </span><br><span class="line">fetch(<span class="number">2</span>) = <span class="number">2</span>  </span><br><span class="line">fetch(<span class="number">3</span>) = <span class="number">3</span>  </span><br><span class="line">fetch(<span class="number">4</span>) = <span class="number">4</span>  </span><br><span class="line">fetch(<span class="number">5</span>) = <span class="number">5</span>  </span><br><span class="line">fetch(<span class="number">6</span>) = <span class="number">6</span>  </span><br><span class="line">fetch(<span class="number">7</span>) = <span class="number">7</span>  </span><br><span class="line">fetch(<span class="number">8</span>) = <span class="number">8</span>  </span><br><span class="line">fetch(<span class="number">9</span>) = <span class="number">9</span>  </span><br><span class="line">fetch(<span class="number">10</span>) = <span class="number">10</span>  </span><br><span class="line">fetch(<span class="number">11</span>) = <span class="number">11</span>  </span><br><span class="line">Use requests+ThreadPoolExecutor cost: <span class="number">6.493273019790649</span></span><br></pre></td></tr></table></figure>


<p>注意，和ThreadPoolExecutor有关的实现都在scraper_thread.py一个文件中，让网络状态的影响更小，运行的效果也是在一次运行之后截取的。</p>
<h4 id="asyncio-requests-ThreadPoolExecutor"><a href="#asyncio-requests-ThreadPoolExecutor" class="headerlink" title="asyncio + requests + ThreadPoolExecutor"></a>asyncio + requests + ThreadPoolExecutor</h4><p>现在我们加入asyncio再试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_scraper_tasks</span><span class="params">(executor)</span>:</span>  </span><br><span class="line">    loop = asyncio.get_event_loop()  </span><br><span class="line">  </span><br><span class="line">    blocking_tasks = []  </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> NUMBERS:  </span><br><span class="line">        task = loop.run_in_executor(executor, fetch, num)  </span><br><span class="line">        task.__num = num  </span><br><span class="line">        blocking_tasks.append(task)  </span><br><span class="line">  </span><br><span class="line">    completed, pending = <span class="keyword">await</span> asyncio.wait(blocking_tasks)  </span><br><span class="line">    results = &#123;t.__num: t.result() <span class="keyword">for</span> t <span class="keyword">in</span> completed&#125;  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> sorted(results.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]):  </span><br><span class="line">        print(<span class="string">'fetch(&#123;&#125;) = &#123;&#125;'</span>.format(num, result))  </span><br><span class="line">  </span><br><span class="line">start = time.time()  </span><br><span class="line">executor = ThreadPoolExecutor(<span class="number">3</span>)  </span><br><span class="line">event_loop = asyncio.get_event_loop()  </span><br><span class="line">  </span><br><span class="line">event_loop.run_until_complete(  </span><br><span class="line">    run_scraper_tasks(executor)  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Use asyncio+requests+ThreadPoolExecutor cost: &#123;&#125;'</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>


<p>如果之前没有使用过asyncio的同学可能看完就一脸😳了。我们之前编写多进程和多线程代码的时候，会感觉和我们的线性思维方法是一致的，所以写起来很舒服，理解和维护也相对容易。大家要做好一些心理准备，Python核心开发们在努力让Python开发者用同步编程的方式去写异步代码，<br>但是还是需要调整一下心态，做好迎接新的写法的准备。我来分析下这个例子：</p>
<ol>
<li>当我们给一个函数添加了async关键字，就会把它变成一个异步函数。</li>
<li>每个线程有一个事件循环，主线程调用asyncio.get_event_loop时会创建事件循环，你需要把异步的任务丢给这个循环的run_until_complete方法，事件循环会 <strong>安排协同程序的执行</strong> 。和方法名字一样，异步的任务完成方法才会就执行完成了。</li>
<li>为了在asyncio中使用concurrent.futures的执行器，我这用到了run_in_executor，它可以接收要 <em>同步</em> 执行的任务。</li>
<li>给task设置__num属性，是因为后面的completed中的Future对象只包含结果，但是我们并不知道num是什么，所以hack了下，之后的例子中会有其他的方案，本文是给大家提供各种解题的思路，在合适的场景还是有用处的。</li>
<li><code>await asyncio.wait(blocking_tasks)</code>就是协同的执行那些同步的任务，直到完成。</li>
<li>最后根据__num找到和执行结果的对应关系，排序然后打印结果。<br>有一点得强调： <strong>async/await是Python提供的异步编程API，而asyncio只是一个利用 async/await<br>API进行异步编程的框架</strong><br>运行一下看看性能有没有提升：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fetch(<span class="number">0</span>) = <span class="number">0</span>  </span><br><span class="line">fetch(<span class="number">1</span>) = <span class="number">1</span>  </span><br><span class="line">fetch(<span class="number">2</span>) = <span class="number">2</span>  </span><br><span class="line">fetch(<span class="number">3</span>) = <span class="number">3</span>  </span><br><span class="line">fetch(<span class="number">4</span>) = <span class="number">4</span>  </span><br><span class="line">fetch(<span class="number">5</span>) = <span class="number">5</span>  </span><br><span class="line">fetch(<span class="number">6</span>) = <span class="number">6</span>  </span><br><span class="line">fetch(<span class="number">7</span>) = <span class="number">7</span>  </span><br><span class="line">fetch(<span class="number">8</span>) = <span class="number">8</span>  </span><br><span class="line">fetch(<span class="number">9</span>) = <span class="number">9</span>  </span><br><span class="line">fetch(<span class="number">10</span>) = <span class="number">10</span>  </span><br><span class="line">fetch(<span class="number">11</span>) = <span class="number">11</span>  </span><br><span class="line">Use asyncio+requests+ThreadPoolExecutor cost: <span class="number">6.142597913742065</span></span><br></pre></td></tr></table></figure>


<p>多跑几次可以发现和requests+ThreadPoolExecutor相比没有什么优势，就像是封装了一层，是有损耗的。<br>讲到这里，我们想想为什么asyncio的强大优势没有显示出来？<br>现存的一些库其实并不能原生的支持asyncio（因为会发生阻塞或者功能不可用），比如requests，如果要写爬虫，配合asyncio的应该用aiohttp，其他的如数据库驱动等各种Python对应的库也都得使用对应的aioXXX版本了。</p>
<h4 id="asyncio-aiohttp"><a href="#asyncio-aiohttp" class="headerlink" title="asyncio + aiohttp"></a>asyncio + aiohttp</h4><p>我们看一下使用aiohttp会发生什么。第一步就是把fetch函数改成异步的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_async</span><span class="params">(a)</span>:</span>  </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.request(<span class="string">'GET'</span>, URL.format(a)) <span class="keyword">as</span> r:  </span><br><span class="line">        data = <span class="keyword">await</span> r.json()  </span><br><span class="line">    <span class="keyword">return</span> data[<span class="string">'args'</span>][<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>


<p>其实看起来和requests的接口差不多，只是你要熟悉这种编程模式就好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">start = time.time()  </span><br><span class="line">event_loop = asyncio.get_event_loop()  </span><br><span class="line">tasks = [fetch_async(num) <span class="keyword">for</span> num <span class="keyword">in</span> NUMBERS]  </span><br><span class="line">results = event_loop.run_until_complete(asyncio.gather(*tasks))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, results):  </span><br><span class="line">    print(<span class="string">'fetch(&#123;&#125;) = &#123;&#125;'</span>.format(num, result))</span><br></pre></td></tr></table></figure>


<p>代码比上个例子简单不少，这里需要注意，asyncio.gather可以按顺序搜集异步任务执行的结果，我们就不需要用到之前提过的__num（而且也hack不了，因为fetch_async是一个生成器，不能那样添加属性）<br>希望能进行协程切换的地方，就需要使用await关键字。如上的例子中r.json方法会等待I/O（也就是正在做一个网络请求），这种就可以切换去做其他的时候，之后再切换回来。<br>运行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fetch(<span class="number">0</span>) = <span class="number">0</span>  </span><br><span class="line">fetch(<span class="number">1</span>) = <span class="number">1</span>  </span><br><span class="line">fetch(<span class="number">2</span>) = <span class="number">2</span>  </span><br><span class="line">fetch(<span class="number">3</span>) = <span class="number">3</span>  </span><br><span class="line">fetch(<span class="number">4</span>) = <span class="number">4</span>  </span><br><span class="line">fetch(<span class="number">5</span>) = <span class="number">5</span>  </span><br><span class="line">fetch(<span class="number">6</span>) = <span class="number">6</span>  </span><br><span class="line">fetch(<span class="number">7</span>) = <span class="number">7</span>  </span><br><span class="line">fetch(<span class="number">8</span>) = <span class="number">8</span>  </span><br><span class="line">fetch(<span class="number">9</span>) = <span class="number">9</span>  </span><br><span class="line">fetch(<span class="number">10</span>) = <span class="number">10</span>  </span><br><span class="line">fetch(<span class="number">11</span>) = <span class="number">11</span>  </span><br><span class="line">Use asyncio+aiohttp cost: <span class="number">1.8903069496154785</span></span><br></pre></td></tr></table></figure>


<p>有木有亮瞎眼，3倍的提升！！！</p>
<h4 id="asyncio-aiohttp-ThreadPoolExecutor"><a href="#asyncio-aiohttp-ThreadPoolExecutor" class="headerlink" title="asyncio + aiohttp + ThreadPoolExecutor"></a>asyncio + aiohttp + ThreadPoolExecutor</h4><p>接着我们再加回ThreadPoolExecutor。之前说asyncio是单线程单进程的，那么我多线程同时运行，会不会翻倍 ╰( <em>°▽°</em> )╯<br>作为工程师，有想法就实践来验证下。写代码之前我们回忆一下，XXExecutor其实就是封装了队列，但是由于run_in_executor并不能传入异步的函数，我们不能按照例子2来用。独立使用队列其实效果应该和ThreadPoolExecutor差不多，那我们可不可以把任务平均切分一下，尽量让每个线程拿到的任务差不多。这就是我选择<code>NUMBERS
= range(12)</code>的原因：可以均分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_async</span><span class="params">(a)</span>:</span>  </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.request(<span class="string">'GET'</span>, URL.format(a)) <span class="keyword">as</span> r:  </span><br><span class="line">        data = <span class="keyword">await</span> r.json()  </span><br><span class="line">    <span class="keyword">return</span> a, data[<span class="string">'args'</span>][<span class="string">'a'</span>]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_loop</span><span class="params">(numbers)</span>:</span>  </span><br><span class="line">    loop = asyncio.new_event_loop()  </span><br><span class="line">    asyncio.set_event_loop(loop)  </span><br><span class="line">    tasks = [fetch_async(num) <span class="keyword">for</span> num <span class="keyword">in</span> numbers]  </span><br><span class="line">    results = loop.run_until_complete(asyncio.gather(*tasks))  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> results:  </span><br><span class="line">        print(<span class="string">'fetch(&#123;&#125;) = &#123;&#125;'</span>.format(num, result))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(executor, numbers)</span>:</span>  </span><br><span class="line">    <span class="keyword">await</span> asyncio.get_event_loop().run_in_executor(executor, sub_loop, numbers)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunks</span><span class="params">(l, size)</span>:</span>  </span><br><span class="line">    n = math.ceil(len(l) / size)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(l), n):  </span><br><span class="line">        <span class="keyword">yield</span> l[i:i + n]                                                       </span><br><span class="line">          </span><br><span class="line">event_loop = asyncio.get_event_loop()  </span><br><span class="line">tasks = [run(executor, chunked) <span class="keyword">for</span> chunked <span class="keyword">in</span> chunks(NUMBERS, <span class="number">3</span>)]  </span><br><span class="line">results = event_loop.run_until_complete(asyncio.gather(*tasks))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Use asyncio+aiohttp+ThreadPoolExecutor cost: &#123;&#125;'</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>


<p>我在解释下这个例子中的几点：</p>
<ol>
<li>现在任务被拆分，不能用<code>zip(NUMBERS, results)</code>的方式拿到正确的num和结果的对应关系了，也由于由于不能给fetch_async加一个__num的属性随意直接改了任务的返回值，把num也返回了</li>
<li>chunks是一个给任务分组的函数，分三份是因为ThreadPoolExecutor用了三个线程。</li>
<li>非主线程不能使用主线程的事件循环对象，所以在sub_loop中我对重新设置了新的对象。<br>见证奇迹的时刻到了：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fetch(<span class="number">8</span>) = <span class="number">8</span>  </span><br><span class="line">fetch(<span class="number">9</span>) = <span class="number">9</span>  </span><br><span class="line">fetch(<span class="number">10</span>) = <span class="number">10</span>  </span><br><span class="line">fetch(<span class="number">11</span>) = <span class="number">11</span>  </span><br><span class="line">fetch(<span class="number">0</span>) = <span class="number">0</span>  </span><br><span class="line">fetch(<span class="number">1</span>) = <span class="number">1</span>  </span><br><span class="line">fetch(<span class="number">2</span>) = <span class="number">2</span>  </span><br><span class="line">fetch(<span class="number">3</span>) = <span class="number">3</span>  </span><br><span class="line">fetch(<span class="number">4</span>) = <span class="number">4</span>  </span><br><span class="line">fetch(<span class="number">5</span>) = <span class="number">5</span>  </span><br><span class="line">fetch(<span class="number">6</span>) = <span class="number">6</span>  </span><br><span class="line">fetch(<span class="number">7</span>) = <span class="number">7</span>  </span><br><span class="line">Use asyncio+aiohttp+ThreadPoolExecutor cost: <span class="number">2.66983699798584</span></span><br></pre></td></tr></table></figure>


<p>╮(╯_╰)╭ 忧伤，就算最后没有对结果排序，依然慢了一些。还是asyncio+aiohttp最好了。</p>
<h4 id="使用ProcessPoolExecutor会怎么样？"><a href="#使用ProcessPoolExecutor会怎么样？" class="headerlink" title="使用ProcessPoolExecutor会怎么样？"></a>使用ProcessPoolExecutor会怎么样？</h4><p>为了验证多进程模式下的上述实验的效果，我找了一台服务器，把ThreadPoolExecutor都替换成ProcessPoolExecutor。我就直接贴答案了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; python3 scraper_process.py  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">Use requests+ProcessPoolExecutor cost: <span class="number">2.2943034172058105</span>  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">Use asyncio+requests+ThreadPoolExecutor cost: <span class="number">2.609675407409668</span>  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">Use asyncio+aiohttp cost: <span class="number">0.6706254482269287</span>  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">Use asyncio+aiohttp+ThreadPoolExecutor cost: <span class="number">1.690920352935791</span></span><br></pre></td></tr></table></figure>


<p>结论就是 <strong>在Python 3，请直接原生的使用asyncio</strong> 吧。</p>
<h3 id="深入asyncio"><a href="#深入asyncio" class="headerlink" title="深入asyncio"></a>深入asyncio</h3><p>首先我们先补充点基础知识。先说「10K问题怎么解决」</p>
<h4 id="10K问题怎么解决"><a href="#10K问题怎么解决" class="headerlink" title="10K问题怎么解决"></a>10K问题怎么解决</h4><p>在Nginx没有流行起来的时候，常被提到一个词<br>10K（并发1W）。在互联网的早期，网速很慢、用户群很小需求也只是简单的页面浏览，所以最初的服务器设计者们使用基于进程/线程模型，也就是一个TCP连接就是分配一个进程(线程)。谁都没有想到现在Web<br>2.0时候用户群里和复杂的页面交互问题，而现在即时通信和实在实时互动已经很普遍了。那么你设想如果每一个用户都和服务器保持一个（甚至多个）TCP连接才能进行实时的数据交互，别说BAT这种量级的网站，就是豆瓣这种比较小的网站，同时的并发连接也要过亿了。进程是操作系统最昂贵的资源，一台机器无法创建很多进程。如果要创建10K个进程，那么操作系统是无法承受的。就算我们不讨论随着服务器规模大幅上升带来复杂度几何级数上升的问题，采用分布式系统，只是维持1亿用户在线需要10万台服务器，成本巨大，也只有FLAG、BAT这样公司才有财力购买如此多的服务器。<br>为了解决这一问题，出现了「用同一进程/线程来同时处理若干连接」的思路，也就是I/O多路复用：</p>
<ol>
<li>select。每个连接对应一个描述符（socket），循环处理各个连接，先查下它的状态，ready了就进行处理，不ready就不进行处理。但是缺点很多：<ol>
<li>单个进程能够监视的文件描述符的数量存在最大限制</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</li>
<li>需要维护一个用来存放大量的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</li>
</ol>
</li>
<li>poll。本质上和select没有区别，但是由于它是基于链表来存储的，没有最大连接数的限制。缺点是：<ol>
<li>大量的的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>poll的特点是「水平触发(只要有数据可以读，不管怎样都会通知)」，如果报告后没有被处理，那么下次poll时会再次报告它。</li>
</ol>
</li>
<li>epoll。它使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。epoll支持水平触发和边缘触发，最大的特点在于「边缘触发」，它只告诉进程哪些刚刚变为就绪态，并且只会通知一次。使用epoll的优点很多：<ol>
<li>没有最大并发连接的限制，能打开的fd的上限远大于1024（1G的内存上能监听约10万个端口）</li>
<li>效率提升，不是轮询的方式，不会随着fd数目的增加效率下降</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销<br>因为Linux是互联网企业中使用率最高的操作系统，epoll就成为C10K<br>killer、高并发、高性能、异步非阻塞这些技术的代名词了。FreeBSD推出了kqueue，Linux推出了epoll，Windows推出了IOCP，Solaris推出了/dev/poll。这些操作系统提供的功能就是为了解决C10K问题。epoll技术的编程模型就是异步非阻塞回调，也可以叫做Reactor、事件驱动、事件轮循（EventLoop）、libevent、Tornado、Node.js这些就是epoll时代的产物。<br>看了上面一段话，是不是感觉对着一坨概念理解的更清晰了呢？Python 3.4中还新增了一个与asyncio配套的新模块：selectors.<br>这个模块将select、epoll、kqueue等等系统级异步IO接口抽象成Selector类型，规定了统一的对外接口，于是程序只管使用selector的接口就行了。一般使用<code>selectors.DefaultSelector</code>就好了，它是这个模块根据你的系统自动帮你选择的最合适的Selector。<br>就这样小公司也可以玩高并发了。但是时代在发展，现在大家讨论的都是10M、100M这种挑战，而写过Node.js都知道异步嵌套回调非常难写，同样的问题也存在于Twisted：对代码的理解和调试都变得困难，维护性很低。上述的技术已经无能为力了。从前面的演化过程中，我们可以看到，根本的思路是要</li>
</ol>
<strong>高效的去阻塞，让CPU可以干核心的任务。所以，千万级并发实现的秘密：内核不是解决方案，而是问题所在！</strong><br>这意味着：<blockquote>
</blockquote>
不要让内核执行所有繁重的任务。将数据包处理，内存管理，处理器调度等任务从内核转移到应用程序高效地完成。让Linux只处理控制层，数据层完全交给应用程序来处理。<br>当连接很多时，首先需要大量的进程/线程来做事。同时系统中的应用进程/线程们可能大量的都处于 ready<br>状态，需要系统去不断的进行快速切换，而我们知道系统上下文的切换是有代价的。虽然现在Linux系统的调度算法已经设计的很高效了，但对于10M这样大规模的场景仍然力有不足。<br>所以我们面临的瓶颈有两个：</li>
<li>进程/线程作为处理单元还是太厚重</li>
<li>系统调度的代价太高<br>很自然地，我们会想到，如果有一种更轻量级的进程/线程作为处理单元，而且它们的调度可以做到很快（最好不需要锁），那就完美了。这个时候「协程」出现了，下一小节我们继续了解它。<h4 id="再谈协程"><a href="#再谈协程" class="headerlink" title="再谈协程"></a>再谈协程</h4>它们在实现上都是试图用一组少量的线程来实现多个任务，一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换。每个协程所独占的系统资源往往只有栈部分。而且，各个协程之间的切换，往往是用户通过代码来显式指定的（跟各种<br>callback 类似），不需要内核参与，可以很方便的实现异步。<br>协程本质上也是异步非阻塞技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环。程序员就像写阻塞代码一样简单。比如调用 client-&gt;recv()<br>等待接收数据时，就像阻塞代码一样写。实际上是底层库在执行recv时悄悄保存了一个状态，比如代码行数，局部变量的值。然后就跳回到EventLoop中了。什么时候真的数据到来时，它再把刚才保存的代码行数，局部变量值取出来，又开始继续执行。<br>简单的说，进程/线程是操作系统充当了EventLoop调度，而协程是自己用epoll进行调度。<br>协程是异步非阻塞的另外一种展现形式。Golang，Erlang，Lua协程都是这个模型。那什么是异步和非阻塞呢？<br>在网站可以找到很多对I/O模型进行对比和解释的文章，推荐阅读知友<a href="https://www.zhihu.com/people/svjoke" target="_blank" rel="noopener">严肃</a>对它们的<a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">理解</a>（已获得授权）：<blockquote>
<p>1.同步与异步<br>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个 <em>调用</em> 时，在没有得到结果之前，该 <em>调用</em> 就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由 <em>调用者</em> 主动等待这个 <em>调用</em> 的结果。<br>而异步则是相反， <em>调用</em> 在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<br><em>调用</em> 发出后， _<br>被调用者_ 通过状态、通知来通知调用者，或通过回调函数处理这个调用。<br>典型的异步编程模型比如Node.js，举个通俗的例子：  </p>
</blockquote>
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。  <blockquote>
</blockquote>
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。<blockquote>
<ol start="2">
<li>阻塞与非阻塞<br>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</li>
</ol>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>还是上面的例子，  </p>
</blockquote>
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了，<br>当然你也要偶尔过几分钟check一下老板有没有返回结果。  <blockquote>
<p>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
</blockquote>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4>事件循环是一种处理多并发量的有效方式，在<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">维基百科</a>中它被描述为「一种等待程序分配事件或消息的编程架构」,，我们可以定义事件循环来简化使用轮询方法来监控事件。它的意义最通俗的说法就是「当A发生时，执行B」。事件循环利用poller对象，使得程序员不用控制任务的添加、删除和事件的控制。事件循环使用回调方法来知道事件的发生。例如，有一个资源描述符A，当一个写事件在A中发生就会调用一个回调函数。如下应用都实现了事件循环：</li>
</ol>
<ul>
<li><a href="http://www.tornadoweb.org/" target="_blank" rel="noopener">Tornado web server</a></li>
<li><a href="https://twistedmatrix.com/" target="_blank" rel="noopener">Twisted</a></li>
<li><a href="http://www.gevent.org" target="_blank" rel="noopener">Gevent</a><br>当然也包含asyncio，他是asyncio提供的「中央处理设备」，支持如下操作：</li>
<li>注册、执行和取消延迟调用（超时）</li>
<li>创建可用于多种类型的通信的服务端和客户端的Transports</li>
<li>启动进程以及相关的和外部通信程序的Transports</li>
<li>将耗时函数调用委托给一个线程池<br>单线程（进程）的架构也避免的多线程（进程）修改可变状态的锁的问题。<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://rango.swoole.com/archives/381" target="_blank" rel="noopener">关于C10K、异步回调、协程、同步阻塞</a></li>
<li><a href="http://www.jianshu.com/p/b594acbcf9b7" target="_blank" rel="noopener">聊聊C10K问题及解决方案</a><br>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2016-12-13" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到。<br>我的知乎Live「<a href="https://www.zhihu.com/lives/789840559912009728" target="_blank" rel="noopener">Python 工程师的入门和进阶</a>」<br>无耻的广告：<a href="https://zhuanlan.zhihu.com/p/22371355" target="_blank" rel="noopener">《Python Web开发实战》上市了！</a></li>
</ul>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>仿slid.es的在线PPT编辑网站</title>
    <url>/2016-01-23.html</url>
    <content><![CDATA[<p>####前言<br><a href="https://slid.es" target="_blank" rel="noopener">slid.es</a>是我最喜欢的前端之一<a href="https://github.com/hakimel" target="_blank" rel="noopener">hakimel</a>的作品，前身叫做rvl.io,<br>网站已经改版。源于去年年底在上家公司做年终总结PPT，对我这种不搞office，没有美感的小程序员太痛苦了，然后就找到了<a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js</a>,<br>后来萌发做个基于它的网站, 其实也是为了练手学习mongoengine和oauth<br>项目地址 <a href="https://github.com/dongweiming/flask_reveal" target="_blank" rel="noopener">flask_reveal</a><br>####它能做什么</p>
<ul>
<li>保存漂亮的在线PPT(我认为的)</li>
<li>记录浏览次数</li>
<li>多种主题和字体</li>
<li>可以把PPT私有化(默认是公开的)</li>
<li>自动保存修改</li>
<li>支持Bitbucket/Google/Github/Instagram/Linkdln/Trello/Tumblr/Stackoverflow oauth/oauth2登陆</li>
<li>PPT预览<br>####使用了什么</li>
<li>flask</li>
<li>mongoengine (忍不了非orm)</li>
<li>flask-script (像django那样的命令行启动)</li>
<li>前端js借用我做喜欢的原作者的90%，然后根据我的需要改动，css基本没动</li>
<li><a href="https://github.com/omab/python-social-auth" target="_blank" rel="noopener">python-social-auth</a>的oauth后端，但是它使用的是flask+sqlalchemy，不支持flask+mongoengine，我改写了这部分<br>####Usage<br>设置hosts文件<br>唉，本来申请了很多oauth想放在sae上面，但是遗憾的是新浪不支持，所以只能本地加hosts，让验证后的回调正确返回 linux<br>在你的/etc/hosts 文件里面添加一行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">YOURIP   YOURDOMAIN</span><br></pre></td></tr></table></figure>


<p>复制配置文件然后把你注册的ouauth放进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cp settings.py.example settings.py</span><br></pre></td></tr></table></figure>


<p>象django那样启动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python manage.py runserver -t <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> -p <span class="number">80</span></span><br></pre></td></tr></table></figure>


<p>And 访问主页<code>http://revealcn.sinaapp.com</code><br>####使用nginx+uwsgi<br>这里是我的配置nginx的这段（假设你git clone 后在/home/dongwm/flask_reveal）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;  </span><br><span class="line">		listen <span class="number">80</span>;  </span><br><span class="line">		server_name revealcn.sinaapp.com;  </span><br><span class="line">  </span><br><span class="line">		access_log /var/log/nginx/revealcn.access_log main;  </span><br><span class="line">		error_log /var/log/nginx/revealcn.error_log info;  </span><br><span class="line">		location / &#123;  </span><br><span class="line">                include uwsgi_params;  </span><br><span class="line">                uwsgi_pass unix:///tmp/uwsgi.sock;  </span><br><span class="line">        	&#125;  </span><br><span class="line">		location /zongjie &#123;  </span><br><span class="line">		root   /home/dongwm/flask_reveal;  </span><br><span class="line">		index index.html;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>uwsgi的xml配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;uwsgi&gt;  </span><br><span class="line">     &lt;pythonpath&gt;/home/dongwm/flask_reveal&lt;/pythonpath&gt;  </span><br><span class="line">     &lt;module&gt;manage&lt;/module&gt;  </span><br><span class="line">     &lt;socket&gt;/tmp/uwsgi.sock&lt;/socket&gt;      </span><br><span class="line">    &lt;callable&gt;manager&lt;/callable&gt;  </span><br><span class="line">     &lt;master/&gt;  </span><br><span class="line">     &lt;processes&gt;4&lt;/processes&gt;         </span><br><span class="line">     &lt;memory-report/&gt;  </span><br><span class="line">&lt;/uwsgi&gt;</span><br></pre></td></tr></table></figure>


<p>这里有个坑，我的gentoo的uwsgi安装后是有插件的，你需要这样启动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">uwsgi_python27 -x uwsgi.xml</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>r-上传文件服务</title>
    <url>/2016-01-25.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>豆瓣内部有一些基础设施我认为做得都很好, 比如bridge和p. 一是身为用户的体验, 一个是我以开发的角度会去想我能不能做的更好.<br>这些基础设施凝聚了豆瓣早期的工程师文化的精髓, 至今还在影响着每个豆瓣的工程师.<br>今天我们聊到的是<a href="https://github.com/qingfeng/p" target="_blank" rel="noopener">p</a> - 一个文件上传托管服务, 一个被严重低估了的工具,<br>它已经被清风老师拆分出来不需要跑在dae上.<br>而我今天推荐的就是我用react+es6plus+webpack重写的版本 <a href="https://github.com/dongweiming/r" target="_blank" rel="noopener">r</a><br>为什么说我认为被低估呢? 目前star也才五十几. 当时开始用p. 我对效果非常惊艳.<br>如果你很好奇是不是也会这么认为. 可以先看个heroku的[demo](<a href="https://vast-" target="_blank" rel="noopener">https://vast-</a><br>brushlands-4477.herokuapp.com/). 因为连接了heroku的远程cleardb(mysql的封装), 上传反映略慢.<br>而本地会很流畅. 主要看效果吧.</p>
<h3 id="r的用途"><a href="#r的用途" class="headerlink" title="r的用途"></a>r的用途</h3><p>身在互联网工作, 会经常有这样的需求</p>
<ol>
<li>希望上传后的文件(包含图片)可以被永久存放.</li>
<li>想在github(CODE)上, 能方便的引用一些bug截图(甚至在多个地方引用).</li>
<li>希望上传的文件(包含图片), 能有一个比较好的预览页(包含文件大小, 文件类型, 上传时间等), 下载地址, 也能生成短链接, 二维码</li>
<li>希望能对某上传的图片传一些参数做对应的缩放和剪切</li>
<li>身在互联网, 页面太low, 效果不炫, 作为工程师, 用起来是会有抵制心情的.<br>对. r(p) 就可以做这些事.<h3 id="用到的其他技术"><a href="#用到的其他技术" class="headerlink" title="用到的其他技术"></a>用到的其他技术</h3>Flask, SQLAlchemy, Mako, Pillow</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之微信小程序实战（一）</title>
    <url>/2016-01-24.html</url>
    <content><![CDATA[<p>首先感受下效果：<br>![](<a href="https://github.com/dongweiming/weapp-" target="_blank" rel="noopener">https://github.com/dongweiming/weapp-</a><br>zhihulive/raw/master/screenshot/zhihulive.png)<br>项目地址 <a href="https://github.com/dongweiming/weapp-zhihulive" target="_blank" rel="noopener">https://github.com/dongweiming/weapp-zhihulive</a></p>
<h3 id="我对小程序的看法"><a href="#我对小程序的看法" class="headerlink" title="我对小程序的看法"></a>我对小程序的看法</h3><p>我一向不喜欢跟风。小程序刚出的时候一大波人吹捧，一个月后一大堆人看衰，全然忘记曾经的话，其实脸被打的是啪啪啪。<br>当我真正的用它开发，实践了产品需求。现在我还是对它持观察态度：</p>
<ol>
<li>整体太过封闭。微信想的是用户不断的进行「手机开机 —&gt; 微信 —&gt; （社交+购物+吃饭+金融…） —&gt; 手机关机」的循环，但是别的公司想的是「微信 —&gt; 小程序 —&gt; 获得粉丝 —&gt; 引流或者引导用户下载APP感受完整版」，大家各怀鬼胎，但是谁都不蠢。</li>
<li>相关限制太多（分享按钮、诱导分享）。</li>
<li>入口太深。搜索和使用小程序目前看是不小的门槛。<br>但引用我点过赞的一个对于小程序发布一个月的表现如何的<a href="https://www.zhihu.com/question/55480298/answer/145823043" target="_blank" rel="noopener">大司马大将军</a>回答：<blockquote>
<p>互联网时代，人们更加没有耐心——没耐心到以至于30天时间，就有人开始对小程序“盖棺定论”了。这真是一件让人悲哀的不知道该说啥的事。<br>具体的回答内容限于篇幅就不展开了。期待小程序的下一步。</p>
</blockquote>
<h3 id="页面设计思路"><a href="#页面设计思路" class="headerlink" title="页面设计思路"></a>页面设计思路</h3>术业有专攻，我有个缺点，就是设计页面会懵…<br>如果没有设计图让我凭空去想我很痛苦，比如这个小程序，我一开始是按着知乎APP的配色和Live相关内容的布局做的，但是越到后来越发现效果我不喜欢。现在的主色、发现页、话题页是抄袭了&lt;<a href="https://github.com/romoo/weapp-" target="_blank" rel="noopener">https://github.com/romoo/weapp-</a><br>demo-breadtrip的感觉，加上了一些我的理解。其他的页面是我自己对Live产品的理解做的。&gt;<h3 id="小程序完成的功能"><a href="#小程序完成的功能" class="headerlink" title="小程序完成的功能"></a>小程序完成的功能</h3>我之前在我的知乎Live以及回答的一些问题中都提到过，一定要找个机会写一个相对复杂的项目深入你要学习的技术，只看文章、书、视频效果其实是很差的，只有实践了才真的能记住和理解。<br>那对我来说，这个小程序就是对我最近学习的东西效果的产出。这也是我平时学习东西的方式。在一开始的时候我就基于对知乎Live的理解，给自己列出了小程序要完成的功能：</li>
<li>发现页。用户一登录就看到的页面，展示了一些基于我的理解的算法排序的Live。</li>
<li>7/30天最受欢迎的Live。知乎也有，但是我对它那个顺序不太满意：小众的Live太难上榜，评分低但是收入高的Live排的靠前。在豆瓣，要是国产电影3-4分但是由于票房很高就排得很高，你们想想我们会被怎么骂。</li>
<li>热门话题页面/话题筛选。我开始有这个小程序的想法的时候，知乎还不能基于分类去筛选Live。不方便。</li>
<li>搜索。当时还没有搜索，现在的搜索也比较鸡肋吧，就是个简单的关键词匹配，都不能模糊查询（比如搜索pythno就找不到符合的Live）。</li>
<li>个人页面，社交必备元素了，包含个人信息以及其主讲的Live列表。</li>
<li>基于多种条件对主讲人排序。<br>我以前说过，我不反对造轮子，关键是造的得有意义。就是你要造的东西能解决你的痛点，比如我这个就是由于知乎提供的功能不满足我的需求（比如当时想找个某关键词的相关Live，用「site:zhihu.com<br>live python」这样的方式Google），以及它提供的排序价值观我不太认同。<br>要不然造轮子，造着造着容易放弃。<br>基于上面说的需求，我不断的更新这个专题直到今天（昨天的MVVM都是给今天做铺垫）。<h3 id="组件化思想"><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h3>关于「组件化」网上有很多写的很不错的文章，推荐大家去看看。我特别喜欢美团点评团队的博客中提到的：<blockquote>
<p>Controlling complexity is the essence of computer programming.<br>随着前端开发复杂度的日益提升，组件化开发应运而生，并随着React等优秀框架的出现遍地开花。大家都在各种尝试努力的「Controlling<br>complexity」。<br>我试着用最多的描述介绍下组件化发展的历史。<br>我们先讨论什么是组件？其实我们日常开发（尤其是前端开发）接触到的component , widget , module ,<br>plugin就是组件，缺点是大家实现不统一，使用方式也不统一。到了2011年，Alex Russell提出了「Web Component」：</p>
</blockquote>
</li>
<li>Custom Element: 自定义HTML元素</li>
<li>shadow DOM: 封装</li>
<li>HTML Imports: 打包一切</li>
<li>HTML Template: Lazy的DOM模板<br>JavaScript本来是一门作为浏览器上的脚本语言出身，并不适合于大规模开发。同年Google提出的MDV（Model-Driven<br>Views）框架，提出了我们也需要向对待后端系统一样对前端逻辑进行统一管理、分层(表现逻辑、viewmodel、视图)。所以Backbone、AngularJS、Ember之类的数据绑定框架横空出世了，力求给我们带来代码的模块管理、数据、视图的分离，他们以他们不同的方式解决共同的问题：<br>1.如何更好地模块化开发<br>2.业务数据如何组织<br>3.界面和业务数据，业务逻辑的分离<br>与此同时其实用户体验的要求html5，ECMAScript也在快速的推进。2013年，Googl推出了新的UI框架Polymer，它的实现使用了WebComponent标准，并且Polymer可保证针对包含各种平台的Web<br>Component规范本地实现的浏览器、库和组件的使用效果完全相同。它代表了下一代的web组件方向：一切皆组件、尽量减少代码量、尽量减少框架限制。<br>同年，React并没有采用Web<br>Components的方案，以高性能虚拟Dom为切入点，在facebook的造势下，社区得到了大力发展。官方说React倾向于做传统MVC架构中的View层。不同于AngularJS，所以非常用起来很自由（可以在大项目中的一个小组件上使用）。<br>我在工作中多次用到React。其实一开始有种颠覆前端开发的感觉，熟悉后感觉却觉得这种方式非常舒服。<br>说了这么多，什么是组件化呢？<br>我还是引用张云龙老师的理解（BTW，他的博客真得好好看看呢，最后的参考资料有）：</li>
<li>页面上的每个 独立的 可视/可交互区域视为一个组件；</li>
<li>每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护；</li>
<li>由于组件具有独立性，因此组件与组件之间可以 自由组合；</li>
<li>页面只不过是组件的容器，负责组合组件形成功能完整的界面；</li>
<li>当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。<h3 id="RN-Weex-小程序"><a href="#RN-Weex-小程序" class="headerlink" title="RN/Weex/小程序"></a>RN/Weex/小程序</h3>随着移动设备类型的变多，操作系统的变多，用户需求的增加，对于每个项目启动前，大家都会考虑到的成本，团队成员，技术成熟度，时间，项目需求等一堆的因素。因此，开发App的方案已经变得越来越多了。曾经有一段HTML5的小浪潮，无数的人参与或者看到过一个讨论：原生（Native<br>App）开发还是混合（Hybrid<br>App）开发？原生开发显然是最可靠的方案。但是学习成本，人才成本，开发效率以及照顾不同平台的特性去考虑，都成为了开发人员心目中的一道坎。<br>混合开发的直白的解释是 Native 和 Web 技术都要用，兼具「Native App 良好用户交互体验的优势」和「Web App<br>跨平台开发的优势」。促使开发者在移动开发中使用 Web 技术主要动力在于，相比于 Native 技术，Web 技术具有诸多优势：</li>
<li>HTML，CSS，JavaScript 的组合被证明在用户界面开发方面具有很高的效率。</li>
<li>统一的浏览器内核标准，使得 Web 技术具有跨平台特性。iOS 和 Android 可以使用一套代码。</li>
<li>可越过发布渠道自主更新应用。<br>豆瓣为此也有了一些混合开发实践，有兴趣的可以看最后的文章。<br>早期的混合开发有一些缺点：</li>
<li>受限于Webview（手机中内置的浏览器控件）的性能限制, 相比原生而言有不少损耗, 体验无法和原生相比</li>
<li>不适用于交互性较强的app<br>RN(React Native)是Facebook在React.js Conf 2015上推出的一个框架，结合了 Web 应用和 Native<br>应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。在 JavaScript 中用 React 抽象操作系统原生的<br>UI 组件，代替 DOM 元素来渲染等。它给我的感觉是不同于H5,也不同于原生,更像是用JS写出原生应用。它的优点很多：</li>
<li>虽然说开发成本大于Hybrid模式,但是小于原生模式,大部分代码可复用</li>
<li>性能体验高于Hybrid,不逊色与原生</li>
<li>开发人员单一技术栈,一次学习,跨平台开发</li>
<li>社区繁荣,遇到问题容易解决<br>那一天，我发了个QQ状态：感觉JS要一统江湖了。<br>去年6月，阿里无线前端开源了无线电商动态化解决方案Weex，特点是轻量级，性能很高，官方给出的口号是 “Write Once Run<br>Everywhere”。由于这个轮子太像Vue + React-Native（可以称为Vue-<br>Native），后来Vue作者尤雨溪加盟Weex项目担任技术顾问… 😝<br>而微信小程序提供了模块化，模板，数据绑定等特性，极大的方便了使用惯了MVVM框架的开发者。在了解微信小程序后，能感受到其实又是一个RN的轮子。开发者在自己的微信中通过小程序的开发者工具，撰写出Native<br>级别的界面，通过开发者工具生成压缩包，提交到微信公众平台，然后在微信 app 中请求执行，便可实现原生Native<br>的界面体验。微信之父张小龙在他的朋友圈里写道微信小程序是不需要下载安装的应用，实现「触手可及」，「用完即走」的理念。<br>只不过，他们三者有点区别：</li>
<li>RN偏向整体业务的实现</li>
<li>Weex偏向单个页面的数据交互</li>
<li>小程序的UI使用了Native（体验要求比较高的组件，比如Tab）+ Webview，但除了把腾讯的一些访问优化技术放进来，基本没有技术上的创新和突破<h3 id="要不要学小程序"><a href="#要不要学小程序" class="headerlink" title="要不要学小程序"></a>要不要学小程序</h3>除了微信，不会有小程序时代的赢家，先别想着逆袭，除非微信能比较好的平衡这一点。作为非前端开发，我个人倒是建议Python<br>的Web开发通过小程序来提高「切图」甚至设计能力。因为微信提供了JSSDK，包含了满足绝大部分功能需求的事件/组件。那你可以放心的直接写HTML和CSS，而不用自己绑定Javascript事件，另外是如果之前没接触过，可以了解到前端使用Javascript和后端是用什么样的方式通信的。<br>最后一点是，通过学习可以了解到一种新的设计理念、甚至编程范式。当你遇到的场景足够复杂，你的思考足够深入，造的轮子足够多，在未来才可能找到一个行业的痛点，完成一个优秀的东西。<br>限于公众号文章篇幅的限制，下篇将是具体的小程序代码实战和我的经验。<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><a href="http://leeluolee.github.io/fequan-netease" target="_blank" rel="noopener">漫谈Web前端的『组件化』</a><br><a href="http://tech.meituan.com/frontend-component-practice.html" target="_blank" rel="noopener">前端组件化开发实践</a><br>[Web组件化-angularjs实践](<a href="http://greengerong.com/blog/2013/12/11/angularjs-web-" target="_blank" rel="noopener">http://greengerong.com/blog/2013/12/11/angularjs-web-</a><br>component/)<br><a href="https://github.com/xufei/blog/issues/19" target="_blank" rel="noopener">2015前端组件化框架之路</a><br><a href="https://github.com/fouber/blog/blob/master/201508/01.md" target="_blank" rel="noopener">前端工程——基础篇</a><br>[Hybrid App开发实战](<a href="http://www.infoq.com/cn/articles/hybrid-app-development-" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/hybrid-app-development-</a><br>combat)<br><a href="http://lincode.github.io/Hybrid-Rexxar" target="_blank" rel="noopener">豆瓣混合开发实践</a><br><a href="http://www.cnblogs.com/dailc/p/5930238.html#hybrid_2_3" target="_blank" rel="noopener">Hybrid APP基础篇(二)-&gt;Native、Hybrid、React Native、Web<br>App方案的分析比较</a></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vary.vim-自动去掉行尾空格</title>
    <url>/2016-01-26.html</url>
    <content><![CDATA[<p>####前言<br>一直想改成emacs无奈工作需要效率，所以vim还没有完全放弃. 我想做python的同学很可能有我一样的困扰:</p>
<ol>
<li>在维护别人的代码的时候发现有很多tab和空格混用或者行尾空格没有删除<br>我以前可能没有注意这个问题，就是自觉的使用ed模式: :%s/\s+$//g和:retab，最近老大的一句话提醒<br>了我:他问我是否vim可以配置成自动模式? 以我对vim的了解它肯定不会介入个人的编辑,那么可能就要使用hook的方法.<br>这也就是我的<a href="https://github.com/dongweiming/vary.vim" target="_blank" rel="noopener">vary.vim</a>的原理:当保存文件的时候(:w)自动执行命令.<br>其实我想你可能会问，为啥是我保存的时候而不是打开的时候呢?额 下面会讲到<br>####安装配置请看项目的README<br>安装后就算不配置默认只对python语言生效-团队和语言风格不同<br>####修改我的vim插件<br>我一直在想究竟哪种方式更合理(打开文件就修改还是保存的时候再修改),我默认是保存，但是其实你可以修改我的autocmd命令为:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">autocmd BufReadPost * :call StripTrailingWhite()  </span><br><span class="line">autocmd BufReadPost * :call RetabIndents()</span><br></pre></td></tr></table></figure>


<p>表示打开文件之前就修改，把修改后的结果呈现给你</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python正则备忘单</title>
    <url>/2016-01-28.html</url>
    <content><![CDATA[<p>学习正则的第一个教程应该去看<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">&lt;正则表达式30分钟入门教程&gt;</a>,<br>学会里面的内容就足够满足大部分的工作需要了。而对于Python来说，就要学习模块re的使用方法。文本将展示一些大家都应该掌握的技巧。</p>
<h3 id="编译正则对象"><a href="#编译正则对象" class="headerlink" title="编译正则对象"></a>编译正则对象</h3><p>re.compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。用法上略有区别，举个例子,<br>匹配一个字符串可用如下方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">re.match(<span class="string">r'hello \w+'</span>, <span class="string">'hello world'</span>)  <span class="comment"># re.match(pattern, string, flags=0)</span></span><br></pre></td></tr></table></figure>


<p>如果使用compile，将变成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">regex = re.compile(<span class="string">r'hello \w+'</span>)  </span><br><span class="line">regex.match(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>


<p>为什么要这么用呢？其实就是为了提高正则匹配的速度，重复利用正则表达式对象。我们对比一下2种方式的效率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : timeit -n <span class="number">10000</span> re.match(<span class="string">r'hello \w+'</span>, <span class="string">'hello world'</span>)  </span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">2.06</span> µs per loop  </span><br><span class="line">  </span><br><span class="line">In : regex = re.compile(<span class="string">r'hello \w+'</span>)  </span><br><span class="line">  </span><br><span class="line">In : timeit -n <span class="number">10000</span>  regex.match(<span class="string">'hello world'</span>)  </span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">927</span> ns per loop</span><br></pre></td></tr></table></figure>


<p>可以看到第二种方式要快很多。在实际的工作中你会发现越多的使用编译好的正则表达式对象，效果就越好。</p>
<h3 id="分组-group"><a href="#分组-group" class="headerlink" title="分组(group)"></a>分组(group)</h3><p>你可能已经见过对匹配的内容进行分组的用法了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : match = re.match(<span class="string">r'hello (\w+)'</span>, <span class="string">'hello world'</span>)  </span><br><span class="line">  </span><br><span class="line">In : match.groups()  </span><br><span class="line">Out: (<span class="string">'world'</span>,)  </span><br><span class="line">  </span><br><span class="line">In : match.group()  </span><br><span class="line">Out: <span class="string">'hello world'</span>  </span><br><span class="line">  </span><br><span class="line">In : match.group(<span class="number">1</span>)  </span><br><span class="line">Out: <span class="string">'world'</span></span><br></pre></td></tr></table></figure>


<p>通过对要匹配的对象添加括号，就可以精确的对应符合的结果了。我们还可以进行嵌套的分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : m = re.search(<span class="string">r'(((\d&#123;4&#125;)-\d&#123;2&#125;)-\d&#123;2&#125;)'</span>, <span class="string">'2016-01-01'</span>)  </span><br><span class="line">  </span><br><span class="line">In : m.groups()  </span><br><span class="line">Out: (<span class="string">'2016-01-01'</span>, <span class="string">'2016-01'</span>, <span class="string">'2016'</span>)  </span><br><span class="line">  </span><br><span class="line">In : m.group()  </span><br><span class="line">Out: <span class="string">'2016-01-01'</span>  </span><br><span class="line">  </span><br><span class="line">In : m.group(<span class="number">1</span>)  </span><br><span class="line">Out: <span class="string">'2016-01-01'</span>  </span><br><span class="line">  </span><br><span class="line">In : m.group(<span class="number">2</span>)  </span><br><span class="line">Out: <span class="string">'2016-01'</span>  </span><br><span class="line">  </span><br><span class="line">In : m.group(<span class="number">3</span>)  </span><br><span class="line">Out: <span class="string">'2016'</span></span><br></pre></td></tr></table></figure>


<p>分组都满足的需求的，但是有时候可读性很差，那可以对分组进行命名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : pattern = <span class="string">'(?P&lt;year&gt;\d&#123;4&#125;)-(?P&lt;month&gt;\d&#123;2&#125;)-(?P&lt;day&gt;\d&#123;2&#125;)'</span>  </span><br><span class="line">  </span><br><span class="line">In : m = re.search(pattern, <span class="string">'2016-01-01'</span>)  </span><br><span class="line">  </span><br><span class="line">In : m.groupdict()  </span><br><span class="line">Out: &#123;<span class="string">'day'</span>: <span class="string">'01'</span>, <span class="string">'month'</span>: <span class="string">'01'</span>, <span class="string">'year'</span>: <span class="string">'2016'</span>&#125;  </span><br><span class="line">  </span><br><span class="line">In : m.group(<span class="string">'year'</span>)  </span><br><span class="line">Out: <span class="string">'2016'</span>  </span><br><span class="line">  </span><br><span class="line">In : m.group(<span class="string">'month'</span>)  </span><br><span class="line">Out: <span class="string">'01'</span>  </span><br><span class="line">  </span><br><span class="line">In : m.group(<span class="string">'day'</span>)  </span><br><span class="line">Out: <span class="string">'01'</span></span><br></pre></td></tr></table></figure>


<p>现在可读性非常高了。</p>
<h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>学过sed的同学可能见过如下替换用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ echo ab123c | sed <span class="string">'s/\([0-9]\&#123;3\&#125;\)/[\1]/'</span>  </span><br><span class="line">ab[<span class="number">123</span>]c</span><br></pre></td></tr></table></figure>


<p>这个\1表示前面正则匹配到的结果，也就是给匹配到的结果加上中括号。<br>在re模块中也存在这样的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : re.sub(<span class="string">r'(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)'</span>, <span class="string">r'\2/\3/\1'</span>, <span class="string">'2016-01-01'</span>)  </span><br><span class="line">Out: <span class="string">'01/01/2016'</span></span><br></pre></td></tr></table></figure>


<p>用命名分组也是可以的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line">In : pattern = <span class="string">'(?P&lt;year&gt;\d&#123;4&#125;)-(?P&lt;month&gt;\d&#123;2&#125;)-(?P&lt;day&gt;\d&#123;2&#125;)'</span>  </span><br><span class="line">  </span><br><span class="line">In : re.sub(pattern, <span class="string">r'\g&lt;month&gt;/\g&lt;day&gt;/\g&lt;year&gt;'</span>, <span class="string">'2016-01-01'</span>)  </span><br><span class="line">Out: <span class="string">'01/01/2016'</span></span><br></pre></td></tr></table></figure>


<h3 id="附近匹配-Look-around"><a href="#附近匹配-Look-around" class="headerlink" title="附近匹配(Look around)"></a>附近匹配(Look around)</h3><p>re模块也支持附近匹配，看看例子就懂了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : re.sub(<span class="string">'(?=\d&#123;3&#125;)'</span>, <span class="string">' '</span>, <span class="string">'abc12345def'</span>)  <span class="comment"># (?=XX) 从左向右匹配，符合内容的字符串后面加空格  </span></span><br><span class="line">Out: <span class="string">'abc 1 2 345def'</span>  </span><br><span class="line">  </span><br><span class="line">In : re.sub(<span class="string">'(?!\d&#123;3&#125;)'</span>, <span class="string">' '</span>, <span class="string">'abc12345def'</span>)  <span class="comment"># (?!XX) 和上面的匹配效果相反，也是后面加空格  </span></span><br><span class="line">Out: <span class="string">' a b c123 4 5 d e f '</span>  </span><br><span class="line">  </span><br><span class="line">In : re.sub(<span class="string">'(?&lt;=\d&#123;3&#125;)'</span>, <span class="string">' '</span>, <span class="string">'abc12345def'</span>)  <span class="comment"># (?&lt;=XX) 从右向左匹配，符合内容的字符串前面加空格  </span></span><br><span class="line">Out: <span class="string">'abc123 4 5 def'</span>  </span><br><span class="line">  </span><br><span class="line">In : re.sub(<span class="string">'(?&lt;!\d&#123;3&#125;)'</span>, <span class="string">' '</span>, <span class="string">'abc12345def'</span>)  <span class="comment"># (?&lt;!XX) 和上面的匹配效果相反，也是前面加空格  </span></span><br><span class="line">Out: <span class="string">' a b c 1 2 345d e f '</span></span><br></pre></td></tr></table></figure>


<h3 id="正则匹配的时候使用函数"><a href="#正则匹配的时候使用函数" class="headerlink" title="正则匹配的时候使用函数"></a>正则匹配的时候使用函数</h3><p>之前我们看到的大部分内容都是匹配的是一个表达式，但是有时候需求要复杂得多，尤其是在替换的时候。<br>举个例子，通过Slack的API能获取聊天记录，比如下面这句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s = &lt;@U1EAT8MG9&gt;, &lt;@U0K1MF23Z&gt; 嗯 确实是这样的</span><br></pre></td></tr></table></figure>


<p>其中&lt;@U1EAT8MG9&gt;和&lt;@U0K1MF23Z&gt;是2个真实的用户，但是被Slack封装了，需要通过其他接口获取这个对应关系，<br>其结果类似这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ID_NAMES = &#123;<span class="string">'U1EAT8MG9'</span>: <span class="string">'xiaoming'</span>, <span class="string">'U0K1MF23Z'</span>: <span class="string">'laolin'</span>&#125;</span><br></pre></td></tr></table></figure>


<p>在解析对应关系之后，还希望吧尖括号也去掉，替换后的结果是「@xiaoming, @laolin 嗯 确实是这样的 」<br>用正则怎么实现呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : REGEX_AT = re.compile(<span class="string">r'\&lt;@.*?\&gt;'</span>)  </span><br><span class="line">  </span><br><span class="line">In : <span class="function"><span class="keyword">def</span> <span class="title">id_to_name</span><span class="params">(match)</span>:</span>  </span><br><span class="line">...:     content = match.group()  </span><br><span class="line">...:     name = ID_NAMES.get(content[<span class="number">2</span>:<span class="number">-1</span>])  </span><br><span class="line">...:     <span class="keyword">return</span> <span class="string">'@&#123;&#125;'</span>.format(name) <span class="keyword">if</span> name <span class="keyword">else</span> content  </span><br><span class="line">...:  </span><br><span class="line">  </span><br><span class="line">In : <span class="keyword">print</span> REGEX_AT.sub(id_to_name, s)  </span><br><span class="line"><span class="meta">@xiaoming, @laolin 嗯 确实是这样的</span></span><br></pre></td></tr></table></figure>


<p>所以pattern当然也可以是一个函数</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之微信小程序实战（一）</title>
    <url>/2016-01-27.html</url>
    <content><![CDATA[<p>首先感受下效果：<br>![](<a href="https://github.com/dongweiming/weapp-" target="_blank" rel="noopener">https://github.com/dongweiming/weapp-</a><br>zhihulive/raw/master/screenshot/zhihulive.png)<br>项目地址 <a href="https://github.com/dongweiming/weapp-zhihulive" target="_blank" rel="noopener">https://github.com/dongweiming/weapp-zhihulive</a><br>限于公众号文章篇幅的限制，只能将具体的小程序代码实战和我的经验放在下篇了。今天我先介绍下我对小程序的一些理解以及用尽量少的篇幅介绍小程序背后的技术的发展历程。</p>
<h3 id="我对小程序的看法"><a href="#我对小程序的看法" class="headerlink" title="我对小程序的看法"></a>我对小程序的看法</h3><p>我一向不喜欢跟风。小程序刚出的时候一大波人吹捧，一个月后一大堆人看衰，全然忘记曾经的话，其实脸被打的是啪啪啪。<br>引用我点过赞的一个对于小程序发布一个月的表现如何的<a href="https://www.zhihu.com/question/55480298/answer/145823043" target="_blank" rel="noopener">大司马大将军</a>的回答：</p>
<blockquote>
<p>互联网时代，人们更加没有耐心——没耐心到以至于30天时间，就有人开始对小程序“盖棺定论”了。这真是一件让人悲哀的不知道该说啥的事。<br>具体的回答内容限于篇幅就不展开了。<br>当我真正的用它开发，实践了产品需求。我对它持观察态度：</p>
</blockquote>
<ol>
<li>生态太过封闭。微信想的是用户不断的进行「手机开机 —&gt; 微信 —&gt; （社交+购物+吃饭+金融…） —&gt; 手机关机」的循环，但是别的公司想的是「微信 —&gt; 小程序 —&gt; 获得粉丝 —&gt; 引流或者引导用户下载APP感受完整版」，大家各怀鬼胎，但是谁都不蠢。</li>
<li>相关限制太多（分享按钮、诱导分享）。</li>
<li>入口不好找。<br>期待小程序的下一步。<h3 id="页面设计思路"><a href="#页面设计思路" class="headerlink" title="页面设计思路"></a>页面设计思路</h3>术业有专攻，我有个缺点，就是设计页面会懵…<br>如果没有设计图让我凭空去想我很痛苦，比如这个小程序，我一开始是按着知乎APP的配色和Live相关内容的布局做的，但是越到后来越发现效果我不喜欢。现在的主色、发现页、话题页是抄袭了&lt;<a href="https://github.com/romoo/weapp-" target="_blank" rel="noopener">https://github.com/romoo/weapp-</a><br>demo-breadtrip&gt; 的感觉，加上了一些我的理解。其他的页面是我自己对Live产品的理解做的。<h3 id="小程序完成的功能"><a href="#小程序完成的功能" class="headerlink" title="小程序完成的功能"></a>小程序完成的功能</h3>我之前在我的知乎Live以及回答的一些问题中都提到过，一定要找个机会写一个相对复杂的项目深入你要学习的技术，只看文章、书、视频效果其实是很差的，只有实践了才真的能记住和理解。<br>那对我来说，这个小程序就是学习效果的产出，这也是我平时学习东西的方式。在一开始的时候我就基于对知乎Live的理解，给自己列出了小程序要完成的功能：</li>
<li>发现页。用户一登录就看到的页面，展示了一些基于我的理解的算法排序的Live。</li>
<li>7/30天最受欢迎的Live。知乎也有，但是我对它那个顺序不太满意：小众的Live太难上榜，评分低但是收入高的Live排的靠前。在豆瓣，要是国产电影3-4分但是由于票房很高就排得很高，你们想想我们会被怎么骂。</li>
<li>热门话题页面/话题筛选。我开始有这个小程序的想法的时候，知乎还不能基于分类去筛选Live，不方便。</li>
<li>搜索。当时还没有搜索，现在的搜索也比较鸡肋吧，就是个简单的关键词匹配，都不能模糊查询（比如搜索pythno就找不到符合的Live）。</li>
<li>个人页面，社交必备元素了，包含个人信息以及其主讲的Live列表。</li>
<li>基于多种条件对主讲人排序。<br>我以前说过，我不反对造轮子，关键是造的得有意义。就是你要造的东西能解决你的痛点，比如我这个就是由于知乎提供的功能不满足我的需求（比如当时想找个某关键词的相关Live，只能用「site:zhihu.com<br>live<br>python」这样的方式Google），以及它提供的排序价值观我不太认同。作为工程师最大的好处（其实是会写爬虫的工程师），不满意我就写一个。不过这个小程序只能平静的躺在本来开发环境里面。<br><strong>要不然造轮子，造着造着容易弃坑</strong><br>基于上面说的需求，我不断的更新这个专题直到今天（昨天的MVVM都是给今天做铺垫）。<h3 id="组件化思想"><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h3>关于「组件化」网上有很多写的很不错的文章，推荐大家去看看。我特别喜欢美团点评团队的博客中提到的下面这句话：<blockquote>
<p>Controlling complexity is the essence of computer programming.<br>随着前端开发复杂度的日益提升，组件化开发应运而生，并随着React等优秀框架的出现遍地开花。大家都在各种尝试努力的「Controlling<br>complexity」。<br>我试着介绍下组件化发展的历史（去掉一些已经夭折、不看好的部分，只保留相关的主流）。<br>我们先讨论什么是组件？其实我们日常开发（尤其是前端开发）接触到的component、widget、module、plugin就是组件，缺点是大家实现不统一，使用方式也不统一。到了2011年，Alex<br>Russell提出了「Web Component」：</p>
</blockquote>
</li>
<li>Custom Element: 自定义HTML元素</li>
<li>shadow DOM: 封装</li>
<li>HTML Imports: 打包一切</li>
<li>HTML Template: Lazy的DOM模板<br>JavaScript本来是一门作为浏览器上的脚本语言出身，并不适合于大规模开发。同年Google提出的MDV（Model-Driven<br>Views）框架，提出了我们也需要像对待后端系统一样对前端逻辑进行统一管理、分层(表现逻辑、viewmodel、视图)。所以Backbone、AngularJS、Ember之类的数据绑定框架横空出世了，力求给我们带来代码的模块管理、数据、视图的分离，他们以他们不同的方式解决共同的问题：<br>1.如何更好地模块化开发<br>2.业务数据如何组织<br>3.界面和业务数据，业务逻辑的分离<br>与此同时为了用户体验的要求，HTML5和ECMAScript也在快速的推进。2013年，Google推出了新的UI框架Polymer，它的实现使用了WebComponent标准，并且Polymer可保证针对包含各种平台的Web<br>Component规范本地实现的浏览器、库和组件的使用效果完全相同。它代表了下一代的web组件方向：一切皆组件、尽量减少代码量、尽量减少框架限制。<br>同年，React并没有采用Web<br>Components的方案，以高性能虚拟Dom为切入点，在Facebook的造势下，社区得到了大力发展。官方说React倾向于做传统MVC架构中的View层。不同于AngularJS，所以用起来很自由（可以在大项目中的一个小组件上使用）。<br>我在工作中多次用到React。其实一开始有种颠覆前端开发的感觉，熟悉后感觉却觉得这种方式非常舒服。<br>说了这么多，什么是组件化呢？<br>我还是引用张云龙老师的理解（BTW，他的博客真得好好看看呢，最后的参考资料有）：</li>
<li>页面上的每个 <strong>独立的</strong> 可视/可交互区域视为一个组件；</li>
<li>每个组件对应一个工程目录，组件所需的各种资源都在这个目录下 <strong>就近维护</strong> ；</li>
<li>由于组件具有独立性，因此组件与组件之间可以 <strong>自由组合</strong> ；</li>
<li><strong>页面只不过是组件的容器，负责组合组件形成功能完整的界面</strong> ；</li>
<li>当不需要某个组件，或者想要替换组件时， <strong>可以整个目录删除/替换</strong> 。<h3 id="RN-Weex-小程序"><a href="#RN-Weex-小程序" class="headerlink" title="RN/Weex/小程序"></a>RN/Weex/小程序</h3>随着移动设备类型的变多，操作系统的变多，用户需求的增加，对于每个项目启动前，大家都会考虑到的成本，团队成员，技术成熟度，时间，项目需求等一堆的因素。因此，开发App的方案已经变得越来越多了。曾经有一段HTML5的小浪潮，无数的人参与或者看到过一个讨论：原生（Native<br>App）开发还是混合（Hybrid<br>App）开发？原生开发显然是最可靠的方案。但是学习成本，人才成本，开发效率以及照顾不同平台的特性去考虑，都成为了开发人员心目中的一道坎。<br>混合开发的直白的解释是 Native 和 Web 技术都要用，兼具「Native App 良好用户交互体验的优势」和「Web App<br>跨平台开发的优势」。促使开发者在移动开发中使用 Web 技术主要动力在于，相比于 Native 技术，Web 技术具有诸多优势：</li>
<li>HTML，CSS，JavaScript 的组合被证明在用户界面开发方面具有很高的效率。</li>
<li>统一的浏览器内核标准，使得 Web 技术具有跨平台特性。iOS 和 Android 可以使用一套代码。</li>
<li>可越过发布渠道自主更新应用。<br>豆瓣为此也有了一些混合开发实践，有兴趣的可以看最后的文章。<br>早期的混合开发有一些缺点：</li>
<li>受限于Webview（手机中内置的浏览器控件）的性能限制, 相比原生而言有不少损耗, 体验无法和原生相比</li>
<li>不适用于交互性较强的app<br>RN(React Native)是Facebook在React.js Conf 2015上推出的一个框架，结合了 Web 应用和 Native<br>应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。在 JavaScript 中用 React 抽象操作系统原生的<br>UI 组件，代替 DOM 元素来渲染等。它给我的感觉是不同于HTML5，也不同于原生，更像是用JS写出原生应用。它的优点很多：</li>
<li>虽然说开发成本大于Hybrid模式，但是小于原生模式，大部分代码可复用</li>
<li>性能体验高于Hybrid,不逊色于原生</li>
<li>开发人员单一技术栈，一次学习，跨平台开发</li>
<li>社区繁荣，遇到问题容易解决<br>那一天，我发了个QQ状态：感觉JS要一统江湖了。<br>Vue（view的法语）于2014年2月对外发布，它采用MVVM数据绑定，有着简洁的API，是一个用于构建Web界面的库。我们可以用 Vue<br>扩展出来的ViewModel子类当做可复用的组件。这在概念上与Web<br>Components非常相似，但是带了数据绑定、动画系统等上层功能。Vue和Polymer在功能上和API上比较相似，不同之处在于Vue的组件无需(IE9+)任何polyfill（描述复制缺少的API和API功能的行为，可以使用它编写单独应用的代码而不用担心其他浏览器原生是不是支持）。<br>2016年6月，阿里无线前端开源了无线电商动态化解决方案Weex，特点是轻量级，性能很高，官方给出的口号是 “Write Once Run<br>Everywhere”。由于这个轮子太像Vue + React-Native（可以称为Vue-<br>Native），后来Vue作者尤雨溪加盟Weex项目担任技术顾问… 😝 。<br>2016年9月开始内测的微信小程序提供了模块化、模板、数据绑定等特性，极大的方便了使用惯了MVVM框架的开发者。在了解微信小程序后，能感受到其实又是一个RN的轮子。开发者在自己的微信中通过小程序的开发者工具，撰写出Native<br>级别的界面，通过开发者工具生成压缩包，提交到微信公众平台，然后在微信 app 中请求执行，便可实现原生Native<br>的界面体验。微信之父张小龙在他的朋友圈里写道微信小程序是不需要下载安装的应用，实现「触手可及」，「用完即走」的理念。但除了把腾讯的一些访问优化技术放进来，基本没有技术上的创新和突破。<br>只不过，他们三者有点区别：</li>
<li>RN偏向整体业务的实现</li>
<li>Weex偏向单个页面的数据交互</li>
<li>小程序的UI使用了Native（体验要求比较高的组件，比如Tab）+ Webview<h3 id="要不要学小程序"><a href="#要不要学小程序" class="headerlink" title="要不要学小程序"></a>要不要学小程序</h3>除了微信，不会有小程序时代的赢家，先别想着逆袭，除非微信能比较好的平衡这一点。作为非前端开发，我个人倒是建议Python<br>的Web开发通过小程序来提高「切图」甚至设计能力。因为微信提供了JSSDK，包含了满足绝大部分功能需求的事件/组件。那你可以放心的直接写HTML和CSS，而不用自己绑定Javascript事件，另外是如果之前没接触过，可以了解到前端使用Javascript和后端是用什么样的方式通信的。<br>然后是前端的组件开发的方式在后端的某些层面也是可借鉴的，虽然MVVM在Web后端没有存在的必要（比如数据双向绑定对后端无意义还增加个服务器和网络请求的负担）。<br>最后一点是，通过学习可以了解到一种新的设计理念、甚至编程范式。工程师要提高眼界，当你遇到的场景足够复杂，思考足够深入，造的轮子足够多，在未来才可能找到痛点，实现基于更先进的开发理念做出革新的框架或者工具，所以不必那么现实和功力。<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><a href="http://leeluolee.github.io/fequan-netease" target="_blank" rel="noopener">漫谈Web前端的『组件化』</a><br><a href="http://tech.meituan.com/frontend-component-practice.html" target="_blank" rel="noopener">前端组件化开发实践</a><br>[Web组件化-angularjs实践](<a href="http://greengerong.com/blog/2013/12/11/angularjs-web-" target="_blank" rel="noopener">http://greengerong.com/blog/2013/12/11/angularjs-web-</a><br>component/)<br><a href="https://github.com/xufei/blog/issues/19" target="_blank" rel="noopener">2015前端组件化框架之路</a><br><a href="https://github.com/fouber/blog/blob/master/201508/01.md" target="_blank" rel="noopener">前端工程——基础篇</a><br>[Hybrid App开发实战](<a href="http://www.infoq.com/cn/articles/hybrid-app-development-" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/hybrid-app-development-</a><br>combat)<br><a href="http://lincode.github.io/Hybrid-Rexxar" target="_blank" rel="noopener">豆瓣混合开发实践</a><br><a href="http://www.cnblogs.com/dailc/p/5930238.html#hybrid_2_3" target="_blank" rel="noopener">Hybrid APP基础篇(二)-&gt;Native、Hybrid、React Native、Web<br>App方案的分析比较</a></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>选Python还是Java？</title>
    <url>/2016-01-29.html</url>
    <content><![CDATA[<p>抱歉啦，整个9月都在充电和赶进度。好久不冒泡了，今天还有订阅的同学给我发了句淡淡的「好久没更新了」来催更，所以今天先「水」一篇非技术的吧。<br>知乎上有很多关于语言选择的问题，这已经是月经贴了。其中关于Python和Java的问题大抵如下：</p>
<ol>
<li>Python和Java该如何选择 ？</li>
<li>将来Python(Java)会不会替代Java(Python) ？</li>
<li>零基础应该选择学习Python还是Java ？</li>
<li>做web开发，用Python好还是Java好呢？<br>这类问题过一段时间就得来一波，今天我就以这个为切入点和大家唠唠。<h3 id="我为啥要说这个话题？"><a href="#我为啥要说这个话题？" class="headerlink" title="我为啥要说这个话题？"></a>我为啥要说这个话题？</h3>相信你们最近又看到一波「夸」Python的文章，引用了一些国外的数据，无非说Python现在很火，薪资很高，是未来的趋势balabala…<br>不过我们要关注下带节奏的是谁：<br>A: 培训机构营销号<br>他们说的话可以信？<h3 id="那么Python在国内的发展情况如何？"><a href="#那么Python在国内的发展情况如何？" class="headerlink" title="那么Python在国内的发展情况如何？"></a>那么Python在国内的发展情况如何？</h3>注：此文发布时间为 2017-09-28<br>我最近4-5年是一个靠Python吃饭的一线开发者。在我认知里面，Python既是一个大众化的语言，也是一小搓儿开发者喜欢的语言。怎么说呢？<br>每个开发者都应该学学Python这个胶水语言，后端开发者不会Python都不好意思出门和别人打招呼。事实上基本在每个公司都有Python的身影，只不过公司的核心业务、用户产品很少用Python来做。<br>国内大一点的、使用Python做基础设施的公司1只手就可以数出来：豆瓣、知乎、美团、饿了么、搜狐（漏掉的欢迎补充）。<br>公司级别把Python作为核心的公司屈指可数，它更像是一波有「特殊」感情开发者的选择，这波人品味很挑剔，这个有点难描述，参照Pythonic这个词希望你成为的开发者吧。<br>Python在国外环境要好得多，但是在国内一直在缓慢的赢得更多人的心，在我的感觉里还有点「病态」发展（这个就不展开了），增速是可预期的，不会出现井喷式的增长。<br>职位就是那么多，但是由于那些无良培训机构和不明真相的吃瓜群众的引导和欺骗，再加上浮躁的社会的风气，进来了一大帮水货，企业相应的也就提高的招聘要求，让offer拿的更难了。和前端市场一样，很多人抱怨找不到工作，究其原因，无非是市场冷静客观下来优胜劣汰，能力不达标罢了。据我所知，只要你的能力匹配，Python高级工程师是非常受市场青睐的。<h3 id="造成Python市场不好的原因有哪些？"><a href="#造成Python市场不好的原因有哪些？" class="headerlink" title="造成Python市场不好的原因有哪些？"></a>造成Python市场不好的原因有哪些？</h3></li>
<li>政治。在我的第一个知乎Live「Python 工程师的入门和进阶」中也提过，我们都知道语言通常不是技术瓶颈，那为什么公司会有很强烈的技术选型因素？这其实是「政治」。BAT出来的人到其他小型公司做高管，他们为了站稳会选择重构成自己熟悉和喜欢的技术栈，而且重构大部分是为了KPI和晋升。这些有话语权的人往往不会Python，只熟悉传统的PHP，Java，这就造成一种「恶性」循环，其他语言的市场热度不会降下去，政治正确要比技术正确更重要，Python语言很难在这种环境里突破重围。那么知乎、饿了么这些公司为什么选择Python？嘿嘿，除了创业早期为了显得逼格高（有时候这是创业营销的一种需要），他们的高管中有些是豆瓣出去的哦，所以你看到同样的现象，豆瓣出去的人做技术决策的结果选了Python。😝 </li>
<li>招人难。国内找靠谱的Python工程师实在是太难了。会Python和真的靠它吃饭差别实在太大了，知乎Python话题下大部分充其量算是会用Python写脚本的人在强答罢了。你看我的同事或者我了解到的Python领域里面的开发者基本都是不用知乎也不回答Python问题的。我们知道，Python非常适合创业期完成产品快速试错和迭代，如果一个公司没有优秀的开发者坐镇，我还是不太相信用Python能坚持下去的，太多工程问题真的不是学院派能解决的，很多问题Google/SO是找不到的。那么用人荒造成了想选择Python为公司技术栈的公司望而却步，最后恶性循环大家都不太敢让核心系统用Python了。</li>
<li>总有刁民拿性能说事儿。性能问题确实是存在的，但事实上绝大部分公司和产品真的不需要担心这点，也有人说Python没有大型网站的顶级的解决方案。其实不然，国内有豆瓣，国外有Instagram、Reddit等等成功的案例，我说了很多遍了，决定网站性能的主要因素是架构，然后是代码水平，最后才是语言。 但是很多对Python一知半解的人就被这么吓跑了，并且拿着这些槽点去吓别人。</li>
<li>技术环境不好。PyCON北京场都组织不起来，真的有干货的开发者都不出来活动，万事与Ta无关高高挂起，反观前端氛围真的很好。很多新人想入坑，但是没人带，没方向，没组织，外面尽是坏人，每天看到的都是类型于发爬虫这种很low级别的技术文章，这种气氛下，未来真的青黄不接呀。<h3 id="Python-or-Java？"><a href="#Python-or-Java？" class="headerlink" title="Python or Java？"></a>Python or Java？</h3>终于到了正题了。我确实不用Java，不过工作和个人项目中我会用到Python，Golang，Lua，Javascript、CSS，以前做运维的时候还用过Perl和Ruby。很多年前看《程序员修炼之道》，作者建议每年至少学习一门新语言，每季度阅读一本技术书籍。非常有道理，我今年学的是Rust，明年准备学Swift。其实学习语言无非是语法、库和框架这三者，如果掌握正确的方法一个月就能开始用它写点东西了，没什么必要纠结学那个的问题，开发者的基本素养之一就是整个职业生涯里面都得不断学习，除非我不认同某个语言的设计哲学和语法，比如我个人是不喜欢Java的。学的时候可以带着问题来学，比如A语言和B语言相比有什么优劣，设计上为什么不同、它们只能有很么互相借鉴的地方，为什么？等等..<br>以后在工作中可以针对不同的项目特点选择合适的语言。我爱Python，但是只在正确的时候用它，而不是一棒子打死无论什么场景都用某语言，要记住，用语言或<br>者框架来划分技术其实很幼稚。<br>插个题外话，可能有的读者会问「那怎么不见你写/回答Golang、Rust等方面的文章/问题呀」？因为不自信，不想误人子弟，也不想强答。「自信」是什么呢？就是使用它的时候不担心有什么解决不了的问题，天下我有的感觉，大不了看源码，我C学的不好，但是不影响我带着问题读CPython的源码，不过离贡献C代码就差的很远了，我现在也没想着走这一步，所以对C语言的掌握程度好久没变过了。如果没有经过4-5年的深入和实践，我真的不觉得能在某个领域指手画脚。<br>说到选择。如果你没有强烈的对语言的认可或者不认可，单纯为了尽快养家糊口，选Java，因为市场需求量大，应用广泛，成熟案例多。如果你很理解「人生苦短我用Python」这句话，答案就不言而喻了，不过无论是否选择Python吃饭，甚至你不是一个纯纯的开发者，我还是再建议你应该也要学学Python。<br>之前在知乎看到过大概这样一句话「只会Python找工作很难」，我是认可的。通过观察和了解，我身边的大部分除了Python都能使用其他技术完成工作，比如前端、IOS、安卓等。无论Python还是Java都只是编程语言，工作中还需要具备很多其他的能力，拿Web开发来说（这里不考虑软技能和需求分析、沟通协作等方面的事情），HTTP/TCP、Linux、数据库、Web服务器、第三方库和框架、Web基础（HTML/CSS/JS/ES6)<br>、消息队列、分布式、虚拟化、RPC、缓存、搜索引擎、微服务、上线流程、趁手的开发工具、调试流程、分布式文件系统、安全等等，随便一想就这么多内容。当然最难的和最有价值的是工作经验。只会编程语言算什么？你有什么竞争力，你给个有点悟性的本科生2个月时间工作起来不会差很多。一定不要放大编程语言对于找工作的重要性。<br>另外插个话题。应届生找工作对语言的要求并没有那么重要，反而数据结构、算法、计算机系统、Linux、计算机网络甚至英语这些基础更重要。希望还没有毕业的同学能够抓紧时间多多充电。多看书多时间多刷题，而不是上知乎。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊python面试这件事儿</title>
    <url>/2016-01-30.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天在微博上被私信, 聊了好久的关于python面试的事情. 其实感觉蛮经常的和很多人在聊这个话题. 尤其是建了一个python学习交流群之后,<br>群里讨论的, 私聊我的, 问的比较多的真的有python面试相关的.<br>总结起来大概以下几种:</p>
<ol>
<li>python面试最常用的面试题有哪些?</li>
<li>某个面试题感觉回答的不好, 问怎么回答比较好.</li>
<li>有什么面试经验可以分享.</li>
<li>豆瓣面试一般问什么 - 我是不可能泄题的, 以后不要这么可爱了……<br>突然觉得有必要专门聊聊python面试这件事儿. 随便分享下我的故事.<br>工作了几年, 必然面过几家. 我不是面霸, 但是也肯定有感觉特别奇葩的, 没对上眼的, 完虐我的，励志的，<br>让我感动的. 让我感恩的.<h3 id="来个趣事儿"><a href="#来个趣事儿" class="headerlink" title="来个趣事儿"></a>来个趣事儿</h3>国内python圈有名的公司不多. 12年的时候觉得要从运维开发转型为真正的开发, 面试了某知名公司S. 一直到现在我还觉得他的面试模式很好 -<br>初步筛选之后会发面试题, 2个题目任选其一, 一周做好. 当时python刚学会一年多, 反正蛮辛苦的还是做完了. 后来接到一面的电话.<br>当时觉得他们的工作环境特别好, 想着能留下来该多好. 这个组的面试风格比较特别 - 三个组员一起来面试, 轮流问问题, 有技术的, 有个人兴趣的,<br>有职业规划的. 为什么说这个呢? 这是我工作以来影响最深的面试, 甚至说对我未来影响很大,<br>一直到现在我都非常感谢他们. 现在我每次面试其他人, 都要花的时间比较多, 希望挖掘更多的候选人的优点, 给更多的建议和帮助. 总是想起他们对我的建议.<br>我们说了什么呢?<br>我清楚的记得几个事情</li>
<li>看我简历学了熟悉django. 问我django请求到响应的流程. 没有回答上来. 其中一个面试官给我解释下流程.</li>
<li>问了一些python语法, 应用场景, 但是我大都没有深入了解, 事后我挨个查了这些知识点, 发现其实我只是学会了皮毛</li>
<li>无意间聊到了编辑器, 我说用vim, 但是只是会用<code>:q</code>, <code>:%s</code>这有限的几个. 他们说这么久了, 就没有想想应该花时间好好的学习下, 提高工作效率么?<br>很难想象我是怎么开发的.. 说了很多, 我都有点完全被鄙视的想快点结束这个面试了.<br>面试其实时间还挺长的. 最后我问了我每次面试结束都会问的问题: 你们对我有什么建议?<br>他们说了这么几点, 和大家共勉</li>
<li>他们觉得我买了好多书, 想看想学的很多, 但是都没有深入. 建议我砍掉一半的兴趣, 把这些时间专注于做其中的几件</li>
<li>一个领域学习1，2个就好了. 比如web框架. 只要学好django或者flask, 理解原理. 用什么框架已经不重要了</li>
<li>好好学习一个编辑器. 驾驭好它, 让它提高你的工作效率.</li>
<li>python学的不够深入, 建议我在细节上一个一个的抠, 力争弄清楚每一个, 积少成多<br>说到这里, 好像没啥有趣的.. 对吧<br>14年初, 在我面试豆瓣前, 我特意给S当时虐我的三人之一发邮件. 希望获得一个面试机会. 大概因为之前特意吐槽了S开源的一个项目还对我有兴趣,<br>很快又拿到了面试题. 这次的要难很多, 我还拖了一天交卷. 但是还是获得了一面的机会. 然后一直到最后谈薪资.<br>不同的是, 当时三人已经只剩下一个. 面试过程也没再问python问题(面试题答案应该已经证明了).<br>当时我已经准备好虐他们了….</li>
<li>我真的不再关注那么多的领域, 当时买的好多书甚至因为搬家给卖掉了却出来没看过</li>
<li>我曾经专注的看过python标准库和一些项目的代码, 给很多开源项目贡献代码, 甚至给python标准库贡献了代码</li>
<li>我都不用vim, 改用emacs了</li>
<li>后来面试豆瓣时候也基本没有问python问题, 可见我python能力还好 (*＾ー＾)<br>还没完….<br>以前一面某S的一个工程师. 聊着聊着.<br>他说: 你知不知道有个叫做XXX的?<br>我说: 我就是.<br>他说: 啊！ 我还在想我会不会遇到你呢?<br>我说: 嘿嘿, 你如愿了<br>他说: 之前听别人说过你. balabala<br>机会是给有准备的人的. 不是python工作不好找, 只是没学好. 当时去S面试是个下午, 那天阳光和煦,<br>阳光照在我们那个屋子里面的玻璃桌上面, 面试的气氛很轻松. 当时觉得他们每个人对自己做的事情，对python都非常了解,<br>你是不是也想去这样的环境呢? 那么努力吧..<br>我来豆瓣也是一个励志的故事, 但是有点脱题了, 我们开始说python面试吧<h3 id="我推崇的面试方式"><a href="#我推崇的面试方式" class="headerlink" title="我推崇的面试方式"></a>我推崇的面试方式</h3>这个更适合面试官来看</li>
<li>上面提到的, 决定要不要一面, 先发面试题来做, 看题目功能实现, 代码风格, 注释等和团队文化匹配度决定要不要一面,<br>更少的减少无用面试时间</li>
<li>知道创宇有一道爬虫的面试题写在博客里面, 想去的人把题做完发给他们就好了. 这道题确实不错.<br>python掌握不好的确实做的会比较吃力, 也会直接暴露细节点掌握情况, 也可能会留下惊喜. 这样模式的题目也是一个筛选合适人才的办法<h3 id="候选人应该做好哪些技术准备呢"><a href="#候选人应该做好哪些技术准备呢" class="headerlink" title="候选人应该做好哪些技术准备呢?"></a>候选人应该做好哪些技术准备呢?</h3>网上可以搜到一些面试题, 找了一些还不错的链接列出来</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">http://programmers.stackexchange.com/questions/<span class="number">21917</span>/python-interview-questions  </span><br><span class="line">https://github.com/sigmavirus24/python-interview-questions  </span><br><span class="line">https://gist.github.com/xiangzhuyuan/<span class="number">7454001522</span>d275021b2d  </span><br><span class="line">https://github.com/ContinuumIO/interview-questions  </span><br><span class="line">https://github.com/Flowerowl/python_articles  </span><br><span class="line">http://marselester.com/preparation-to-python-interview.html  </span><br><span class="line">https://github.com/zachwill/cracking-the-coding-interview  </span><br><span class="line">http://www.bogotobogo.com/python/python_interview_questions.php  </span><br><span class="line">https://www.quora.com/What-are-good-Python-interview-questions  </span><br><span class="line">https://www.reddit.com/r/Python/comments/<span class="number">1</span>knw7z/python_interview_questions  </span><br><span class="line">https://github.com/<span class="number">1</span>st/interview/blob/master/python.md  </span><br><span class="line">  </span><br><span class="line">还有<span class="number">2</span>个中文:  </span><br><span class="line">  </span><br><span class="line">https://github.com/taizilongxu/interview_python  </span><br><span class="line">https://gist.github.com/prim/<span class="number">3e7</span>f814187c715541ef2</span><br></pre></td></tr></table></figure>


<p>毕竟我也是面试官, 就不划定那些是常见问题了. 防止我的主观意见对于未来影响面试者的评价公正性.<br>而且我也要说一点, 我也不评论上述文章中的答案的正确性了. 大家还是需要在面试前先做些查询和研究了</p>
<h3 id="用心"><a href="#用心" class="headerlink" title="用心"></a>用心</h3><ol>
<li>去某公司面试前, 或者立志要去该公司. 最好先了解公司用到的python相关的技术栈, 这样可以有针对的准备相关内容</li>
<li>针对性的准备想要做的职位的python技能需求. 比如面试运维开发, 多准备系统, 数据库, 配置管理相关的知识, 比如web框架(除非了解到该职位需要)</li>
<li>及时关注python技能最新用法, 或者推荐用法. 多了解python3的趋势, 有可能会被面试官问到.</li>
<li>有个github账号. 能把自己的想法实践出来的python项目, 这样就多了了解你的机会. 可能在面试中就会少问你对应的技术点</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀开源项目kombu源码分析之可扩展的Transport</title>
    <url>/2016-02-01.html</url>
    <content><![CDATA[<p>Kombu里面使用Transport类来表示一个具体的消息代理（Broker），目前包含Redis、MongoDB、Zookeeper、Django、SQLAlchemy等类型。这种对不同类型实现相同接口的需求要求我们要设计成可扩展的方式。<br>我之前写代码，习惯这么设计：</p>
<ol>
<li>写一个基类Transport，定义还未实现的那些接口。</li>
<li>继承这个基类，实现对应的接口。</li>
<li>调用的时候通过一个带有别名和对应类的字典找到这个类。<br>如果新加一种类型，就是实现这个类型的Transport，然后在对应关系的映射里面加在它。<br>Kombu实现的更深入一些。今天我们分析下它是怎么实现的。<br>首先Kombu也有一个基类<a href="https://github.com/celery/kombu/blob/master/kombu/transport/virtual/base.py#L867" target="_blank" rel="noopener">Transport</a>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> kombu.transport <span class="keyword">import</span> base  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span><span class="params">(AbstractChannel, base.StdChannel)</span>:</span>  </span><br><span class="line">    <span class="comment"># 队列和消息处理的逻辑  </span></span><br><span class="line">    ...  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transport</span><span class="params">(base.Transport)</span>:</span>  </span><br><span class="line">    Channel = Channel  </span><br><span class="line">    implements = base.Transport.implements.extend(  </span><br><span class="line">        exchange_type=frozenset([<span class="string">'direct'</span>, <span class="string">'topic'</span>]),  </span><br><span class="line">        ...  </span><br><span class="line">    )   </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>这个base.Transport相当于预先定义了一些接口，相当于更加「基类」，这就不看了，权当这个Transport是各种消息代理的基类吧。<br>我们看一下MongoDB类型的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> virtual  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span><span class="params">(virtual.Channel)</span>:</span>  </span><br><span class="line">    <span class="comment"># MongoDB的逻辑  </span></span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transport</span><span class="params">(virtual.Transport)</span>:</span>  </span><br><span class="line">    Channel = Channel  <span class="comment"># 在这里被替换成MongoDB的Channel逻辑了  </span></span><br><span class="line">    driver_type = <span class="string">'mongodb'</span>  </span><br><span class="line">    driver_name = <span class="string">'pymongo'</span>  </span><br><span class="line">  </span><br><span class="line">    implements = virtual.Transport.implements.extend(  </span><br><span class="line">        exchange_type=frozenset([<span class="string">'direct'</span>, <span class="string">'topic'</span>, <span class="string">'fanout'</span>]),  </span><br><span class="line">    )  <span class="comment"># 不同消息代理能实现的交换类型是有区别的  </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>套路来了：每种Transport使用了完全不同的Channel，其他需要不一样处理的地方也会被覆写。<br>看起来和我上面说的方式也没什么不同嘛？重点来了，看它怎么用的，首先我们先了解2个函数：</p>
<ol>
<li>symbol_by_name函数可以通过字符串转化成对应的类对象：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    &gt;&gt;&gt; symbol_by_name(<span class="string">'celery.concurrency.processes.TaskPool'</span>)  </span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">celery</span>.<span class="title">concurrency</span>.<span class="title">processes</span>.<span class="title">TaskPool</span>'&gt;</span></span><br></pre></td></tr></table></figure>


<p>它和werkzeug.utils.import_string的作用差不多，但是更符合业务需要。<br>  2. fmatch_best函数是用来模糊匹配的，如果你不小心输错了他可以基于现有资源告诉你最符合的那个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fmatch_best(<span class="string">'hello'</span>, [<span class="string">'xxx'</span>, <span class="string">'hell'</span>, <span class="string">'hea'</span>])  </span><br><span class="line"><span class="string">'hell'</span></span><br></pre></td></tr></table></figure>

<p>有兴趣的可以研究kombu的实现。 `<br>回答正题看看它怎么实现的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TRANSPORT_ALIASES = &#123;  </span><br><span class="line">    <span class="string">'amqp'</span>: <span class="string">'kombu.transport.pyamqp:Transport'</span>,  </span><br><span class="line">    <span class="string">'memory'</span>: <span class="string">'kombu.transport.memory:Transport'</span>,  </span><br><span class="line">    <span class="string">'redis'</span>: <span class="string">'kombu.transport.redis:Transport'</span>,  </span><br><span class="line">    <span class="string">'mongodb'</span>: <span class="string">'kombu.transport.mongodb:Transport'</span>,  </span><br><span class="line">    ...  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">_transport_cache = &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolve_transport</span><span class="params">(transport=None)</span>:</span>  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        transport = TRANSPORT_ALIASES[transport]  </span><br><span class="line">    <span class="keyword">except</span> KeyError:  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">not</span> <span class="keyword">in</span> transport <span class="keyword">and</span> <span class="string">':'</span> <span class="keyword">not</span> <span class="keyword">in</span> transport:  </span><br><span class="line">            <span class="keyword">from</span> kombu.utils.text <span class="keyword">import</span> fmatch_best  </span><br><span class="line">            alt = fmatch_best(transport, TRANSPORT_ALIASES)  </span><br><span class="line">            <span class="keyword">if</span> alt:  </span><br><span class="line">                <span class="keyword">raise</span> KeyError(  </span><br><span class="line">                    <span class="string">'No such transport: &#123;0&#125;.  Did you mean &#123;1&#125;?'</span>.format(  </span><br><span class="line">                        transport, alt))  </span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">'No such transport: &#123;0&#125;'</span>.format(transport))  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="keyword">if</span> callable(transport):  </span><br><span class="line">            transport = transport()  </span><br><span class="line">    <span class="keyword">return</span> symbol_by_name(transport)  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_transport_cls</span><span class="params">(transport=None)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> transport <span class="keyword">not</span> <span class="keyword">in</span> _transport_cache:  </span><br><span class="line">        _transport_cache[transport] = resolve_transport(transport)  </span><br><span class="line">    <span class="keyword">return</span> _transport_cache[transport]</span><br></pre></td></tr></table></figure>


<p>使用一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">from</span> kombu.transport <span class="keyword">import</span> get_transport_cls  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: get_transport_cls(<span class="string">'mongodb'</span>)  </span><br><span class="line">Out[<span class="number">7</span>]: kombu.transport.mongodb.Transport</span><br></pre></td></tr></table></figure>


<p>它比较好的设计有2个：</p>
<ol>
<li>使用了缓存。Kombu把获取的对应关系存在了_transport_cache，但是你不去获取它什么都不会做。</li>
<li>竟然比较好的支持了模糊匹配！！ↁ_ↁ</li>
<li>通过字符串获得对应的类对象的实现非常智能，不用在<strong>init</strong>里面把所有类型import进来在alias一下，否则就要这样了:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> .mongodb <span class="keyword">import</span> Transport <span class="keyword">as</span> MongodbTransport  </span><br><span class="line"><span class="keyword">from</span> .redis <span class="keyword">import</span> Transport <span class="keyword">as</span> RedisTransport  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">  </span><br><span class="line">TRANSPORT_ALIASES = &#123;  </span><br><span class="line">    <span class="string">'redis'</span>: RedisTransport,  </span><br><span class="line">    <span class="string">'mongodb'</span>: MongodbTransport,  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>唯一我觉得可以简化的地方是TRANSPORT_ALIASES中的对应关系，因为大部分情况下，键的名字和类型文件的名字是对应的，比如「’redis’:<br>‘kombu.transport.redis:Transport’」中的redis其实就一种命令规则，除了一些amqp类型的对应关系外，我们显然可以通过XX直接尝试去获取<code>kombu.transport.XX:Transport</code>类。但是kombu为啥没有省着差不多10行的代码呢？<br><strong>这涉及到了代码可读性可维护性的问题，没有必要为了极简的代码量增加复杂度。</strong></p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>sed-and-awk</title>
    <url>/2016-02-03.html</url>
    <content><![CDATA[<p>####前言<br>最近做一个关于sed和awk的分享,这里把源码开源:<a href="https://github.com/dongweiming/sed_and_awk" target="_blank" rel="noopener">sed_and_awk</a>,或者直接访问<a href="http://dongweiming.github.io/sed_and_awk" target="_blank" rel="noopener">http://dongweiming.github.io/sed_and_awk</a>.<br>我这个ppt基本覆盖90%以上的知识点.<br>####一些说明<br>我测试例子都是在osx下,freebsd的sed和awk和gnu的都略有不同.甚至osx下得版本都不能使用,我会在注释中说明.</p>
<ul>
<li>sed<ol>
<li>sed 通用</li>
<li>/usr/local/bin/sed osx下编译的gnu sed</li>
</ol>
</li>
<li>awk<ol>
<li>awk 通用</li>
<li>gawk osx编译的gnu awk</li>
</ol>
</li>
</ul>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于expect研究(四)</title>
    <url>/2016-02-02.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近又开始开始了expect的一些更深层次的东西，分享出来</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>expect没有严格意义的字典，但是确实可以使用<br>创建字典:</p>
<pre><code>set mydict [dict create tbj tbjpass server serverpass]  
它表示创建一个字典叫做mydict，包含2个kv对：tbj &amp; tbjpass 和server &amp; serverpass  </code></pre><p>你也可以这样添加数据:</p>
<pre><code>set mydict .dongwm dongwmpass  
 表示添加一个键为.dongwm 值为dongwmpass的新数据到mydict  </code></pre><p>根据key获取值可以这样:</p>
<pre><code>[dict get $mydict server]  
表示从mydict获取server的值  </code></pre><p>NB的事，可以直接这样写，看我的片段:</p>
<pre><code>expect “password:”  
send “[dict get $mydict s70]\n”  
也就是直接把这个看起来像列表的东东直接写到字符串里面  </code></pre><h2 id="判断变量是否存在"><a href="#判断变量是否存在" class="headerlink" title="判断变量是否存在"></a>判断变量是否存在</h2><pre><code>if {[info exists serverpass]!=1} {  
    puts ‘sd’  
}  
表示如果serverpass这个变量要是不存在，就puts，但是注意的是，  
假如上面你已经set 这个变量，不管有没有值，这个变量都已经被 _定义_ 了  </code></pre><h2 id="判断列表包含"><a href="#判断列表包含" class="headerlink" title="判断列表包含"></a>判断列表包含</h2><p>一种使用switch结构，还有一种是if方式，将属于一类的放在一个列表，<br>看它是不是’in’:</p>
<pre><code>set listserver “1 2 3 4 “  
if {1 in $listserver} {puts 11}  
当1在列表$listserver里面puts  </code></pre><h2 id="switch多条件"><a href="#switch多条件" class="headerlink" title="switch多条件"></a>switch多条件</h2><p>假如有一些switch的结果，但是他们有一些需要做一样的操作，<br>那么就可以吧他们放在一起</p>
<pre><code>switch $port {  
    100  -  
    200  { puts 1}  
    300  -  
    400 {puts 2}  
    }  
这里表示当port是100,或者200会puts1,当port是300或者400，会puts2  </code></pre><p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tornado让你的请求异步非阻塞</title>
    <url>/2016-01-31.html</url>
    <content><![CDATA[<p>####前言<br>也许有同学很迷惑:tornado不是标榜异步非阻塞解决10K问题的嘛?但是我却发现不是torando不好，而是你用错了.比如最近发现一个事情:某网站打开页面很慢,服务器cpu/内存都正常.网络状态也良好.<br>后来发现，打开页面会有很多请求后端数据库的访问，有一个mongodb的数据库业务api的rest服务.但是它的tornado却用错了,一步步的来研究问题:<br>####说明<br>以下的例子都有2个url,一个是耗时的请求，一个是可以或者说需要立刻返回的请求,我想就算一个对技术不熟，从道理上来说的用户，<br>他希望的是他访问的请求不会影响也不会被其他人的请求影响</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/env python  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> tornado.httpserver  </span><br><span class="line"><span class="keyword">import</span> tornado.ioloop  </span><br><span class="line"><span class="keyword">import</span> tornado.options  </span><br><span class="line"><span class="keyword">import</span> tornado.web  </span><br><span class="line"><span class="keyword">import</span> tornado.httpclient  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options  </span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        time.sleep(<span class="number">5</span>)  </span><br><span class="line">        self.write(<span class="string">"when i sleep 5s"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustNowHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.write(<span class="string">"i hope just now see you"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">    tornado.options.parse_command_line()  </span><br><span class="line">    app = tornado.web.Application(handlers=[  </span><br><span class="line">            (<span class="string">r"/sleep"</span>, SleepHandler), (<span class="string">r"/justnow"</span>, JustNowHandler)])  </span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)  </span><br><span class="line">    http_server.listen(options.port)  </span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>


<p>假如你使用页面请求或者使用哪个httpie,curl等工具先访问<a href="http://localhost:8000/sleep,再访问http://localhost:8000/justnow.你会发现本来可以立刻返回的/jsutnow的请求会一直阻塞到/sleep请求完才返回" target="_blank" rel="noopener">http://localhost:8000/sleep,再访问http://localhost:8000/justnow.你会发现本来可以立刻返回的/jsutnow的请求会一直阻塞到/sleep请求完才返回</a>.<br>这是为啥?为啥我的请求被/sleep请求阻塞了？如果平时我们的web请求足够快我们可能不会意识到这个问题，但是事实上经常会有一些耗时的进程，意味着应用程序被有效的锁定直至处理结束.<br>这是时候你有没有想起@tornado.web.asynchronous这个装饰器？但是使用这个装饰器有个前提就是你要耗时的执行需要执行异步,比如上面的time.sleep,你只是加装饰器是没有作用的，而且需要注意的是<br>Tornado默认在函数处理返回时关闭客户端的连接,但是当你使用@tornado.web.asynchonous装饰器时，Tornado永远不会自己关闭连接，需要显式的self.finish()关闭<br>我们大部分的函数都是阻塞的, 比如上面的time.sleep其实tornado有个异步的实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/env python  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> tornado.httpserver  </span><br><span class="line"><span class="keyword">import</span> tornado.ioloop  </span><br><span class="line"><span class="keyword">import</span> tornado.options  </span><br><span class="line"><span class="keyword">import</span> tornado.web  </span><br><span class="line"><span class="keyword">import</span> tornado.gen  </span><br><span class="line"><span class="keyword">import</span> tornado.httpclient  </span><br><span class="line"><span class="keyword">import</span> tornado.concurrent  </span><br><span class="line"><span class="keyword">import</span> tornado.ioloop  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options  </span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line"><span class="meta">    @tornado.web.asynchronous  </span></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">yield</span> tornado.gen.Task(tornado.ioloop.IOLoop.instance().add_timeout, time.time() + <span class="number">5</span>)  </span><br><span class="line">        self.write(<span class="string">"when i sleep 5s"</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustNowHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.write(<span class="string">"i hope just now see you"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">    tornado.options.parse_command_line()  </span><br><span class="line">    app = tornado.web.Application(handlers=[  </span><br><span class="line">            (<span class="string">r"/sleep"</span>, SleepHandler), (<span class="string">r"/justnow"</span>, JustNowHandler)])  </span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)  </span><br><span class="line">    http_server.listen(options.port)  </span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>


<p>这里有个新的tornado.gen.coroutine装饰器, coroutine是3.0之后新增的装饰器.以前的办法是用回调，还是看我这个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line"><span class="meta">    @tornado.web.asynchronous  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        tornado.ioloop.IOLoop.instance().add_timeout(time.time() + <span class="number">5</span>, callback=self.on_response)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.write(<span class="string">"when i sleep 5s"</span>)  </span><br><span class="line">        self.finish()</span><br></pre></td></tr></table></figure>


<p>使用了callback, 但是新的装饰器让我们通过yield实现同样的效果:你在打开/sleep之后再点击/justnow，<br>justnow的请求都是立刻返回不受影响.但是用了asynchronous的装饰器你的耗时的函数也需要执行异步<br>刚才说的都是没有意义的例子，下面写个有点用的:读取mongodb数据库数据，然后再前端按行write出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/env python  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> tornado.httpserver  </span><br><span class="line"><span class="keyword">import</span> tornado.ioloop  </span><br><span class="line"><span class="keyword">import</span> tornado.options  </span><br><span class="line"><span class="keyword">import</span> tornado.web  </span><br><span class="line"><span class="keyword">import</span> tornado.gen  </span><br><span class="line"><span class="keyword">import</span> tornado.httpclient  </span><br><span class="line"><span class="keyword">import</span> tornado.concurrent  </span><br><span class="line"><span class="keyword">import</span> tornado.ioloop  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="comment"># 一个mongodb出品的支持异步的数据库的python驱动  </span></span><br><span class="line"><span class="keyword">import</span> motor  </span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options  </span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)  </span><br><span class="line"><span class="comment"># db其实就是test数据库的游标  </span></span><br><span class="line">db = motor.MotorClient().open_sync().test  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepHandler</span><span class="params">(BaseHandler)</span>:</span>  </span><br><span class="line"><span class="meta">    @tornado.web.asynchronous  </span></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="comment"># 这一行执行还是阻塞需要时间的，我的tt集合有一些数据并且没有索引  </span></span><br><span class="line">        cursor = db.tt.find().sort([(<span class="string">'a'</span>, <span class="number">-1</span>)])  </span><br><span class="line">        <span class="comment"># 这部分会异步非阻塞的执行二不影响其他页面请求  </span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">yield</span> cursor.fetch_next):  </span><br><span class="line">            message = cursor.next_object()  </span><br><span class="line">            self.write(<span class="string">'&lt;li&gt;%s&lt;/li&gt;'</span> % message[<span class="string">'a'</span>])  </span><br><span class="line">        self.write(<span class="string">'&lt;/ul&gt;'</span>)  </span><br><span class="line">        self.finish()  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_on_response</span><span class="params">(self, message, error)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> error:  </span><br><span class="line">            <span class="keyword">raise</span> tornado.web.HTTPError(<span class="number">500</span>, error)  </span><br><span class="line">        <span class="keyword">elif</span> message:  </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> message:  </span><br><span class="line">                self.write(<span class="string">'&lt;li&gt;%s&lt;/li&gt;'</span> % i[<span class="string">'a'</span>])  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            self.write(<span class="string">'&lt;/ul&gt;'</span>)  </span><br><span class="line">            self.finish()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustNowHandler</span><span class="params">(BaseHandler)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.write(<span class="string">"i hope just now see you"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">    tornado.options.parse_command_line()  </span><br><span class="line">    app = tornado.web.Application(handlers=[  </span><br><span class="line">            (<span class="string">r"/sleep"</span>, SleepHandler), (<span class="string">r"/justnow"</span>, JustNowHandler)])  </span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)  </span><br><span class="line">    http_server.listen(options.port)  </span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>


<p>一个同事提示为什么这个耗时的东西不能异步的丢给某工具去执行而不阻塞我的请求呢?好吧，我也想到了:celery，正好github有这个东西:<a href="https://github.com/mher/tornado-celery" target="_blank" rel="noopener">tornado-<br>celery</a><br>执行下面的程序首先你要安装rabbitmq和celery:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/env python  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> tornado.httpserver  </span><br><span class="line"><span class="keyword">import</span> tornado.ioloop  </span><br><span class="line"><span class="keyword">import</span> tornado.options  </span><br><span class="line"><span class="keyword">import</span> tornado.web  </span><br><span class="line"><span class="keyword">import</span> tornado.gen  </span><br><span class="line"><span class="keyword">import</span> tornado.httpclient  </span><br><span class="line"><span class="keyword">import</span> tcelery, tasks  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options  </span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)  </span><br><span class="line">  </span><br><span class="line">tcelery.setup_nonblocking_producer()  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line"><span class="meta">    @tornado.web.asynchronous  </span></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="comment"># tornado.gen.Task的参数是:要执行的函数, 参数  </span></span><br><span class="line">        <span class="keyword">yield</span> tornado.gen.Task(tasks.sleep.apply_async, args=[<span class="number">5</span>])  </span><br><span class="line">        self.write(<span class="string">"when i sleep 5s"</span>)  </span><br><span class="line">        self.finish()  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustNowHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.write(<span class="string">"i hope just now see you"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">    tornado.options.parse_command_line()  </span><br><span class="line">    app = tornado.web.Application(handlers=[  </span><br><span class="line">            (<span class="string">r"/sleep"</span>, SleepHandler), (<span class="string">r"/justnow"</span>, JustNowHandler)])  </span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)  </span><br><span class="line">    http_server.listen(options.port)  </span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>


<p>task是celery的任务定义的文件，包含我们说的time.sleep的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery  </span><br><span class="line">  </span><br><span class="line">celery = Celery(<span class="string">"tasks"</span>, broker=<span class="string">"amqp://guest:guest@localhost:5672"</span>)  </span><br><span class="line">celery.conf.CELERY_RESULT_BACKEND = <span class="string">"amqp"</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@celery.task  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(seconds)</span>:</span>  </span><br><span class="line">    time.sleep(float(seconds))  </span><br><span class="line">    <span class="keyword">return</span> seconds  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">    celery.start()</span><br></pre></td></tr></table></figure>


<p>然后启动celelry worker(要不然你的任务怎么执行呢?肯定需要一个消费者取走):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">celery -A tasks worker --loglevel=info</span><br></pre></td></tr></table></figure>


<p>但是这里的问题也可能很严重:我们的异步非阻塞依赖于celery,还是这个队列的长度,假如任务很多那么就需要等待,效率很低.有没有一种办法把我的同步阻塞函数变为异步(或者说被tornado的装饰器理解和识别)呢?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/env python  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> tornado.httpserver  </span><br><span class="line"><span class="keyword">import</span> tornado.ioloop  </span><br><span class="line"><span class="keyword">import</span> tornado.options  </span><br><span class="line"><span class="keyword">import</span> tornado.web  </span><br><span class="line"><span class="keyword">import</span> tornado.httpclient  </span><br><span class="line"><span class="keyword">import</span> tornado.gen  </span><br><span class="line"><span class="keyword">from</span> tornado.concurrent <span class="keyword">import</span> run_on_executor  </span><br><span class="line"><span class="comment"># 这个并发库在python3自带在python2需要安装sudo pip install futures  </span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options  </span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">2</span>)  </span><br><span class="line"><span class="meta">    @tornado.web.asynchronous  </span></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="comment"># 假如你执行的异步会返回值被继续调用可以这样(只是为了演示),否则直接yield就行  </span></span><br><span class="line">        res = <span class="keyword">yield</span> self.sleep()  </span><br><span class="line">        self.write(<span class="string">"when i sleep"</span>)  </span><br><span class="line">        self.finish()  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @run_on_executor  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        time.sleep(<span class="number">5</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustNowHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.write(<span class="string">"i hope just now see you"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">    tornado.options.parse_command_line()  </span><br><span class="line">    app = tornado.web.Application(handlers=[  </span><br><span class="line">            (<span class="string">r"/sleep"</span>, SleepHandler), (<span class="string">r"/justnow"</span>, JustNowHandler)])  </span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)  </span><br><span class="line">    http_server.listen(options.port)  </span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>


<p>但是有朋友留言和我说为什么在浏览器打开多个url请求还是会阻塞一个个的响应呢?<br>这个事浏览器自身实现的可能是缓存把,当请求的资源相同就会出现这个问题,可以使用多浏览器(多人)或者命令行下的curl登都不会有这个问题,还有个比较恶的解决方法:<br>给你的请求添加一些无用参数，比如: <a href="http://localhost:8000/sleep/?a=1" target="_blank" rel="noopener">http://localhost:8000/sleep/?a=1</a> 也可以是个时间戳</p>
<h5 id="2014-4-1更新-发现了2种新的写法-请参照-Blocking-tasks-in"><a href="#2014-4-1更新-发现了2种新的写法-请参照-Blocking-tasks-in" class="headerlink" title="2014.4.1更新,发现了2种新的写法,请参照[Blocking tasks in"></a>2014.4.1更新,发现了2种新的写法,请参照[Blocking tasks in</h5><p>Tornado](<a href="http://lbolla.info/blog/2013/01/22/blocking-tornado" target="_blank" rel="noopener">http://lbolla.info/blog/2013/01/22/blocking-tornado</a>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor  </span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial, wraps  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> tornado.ioloop  </span><br><span class="line"><span class="keyword">import</span> tornado.web  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options  </span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8000</span>, help=<span class="string">"run on the given port"</span>, type=int)  </span><br><span class="line">  </span><br><span class="line">EXECUTOR = ThreadPoolExecutor(max_workers=<span class="number">4</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unblock</span><span class="params">(f)</span>:</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @tornado.web.asynchronous  </span></span><br><span class="line"><span class="meta">    @wraps(f)  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">        self = args[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span>  </span><br><span class="line">            self.write(future.result())  </span><br><span class="line">            self.finish()  </span><br><span class="line">  </span><br><span class="line">        EXECUTOR.submit(  </span><br><span class="line">            partial(f, *args, **kwargs)  </span><br><span class="line">        ).add_done_callback(  </span><br><span class="line">            <span class="keyword">lambda</span> future: tornado.ioloop.IOLoop.instance().add_callback(  </span><br><span class="line">                partial(callback, future)))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> wrapper  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustNowHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.write(<span class="string">"i hope just now see you"</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @unblock  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, n)</span>:</span>  </span><br><span class="line">        time.sleep(float(n))  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Awake! %s"</span> % time.time()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepAsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @tornado.web.asynchronous  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, n)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span>  </span><br><span class="line">            self.write(future.result())  </span><br><span class="line">            self.finish()  </span><br><span class="line">  </span><br><span class="line">        EXECUTOR.submit(  </span><br><span class="line">            partial(self.get_, n)  </span><br><span class="line">        ).add_done_callback(  </span><br><span class="line">            <span class="keyword">lambda</span> future: tornado.ioloop.IOLoop.instance().add_callback(  </span><br><span class="line">                partial(callback, future)))  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_</span><span class="params">(self, n)</span>:</span>  </span><br><span class="line">        time.sleep(float(n))  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Awake! %s"</span> % time.time()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">application = tornado.web.Application([  </span><br><span class="line">    (<span class="string">r"/justnow"</span>, JustNowHandler),  </span><br><span class="line">    (<span class="string">r"/sleep/(\d+)"</span>, SleepHandler),  </span><br><span class="line">    (<span class="string">r"/sleep_async/(\d+)"</span>, SleepAsyncHandler),  </span><br><span class="line">])  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:  </span><br><span class="line">   application.listen(options.port)  </span><br><span class="line">   tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之微信小程序实战(二)</title>
    <url>/2016-02-04.html</url>
    <content><![CDATA[<p>今天进入正题，看看下面效果的小程序是怎么实现的：<br>![](<a href="https://github.com/dongweiming/weapp-" target="_blank" rel="noopener">https://github.com/dongweiming/weapp-</a><br>zhihulive/raw/master/screenshot/zhihulive.png)<br>项目地址 <a href="https://github.com/dongweiming/weapp-zhihulive" target="_blank" rel="noopener">https://github.com/dongweiming/weapp-zhihulive</a><br>PS: 本文是假设你已经看过微信小程序的官方文档、demo甚至已经动手写过小程序，否则建议先去翻翻再来看。</p>
<h3 id="设计目录结构"><a href="#设计目录结构" class="headerlink" title="设计目录结构"></a>设计目录结构</h3><p>我在上一节<a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E6%88%98(%E4%B8%80" target="_blank" rel="noopener">知乎Live全文搜索之微信小程序实战（一）</a>/)介绍了组件化，今天就是要实施了。首先我们考虑一个只有index页面的小程序的目录结构是怎么样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├── app.js  // 全局的脚本文件  </span><br><span class="line">├── app.json  // 全局的配置文件  </span><br><span class="line">├── app.wxss  // 全局的样式文件  </span><br><span class="line">├── pages  </span><br><span class="line">│   ├── index  </span><br><span class="line">│   │   ├── index.js // 脚本文件  </span><br><span class="line">│   │   ├── index.json // 组件的配置文件  </span><br><span class="line">│   │   ├── index.wxml  // 页面结构文件  </span><br><span class="line">│   │   ├── rating.png  // 还有其他的图片..  </span><br><span class="line">│   │   └── index.wxss  // 样式表文件</span><br></pre></td></tr></table></figure>


<p>pages目录下有个index目录，存放了名字叫做index，后缀为js/json/wxml/wxss的四个文件。这样做的好处是：</p>
<ol>
<li>index目录下存放了页面组件所需要的各种资源， <strong>就近维护</strong> 。如果是React，还得通过使用各种loader，用import的方式来用，所以我喜欢小程序的处理方式。</li>
<li>当某天不再需要index这个页面，或者要替换成其他的组件，直接把index目录删掉/替换就完事了。<br>接着我们基于Live搜索，思考下如果页面变的复杂，重要元素多的场景：</li>
<li>需要Live、User、Topic三大元素。</li>
<li>有些内容是可以重复被利用的，比如评分（就是大家熟悉的星星，5星满分，4.5星次之…）在Live详情页的效果比较大，而在搜索页由于区域小所以小了很多，但是本质上内容是一样的，只不过样式不同。</li>
<li>有些内容在不同页面重复出现，比如Live，在topic详情页、用户详情页、发现页都有，而且一样。<br>那么：</li>
<li>评分是一个独立的区域，可以视作一个组件。</li>
<li>组件与组件之间应该可以 <strong>自由组合</strong> ，所以组件的粒度要细，细到一个组件就是做一件事。</li>
<li>单个评分组件拿出来是无意义的，只有和Live信息汇合起来才是一个完整页面。<br>所以重新定义目录结构吧：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">App  </span><br><span class="line">├── components  </span><br><span class="line">│   ├── hot  </span><br><span class="line">│   ├── live  </span><br><span class="line">│   ├── user  </span><br><span class="line">│   └── widget  </span><br><span class="line">├── images  </span><br><span class="line">│   └── rating  </span><br><span class="line">├── pages  </span><br><span class="line">│   ├── explore  </span><br><span class="line">│   ├── hot  </span><br><span class="line">│   ├── live  </span><br><span class="line">│   ├── search  </span><br><span class="line">│   ├── topic  </span><br><span class="line">│   └── users  </span><br><span class="line">└── utils</span><br></pre></td></tr></table></figure>


<p>现在pages的每个子目录下后缀为js的文件就是页面逻辑。比如pages/users/users.js存放了/users/users的页面逻辑。<br>我新增了3个目录：</p>
<ol>
<li>utils。存放一些用得到的功能性的函数，如和后端通信的api.js，一会我们详细再看。</li>
<li>images。存放公共的静态图片资源。</li>
<li>components。组件目录，我们把抽象的元素都放在这里，比如评分是一个组件。组件目录下有这些文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">components/  </span><br><span class="line">├── hot  </span><br><span class="line">│   ├── hot.wxml  </span><br><span class="line">│   └── hot.wxss  </span><br><span class="line">├── live  </span><br><span class="line">│   ├── live.wxml  </span><br><span class="line">│   ├── live.wxss  </span><br><span class="line">│   ├── live_middle.wxml  </span><br><span class="line">│   ├── live_middle.wxss  </span><br><span class="line">│   ├── live_small.wxml  </span><br><span class="line">│   └── live_small.wxss  </span><br><span class="line">├── user  </span><br><span class="line">│   ├── user.wxml  </span><br><span class="line">│   ├── user.wxss  </span><br><span class="line">│   ├── user_small.wxml  </span><br><span class="line">│   └── user_small.wxss  </span><br><span class="line">└── widget  </span><br><span class="line">    ├── rating.wxml  </span><br><span class="line">    └── rating.wxss</span><br></pre></td></tr></table></figure>


<p>widget是更小层级的组件，也是本项目最小的组件单元了。它会被其他的如user/live/hot引用，而user/live/hot最后又会被pages下对应的模板引用。</p>
<h3 id="捋一个组件化的例子"><a href="#捋一个组件化的例子" class="headerlink" title="捋一个组件化的例子"></a>捋一个组件化的例子</h3><p>首先感受一下发现页：<br><img src="https://cloud.githubusercontent.com/assets/841395/23269238/dcd5d5f6-fa2a-11e6-9065-cde6cef11dbe.png" alt><br>发现页是live的集合。每个live都是一个card，看上面的components目录，live有三种组件，发现页用的是user类型的。<br>pages/explore.wxml文件的内容是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% raw %&#125;  </span><br><span class="line">&lt;<span class="keyword">import</span> src=<span class="string">"../../components/live/live.wxml"</span> /&gt;  </span><br><span class="line">&lt;scroll-view class="list" style="height: &#123;&#123; windowHeight &#125;&#125;px; width: &#123;&#123; windowWidth &#125;&#125;px;" scroll-y="true" bindscrolltolower="loadMore" lower-threshold="800"&gt;  </span><br><span class="line">  &lt;block wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123; lives &#125;&#125;"</span> wx:<span class="keyword">for</span>-item=<span class="string">"live"</span> wx:key=<span class="string">"live.id"</span>&gt;  </span><br><span class="line">    &lt;template <span class="keyword">is</span>=<span class="string">"m-live"</span> data=<span class="string">"&#123;&#123;live: live&#125;&#125;"</span> /&gt;  </span><br><span class="line">  &lt;/block&gt;  </span><br><span class="line">  &lt;view class="loading"&gt;  </span><br><span class="line">    正在加载...  </span><br><span class="line">  &lt;/view&gt;  </span><br><span class="line">&lt;/scroll-view&gt;  </span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>


<p>我简单介绍下这段模板的含义：</p>
<ol>
<li>import语句对于写Python，尤其是会Mako的同学非常好理解，就是引入文件。</li>
<li>scroll-view是「可滚动视图区域」容器，小程序自带的组件，我们可以上下滑动。</li>
<li>bindscrolltolower=”loadMore” 绑定了一个滚动到底部/右边就会触发的事件，会执行loadMore函数，之后会讲到。</li>
<li>`` 表示一个for循环的块。</li>
<li>wx:for-item=”live” 表示循环的每个元素赋值为live。</li>
<li>`` 表示找名字叫做m-live的模板渲染，传入的参数是live，值为上面循环for-item指定的那个变量‘live’。<br>上面用import通过一个相对路径引入了../../components/live/live.wxml这个模板文件，它里面就会有这个叫做m-<br>live的模板，我们看看它的内容：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% raw %&#125;  </span><br><span class="line">&lt;<span class="keyword">import</span> src=<span class="string">"../../components/widget/rating.wxml"</span> /&gt;  </span><br><span class="line">&lt;template name=<span class="string">"m-live"</span>&gt;  </span><br><span class="line">  &lt;view class="m-live" bindtap="onViewTap" data-id="&#123;&#123; live.id &#125;&#125;" data-type="live"&gt;  </span><br><span class="line">    &lt;image class="cover" src="&#123;&#123; live.cover &#125;&#125;" mode="aspectFill"&gt;&lt;/image&gt;  </span><br><span class="line">    &lt;view class="info"&gt;  </span><br><span class="line">      &lt;text class="h2"&gt;&#123;&#123; live.subject &#125;&#125;&lt;/text&gt;  </span><br><span class="line">      &lt;view class="rating"&gt;  </span><br><span class="line">        &lt;template <span class="keyword">is</span>=<span class="string">"m-rating"</span> data=<span class="string">"&#123;&#123;count: live.feedback_score, size: 's'&#125;&#125;"</span> /&gt;  </span><br><span class="line">        &lt;view catchtap="onViewTap" data-id="&#123;&#123; live.speaker.id &#125;&#125;" data-type="user" class="user"&gt;  </span><br><span class="line">          &lt;image class="avatar" src="&#123;&#123; live.speaker.avatar_url &#125;&#125;"&gt;&lt;/image&gt;  </span><br><span class="line">          &lt;view class="name"&gt;by &#123;&#123; live.speaker.name &#125;&#125;&lt;/view&gt;  </span><br><span class="line">        &lt;/view&gt;  </span><br><span class="line">      &lt;/view&gt;  </span><br><span class="line">      &lt;view class="detail"&gt;  </span><br><span class="line">        &lt;view&gt;  </span><br><span class="line">          &lt;text&gt;开始时间&#123;&#123; live.starts_at &#125;&#125;&lt;/text&gt;  </span><br><span class="line">        &lt;/view&gt;  </span><br><span class="line">      &lt;/view&gt;  </span><br><span class="line">      &lt;view class="bottom"&gt;&#123;&#123; live.seats_taken &#125;&#125;参与 / &#123;&#123; live.liked_num &#125;&#125;喜欢 / &#123;&#123; live.speaker_message_count &#125;&#125;个回答  </span><br><span class="line">      &lt;/view&gt;  </span><br><span class="line">    &lt;/view&gt;  </span><br><span class="line">  &lt;/view&gt;  </span><br><span class="line">&lt;/template&gt;  </span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>


<p>这个模板中还用到了import，引入了更小的组件单元rating.wxml，也用到了``这样的方式来调用rating.wxml中的名为m-<br>rating的模板。用这样的方式就实现了组件化，也保证了模板的整洁。<br>这个模板中还有个bindtap=”onViewTap”，相当于给这个div加了一个事件绑定，bindtap表示当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数onViewTap。<br>剩下的就是铺页面结构了，具体想展示什么数据，页面想设计成什么就铺成对应的view，有一点，标签你就当<br>理解好了。</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>现在大家对组件化的用法有了些了解，我们再看看视图和模板之间怎么做数据绑定的。<br>如果你熟悉jinja2或者Mustache，想必对于<code></code>的语法很亲切。对，相当于将变量包起来。<br>那么其中的windowWidth、lives、windowHeight这些是哪里来的呢？<br>答案是「WXML 中的动态数据均来自对应 Page 的 data」，在这里就是pages/explore.js里面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% raw %&#125;  </span><br><span class="line">const App = getApp(); // sdk提供的  </span><br><span class="line">const api = require(<span class="string">'../../utils/api.js'</span>);  // 用require语句加载模块，相对路径  </span><br><span class="line">const util = require(<span class="string">'../../utils/util.js'</span>);  </span><br><span class="line">  </span><br><span class="line">const formatTime = util.formatTime;  </span><br><span class="line">  </span><br><span class="line">Page(&#123;  // Page是sdk提供的  </span><br><span class="line">  data: &#123;  // 模板用到的数据都在data下  </span><br><span class="line">    lives: [],   </span><br><span class="line">    start: <span class="number">0</span>,  </span><br><span class="line">    limit: <span class="number">20</span>,  </span><br><span class="line">    loading: false,  </span><br><span class="line">    windowWidth: App.systemInfo.windowWidth,  </span><br><span class="line">    windowHeight: App.systemInfo.windowHeight,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  onLoad() &#123;  // Page自带的生命周期函数，监听页面加载。其他的生命周期可以看官方文档啦  </span><br><span class="line">    this.loadMore(); // 加载页面就会通过loadMore加载数据  </span><br><span class="line">  &#125;,  </span><br><span class="line">  onPullDownRefresh() &#123; // 另外一个Page自带的生命周期函数，监听用户下拉动作  </span><br><span class="line">    this.loadMore(null, true);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  loadMore(e, needRefresh) &#123;  </span><br><span class="line">     ...// 加载数据的逻辑，下面再聊  </span><br><span class="line">  &#125;,  </span><br><span class="line">  onViewTap(e) &#123; // 模板绑定的bindtap/catchtap事件就会执行这个函数  </span><br><span class="line">    const ds = e.currentTarget.dataset; // 查找模板对应div的数据集，也就是那些<span class="string">'data-'</span>开头的属性，比如上面的「data-id=<span class="string">"&#123;&#123; live.id &#125;&#125;"</span> data-type=<span class="string">"live"</span>」,这里会能找到ds.id和ds.type了  </span><br><span class="line">    const t = ds['type'] === 'live' ? 'live/live' : 'users/user' // ds.type 和 ds['type'] 一样的用  </span><br><span class="line">    wx.navigateTo(&#123; // 是sdk提供的一个界面API，表示在新窗口打开页面  </span><br><span class="line">      url: `../$&#123;t&#125;?id=$&#123;ds.id&#125;`,  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;);  </span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>


<h3 id="loadMore"><a href="#loadMore" class="headerlink" title="loadMore"></a>loadMore</h3><p>实现一个简单的加载数据的逻辑，首先是在data下面初始化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Page(&#123;  </span><br><span class="line">  data: &#123;  </span><br><span class="line">    lives: [],  </span><br><span class="line">    start: <span class="number">0</span>,  </span><br><span class="line">    limit: <span class="number">20</span>,  </span><br><span class="line">    loading: false,  </span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>


<p>start/limit就是用来翻页的参数，后端拿到的结果合并到lives中，loading检查是不是已经请求过而减少后端压力：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">loadMore(e, needRefresh) &#123;  </span><br><span class="line">    const self = this;  </span><br><span class="line">    const loading = self.data.loading;  </span><br><span class="line">    const data = &#123;  </span><br><span class="line">      start: self.data.start,  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">if</span> (loading) &#123;  </span><br><span class="line">      <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    self.setData(&#123;  </span><br><span class="line">      loading: true,  </span><br><span class="line">    &#125;);  </span><br><span class="line">    api.explore(&#123;  </span><br><span class="line">      data,  </span><br><span class="line">      success: (res) =&gt; &#123;  </span><br><span class="line">        let lives = res.data.rs;  </span><br><span class="line">        lives.map((live) =&gt; &#123;  </span><br><span class="line">          const item = live;  </span><br><span class="line">          item.starts_at = formatTime(new Date(item.starts_at * <span class="number">1000</span>), <span class="number">1</span>);  </span><br><span class="line">          <span class="keyword">return</span> item;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="keyword">if</span> (needRefresh) &#123;  </span><br><span class="line">          wx.stopPullDownRefresh();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          lives = self.data.lives.concat(lives);  </span><br><span class="line">        &#125;  </span><br><span class="line">        self.setData(&#123;  </span><br><span class="line">          lives: lives,  </span><br><span class="line">          start: self.data.start + self.data.limit,  </span><br><span class="line">          loading: false,  </span><br><span class="line">        &#125;);  </span><br><span class="line">      &#125;,  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>


<p>有几点需要注意：</p>
<ol>
<li>说一下<code>const self = this;</code>这样的用法的原因：this是一个特殊的对象，这个this对象是在运行时基于执行环境绑定的，即在全局对象中，this指向的是window对象；在自定义函数中，this对象指向的是调用这个函数的对象。常用的做法是在函数内赋值给一个私有的self（叫that或者其他也没有关系），这样就能保证在外部调用的时候使用的是函数对象了。</li>
<li>setData就类似于React的setState。</li>
<li>api.explore是封装好的api方法，后面会提到实现的原理。<h3 id="小程序怎么和后端交互"><a href="#小程序怎么和后端交互" class="headerlink" title="小程序怎么和后端交互"></a>小程序怎么和后端交互</h3>我们后端提供JSON<br>API返回需要的数据，在小程序中如何来调用呢？小程序提供了wx.request这个方法来发起HTTP（S）请求。但是需要注意它不容许使用referer，所以图片不是直接从知乎获取，而是先下载到本地，再由本地来serve的。<br>我们基于wx.request封装一下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const apiURL = <span class="string">'http://localhost:8300/api/v1'</span>;  </span><br><span class="line">  </span><br><span class="line">const wxRequest = (params, url) =&gt; &#123;  </span><br><span class="line">  wx.request(&#123;  </span><br><span class="line">    url,  </span><br><span class="line">    method: params.method || <span class="string">'GET'</span>,  </span><br><span class="line">    data: params.data || &#123;&#125;,  </span><br><span class="line">    header: &#123;  </span><br><span class="line">      Accept: <span class="string">'application/json'</span>,  </span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,  </span><br><span class="line">    &#125;,  </span><br><span class="line">    success(res) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (params.success) &#123;  </span><br><span class="line">        params.success(res);  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    fail(res) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (params.fail) &#123;  </span><br><span class="line">        params.fail(res);  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    complete(res) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (params.complete) &#123;  </span><br><span class="line">        params.complete(res);  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;,  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">const explore = (params) =&gt; &#123;  </span><br><span class="line">  wxRequest(params, `$&#123;apiURL&#125;/explore`);  </span><br><span class="line">&#125;;  </span><br><span class="line">const getLiveInfoById = (params) =&gt; &#123;  </span><br><span class="line">  wxRequest(&#123; success: params.success &#125;, `$&#123;apiURL&#125;/live/$&#123;params.data.id&#125;`);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">module.exports = &#123;  </span><br><span class="line">  explore,  </span><br><span class="line">  getLiveInfoById,  </span><br><span class="line">  ...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>由于这个项目都是一些获取资源的需求，一律用的GET，实现的就比较简单了。使用这个模块里面的那些函数就可以实现请求后端对应接口了。</p>
<h3 id="组合这些页面"><a href="#组合这些页面" class="headerlink" title="组合这些页面"></a>组合这些页面</h3><p>上面展示的是一个组件的实现。多个组件是路由的呢？在小程序中是靠全局配置文件app.json实现的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="string">"pages"</span>: [  </span><br><span class="line">    <span class="string">"pages/explore/explore"</span>,  </span><br><span class="line">    <span class="string">"pages/search/search"</span>,  </span><br><span class="line">    <span class="string">"pages/users/users"</span>,  </span><br><span class="line">    <span class="string">"pages/users/user"</span>,  </span><br><span class="line">    <span class="string">"pages/hot/weekly"</span>,  </span><br><span class="line">    <span class="string">"pages/topic/hot_topics"</span>,  </span><br><span class="line">    <span class="string">"pages/live/live"</span>,  </span><br><span class="line">    <span class="string">"pages/topic/topic"</span>,  </span><br><span class="line">    <span class="string">"pages/hot/monthly"</span>  </span><br><span class="line">  ],  </span><br><span class="line">  <span class="string">"window"</span>: &#123;  </span><br><span class="line">    <span class="string">"backgroundTextStyle"</span>: <span class="string">"dark"</span>,  </span><br><span class="line">    <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">"#4abdcc"</span>,  </span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"知乎Live"</span>,  </span><br><span class="line">    <span class="string">"navigationBarTextStyle"</span>: <span class="string">"white"</span>,  </span><br><span class="line">    <span class="string">"enablePullDownRefresh"</span>: true  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="string">"tabBar"</span>: &#123;  </span><br><span class="line">    <span class="string">"color"</span>: <span class="string">"#b0b0b0"</span>,  </span><br><span class="line">    <span class="string">"selectedColor"</span>: <span class="string">"#4abdcc"</span>,  </span><br><span class="line">    <span class="string">"borderStyle"</span>: <span class="string">"white"</span>,  </span><br><span class="line">    <span class="string">"backgroundColor"</span>: <span class="string">"#fff"</span>,  </span><br><span class="line">    <span class="string">"list"</span>: [  </span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="string">"pagePath"</span>: <span class="string">"pages/explore/explore"</span>,  </span><br><span class="line">        <span class="string">"iconPath"</span>: <span class="string">"images/explore_normal.png"</span>,  </span><br><span class="line">        <span class="string">"selectedIconPath"</span>: <span class="string">"images/explore_pressed.png"</span>,  </span><br><span class="line">        <span class="string">"text"</span>: <span class="string">"发现"</span>  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="string">"pagePath"</span>: <span class="string">"pages/hot/weekly"</span>,  </span><br><span class="line">        <span class="string">"iconPath"</span>: <span class="string">"images/hot_normal.png"</span>,  </span><br><span class="line">        <span class="string">"selectedIconPath"</span>: <span class="string">"images/hot_pressed.png"</span>,  </span><br><span class="line">        <span class="string">"text"</span>: <span class="string">"热门"</span>  </span><br><span class="line">      &#125;,  </span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="string">"pagePath"</span>: <span class="string">"pages/search/search"</span>,  </span><br><span class="line">        <span class="string">"iconPath"</span>: <span class="string">"images/search-off.png"</span>,  </span><br><span class="line">        <span class="string">"selectedIconPath"</span>: <span class="string">"images/search-on.png"</span>,  </span><br><span class="line">        <span class="string">"text"</span>: <span class="string">"搜索"</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">    ]  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="string">"debug"</span>: true  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中：</p>
<ul>
<li>pages。设置页面路径，指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。</li>
<li>tabBar。设置底部tab的表现。</li>
<li>window。设置页面路径。如状态栏、导航条、标题、窗口背景色等。<h3 id="小程序的一些经验"><a href="#小程序的一些经验" class="headerlink" title="小程序的一些经验"></a>小程序的一些经验</h3>上面就是我对小程序的玩法的理解了。说几个我开发中遇到的坑儿吧：<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4>发现页的Live上有2种事件：点击头像会去用户详情页，其他位置会去Live详情页。事件绑定在组件上，触发事件就会执行逻辑层中对应的事件处理函数。想象一下，如果点击用户头像会发生什么：</li>
</ul>
<ol>
<li>进入用户详情页</li>
<li>然后再进入Live详情页<br>由于小程序的事件封装，我们不能使用e.stopPropagation()这样的方式阻止事件冒泡，所以在用户这个view上不能绑定bindtap，而是要用catchtap。在前面展示live.wxml的时候，你可以没注意到这点，我简化下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% raw %&#125;  </span><br><span class="line">&lt;view class="m-live" bindtap="onViewTap" data-id="&#123;&#123; live.id &#125;&#125;" data-type="live"&gt;  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">&lt;view class="info"&gt;  </span><br><span class="line">  ..  </span><br><span class="line">  &lt;view class="rating"&gt;  </span><br><span class="line">    ..  </span><br><span class="line">    &lt;view catchtap="onViewTap" data-id="&#123;&#123; live.speaker.id &#125;&#125;" data-type="user" class="user"&gt;  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>


<p>绑定到同一个事件函数上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">onViewTap(e) &#123;  </span><br><span class="line">  const ds = e.currentTarget.dataset;  </span><br><span class="line">  const t = ds['type'] === 'live' ? 'live/live' : 'users/user'  </span><br><span class="line">  wx.navigateTo(&#123;  </span><br><span class="line">    url: `../$&#123;t&#125;?id=$&#123;ds.id&#125;`,  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<h4 id="抽象Page"><a href="#抽象Page" class="headerlink" title="抽象Page"></a>抽象Page</h4><p>我没有使用额外的辅助工具开发，不能使用继承的方式用Page：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export default class Index extends Page &#123;  </span><br><span class="line">  </span><br><span class="line">  data = &#123;  </span><br><span class="line">    userInfo: &#123;&#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">  bindViewTap () &#123;  </span><br><span class="line">    console.log(<span class="string">'Button Clicked'</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  onLoad() &#123;  </span><br><span class="line">    console.log(<span class="string">'OnLoad'</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这很不爽。你想啊，一些页面的LoadMore、Onload其实差不多。尤其是7天热门和30天热门这2个页面，不一样的只是调用了api.getHotByWeekly和api.getHotByMonthly，重复代码是不是有点不能忍？仔细看一下Page其实是接受了一个字典，每个其中的data和其他生命周期函数以及自定义方法都是键值对的方式传进去。那么这有点简单了，我写个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export function gen_page(type) &#123;  </span><br><span class="line">  <span class="keyword">return</span> &#123;  </span><br><span class="line">    data: &#123;  </span><br><span class="line">      lives: [],  </span><br><span class="line">      ...  </span><br><span class="line">    &#125;,  </span><br><span class="line">    onLoad() &#123;  </span><br><span class="line">      ...  </span><br><span class="line">      api[`getHotBy$&#123;type&#125;ly`](&#123;  </span><br><span class="line">        success: (res) =&gt; &#123;  </span><br><span class="line">        ...  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;);  </span><br><span class="line">    &#125;,  </span><br><span class="line">    onChangeTab(e) &#123;  </span><br><span class="line">      const ds = e.currentTarget.dataset;  </span><br><span class="line">      <span class="keyword">if</span> (type == <span class="string">'Month'</span> &amp;&amp; ds.type == <span class="string">'Week'</span>) &#123;  </span><br><span class="line">        wx.navigateBack(<span class="string">'../hot/weekly'</span>);  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        wx.navigateTo(&#123;  </span><br><span class="line">          url: `../hot/$&#123;ds.type.toLowerCase()&#125;ly`,  </span><br><span class="line">        &#125;);  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;,  </span><br><span class="line">  &#125;,  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>需要注意一点，onChangeTab中对于Tab切换的时间的处理用到wx.navigateBack，我觉得这也是小程序实现的一个不好的地方，我需要特殊处理「这种打开了页面A（navigateTo），然后打开页面B（navigateTo），再用navigateTo就不能回到A了」的问题，得用navigateBack。<br>这样，调用的时候就简单了，比如7天的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const lib = require(<span class="string">'./lib.js'</span>);  </span><br><span class="line">  </span><br><span class="line">Page(lib.gen_page(<span class="string">'Week'</span>));</span><br></pre></td></tr></table></figure>


<p>这是「知乎Live全文搜索的小程序」专题的最后一篇啦，感谢大家坚持阅读..</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>wechat-admin:Celery使用篇</title>
    <url>/2016-02-05.html</url>
    <content><![CDATA[<p>Celery是一个专注于实时处理和任务调度分布式任务队列。通过RabbitMQ、Redis、MongoDB等消息代理，把任务发给执行任务的Worker以达到异步执行。<br>我写的那本《Python<br>Web开发实战》的样章就是<a href="https://zhuanlan.zhihu.com/p/22304455" target="_blank" rel="noopener">《使用Celery》</a>，建议看下面内容之前先读一下这篇文章。<br>接下来的内容假设你已经对Celery有了一定的了解。对<a href="https://github.com/dongweiming/wechat-admin" target="_blank" rel="noopener">wechat-<br>admin</a>项目来说，使用Celery要做如下事情：</p>
<ol>
<li>更新项目数据库中的联系人、群聊和公众号等相关内容</li>
<li>监听wxpy进程，处理自动加群、接受消息、踢人以及各种插件功能等</li>
<li>自动重启上述的监听进程</li>
<li>发送新消息数量提醒<br>首先我们创建一个目录（wechat），专门用来存放celery任务相关的内容，目录下文件列表如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ tree wechat  </span><br><span class="line">wechat  </span><br><span class="line">├── __init__.py  </span><br><span class="line">├── celery.py  <span class="comment"># 名为celery.py是主程序，启动的时候可以直接`celery -A wechat worker -l info -B`  </span></span><br><span class="line">├── celeryconfig.py  <span class="comment"># 配置文件  </span></span><br><span class="line">└── tasks.py  <span class="comment"># 存放任务逻辑  </span></span><br><span class="line">  </span><br><span class="line"><span class="number">0</span> directories, <span class="number">4</span> files</span><br></pre></td></tr></table></figure>


<p>我们挨个看看</p>
<h3 id="celeryconfig-py"><a href="#celeryconfig-py" class="headerlink" title="celeryconfig.py"></a>celeryconfig.py</h3><p>看文件名字就知道了，这个是放配置的文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat celeryconfig.py  </span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> REDIS_URL  </span><br><span class="line">BROKER_URL = REDIS_URL  </span><br><span class="line">CELERY_RESULT_BACKEND = REDIS_URL  </span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'msgpack'</span>  </span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span>  </span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>  </span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'json'</span>, <span class="string">'msgpack'</span>]</span><br></pre></td></tr></table></figure>


<p>指定消息代理和执行结果都使用Redis，任务（消息）使用msgpack序列化，结果使用json序列化，任务结果保存时间24小时等</p>
<h3 id="celery-py"><a href="#celery-py" class="headerlink" title="celery.py"></a>celery.py</h3><p>主程序有点Flask的app.py的感觉：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat celery.py  </span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery  </span><br><span class="line"><span class="keyword">from</span> celery.signals <span class="keyword">import</span> worker_ready  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> models.redis <span class="keyword">import</span> db, LISTENER_TASK_KEY  </span><br><span class="line">  </span><br><span class="line">app = Celery(<span class="string">'wechat'</span>, include=[<span class="string">'wechat.tasks'</span>])  </span><br><span class="line">app.config_from_object(<span class="string">'wechat.celeryconfig'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@worker_ready.connect  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">at_start</span><span class="params">(sender, **k)</span>:</span>  </span><br><span class="line">    <span class="keyword">with</span> sender.app.connection() <span class="keyword">as</span> conn:  <span class="comment"># noqa  </span></span><br><span class="line">        task_id = sender.app.send_task(<span class="string">'wechat.tasks.listener'</span>)  </span><br><span class="line">        db.set(LISTENER_TASK_KEY, task_id)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    app.start()</span><br></pre></td></tr></table></figure>


<p>这段代码有2点需要解释一下：</p>
<ol>
<li>调用send_task会返回任务id，存在LISTENER_TASK_KEY里面用于未来重启时直接通过这个任务id</li>
<li>使用了Celery的信号系统，listener这个异步任务需要在worker启动之后就运行，使用worker_ready这个信号就可以。<h3 id="tasks-py"><a href="#tasks-py" class="headerlink" title="tasks.py"></a>tasks.py</h3>tasks.py这个文件包含了很多业务逻辑，为了演示我省略部分代码。不过代码还是很长，所以我直接在对应行数的代码上加注释来解释了：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat tasks.py  </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta  </span><br><span class="line"><span class="keyword">from</span> celery.task <span class="keyword">import</span> periodic_task  </span><br><span class="line"><span class="keyword">from</span> celery.task.control <span class="keyword">import</span> revoke  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> wechat.celery <span class="keyword">import</span> app  </span><br><span class="line"><span class="keyword">from</span> wxpy.exceptions <span class="keyword">import</span> ResponseError  </span><br><span class="line"><span class="keyword">from</span> itchat.signals <span class="keyword">import</span> logged_out  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restart_listener</span><span class="params">(sender, **kw)</span>:</span>  </span><br><span class="line">    <span class="comment"># 重启tasks.listener这个任务  </span></span><br><span class="line">    task_id = r.get(LISTENER_TASK_KEY)  </span><br><span class="line">    <span class="keyword">if</span> task_id:  </span><br><span class="line">        revoke(str(task_id, <span class="string">'utf-8'</span>))  </span><br><span class="line">    task_id = app.send_task(<span class="string">'wechat.tasks.listener'</span>)  </span><br><span class="line">    r.set(LISTENER_TASK_KEY, task_id)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">logged_out.connect(restart_listener)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> wxpy.signals <span class="keyword">import</span> stopped  </span><br><span class="line"><span class="keyword">from</span> libs.wx <span class="keyword">import</span> get_bot  </span><br><span class="line"><span class="keyword">from</span> views.api <span class="keyword">import</span> json_api  </span><br><span class="line"><span class="keyword">from</span> models.redis <span class="keyword">import</span> db <span class="keyword">as</span> r, LISTENER_TASK_KEY  </span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> app <span class="keyword">as</span> sse_api  </span><br><span class="line">  </span><br><span class="line">stopped.connect(restart_listener)  </span><br><span class="line">bot = get_bot()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_retrieve_data</span><span class="params">(update=False)</span>:</span>  </span><br><span class="line">    _update_contact(bot, update)  </span><br><span class="line">    _update_group(bot, update)  </span><br><span class="line">    _update_mp(bot, update)  </span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.task  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listener</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="comment"># 不用全局的bot，因为在import listener的过程中会  </span></span><br><span class="line">    <span class="comment"># 注册各种函数（处理自动加群、接受消息、踢人以及各种插件功能）  </span></span><br><span class="line">    <span class="keyword">from</span> libs.listener <span class="keyword">import</span> bot  </span><br><span class="line">    <span class="keyword">with</span> json_api.app_context():  </span><br><span class="line">        bot.join()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.task  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieve_data</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="comment"># 使用Flask应用中的方法都需要放在对应的上下文内  </span></span><br><span class="line">    <span class="keyword">with</span> json_api.app_context():  </span><br><span class="line">        _retrieve_data(<span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.task  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_contact</span><span class="params">(update=False)</span>:</span>  </span><br><span class="line">    <span class="comment"># 都是业务逻辑，就省略了，这样分开写是可以单独的更新一种类型的数据  </span></span><br><span class="line">    ...  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.task  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_group</span><span class="params">(update=False)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.task  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_mp</span><span class="params">(update=False)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># periodic_task就是定时任务，表示周期性的执行某任务  </span></span><br><span class="line"><span class="meta">@periodic_task(run_every=timedelta(seconds=60), time_limit=5)  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_notify</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="comment"># 发送新消息数量提醒  </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>上一篇我说SSE的时候忘说了一点，就是更新消息提醒。在Web页面标记已读的时候，会POST到/readall接口，后端清空新通知数量。这是由于SSE的单向特点造成的，如果使用socketio(WebSocket)的话可以直接emit到后端，就不用HTTP这种方案了</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Flask+Vue+Celery+ItChat+Wxpy实现强大的微信管理系统</title>
    <url>/2016-02-06.html</url>
    <content><![CDATA[<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之使用Elasticsearch全文搜索</title>
    <url>/2016-02-07.html</url>
    <content><![CDATA[<h3 id="为什么需要全文搜索"><a href="#为什么需要全文搜索" class="headerlink" title="为什么需要全文搜索"></a>为什么需要全文搜索</h3><p>一般的网站都会包含搜索功能，它能帮助用户发现没有找到想要的东西，甚至能帮助用户挖掘到兴趣，这对提升用户对网站的黏性和用户体验有非常大的帮助。举个豆瓣的例子，用户可以在主站的搜索里面找到电影、书籍、音乐、用户、小站、小组、游戏等相关内容。<br>传统的数据库系统设计成可进行「增删改查」等操作，我们都知道，需要存储到数据库的内容都是经过深思熟虑的，如果用户规模和数据很大，多增加一个字段就意味着要增加很多额外的空间、多个索引，并影响到执行效率，这意味着我们无法把全部数据都存进数据库。举个例子，写一篇日记，可以把作者、发表时间、标题等字段存入数据库，但是日记正文无法也放进去，太占空间了。<br>现在的一个最佳实践是把访问比较集中的、频繁的数据直接放到内存和键值数据库中。但是再进行搜索，就要对不同的存储内容整理，并根据一定的算法把符合的内容排序后返回。而且这些数据非常有可能是由不同的开发团队来维护和开发的，首先这些产品间的网络通信就是一笔不小的开销，还要从不同的产品获取到结果之后再排序。这显然不合理。<br>全文搜索软件如Elasticsearch则有如下特点：</p>
<ol>
<li>查询速度。全文搜索的数据存取方式只考虑快速读取，相比数据库的查询，要快的多得多。</li>
<li>支持复杂的查询表达式。数据库系统的查询通常只支持AND/OR等有限的模式，全文检索支持多得多的查询方式。</li>
<li>灵活排序。数据库系统一般按照内置的排序规则来排序，有什么字段并且有对应的索引才可能按什么字段排序。而全文搜索除了能够支持数据库的排序规则外，还支持按照结果的相关度排序，比如Elasticsearch内置了文本相关性、衰减、分词等高级特性，对搜索的效果有非常大的帮助。虽然Elasticsearch自带的中文分词不好，但是提供良好的插件机制，我们可以安装第三方中文分词插件，可以达到非常好的中文搜索效果。<br>ElasticSearch（简称ES）是一个提供Restful API的、实时的分布式搜索和分析引擎，稳定，可靠，快速，功能强大。<br>我最早关注到ElasticSearch是因为Github抛弃了Solr，采取ElasticSearch来做PB级的搜索。而现在ES已经是变得非常流行了。除此之外，基于ELK(ElasticSearch,<br>Logstash, Kibana)的实时日志分析平台应用也非常广泛。<br>在上篇文章中我们已经抓取了需要的Live数据。我们先感受一条:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> models <span class="keyword">import</span> Live  </span><br><span class="line">In : live = Live.get(<span class="number">789840559912009728</span>)  </span><br><span class="line">In : live  </span><br><span class="line">Out: Live(index=<span class="string">'live'</span>, doc_type=<span class="string">'live'</span>, id=<span class="string">'789840559912009728'</span>)  </span><br><span class="line">In : <span class="keyword">for</span> k, v <span class="keyword">in</span> vars(live)[<span class="string">'_d_'</span>].items():  </span><br><span class="line">...:     print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(k, <span class="string">'&#123;&#125;&#123;&#125;'</span>.format(v[:<span class="number">30</span>], <span class="string">'...'</span>) <span class="keyword">if</span> isinstance(v, str) <span class="keyword">and</span> len(v) &gt; <span class="number">30</span>  </span><br><span class="line">...: <span class="keyword">else</span> v))  </span><br><span class="line">...:  </span><br><span class="line">subject: Python 工程师的入门和进阶  </span><br><span class="line">feedback_score: <span class="number">4.5</span>  </span><br><span class="line">status: <span class="literal">False</span>  </span><br><span class="line">description: 我是董伟明，豆瓣高级产品开发工程师。从 <span class="number">2011</span> 年开始接触...  </span><br><span class="line">speaker_message_count: <span class="number">208</span>  </span><br><span class="line">liked_num: <span class="number">1134</span>  </span><br><span class="line">outline:  </span><br><span class="line">starts_at: <span class="number">2016</span><span class="number">-12</span><span class="number">-27</span> <span class="number">21</span>:<span class="number">00</span>:<span class="number">00</span>  </span><br><span class="line">speaker_id: <span class="number">314</span>  </span><br><span class="line">topic_names: Python  </span><br><span class="line">seats_taken: <span class="number">3562</span>  </span><br><span class="line">amount: <span class="number">9.99</span>  </span><br><span class="line">tag_names: 互联网</span><br></pre></td></tr></table></figure>


<p>其实对于我这个需求，算是把ES当做NoSQL数据库来用了。<br>假如用户要搜索Python相关的Live，也就是需要从ES中各个需要覆盖到的字段中找Python这个词，最后把符合的文档按照相关度等因素排好序返回给我们。</p>
<h3 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h3><p>默认的ES会根据文档的相关度进行排序的，多字段查询的写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : SEARCH_FIELDS = [<span class="string">'subject'</span>, <span class="string">'description'</span>, <span class="string">'outline'</span>, <span class="string">'tag_names'</span>,  </span><br><span class="line">                     <span class="string">'topic_names'</span>]  </span><br><span class="line">In : lives = s.query(<span class="string">'multi_match'</span>, query=<span class="string">'python'</span>, fields=SEARCH_FIELDS).execute()  </span><br><span class="line">In : lives[<span class="number">0</span>]._score  </span><br><span class="line">Out: <span class="number">9.952918</span>  </span><br><span class="line">In : lives[<span class="number">1</span>]._score  </span><br><span class="line">Out: <span class="number">9.250518</span></span><br></pre></td></tr></table></figure>


<p>排在前面的结果获得的分数要更高，也就是被ES认为更相关。<br>但对于很多场景这是有问题的，比如上面这个文档，不同字段应该要不同的权重。举个例子，2个文档包含Python关键词的数量一致，但是第一个topic_names是Python，另外一个topic_names是Ruby，显然第一个文档要排在之前。因为知乎话题（Topic）是比较可信的一种划分，而相对的description里面\的文本就算有Python也不一定说明这个一个Python相关的Live,<br>有可能只是作者提自己曾经学习过Python而已。所以不同字段我们需要设计不同的权重，我不是算法工程师，只是按自己的理解来调整下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> elasticsearch_dsl.query <span class="keyword">import</span> Q  </span><br><span class="line">In : a = Q(<span class="string">'multi_match'</span>, query=<span class="string">'python'</span>, fields=[<span class="string">'subject^5'</span>, <span class="string">'outline^2'</span>, <span class="string">'description'</span>, <span class="string">'topic_nam  </span></span><br><span class="line"><span class="string">...: es^10'</span>, <span class="string">'tag_names^5'</span>])  </span><br><span class="line">In : lives = s.query(a).execute()  </span><br><span class="line">  </span><br><span class="line">In : lives[<span class="number">0</span>]._score  </span><br><span class="line">Out: <span class="number">73.56763</span></span><br></pre></td></tr></table></figure>


<p>可以看到，这次评分获得了很大的提升，是因为我给subject的权重 <em>5，outline</em> 2……<br>注意，topic_name的权重成了之前的10倍，这样很容易岔开不同Live的得分。<br>还有一点，我使用了Q，这和上面的区别不大，只是随着本文越来越深入，用Q来包装接口会让代码更好理解。</p>
<h3 id="得分衰减"><a href="#得分衰减" class="headerlink" title="得分衰减"></a>得分衰减</h3><p>有了权重还是不够，因为我们还要考虑给新的Live机会。如果一个大V在很久之前举办了一场Live，文本相关度很高、收入很多、评价也很好。那么是不是这个Live就应该一直排在前面甚至第一呢？这对用户的积极性有很多的伤害，因为后来的人很难有机会有足够的曝光。所以当一段「保护期」之后，这个Live的得分会随着时间不断的减低。<br>ES内置了衰减函数（Decay<br>Function）的支持。对于数值、日期和地理位置类型，可以设置一个理想的值，如果实际的值越偏离这个理想值（无论是增大还是减小），就越不符合期望，分数就越低。<br>它支持如下参数：</p>
<ul>
<li>origin：原点，该字段最理想的值，这个值可以得到满分（1.0）</li>
<li>offset：偏移量，与原点相差在偏移量之内的值也可以得到满分</li>
<li>scale：衰减规模，当值超出了原点到偏移量这段范围，它所得的分数就开始进行衰减了，衰减规模决定了这个分数衰减速度的快慢</li>
<li>decay：衰减值，该字段可以被接受的值（默认为0.5），相当于一个分界点，具体的效果与衰减的模式有关<br>衰减函数可以指定三种不同的模式：线性函数（linear）、以e为底的指数函数（Exp）和高斯函数（gauss），它们拥有不同的衰减曲线，我盗用官方的图：<br><img src="https://cloud.githubusercontent.com/assets/841395/22174792/80bdbcac-e021-11e6-85cb-2df1b34284c0.png" alt><br>可以感受到：</li>
</ul>
<ol>
<li>linear直线衰减，在0分外的值都是0分</li>
<li>exp衰减速度先快后慢</li>
<li>gauss衰减速度先慢后快再慢<br>对于Live搜索和排序的需求，我选择了gauss，希望对live开始的前后7天以外的时间点都让这个live的得分变低。<br>我们通过一个例子，来感受下时间衰减对得分的影响。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> elasticsearch_dsl.query <span class="keyword">import</span> Q, SF  </span><br><span class="line">In : lives = s.query(<span class="string">'multi_match'</span>, query=<span class="string">'python'</span>, fields=SEARCH_FIELDS).execute()  </span><br><span class="line">In : live = lives[<span class="number">0</span>]  </span><br><span class="line">In : live._score, live.subject, live.starts_at  </span><br><span class="line">Out: (<span class="number">9.952918</span>, <span class="string">'Python 工程师的入门和进阶'</span>, datetime.datetime(<span class="number">2016</span>, <span class="number">12</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">0</span>))  </span><br><span class="line">In : sf = SF(<span class="string">'gauss'</span>, starts_at=&#123;<span class="string">'origin'</span>: <span class="string">'now'</span>, <span class="string">'offset'</span>: <span class="string">'60d'</span>, <span class="string">'scale'</span>: <span class="string">'10d'</span>&#125;)  </span><br><span class="line">In : sf2 = SF(<span class="string">'gauss'</span>, starts_at=&#123;<span class="string">'origin'</span>: <span class="string">'now'</span>, <span class="string">'offset'</span>: <span class="string">'7d'</span>, <span class="string">'scale'</span>: <span class="string">'10d'</span>&#125;)</span><br></pre></td></tr></table></figure>


<p>我的Live在sf的60天偏移量范围内，但是不在sf2的7天范围内。现在感受下随着时间衰减对得分的影响：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : lives = s.query(Q(<span class="string">'function_score'</span>, boost_mode=<span class="string">'multiply'</span>, functions=[sf])).execute()  </span><br><span class="line">In : lives[<span class="number">0</span>]._score, lives[<span class="number">0</span>].subject  </span><br><span class="line">Out: (<span class="number">10.952918</span>, <span class="string">'Python 工程师的入门和进阶'</span>)  </span><br><span class="line">  </span><br><span class="line">In : lives = s.query(Q(<span class="string">'function_score'</span>, boost_mode=<span class="string">'multiply'</span>, functions=[sf2])).execute()  </span><br><span class="line">In : lives[<span class="number">0</span>]._score, lives[<span class="number">0</span>].subject  </span><br><span class="line">Out: (<span class="number">10.065867</span>, <span class="string">'Python 工程师的入门和进阶'</span>)</span><br></pre></td></tr></table></figure>


<p>用boost_mode可以指定计算后的分数与原始的_score如何合并，有以下选项：</p>
<ul>
<li>multiply：将结果乘以_score</li>
<li>sum：将结果加上_score</li>
<li>min：取结果与_score的较小值</li>
<li>max：取结果与_score的较大值</li>
<li>replace：使结果替换掉_score<br>看看使用sum的效果：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : lives = s.query(Q(<span class="string">'function_score'</span>, boost_mode=<span class="string">'sum'</span>, functions=[sf])).execute()  </span><br><span class="line">In : lives[<span class="number">0</span>]._score, lives[<span class="number">0</span>].subject  </span><br><span class="line">Out: (<span class="number">11.952918</span>, <span class="string">'Python 工程师的入门和进阶'</span>)  </span><br><span class="line">  </span><br><span class="line">In : lives = s.query(Q(<span class="string">'function_score'</span>, boost_mode=<span class="string">'sum'</span>, functions=[sf2])).execute()  </span><br><span class="line">In : lives[<span class="number">0</span>]._score, lives[<span class="number">0</span>].subject  </span><br><span class="line">Out: (<span class="number">11.065802</span>, <span class="string">'Python 工程师的入门和进阶'</span>)</span><br></pre></td></tr></table></figure>


<p>由于我们对不同的字段做了比较大的权重的加成，使用相乘更有意义。</p>
<h3 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h3><p>相信知乎Live在排序的时候也考虑了Live的收入（也就是单价*购买人数）这个因素，所谓「市场经济下价格基本准确反映供需关系」，一个Live是不是受到大家的欢迎从收入以及单价上市可以体现出来的。但是就算我们对文本相关性做了权重的提高，得分也不外乎几十到几百。如果直接和收入相乘，显然是有问题的：小众优秀的主题由于受众小，票价上不去，得分会很低。同理一个低质量的Live由于大家一股脑被吸引进来由于收入较高而排在前面。顺便说，知乎Live的年度精选就有多个3星、三星半的Live的存在，有种想不开的感觉。对我这种长期受豆瓣评分体系价值观的影响，无法理解这种评分怎么入选的…<br>我看Live少的一场才收入2-3k, 而有的一场10几w。怎么对这个指标做标准化处理，让指标之间更具有可比性呢？<br>这就是数据归一化，也就是把原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。<br>归一化的方法很多，我这里为了简单实用，选择了「对数函数转换」。通过Jupyter Notebook+Matplotlib+Numpy看一下转换的效果：<br><img src="https://cloud.githubusercontent.com/assets/841395/22175313/704b7f24-e02d-11e6-9235-42d934bdda62.png" alt><br>这样2k被转化为3.3，10w会被转化成5。收入会有影响，但是被极大的缩小了。<br>再验证下，被归一化之前：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s = s.query(<span class="string">'multi_match'</span>, query=<span class="string">'python'</span>, fields=SEARCH_FIELDS)  </span><br><span class="line">In : lives = s.query(Q(<span class="string">'function_score'</span>, boost_mode=<span class="string">'multiply'</span>, functions=[SF(<span class="string">'script_score'</span>, script=  </span><br><span class="line">...: <span class="string">"doc['seats_taken'].value * doc['amount'].value"</span>)])).execute()  </span><br><span class="line">  </span><br><span class="line">In : lives[<span class="number">0</span>]._score  </span><br><span class="line">Out: <span class="number">75663.34</span></span><br></pre></td></tr></table></figure>


<p>这个得分，我想静静..<br>ES内置了脚本语言painless和groovy，我们能直接在ES内部进行一些简单的编程。当然也支持Python但是需要额外安装了。我觉得完全用不到Python，尤其是5.0开始painless成为了默认编程语言。原因是painless有如下特点：</p>
<ol>
<li>支持List、map和array等高级数据结构</li>
<li>性能接近Java</li>
<li>内置正则表达式</li>
<li>支持匿名函数lambda</li>
<li>语法简单，学过Java、Python、Javascript的开发者很容易就可以学会<br>随便提一下，编程脚本的时候尽量不要出现一些受外界影响大的变量，比如用户id这种，因为ES可以缓存脚本，如果使用一些每次查询都不一样的条件去生成脚本会影响性能。<br>现在我们把log10引入再看看：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : sf = SF(<span class="string">'script_score'</span>, script=&#123;<span class="string">'lang'</span>: <span class="string">'painless'</span>, <span class="string">'inline'</span>: <span class="string">"Math.log10(doc['seats_taken'].value* doc['amount'].value)"</span>&#125;)  </span><br><span class="line">In : lives = s.query(Q(<span class="string">'function_score'</span>, functions=[sf])).execute()  </span><br><span class="line">In : lives[<span class="number">0</span>]._score  </span><br><span class="line">Out: <span class="number">14.504177</span></span><br></pre></td></tr></table></figure>


<p>这样会合理很多。<br>今天先讲到这里。下一篇将介绍聚合分析</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python北京开发者活动第一期PPT出炉啦</title>
    <url>/2016-02-08.html</url>
    <content><![CDATA[<p>Python<br>北京开发者活动第一期结束了，虽然我没有参加，不过仍然第一时间拿到了主题的幻灯片分享给大家。和高大上的Pycon相比，这种技术技术活动更是Python工程师需要也是想要了解到的内容，本文我站着说话不腰疼地也对这些主题闲扯几句吧。<br>三个主题的Slide地址是： <a href="https://github.com/Python-Meetup-Peking/PMP_slide" target="_blank" rel="noopener">https://github.com/Python-Meetup-Peking/PMP_slide</a><br>，你也可以通过文末的「阅读原文」到达。我下面的内容会提到主讲人幻灯片中的一点内容，建议大家先完整看过PPT再来看本文效果会更好。</p>
<h3 id="asyncio-和它的朋友们"><a href="#asyncio-和它的朋友们" class="headerlink" title="asyncio 和它的朋友们"></a>asyncio 和它的朋友们</h3><p>asyncio是Python 3官方的解决方案，也是Guido van Rossum（Python创建者，简称GvR）主推的，我在之前的博文<br><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%96%9C%E6%AC%A2Gevent/" target="_blank" rel="noopener">我为什么不喜欢Gevent</a><br>提到过我是比较认同asyncio，不认可gevent的，我也说过asyncio的生态还远远没有建立，现在基本都只能算是玩一玩。asyncio是非常有革命性意义的，直到它大家当做基本常识一样的被认可需要一个过程，这个过程看起来还比较长，我认为的原因有下面这么几点：</p>
<ol>
<li>迁移成本太高。首先是Python 2到Python 3的迁移，并不是安装一个库就完事了，而且现在大部分公司在Python 2下的产品和服务运行良好，迁移得有值得的收益，所以现阶段不能说服boss干这件事，也让大家没了动力。</li>
<li>使用后的效果不突出。前年使用asyncio发现确实比之前的方案都要快，可以翻之前的内容，不过这个快并不是一个质的飞跃，而只是一个效率的提升，当效率没有成倍的提高的时候，你很难综合的决定为了那百分之XX的提升来做这么大的改变，毕竟现有的效率也没有出现瓶颈。</li>
<li>asyncio改变了编程习惯。asyncio的作者们已经很努力的让开发者感受不到这种变化，但是asyncio用起来需要一整套的开发习惯的支持，简单地说：并不是你用了aiohttp你的web请求就都是异步非阻塞的了。请求到回应过程中某个地方没有注意阻塞了直接让效果大打折扣，但是如果你对业务以及Python和相关的库不熟很多时候这种问题是很难发现和杜绝的。</li>
<li>没有大公司出来背书，也鲜有重要项目宣称支持asyncio版本的驱动并及时维护。举个例子，aioredis接口和py-redis参数不一致，一些常用的开源项目的更新迭代需要对应驱动也跟上，要不然开发者就会很尴尬。主题中主讲人提到了 <a href="https://github.com/aio-libs" target="_blank" rel="noopener">https://github.com/aio-libs</a> 这个组织，组织下面有些aio的驱动，不过这是一个民间组织，大部分开发者都是俄罗斯人，其实没有Python核心开发者参与的，自娱自乐成份要更多一些，质量上我是不放心的。如果哪天豆瓣上了asyncio，我们肯定会选择自己维护一份相关的驱动，而不用社区性质的。其实在Github看到的大部分asyncio项目都不是官方的。大部分Python核心开发者在自己的公司也没有推这件事，只有少量的核心开发做了asyncio支持，比如MongoDB就有官方的motor。<br>说了这么多消极的，那么我们能给asyncio这个生态做点什么？</li>
<li>多多用asyncio做项目，多写一些asyncio相关的文章，让更多人了解它接受它。</li>
<li>能力范围内造造常用工具的驱动，或者参与进来给现有项目提交PR，你们可能不知道Flask刚流行那会插件系统的繁荣场景，其实做这个事情并没有那么难，整的理解asyncio之后，驱动就是一些套路罢了。<h3 id="Python-性能调优"><a href="#Python-性能调优" class="headerlink" title="Python 性能调优"></a>Python 性能调优</h3>性能调优是开发者一直很关注的话题，在我的《Python<br>Web开发实战》中也介绍了很多的我常用的工具和使用方法，这个主题的内容基本覆盖了，唯一在书中没有提到的是pyflame，不过之前在转载Glow的一篇《<a href="https://zhuanlan.zhihu.com/p/28078824" target="_blank" rel="noopener">Python<br>web 应用性能调优</a>》时也提到了。<br>现在大家也能知道大家平时用的工具都差不多，倒没有秘籍。我其实更想说的是性能调优要求工程师平时要很关注到服务器资源的指标，及时发现问题，并且愿意花时间去分析和定位问题。<h3 id="Python-在一家创业公司中的应用"><a href="#Python-在一家创业公司中的应用" class="headerlink" title="Python 在一家创业公司中的应用"></a>Python 在一家创业公司中的应用</h3>清风老师早早的使用上了Python3，羡慕。当然这也是由于没有历史包袱的原因。在老师介绍「Python3带来了哪些好处」的时候提到：<br>1.带来了类型检查<br>2.不再被字符串编码问题折磨<br>第二点是很多人的痛就不提了，我来讲下对类型检查的看法。无独有偶，今年Pycon上海唯一能看的洪教授所在的爱因互动的主题演讲「Building Chatbot<br>Service」中也提到了Type<br>Hint（当然也提到了asyncio）。我之前提到过我不喜欢TypeScript（当然原因复杂得多），所以答案是我对类型检查持保留意见（甚至反对）。当然这部分在一开始也在Python社区产生过分歧，我不喜欢的原因有几点：</li>
<li>我觉得Python就应该走简洁的路线，加上类型检查（哪怕是非强制的）让代码看起来臃肿不舒服，如果哪天Python强制要这么干，我就不再❤️它了。</li>
<li>类型错误造成的错误主要是由于工程师不了解业务需要和对自己写的代码没有充分理解才会出现，当然这还有异常处理的考虑的经验问题。靠类型检查来查出来，本质上是对工程质量的不信任。<br>当然类型检查这种方式可以极大的减少了代码出错的几率，让问题更早的暴露出来，这在实际生产环境中确实是有意义的，比如核心的如支付系统，为了确保万无一失，用上类型检查我还可以认同。<br>第二个点是老师创业选择的框架是Django，理由是：</li>
<li>对于长期项目更加利于维护</li>
<li>第三方库众多</li>
<li>BUG比较少</li>
<li>instagram也在使用 - 之前我也发过一个翻译分享 Instagram 的工程师 Hui Ding 说到：『一直到用户 ID 已经超过了 32bit int 的限额（约为 20 亿），Django 本身仍然没有成为我们的瓶颈所在。』<br>这些我都是认可的，Django确实是Web开发首选。大家知道我一直是推荐Flask的，它对于初学者友好，但是并不是让大家止步于此。我不用Django最重要的是我日常工作中没什么机会用Django，而更常用Flask的首要的原因是我对它很熟悉，我可以随便自由地玩出花儿来，大家在实际开发的时候应该都知道都要基于业务场景对相关第三方库要进行一些定制，有些可能都不合适提交给上游而只能自己维护一个版本，所以对Web框架的熟悉程度是选择的重要标准。我之前记得什么地方有人说「企业开发都是用Django，Flask就是玩具」这样的论调，一看就是知识太狭隘，框架学的也不好，一个框架学好了，学其他的真的很轻松的。<br>想想为什么我没有什么机会用Django呢？</li>
<li>我个人不喜欢Django的大包大揽的不灵活，不用它但是我有能力「造」</li>
<li>没有历史遗留项目的包袱牵扯我的精力</li>
<li>我身边的工程师也不喜欢它，不会主动选择它</li>
<li>很早前阅读它的代码，它耦合度很高，和Flask写代码的方式差别是很明显的，这种方式倒不是不好，优点是代码利用率很高，缺点是刚了解它的人来说阅读和理解代码耗时耗力，Flask则反之，代码调用层级明确且关系简单。<br>清风老师说工作中也使用了Flask，在适当的场景下选择最适合的框架，这才是优秀工程师应该做的。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python元组的赋值谜题</title>
    <url>/2016-02-10.html</url>
    <content><![CDATA[<p>相信很多人对tuple和list的区别的理解是tuple是一个不可变的序列, 不能对它的元素赋值。我之前也是这么理解的，举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  </span><br><span class="line">In : a[<span class="number">3</span>] = <span class="number">4</span>  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-5</span>-d840230b1ac3&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 a[3] = 4  </span><br><span class="line">  </span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment  </span><br><span class="line">  </span><br><span class="line">In : a  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>


<p>也就是一个元组生成，它的元素就不再能改变了。<br>但是相信很多人见过下面这样的玩法（有人把它当做Python的一个笑话）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : a = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])  </span><br><span class="line">In : a[<span class="number">2</span>] += [<span class="number">5</span>, <span class="number">6</span>]  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-2</span><span class="number">-84</span>fb4a701b92&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 a[2] += [5, 6]  </span><br><span class="line">  </span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment  </span><br><span class="line">  </span><br><span class="line">In : a  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>


<p>明确的报错了，可是为了a的值还是改了呢？<br>我曾经思考过这个问题，直接上感觉是「对列表[3, 4]的赋值成功，但是后来发生的元组赋值失败造成的」，但是一直苦于没有证据。直到昨晚看《Fluent<br>Python》的时候，才从作者哪里获得了肯定的答案。今天我们用dis模块来分析+=所产生的bytecode(把python代码反汇编为字节码指令)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">import</span> dis  </span><br><span class="line">In : a = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])  </span><br><span class="line">In : dis.dis(<span class="string">'a[2] += [5, 6]'</span>)  </span><br><span class="line">  <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (a)  </span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2</span>)  </span><br><span class="line">              <span class="number">4</span> DUP_TOP_TWO  </span><br><span class="line">              <span class="number">6</span> BINARY_SUBSCR  </span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="number">5</span>)  </span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">2</span> (<span class="number">6</span>)  </span><br><span class="line">             <span class="number">12</span> BUILD_LIST           </span><br><span class="line">             <span class="number">14</span> INPLACE_ADD  </span><br><span class="line">             <span class="number">16</span> ROT_THREE  </span><br><span class="line">             <span class="number">18</span> STORE_SUBSCR  </span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">3</span> (<span class="literal">None</span>)  </span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>


<p>看起来出现了一坨指令，我挨个逐步的解释下：</p>
<ol>
<li>LOAD_NAME。把本地变量中相关的值（也就是a）放入堆栈。</li>
<li>LOAD_CONST。把字节码中用到的对应常量(也就是2)放入堆栈。</li>
<li>DUP_TOP_TWO。复制栈顶中前2个引用（也就是a和2），并保留顺序。</li>
<li>BINARY_SUBSCR。把a[2]放到栈顶。</li>
<li>LOAD_CONST。再分别把5和6放入堆栈。</li>
<li>BUILD_LIST。 根据目前堆栈包含的数量创建一个列表，并放入堆栈。</li>
<li>INPLACE_ADD。<code>a += b</code>其实就是<code>a = a + b</code>，也就是对栈顶做in-place add的操作。</li>
<li>ROT_THREE。把堆栈中的第二和第三升高，把栈顶（也就是[3, 4, 5, 6]）降到栈中的第三位。</li>
<li>STORE_SUBSCR。就是执行<code>a[2] = [3, 4, 5, 6]</code>。但是由于tuple不可变，这步失败了。<br>可以看到执行的过程，是先对列表进行了iadd操作并且成功，而之后的tuple赋值失败报错。<br>也就是：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">x = a[<span class="number">2</span>]   </span><br><span class="line">x = x.__iadd__([<span class="number">5</span>, <span class="number">6</span>])  </span><br><span class="line">a[<span class="number">2</span>] = x</span><br></pre></td></tr></table></figure>


<p>这样。验证下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : a = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])  </span><br><span class="line">In : a[<span class="number">2</span>] = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-31</span>-d5ba6baf4cf6&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 a[2] = [3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment  </span><br><span class="line">  </span><br><span class="line">In : a  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>


<p>可以看到直接赋值的没有成功。<br>在Python中，变量赋值采用对象引用的方式，传递的是一个对象的内存地址（像一个指针）。在这里a各项指向了内存中储存了不同数据的实体，对list实体的修改会成功：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : b = [<span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">In : a = (<span class="number">1</span>, <span class="number">2</span>, b)  </span><br><span class="line">In : id(b)  </span><br><span class="line">Out: <span class="number">4571378504</span>  </span><br><span class="line">  </span><br><span class="line">In : a[<span class="number">2</span>] += [<span class="number">5</span>, <span class="number">6</span>]  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-16</span><span class="number">-84</span>fb4a701b92&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 a[2] += [5, 6]  </span><br><span class="line">  </span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment  </span><br><span class="line">  </span><br><span class="line">In : id(b)  </span><br><span class="line">Out: <span class="number">4571378504</span>  </span><br><span class="line">  </span><br><span class="line">In : a  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>


<p>可以看到b在值被改变之后，还是原来的那个对象。但是对于其他项的修改就不成功：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : a[<span class="number">1</span>] += <span class="number">1</span>  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-25</span><span class="number">-9</span>fac1c91b625&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 a[1] += 1  </span><br><span class="line">  </span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment  </span><br><span class="line">  </span><br><span class="line">In : a  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>


<p>这是因为数值型（number)、字符串(string)均为不可变的对象。而字典也可以修改成功：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : a = (<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;)  </span><br><span class="line">In : a[<span class="number">2</span>][<span class="string">'b'</span>] += <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">In : a  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">'b'</span>: <span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure>


<p>竟然没有报错就成功了。我们再直接赋值看看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : a[<span class="number">2</span>] = &#123;<span class="string">'b'</span>: <span class="number">5</span>&#125;  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-36</span>-a2916525c596&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 a[2] = &#123;'b': 5&#125;  </span><br><span class="line">  </span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment  </span><br><span class="line">  </span><br><span class="line">In : a  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">'b'</span>: <span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure>


<p>所以<code>a[2][&#39;b&#39;] += 3</code>并不是对元组的赋值，而是直接操作了元组中的字典项了。感受下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : a = (<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;)  </span><br><span class="line">  </span><br><span class="line">In : dis.dis(<span class="string">"a[2]['b'] += 5"</span>)  </span><br><span class="line">          <span class="number">0</span> STORE_GLOBAL    <span class="number">12891</span> (<span class="number">12891</span>)  </span><br><span class="line">          <span class="number">3</span> FOR_ITER        <span class="number">10075</span> (to <span class="number">10081</span>)  </span><br><span class="line">          <span class="number">6</span> DELETE_GLOBAL   <span class="number">23847</span> (<span class="number">23847</span>)  </span><br><span class="line">          <span class="number">9</span> SLICE+<span class="number">2</span>  </span><br><span class="line">         <span class="number">10</span> STORE_SLICE+<span class="number">3</span>  </span><br><span class="line">         <span class="number">11</span> DELETE_SUBSCR  </span><br><span class="line">         <span class="number">12</span> SLICE+<span class="number">2</span>  </span><br><span class="line">         <span class="number">13</span> DELETE_SLICE+<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">In : c = a[<span class="number">2</span>]  </span><br><span class="line">In : c  </span><br><span class="line">Out: &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;  </span><br><span class="line">  </span><br><span class="line">In : dis.dis(<span class="string">"c['b'] += 5"</span>)  </span><br><span class="line">          <span class="number">0</span> DUP_TOPX    </span><br><span class="line">          <span class="number">3</span> DELETE_GLOBAL   <span class="number">23847</span> (<span class="number">23847</span>)  </span><br><span class="line">          <span class="number">6</span> SLICE+<span class="number">2</span>  </span><br><span class="line">          <span class="number">7</span> STORE_SLICE+<span class="number">3</span>  </span><br><span class="line">          <span class="number">8</span> DELETE_SUBSCR  </span><br><span class="line">          <span class="number">9</span> SLICE+<span class="number">2</span>  </span><br><span class="line">         <span class="number">10</span> DELETE_SLICE+<span class="number">3</span></span><br></pre></td></tr></table></figure>


<p>看到了吧，c是一个dict，对<code>c[&#39;b&#39;] += 5&quot;</code>操作的字节码指令和<code>a[2][&#39;b&#39;] += 5</code>的下面绝大部分的指令一样。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>多台服务器进程查看脚本(pexpect+yaml)</title>
    <url>/2016-02-11.html</url>
    <content><![CDATA[<p>####前言<br>最近做自己开发用相关服务的一个checklist，就写了这个脚本，用来在跳板机去检查各个服务器上面的相关服务是否正常<br>####思路<br>使用expect登录每个机器(因为安全问题，不能直接使用ssh信任),然后根据yaml文件的配置读取服务名字以及启动的进程数量<br>去检查每个服务是否正常<br>PS：难点是没有用端口转发也只有普通用户权限<br>####checklist.py</p>
<pre><code>#coding=utf-8  
import sys  
#因为我这个脚本要让很多人能运行，但是不能给他们看见我的密码算法,所以是pyc  
#我这个脚本要给很多其他普通用户去用，是用我的ssh登录操作，不能放在我的home目录，所以放在tmp  
sys.path.append(‘/tmp/local/lib/python2.6/site-packages/PyYAML-3.10-py2.6-linux-x86_64.egg’) #依赖yaml  
sys.path.append(‘/tmp/local/lib/python2.6/site-packages/pexpect-2.4-py2.6.egg’) #依赖pexpect  
import yaml  
import pexpect  
dataDict = yaml.load(open(‘/tmp/config.yaml’)) #将我的yaml配置load进来  

def myprint(color,mes): #以前写的一个终端彩色打印的函数  
    ‘’’使用ANSI控制码终端显示彩色’’’  
    d = dict(r=31, g=32, gb=36, y=33, b=34, p=35, o=37)  
    color = “\x1B[%d;%dm” % (1, d[color])  
    print “%s%s\x1B[0m” % (color, mes)  

def main():  
    list = [‘g’, ‘b’, ‘y’, ‘gb’, ‘p’]  
    light = 0  
    for k in dataDict:  
        if k.startswith(‘bj-‘):  
        color = list[light%5] #根据服务器对颜色轮循  
            SERVER = dataDict[k]  
        #我这是使用了-F 是因为我没有root权限不能修改hosts文件，但是我在config.yaml使用了别名，  
        而这个定义就是自定义了sshconfig，默认是~/.ssh/config  
        child = pexpect.spawn(‘ssh -F /tmp/sshconfig dongwm@{0}’.format(SERVER[‘host’]))  
        #因为有其他用户，可能他还没有链接过某服务器，最开始会让你确认服务器标识，需要点yes  
        f = child.expect([‘Password: ‘, ‘password: ‘, ‘continue connecting (yes/no)?’])  
        if f == 2:  
            #当这个flag为2  表示那个用户没有登录过某服务器  
            child.sendline(‘yes’)  
            child.expect(‘password:’)  
            child.sendline(‘{0}’.format(mypasswd(SERVER[‘host’]))) #mypasswd是加密我服务器权限的函数，每个服务器密码不同  
        if f == 1:  
            child.sendline(‘{0}’.format(mypasswd(SERVER[‘host’])))  
        child.expect(‘~’)  
        for service in SERVER[‘service’]:  
        flag = 0  
        #我在配置里面会加服务,一般会指定服务的进程数来对比是否正常  
        if isinstance(service, dict):  
            data =service.items()[0]  
            service = data[0]  
            num = data[1]  
        else:  
        #假如我在配置只指定服务，不指定进程数，那么只要确定跑了进程 不在乎进程数  
            num = 0  
            flag = 1  
            child.expect(‘~’)  
            child.sendline(‘ps -ef|grep {0}|grep -v grep|wc -l’.format(  
            service))  
            child.readline()  
            #进程数  
            pro_num = child.readline().split(‘\r\n’)[0]  
        if int(pro_num) == num or flag:  
            #进程数符合配置标注的数值  
            myprint(color, ‘[{0}]  [{1}]  [{2}]  [{3}]’.format(k.center(12),  
            SERVER[‘ip’].center(14), service.center(20), ‘ok’.center(4)))  
        else:  
            myprint(‘r’, ‘[{0}]  [{1}]  [{2}]  [{3}]  [{4}!={5}]’.format(k.center(12),  
            SERVER[‘ip’].center(14), service.center(20), ‘fail’,  
            pro_num, num))  
        light += 1  
            child.sendline(‘exit’)  

if **name** == ‘ **main** ‘:  
    main()  </code></pre><p>####config.yaml 我这里只截取了其中一段</p>
<pre><code>bj-2:  
  host: s233 #这个s233在sshconfig指定  
  ip: XXX.XXX.XXX.233 #只是为了显示出ip 好确认  
  service: #服务load后是一个列表  
  #给XX用  
  - nginx: 5  
  - uwsgi: 25  
  - supervisord: 1  
  #给本机XX提供mysql服务  
  - mysql: 3 #django  
  #给本机XX提供XX  
  - celery: 12  
  #给本机XX提供XX  
  - rabbitmq: 9  
  - redis: 1  
  - mongod: 2  </code></pre><p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>我的知乎Live:Python工程师的入门和进阶</title>
    <url>/2016-02-12.html</url>
    <content><![CDATA[<p>关注知乎Live也很久了，但是很少看到程序员做Live。最近看前端都展开了几场Live, 而我大知乎最热语言 Python<br>还没有相关Live。和写书一样，我再来带个头，希望越来越多的同学能把自己的经验和思考分享出来。<br>点击这里上车 →_→ <a href="https://zhihu.com/lives/789840559912009728?utm_campaign=zhihulive&utm_source=zhihucolumn&utm_medium=Livecolumn" target="_blank" rel="noopener">知乎 Live -<br>全新的实时问答</a><br>再次介绍一下这次Live：<br>我叫董伟明，毕业之前是一名「烹饪工艺与营养」专业的专科学生，目前在豆瓣条目组任职高级产品开发工程师，主要负责豆瓣读书、电影、音乐、东西等产品线。从 2011<br>年开始接触 Python, 从运维、运维开发到现在的 Web 开发，积累了丰富的运维和开发经验。热爱开源，为多个知名开源项目贡献过代码，也给 Python<br>标准库提交过 Patch 。我是《 Python Web 开发实战》作者，本书上市的 2 个多月时间里面已经售出 7k<br>余本，第四印正在筹备中，本书也将输出到台湾地区。<br>Python 是一门优雅而又不失实用的语言，它语法简单很容易学会，又具有极高的可读性和灵活性。在知乎上 Python<br>是受关注最多的编程语言。很遗憾在我初学的时候没有知乎这样的平台提供这么多的资源，甚至全靠自己摸索。虽然各类观点俯拾皆是，但是有时候却会让人迷失了方向。<br>本次 Live 我将带来个人对 Python<br>开发工程师如何入门、提高和进阶的一些见解，希望通过我个人的工作经历、学习方法，给不同阶段的同学在学习、工作、职业发展和面试等方面带来一些帮助。<br>我设置了前150人可发言。欢迎提问 []<del>(￣▽￣)</del>*。<br>本次 Live 主要包括以下问题：</p>
<ul>
<li>我的成长路径是怎么样的？</li>
<li>怎么样从零开始自学 Python？</li>
<li>怎么自学更高效？</li>
<li>应不应该接受 Python 培训，我认为靠谱的培训是什么样子的？</li>
<li>初、中级 Python 工程师在创业公司如何提升个人能力？</li>
<li>初、中级 Python 工程师在创业公司如何提升个人能力？</li>
<li>我的职业发展是运维到运维开发再到 web 开发，为什么要转行，怎么转，有什么坑？</li>
<li>如何提高代码品味，写出 Idiomatic 、 Pythonic 的代码？</li>
<li>如何突破目前的技术瓶颈进入下一个阶段？</li>
<li>我所看到的优秀工程师都是什么样子的？</li>
<li>谈点现实的，学习 Python 的前景怎么样？</li>
<li>如何打造一份吸引人的简历，面试前要做好什么准备，有什么面试技巧？<br>在Live开始之前我也会回答一些知友提出来的，大家都比较关心的一些问题，在上面提到的问题回答完毕后的互动环节，也会接着回答知友提出来的一些问题。<br>Live入口： <a href="https://zhihu.com/lives/789840559912009728?utm_campaign=zhihulive&utm_source=zhihucolumn&utm_medium=Livecolumn" target="_blank" rel="noopener">点击报名《董伟明 的 Live －－ Python<br>工程师的入门和进阶》</a></li>
</ul>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫练习</title>
    <url>/2016-02-09.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h4><p>20号参加pycon,发现有个招聘公司[知道创宇](<a href="http://blog.knownsec.com/2012/02/knownsec-" target="_blank" rel="noopener">http://blog.knownsec.com/2012/02/knownsec-</a><br>recruitment/), 正好换工作,就去公司网站转了下,发现挺有意思:投简历需要一个网站爬虫程序,基本要求如下(可以直接点开上面网页去看):</p>
<pre><code>使用python编写一个网站爬虫程序，支持参数如下：  

spider.py -u url -d deep -f logfile -l loglevel(1-5)  –testself -thread number –dbfile  filepath  –key=”HTML5”  


参数说明：  

-u 指定爬虫开始地址  

-d 指定爬虫深度  

–thread 指定线程池大小，多线程爬取页面，可选参数，默认10  

–dbfile 存放结果数据到指定的数据库（sqlite）文件中  

–key 页面内的关键词，获取满足该关键词的网页，可选参数，默认为所有页面  

-l 日志记录文件记录详细程度，数字越大记录越详细，可选参数，默认spider.log  

–testself 程序自测，可选参数  

功能描述：  

1、指定网站爬取指定深度的页面，将包含指定关键词的页面内容存放到sqlite3数据库文件中  

2、程序每隔10秒在屏幕上打印进度信息  

3、支持线程池机制，并发爬取网页  

4、代码需要详尽的注释，自己需要深刻理解该程序所涉及到的各类知识点  

5、需要自己实现线程池  </code></pre><p>搞了2天,根据研究,弄了一个版本(友情提示,仅供学习参考,要是面试这个职位,建议大家用其它方法实现,因为我投递过了,不要拿来主义额^.^)<br>#####代码如下(隐藏了个人信息用’XXX’代替)</p>
<pre><code>#!/usr/bin/env python  
#coding=utf-8  

import urllib2  
import Queue  
import sys  
import traceback  
import threading  
import re  
import datetime  
import lxml  
import chardet  
import logging  
import logging.handlers  
from time import sleep  
from urlparse import urlparse  
from lxml import etree  
from optparse import OptionParser  

try:  
    from sqlite3 import dbapi2 as sqlite  
except:  
    from pysqlite2 import dbapi2 as sqlite  

# **doc** 注释  执行脚本 -h 或者 –help  打印输出的内容  
‘’’  
This script is used to crawl analyzing web!  

The Feature:  
1 可以指定抓取的深度  
2 将抓取到的关键字数据存放在sqlite  
3 使用logging记录日志  
4 并发线程池  

Required dependencies:  
1 chardet #分析抓取页面的字符集  
sudo easy_install chardet  

Usage:  
spider.py -u url -d deep -f logfile -l loglevel(1-5)  –testself -thread number –dbfile  filepath  –key=”HTML5”  

Writer: Dongweiming  
Date: 2012.10.22  
‘’’  


lock = threading.Lock() #设置线程锁  
LOGGER = logging.getLogger(‘Crawler’) #设置logging模块的前缀  
LEVELS={   #日志级别  
        1:’CRITICAL’,  
        2:’ERROR’,  
        3:’WARNING’,  
        4:’INFO’,  
        5:’DEBUG’,#数字越大记录越详细  
        }  
formatter = logging.Formatter(‘%(name)s %(asctime)s %(levelname)s %(message)s’) #自定义日志格式  

class mySqlite(object):  

    def **init** (self, path, logger, level):  
        ‘’’初始化数据库连接.  

           &gt;&gt;&gt; from sqlite3 import dbapi2 as sqlite  
           &gt;&gt;&gt; conn = sqlite.connect(‘testdb’)  
        ‘’’  
        try:  
            self.conn = sqlite.connect(path) #连接sqlite  
            self.cur = self.conn.cursor()  #cursor是一个记录游标，用于一行一行迭代的访问查询返回的结果  
        except Exception, e:  
            myLogger(logger, self.loglevel, e, True)  
            return -1  

        self.logger = logger  
        self.loglevel = level  

    def create(self, table):  
        ‘’’创建table，我这里创建包含2个段 ID（数字型，自增长），Data（char 128字符）’’’  
        try:  
            self.cur.execute(“CREATE TABLE IF NOT EXISTS %s(Id INTEGER PRIMARY KEY AUTOINCREMENT, Data VARCHAR(40))”% table)  
            self.done()  
        except sqlite.Error ,e: #异常记录日志并且做事务回滚,以下相同  
            myLogger(self.logger, self.loglevel, e, True)  
            self.conn.rollback()  
        if self.loglevel &gt;3: #设置在日志级别较高才记录,这样级别高的详细  
                myLogger(self.logger, self.loglevel, ‘创建表%s’ % table)  

    def insert(self, table, data):  
        ‘’’插入数据，指定表名，设置data的数据’’’  
        try:  
            self.cur.execute(“INSERT INTO %s(Data) VALUES(‘%s’)” % (table,data))  
            self.done()  
        except sqlite.Error ,e:  
            myLogger(self.logger, self.loglevel, e, True)  
            self.conn.rollback()  
        else:  
            if self.loglevel &gt;4:  
                myLogger(self.logger, self.loglevel, ‘插入数据成功’)  

    def done(self):  
        ‘’’事务提交’’’  
        self.conn.commit()  

    def close(self):  
        ‘’’关闭连接’’’  
        self.cur.close()  
        self.conn.close()  
        if self.loglevel &gt;3:  
            myLogger(self.logger, self.loglevel, ‘关闭sqlite操作’)  


class Crawler(object):  

    def **init** (self, args, app, table, logger):  
        self.deep = args.depth  #指定网页的抓取深度  
        self.url = args.urlpth #指定网站地址  
        self.key = args.key #要搜索的关键字  
        self.logfile = args.logfile #日志文件路径和名字  
        self.loglevel = args.loglevel #日志级别  
        self.dbpth = args.dbpth #指定sqlite数据文件路径和名字  
        self.tp = app #连接池回调实例  
        self.table = table #每次请求的table不同  
        self.logger = logger #logging模块实例  
        self.visitedUrl = [] #抓取的网页放入列表,防止重复抓取  

    def _hasCrawler(self, url):  
        ‘’’判断是否已经抓取过这个页面’’’  
        return (True if url in self.visitedUrl else False)  

    def getPageSource(self, url, key, deep):  
        ‘’’ 抓取页面,分析,入库.  
        ‘’’  
        headers = {  #设计一个用户代理,更好防止被认为是爬虫  
            ‘User-Agent’:’Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; \  
            rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6’ }  
        #if  urlparse(url).scheme == ‘https’:  
           #pass  
        if self._hasCrawler(url): #发现重复直接return  
            return  
        else:  
            self.visitedUrl.append(url) #发现新地址假如到这个列表  
        try:  
            request = urllib2.Request(url = url, headers = headers) #创建一个访问请求,指定url,并且把访问请求保存在request  
            result = urllib2.urlopen(request).read() #打开这个请求,并保存读取数据  
        except urllib2.HTTPError, e:  #触发http异常记录日志并返回  
            myLogger(self.logger, self.loglevel, e, True)  
            return -1  
        try:  
            encoding = chardet.detect(result)[‘encoding’] #判断页面的编码  
            if encoding.lower() == ‘gb2312’:  
                encoding = ‘gbk’  #今天我抓取新浪是gb2312,但是其中有个’蔡旻佑’不能被识别,所以用gbk去解码gb2312的页面  
            if encoding.lower() != ‘utf-8’: #发现不是默认编码就用应该的类型解码  
                result = result.decode(encoding)  
        except Exception, e:  
            myLogger(self.logger, self.loglevel, e, True)  
            return -1  
        else:  
            if self.loglevel &gt;3:  
                myLogger(self.logger, self.loglevel, ‘抓取网页 %s 成功’ % url)  
        try:  
            self._xpath(url, result, [‘a’], unicode(key, ‘utf8’), deep) #分析页面中的连接地址,以及它的内容  
            self._xpath(url, result, [‘title’, ‘p’, ‘li’, ‘div’], unicode(key, “utf8”), deep) #分析这几个标签的内容  
        except TypeError: #对编码类型异常处理,有些深度页面和主页的编码不同  
            self._xpath(url, result, [‘a’], key, deep)  
            self._xpath(url, result, [‘title’, ‘p’, ‘li’, ‘div’], key, deep)  
        except Exception, e:  
            myLogger(self.logger, self.loglevel, e, True)  
            return -1  
        else:  
            if self.loglevel &gt;3:  
                myLogger(self.logger, self.loglevel, ‘分析网页 %s 成功’ % url)  
        return True  

    def _xpath(self, weburl, data, xpath, key, deep):  

        sq = mySqlite(self.dbpth, self.logger, self.loglevel)  
        page = etree.HTML(data)  
        for i in xpath:  
            hrefs = page.xpath(u”//%s” % i) #根据xpath标签  
            if deep &gt;1:  
                for href in hrefs:  
                    url = href.attrib.get(‘href’,’’)  
                    if not url.startswith(‘java’) and not  \  
                        url.startswith(‘mailto’):  #过滤javascript和发送邮件的链接  
                            self.tp.add_job(self.getPageSource,url, key, deep-1) #递归调用,直到符合的深度  
            for href in hrefs:  
                value = href.text  #抓取相应标签的内容  
                if value:  
                    m = re.compile(r’. _%s._ ‘ % key).match(value) #根据key匹配相应内容  
                    if m:  
                        sq.insert(self.table, m.group().strip()) #将匹配的数据插入到sqlite  
        sq.close()  

    def work(self):  
        ‘’’主方法调用.  

        &gt;&gt;&gt; import datetime  
        &gt;&gt;&gt; logger = configLogger(‘test.log’)  
        &gt;&gt;&gt; time = datetime.datetime.now().strftime(“%m%d%H%M%S”)  
        &gt;&gt;&gt; sq = mySqlite(‘test.db’, logger, 1)  
        &gt;&gt;&gt; table = ‘d’ + str(time)  
        &gt;&gt;&gt; sq.create(table)  
        &gt;&gt;&gt; tp = ThreadPool(5)  
        &gt;&gt;&gt; def t():pass  
        &gt;&gt;&gt; t.depth=1  
        &gt;&gt;&gt; t.urlpth=’&lt;http://www.baidu.com&apos;&gt;  
        &gt;&gt;&gt; t.logfile = ‘test.log’  
        &gt;&gt;&gt; t.loglevel = 1  
        &gt;&gt;&gt; t.dbpth = ‘test.db’  
        &gt;&gt;&gt; t.key = ‘test’  
        &gt;&gt;&gt; d = Crawler(t, tp, table, logger)  
        &gt;&gt;&gt; d.getPageSource(t.urlpth, t.key, t.depth)  
        True  
        ‘’’  
        if not self.url.startswith(‘http://‘): #支持用户直接写域名,当然也支持带前缀  
            self.url = ‘http://‘ + self.url  
        self.tp.add_job(self.getPageSource, self.url, self.key, self.deep)  
        self.tp.wait_for_complete() #等待线程池完成  


class MyThread(threading.Thread):  

    def **init** (self, workQueue, timeout=30, * _kwargs):  
        threading.Thread. **init** (self, kwargs=kwargs)  
        self.timeout = timeout #线程在结束前等待任务队列多长时间  
        self.setDaemon(True)  #设置deamon,表示主线程死掉,子线程不跟随死掉  
        self.workQueue = workQueue  
        self.start() #初始化直接启动线程  

    def run(self):  
        ‘’’重载run方法’’’  
        while True:  
            try:  
                lock.acquire()   #线程安全上锁  
                callable, args = self.workQueue.get(timeout=self.timeout) #从工作队列中获取一个任务  
                res = callable(_args)  #执行的任务  
                lock.release()  #执行完,释放锁  
            except Queue.Empty: #任务队列空的时候结束此线程  
                break  
            except Exception, e:  
                myLogger(self.logger, self.loglevel, e, True)  
                return -1  


class ThreadPool(object):  

    def **init** (self, num_of_threads):  
         self.workQueue = Queue.Queue()  
         self.threads = []  
         self. **createThreadPool(num_of_threads)  

    def ** createThreadPool(self, num_of_threads):  
         for i in range(num_of_threads):  
             thread = MyThread(self.workQueue)  
             self.threads.append(thread)  

    def wait_for_complete(self):  
         ‘’’等待所有线程完成’’’  
         while len(self.threads):  
             thread = self.threads.pop()  
         if thread.isAlive():  #判断线程是否还存活来决定是否调用join  
             thread.join()  

    def add_job( self, callable, *args):  
        ‘’’增加任务,放到队列里面’’’  
        self.workQueue.put((callable, args))  


def configLogger(logfile):  
    ‘’’配置日志文件和记录等级’’’  
    try:  
        handler = logging.handlers.RotatingFileHandler(logfile,  
                                                       maxBytes=10240000, #文件最大字节数  
                                                       backupCount=5, #会轮转5个文件，共6个  
                                                        )  
    except IOError, e:  
        print e  
        return -1  
    else:  
        handler.setFormatter(formatter)  #设置日志格式  
        LOGGER.addHandler(handler) #增加处理器  
        logging.basicConfig(level=logging.NOTSET) #设置,不打印小于4级别的日志  
    return LOGGER #返回logging实例  

def myLogger(logger, lv, mes, err=False):  
    ‘’’记录日志函数’’’  
    getattr(logger, LEVELS.get(lv, ‘WARNING’).lower())(mes)  
    if err: #当发现是错误日志,还会记录错误的堆栈信息  
        getattr(logger, LEVELS.get(lv, ‘WARNING’).lower())(traceback.format_exc())  

def parse():  
    parser = OptionParser(  
                  description=”This script is used to crawl analyzing web!”)  
    parser.add_option(“-u”, “–url”, dest=”urlpth”, action=”store”,  
                  help=”Path you want to fetch”, metavar=”[www.sina.com.cn&quot;](http://www.sina.com.cn&quot;))  
    parser.add_option(“-d”, “–deep”, dest=”depth”, action=”store”,type=”int”,  
                  help=”Url path’s deep, default 1”, default=1)  
    parser.add_option(“-k”, “–key”, dest=”key”, action=”store”,  
                  help=”You want to query keywords, For example ‘test’”)  
    parser.add_option(“-f”, “–file”, dest=”logfile”, action=”store”,  
                  help=”Record log file path and name, default spider.log”,  
                  default=’spider.log’)  
    parser.add_option(“-l”, “–level”, dest=”loglevel”, action = “store”,  
                  type=”int”,help=”Log file level, default 1(CRITICAL)”,  
                  default=1)  
    parser.add_option(“-t”, “–thread”, dest=”thread”, action=”store”,  
                  type=”int”,help=”Specify the thread pool, default 10”,  
                  default=10)  
    parser.add_option(“-q”, “–dbfile”, dest=”dbpth”, action=”store”,  
                  help=”Specify the the sqlite file directory and name, \  
                  default  test.db”, metavar=’test.db’)  
    parser.add_option(“-s”, “–testself”, dest=”testself”, action=”store_true”,  
                  help=”Test myself”, default=False)  
    (options, args) = parser.parse_args()  
    return options  

def main():  
    ‘’’主函数’’’  

    options = parse()  
    if options.testself: #如果testself,执行doctest  
        import doctest  
        print doctest.testmod()  
        return  
    if not options.urlpth or not options.key or not options.dbpth: #判断必选项是否存在  
        print ‘Need to specify the parameters option “-u “ or “-k” or “-q”!’  
        return  
    if ‘-h’ in sys.argv  or ‘–help’ in sys.argv:  #选择帮助信息,打印 **doc**  
        print **doc**  

    logger = configLogger(options.logfile) #实例化日志调用  
    time = datetime.datetime.now().strftime(“%m%d%H%M%S”) #每次请求都会根据时间创建table  
    tp = ThreadPool(options.thread)  
    sq = mySqlite(options.dbpth, logger, options.loglevel)  
    table = ‘d’ + str(time)  
    sq.create(table) #创建table  
    sq.close()  
    crawler = Crawler(options, tp, table, logger)  
    crawler.work()  #主方法  

 if **name** == ‘ **main** ‘:  
    main()  </code></pre><p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python进行并发编程-PoolExecutor篇</title>
    <url>/2016-02-13.html</url>
    <content><![CDATA[<p>之前我们使用多线程(threading)和多进程(multiprocessing)完成常规的需求，在启动的时候start、jon等步骤不能省，复杂的需要还要用1-2个队列。随着需求越来越复杂，如果没有良好的设计和抽象这部分的功能层次，代码量越多调试的难度就越大。有没有什么好的方法把这些步骤抽象一下呢，让我们不关注这些细节，轻装上阵呢？<br>答案是： <strong>有的</strong> 。<br>从Python3.2开始一个叫做concurrent.futures被纳入了标准库，而在Python2它属于第三方的futures库，需要手动安装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pip install futures</span><br></pre></td></tr></table></figure>


<p>这个模块中有2个类：ThreadPoolExecutor和ProcessPoolExecutor，也就是对threading和multiprocessing的进行了高级别的抽象，<br>暴露出统一的接口，帮助开发者非常方便的实现异步调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, as_completed  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">25</span>, <span class="number">38</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(fib, NUMBERS)):  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'fib(&#123;&#125;) = &#123;&#125;'</span>.format(num, result)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> <span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start)</span><br></pre></td></tr></table></figure>


<p>感受下是不是很轻便呢？看一下花费的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python fib_executor.py  </span><br><span class="line">fib(<span class="number">25</span>) = <span class="number">75025</span>  </span><br><span class="line">fib(<span class="number">26</span>) = <span class="number">121393</span>  </span><br><span class="line">fib(<span class="number">27</span>) = <span class="number">196418</span>  </span><br><span class="line">fib(<span class="number">28</span>) = <span class="number">317811</span>  </span><br><span class="line">fib(<span class="number">29</span>) = <span class="number">514229</span>  </span><br><span class="line">fib(<span class="number">30</span>) = <span class="number">832040</span>  </span><br><span class="line">fib(<span class="number">31</span>) = <span class="number">1346269</span>  </span><br><span class="line">fib(<span class="number">32</span>) = <span class="number">2178309</span>  </span><br><span class="line">fib(<span class="number">33</span>) = <span class="number">3524578</span>  </span><br><span class="line">fib(<span class="number">34</span>) = <span class="number">5702887</span>  </span><br><span class="line">fib(<span class="number">35</span>) = <span class="number">9227465</span>  </span><br><span class="line">fib(<span class="number">36</span>) = <span class="number">14930352</span>  </span><br><span class="line">fib(<span class="number">37</span>) = <span class="number">24157817</span>  </span><br><span class="line">COST: <span class="number">10.8920350075</span></span><br></pre></td></tr></table></figure>


<p>除了用map，另外一个常用的方法是submit。如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">30</span>, <span class="number">35</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">34</span>:  </span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Don't do this"</span>)  </span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    future_to_num = &#123;executor.submit(fib, num): num <span class="keyword">for</span> num <span class="keyword">in</span> NUMBERS&#125;  </span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(future_to_num):  </span><br><span class="line">        num = future_to_num[future]  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            result = future.result()  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'raise an exception: &#123;&#125;'</span>.format(e)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'fib(&#123;&#125;) = &#123;&#125;'</span>.format(num, result)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(fib, NUMBERS)):  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'fib(&#123;&#125;) = &#123;&#125;'</span>.format(num, result)</span><br></pre></td></tr></table></figure>


<p>执一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python fib_executor_with_raise.py  </span><br><span class="line">fib(<span class="number">30</span>) = <span class="number">832040</span>  </span><br><span class="line">fib(<span class="number">31</span>) = <span class="number">1346269</span>  </span><br><span class="line"><span class="keyword">raise</span> an exception: Don<span class="string">'t do this  </span></span><br><span class="line"><span class="string">fib(32) = 2178309  </span></span><br><span class="line"><span class="string">fib(33) = 3524578  </span></span><br><span class="line"><span class="string">Traceback (most recent call last):  </span></span><br><span class="line"><span class="string">  File "fib_executor_with_raise.py", line 28, in &lt;module&gt;  </span></span><br><span class="line"><span class="string">    for num, result in zip(NUMBERS, executor.map(fib, NUMBERS)):  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/_base.py", line 580, in map  </span></span><br><span class="line"><span class="string">     yield future.result()  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/_base.py", line 400, in result  </span></span><br><span class="line"><span class="string">    return self.__get_result()  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/_base.py", line 359, in __get_result  </span></span><br><span class="line"><span class="string">    reraise(self._exception, self._traceback)  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/_compat.py", line 107, in reraise  </span></span><br><span class="line"><span class="string">    exec('</span><span class="keyword">raise</span> exc_type, exc_value, traceback<span class="string">', &#123;&#125;, locals_)  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/thread.py", line 61, in run  </span></span><br><span class="line"><span class="string">    result = self.fn(*self.args, **self.kwargs)  </span></span><br><span class="line"><span class="string">  File "fib_executor_with_raise.py", line 9, in fib  </span></span><br><span class="line"><span class="string">    raise Exception("Don'</span>t do this<span class="string">")  </span></span><br><span class="line"><span class="string">Exception: Don't do this</span></span><br></pre></td></tr></table></figure>


<p>可以看到，第一次捕捉到了异常，但是第二次执行的时候错误直接抛出来了。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们就拿ProcessPoolExecutor介绍下它的原理，引用官方代码注释中的流程图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">|======================= In-process =====================|== Out-of-process ==|  </span><br><span class="line">  </span><br><span class="line">+----------+     +----------+       +--------+     +-----------+    +---------+  </span><br><span class="line">|          |  =&gt; | Work Ids |    =&gt; |        |  =&gt; | Call Q    | =&gt; |         |  </span><br><span class="line">|          |     +----------+       |        |     +-----------+    |         |  </span><br><span class="line">|          |     | ...      |       |        |     | ...       |    |         |  </span><br><span class="line">|          |     | <span class="number">6</span>        |       |        |     | <span class="number">5</span>, call() |    |         |  </span><br><span class="line">|          |     | <span class="number">7</span>        |       |        |     | ...       |    |         |  </span><br><span class="line">| Process  |     | ...      |       | Local  |     +-----------+    | Process |  </span><br><span class="line">|  Pool    |     +----------+       | Worker |                      |  <span class="comment">#1..n  |  </span></span><br><span class="line">| Executor |                        | Thread |                      |         |  </span><br><span class="line">|          |     +----------- +     |        |     +-----------+    |         |  </span><br><span class="line">|          | &lt;=&gt; | Work Items | &lt;=&gt; |        | &lt;=  | Result Q  | &lt;= |         |  </span><br><span class="line">|          |     +------------+     |        |     +-----------+    |         |  </span><br><span class="line">|          |     | <span class="number">6</span>: call()  |     |        |     | ...       |    |         |  </span><br><span class="line">|          |     |    future  |     |        |     | <span class="number">4</span>, result |    |         |  </span><br><span class="line">|          |     | ...        |     |        |     | <span class="number">3</span>, <span class="keyword">except</span> |    |         |  </span><br><span class="line">+----------+     +------------+     +--------+     +-----------+    +---------+</span><br></pre></td></tr></table></figure>


<p>我们结合源码和上面的数据流分析一下：</p>
<ol>
<li>executor.map会创建多个_WorkItem对象，每个对象都传入了新创建的一个Future对象。</li>
<li>把每个_WorkItem对象然后放进一个叫做「Work Items」的dict中，键是不同的「Work Ids」。</li>
<li>创建一个管理「Work Ids」队列的线程「Local worker thread」，它能做2件事：<ol>
<li>从「Work Ids」队列中获取Work Id, 通过「Work Items」找到对应的_WorkItem。如果这个Item被取消了，就从「Work Items」里面把它删掉，否则重新打包成一个_CallItem放入「Call Q」这个队列。executor的那些进程会从队列中取_CallItem执行，并把结果封装成_ResultItems放入「Result Q」队列中。</li>
<li>从「Result Q」队列中获取_ResultItems，然后从「Work Items」更新对应的Future对象并删掉入口。<br>看起来就是一个「生产者/消费者」模型，不过要注意，整个过程并不是多个进程与任务+结果-2个队列直接通信的，而是通过一个中间的「Local worker<br>thread」。<br>设想，当某一段程序提交了一个请求，期望得到一个答复。但服务程序对这个请求可能很慢，在传统的单线程环境下，调用函数是同步的，也就是说它必须等到服务程序返回结果后，才能进行其他处理。而在Future模式下，调用方式改为异步，而原先等待返回的时间段，在主调用函数中，则可用于处理其他事物。<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3>Future是常见的一种并发设计模式，在多个其他语言中都可以见到这种解决方案。<br>一个Future对象代表了一些尚未就绪（完成）的结果，在「将来」的某个时间就绪了之后就可以获取到这个结果。比如上面的例子，我们期望并发的执行一些参数不同的fib函数，获取全部的结果。传统模式就是在等待queue.get返回结果，这个是同步模式，而在Future模式下，</li>
</ol>
<strong>调用方式改为异步，而原先等待返回的时间段，由于「Local worker thread」的存在，这个时候可以完成其他工作</strong><br>在tornado中也有对应的实现。2013年的时候，我曾经写过一篇博客[使用tornado让你的请求异步非阻塞](<a href="http://www.dongwm.com/archives/shi-" target="_blank" rel="noopener">http://www.dongwm.com/archives/shi-</a><br>yong-tornadorang-ni-de-qing-qiu-yi-bu-fei-zu-<br>sai/)，最后也提到了用concurrent.futures实现异步非阻塞的完成耗时任务。<h3 id="用multiprocessing中的Pool还是concurrent-futures中的PoolExecutor？"><a href="#用multiprocessing中的Pool还是concurrent-futures中的PoolExecutor？" class="headerlink" title="用multiprocessing中的Pool还是concurrent.futures中的PoolExecutor？"></a>用multiprocessing中的Pool还是concurrent.futures中的PoolExecutor？</h3>上面说到的map，有些同学马上会说，这不是进程（线程）池的效果吗？看起来确实是的：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">25</span>, <span class="number">38</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line">pool = Pool(<span class="number">3</span>)  </span><br><span class="line"><span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, pool.map(fib, NUMBERS)):  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'fib(&#123;&#125;) = &#123;&#125;'</span>.format(num, result)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> <span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start)</span><br></pre></td></tr></table></figure>


<p>好像代码量更小。好吧，看一下花费的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python fib_pool.py  </span><br><span class="line">fib(<span class="number">25</span>) = <span class="number">75025</span>  </span><br><span class="line">fib(<span class="number">26</span>) = <span class="number">121393</span>  </span><br><span class="line">fib(<span class="number">27</span>) = <span class="number">196418</span>  </span><br><span class="line">fib(<span class="number">28</span>) = <span class="number">317811</span>  </span><br><span class="line">fib(<span class="number">29</span>) = <span class="number">514229</span>  </span><br><span class="line">fib(<span class="number">30</span>) = <span class="number">832040</span>  </span><br><span class="line">fib(<span class="number">31</span>) = <span class="number">1346269</span>  </span><br><span class="line">fib(<span class="number">32</span>) = <span class="number">2178309</span>  </span><br><span class="line">fib(<span class="number">33</span>) = <span class="number">3524578</span>  </span><br><span class="line">fib(<span class="number">34</span>) = <span class="number">5702887</span>  </span><br><span class="line">fib(<span class="number">35</span>) = <span class="number">9227465</span>  </span><br><span class="line">fib(<span class="number">36</span>) = <span class="number">14930352</span>  </span><br><span class="line">fib(<span class="number">37</span>) = <span class="number">24157817</span>  </span><br><span class="line">COST: <span class="number">11.8551170826</span></span><br></pre></td></tr></table></figure>


<p>是的，使用multiprocessing.pool中的ThreadPool/Pool其实是更快一点的。<br>既然他们都是面向线程/进程提供相同的API，甚至在一些方法上的参数和使用方式上都是一样的，为什么要保存2份用起来差不多的方案呢（甚至可以说后期实现的concurrent.futures慢一点）？<br>我翻了下源码，试着分析下：</p>
<ol>
<li>concurrent.futures的架构明显要复杂一些，不过更利于写出高效、异步、非阻塞的并行代码，而ThreadPeool/Pool更像一个黑盒，你用就好了，细节不仅屏蔽定制性也差。</li>
<li>concurrent.futures的接口更简单一些。ThreadPool/Pool的API中有processes, initializer，initargs，maxtasksperchild，context等参数，新人看起来容易不解，而concurrent.futures的参数就一个max_workers。<br>其实concurrent.futures底层还是用着threading和multiprocessing，相当于在其上又封装了一层，并且重新设计了架构，所以会慢一点。<br>然后我开始查找各种证据，找到了一个[SO的链接](<a href="https://stackoverflow.com/questions/24896193/whats-" target="_blank" rel="noopener">https://stackoverflow.com/questions/24896193/whats-</a><br>the-difference-between-pythons-multiprocessing-and-concurrent-<br>futures)，其中引用了Python核心贡献者Jesse<br>Noller说的<a href="http://bugs.python.org/issue9205#msg132661" target="_blank" rel="noopener">一段话</a>：<blockquote>
<p>Brian and I need to work on the consolidation we intend(ed) to occur<br>as people got comfortable with the APIs. My eventual goal is to remove<br>anything but the basic multiprocessing.Process/Queue stuff out of MP<br>and into concurrent.* and support threading backends for it.<br>和我的理解差不多吧。<br>不过我尝试让待处理的任务量比较大（上面的NUMBERS才包含13个），结果发现multiprocessing版本的速度差距成倍的扩大（下面会有实验代码）：concurrent.futures不可思议的要慢很多！<br>这个时候我回忆了一下标准库的实现，没找到这2种架构性能差别能这么大的原因，正在疑惑中，以为自己使用的姿势不对。不过正好在上面的链接中作者还特别说明了如下一段：<br>multiprocessing.Pool.map outperforms ProcessPoolExecutor.map. Note that the<br>performance difference is very small per work item, so you’ll probably only<br>notice a large performance difference if you’re using map on a very large<br>iterable. The reason for the performance difference is that<br>multiprocessing.Pool will batch the iterable passed to map into chunks, and<br>then pass the chunks to the worker processes, which reduces the overhead of<br>IPC between the parent and children. ProcessPoolExecutor always passes one<br>item from the iterable at a time to the children, which can lead to much<br>slower performance with large iterables, due to the increased IPC overhead.<br>The good news is this issue will be fixed in Python 3.5, as as chunksize<br>keyword argument has been added to ProcessPoolExecutor.map, which can be used<br>to specify a larger chunk size if you know you’re dealing with large<br>iterables. See this bug(<a href="http://bugs.python.org/issue11271" target="_blank" rel="noopener">http://bugs.python.org/issue11271</a>) for more info.<br>简单说明一下。multiprocessing.Pool.map要优于ProcessPoolExecutor.map，不过性能的差别是很小，如我上面说的，是由于架构和接口实现上的取舍。但是如果要处理的是一个很大的可迭代对象，就会有非常大的性能差别。这是因为multiprocessing.Pool是批量提交任务的，可以节省IPC(进程间通信)开销。而ProcessPoolExecutor每次都只提交一个任务。不过在Python3.5的时候已经通过给map方法添加chunksize参数解决了。<br>你可能比较迷惑，我们看一段代码就好了：</p>
</blockquote>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool  </span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> as_completed, ProcessPoolExecutor  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">1</span>, <span class="number">100000</span>)  </span><br><span class="line">K = <span class="number">50</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span>  </span><br><span class="line">    r = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, K+<span class="number">2</span>):  </span><br><span class="line">        r += x ** (<span class="number">1</span> / k**<span class="number">1.5</span>)  </span><br><span class="line">    <span class="keyword">return</span> r  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'multiprocessing.pool.Pool:\n'</span>)  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line">l = []  </span><br><span class="line">pool = Pool(<span class="number">3</span>)  </span><br><span class="line"><span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, pool.map(f, NUMBERS)):  </span><br><span class="line">    l.append(result)  </span><br><span class="line">print(len(l))  </span><br><span class="line">print(<span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'ProcessPoolExecutor without chunksize:\n'</span>)  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line">l = []  </span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(f, NUMBERS)):  </span><br><span class="line">        l.append(result)  </span><br><span class="line">  </span><br><span class="line">print(len(l))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'ProcessPoolExecutor with chunksize:\n'</span>)  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line">l = []  </span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="comment"># 保持和multiprocessing.pool的默认chunksize一样  </span></span><br><span class="line">    chunksize, extra = divmod(len(NUMBERS), executor._max_workers * <span class="number">4</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(f, NUMBERS, chunksize=chunksize)):  </span><br><span class="line">        l.append(result)  </span><br><span class="line">  </span><br><span class="line">print(len(l))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>


<p>先运行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python map_comparison.py  </span><br><span class="line">multiprocessing.pool.Pool:  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">COST: <span class="number">0.7973268032073975</span>  </span><br><span class="line">ProcessPoolExecutor without chunksize:  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">COST: <span class="number">28.467172861099243</span>  </span><br><span class="line">ProcessPoolExecutor <span class="keyword">with</span> chunksize:  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">COST: <span class="number">0.8141732215881348</span></span><br></pre></td></tr></table></figure>


<p>其中第一段使用multiprocessing.pool，最快。<br>第二段使用没有加chunksize， 这个速度不忍直视。大家不要再这样犯错了。<br>第三段加上了chunksize，分块的原则和第一段标准库实现的一样，速度又回到同一个水平了。<br>迷惑这么久的原因其实是我一直在看Python 2的对应的代码，当我看了最新版的代码就懂了。<br>最后我的建议是：虽然会慢一点点，还是推荐使用接口更简单的concurrent.futures，不过<br><strong>大家使用的时候注意要用Python3.及以后的版本啦！</strong><br>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2017-06-12" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3新特性汇总</title>
    <url>/2016-02-14.html</url>
    <content><![CDATA[<p>这篇文章灵感来源于一个新项目<a href="https://github.com/arogozhnikov/python3_with_pleasure" target="_blank" rel="noopener">A short guide on features of Python 3 for data<br>scientists</a>，这个项目列出来了作者使用Python<br>3用到的一些特性。正巧我最近也想写一篇介绍Python 3(特指Python 3.6+)特色用法的文章。开始吧！</p>
<h3 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h3><p>pathlib模块是Python 3新增的模块，让你更方便的处理路径相关的工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> pathlib <span class="keyword">import</span> Path  </span><br><span class="line">In : Path.home()  </span><br><span class="line">Out: PosixPath(<span class="string">'/Users/dongweiming'</span>)  <span class="comment"># 用户目录  </span></span><br><span class="line">In : path = Path(<span class="string">'/user'</span>)  </span><br><span class="line">In : path / <span class="string">'local'</span>  <span class="comment"># 非常直观  </span></span><br><span class="line">Out: PosixPath(<span class="string">'/user/local'</span>)  </span><br><span class="line">In : str(path / <span class="string">'local'</span> / <span class="string">'bin'</span>)  </span><br><span class="line">Out: <span class="string">'/user/local/bin'</span>  </span><br><span class="line">  </span><br><span class="line">In : f = Path(<span class="string">'example.txt'</span>)  </span><br><span class="line">In : f.write_bytes(<span class="string">'This is the content'</span>.encode(<span class="string">'utf-8'</span>))  </span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">19</span>  </span><br><span class="line">  </span><br><span class="line">In : <span class="keyword">with</span> f.open(<span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> handle:  <span class="comment"># open现在是方法了  </span></span><br><span class="line">....:         print(<span class="string">'read from open(): &#123;!r&#125;'</span>.format(handle.read()))  </span><br><span class="line">....:  </span><br><span class="line">read <span class="keyword">from</span> open(): <span class="string">'This is the content'</span>  </span><br><span class="line">  </span><br><span class="line">In : p = Path(<span class="string">'touched'</span>)  </span><br><span class="line">In : p.exists()  <span class="comment"># 集成了多个常用方法  </span></span><br><span class="line">Out: <span class="literal">False</span>  </span><br><span class="line">In : p.touch()  </span><br><span class="line">In : p.exists()  </span><br><span class="line">Out: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In : p.with_suffix(<span class="string">'.jpg'</span>)  </span><br><span class="line">Out: PosixPath(<span class="string">'touched.jpg'</span>)  </span><br><span class="line">In : p.is_dir()  </span><br><span class="line">Out: <span class="literal">False</span>  </span><br><span class="line">In : p.joinpath(<span class="string">'a'</span>, <span class="string">'b'</span>)  </span><br><span class="line">Out: PosixPath(<span class="string">'touched/a/b'</span>)</span><br></pre></td></tr></table></figure>


<h3 id="可迭代对象的解包"><a href="#可迭代对象的解包" class="headerlink" title="可迭代对象的解包"></a>可迭代对象的解包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : a, b, *rest = range(<span class="number">10</span>)  <span class="comment"># 学过lisp就很好懂了，相当于一个「everything else」  </span></span><br><span class="line">In : a  </span><br><span class="line">Out: <span class="number">0</span>  </span><br><span class="line">In : b  </span><br><span class="line">Out: <span class="number">1</span>  </span><br><span class="line">In : rest  </span><br><span class="line">Out: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]  </span><br><span class="line">  </span><br><span class="line">In : *prev, next_to_last, last = range(<span class="number">10</span>)  </span><br><span class="line">In : prev, next_to_last, last  </span><br><span class="line">Out: ([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>


<h3 id="强制关键字参数"><a href="#强制关键字参数" class="headerlink" title="强制关键字参数"></a>强制关键字参数</h3><p>使用强制关键字参数会比使用位置参数表意更加清晰，程序也更加具有可读性，那么可以让这些参数强制使用关键字参数传递，可以将强制关键字参数放到某个<br><em>参数或者单个</em> 后面就能达到这种效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">(maxsize, *, block)</span>:</span>  </span><br><span class="line">....:  </span><br><span class="line">....:     <span class="keyword">pass</span>  </span><br><span class="line">....:  </span><br><span class="line">  </span><br><span class="line">In : recv(<span class="number">1024</span>, <span class="literal">True</span>)  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-49</span><span class="number">-8e61</span>db2ef94b&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 recv(1024, True)  </span><br><span class="line">  </span><br><span class="line">TypeError: recv() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given  </span><br><span class="line">  </span><br><span class="line">In : recv(<span class="number">1024</span>, block=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符**"></a>通配符**</h3><p>我们都知道在Python 2时不能直接通配递归的目录，需要这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">found_images = \  </span><br><span class="line">    glob.glob(<span class="string">'/path/*.jpg'</span>) \  </span><br><span class="line">  + glob.glob(<span class="string">'/path/*/*.jpg'</span>) \  </span><br><span class="line">  + glob.glob(<span class="string">'/path/*/*/*.jpg'</span>) \  </span><br><span class="line">  + glob.glob(<span class="string">'/path/*/*/*/*.jpg'</span>) \  </span><br><span class="line">  + glob.glob(<span class="string">'/path/*/*/*/*/*.jpg'</span>)</span><br></pre></td></tr></table></figure>


<p>Python3的写法要清爽的多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">found_images = glob.glob(<span class="string">'/path/**/*.jpg'</span>, recursive=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p>事实上更好的用法是使用pathlib:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">found_images = pathlib.Path(<span class="string">'/path/'</span>).glob(<span class="string">'**/*.jpg'</span>)</span><br></pre></td></tr></table></figure>


<h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p>Python 3之后print成为了函数，有了更多的扩展能力：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : print(*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], sep=<span class="string">'\t'</span>)  </span><br><span class="line"><span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>  </span><br><span class="line">In : [x <span class="keyword">if</span> x % <span class="number">3</span> <span class="keyword">else</span> print(<span class="string">''</span>, x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Out: [<span class="literal">None</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="literal">None</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="literal">None</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="literal">None</span>]</span><br></pre></td></tr></table></figure>


<h3 id="格式化字符串变量"><a href="#格式化字符串变量" class="headerlink" title="格式化字符串变量"></a>格式化字符串变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : name = <span class="string">'Fred'</span>  </span><br><span class="line">In : <span class="string">f'My name is <span class="subst">&#123;name&#125;</span>'</span>  </span><br><span class="line">Out: <span class="string">'My name is Fred'</span>  </span><br><span class="line">  </span><br><span class="line">In : <span class="keyword">from</span> datetime <span class="keyword">import</span> *  </span><br><span class="line">In : date = datetime.now().date()  </span><br><span class="line">In : <span class="string">f'<span class="subst">&#123;date&#125;</span> was on a <span class="subst">&#123;date:%A&#125;</span>'</span>  </span><br><span class="line">Out: <span class="string">'2018-01-17 was on a Wednesday'</span>  </span><br><span class="line">  </span><br><span class="line">In : <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span>  </span><br><span class="line">....:     <span class="keyword">return</span> <span class="number">20</span>  </span><br><span class="line">....:  </span><br><span class="line">In : <span class="string">f'result=<span class="subst">&#123;foo()&#125;</span>'</span>  </span><br><span class="line">Out: <span class="string">'result=20'</span></span><br></pre></td></tr></table></figure>


<h3 id="更严格的对比规范"><a href="#更严格的对比规范" class="headerlink" title="更严格的对比规范"></a>更严格的对比规范</h3><p>下面这几种类型的用法在Python 3都是非法的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3</span> &lt; <span class="string">'3'</span>  </span><br><span class="line"><span class="number">2</span> &lt; <span class="literal">None</span>  </span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>) &lt; (<span class="number">3</span>, <span class="literal">None</span>)  </span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>) &lt; [<span class="number">4</span>, <span class="number">5</span>]  </span><br><span class="line">sorted([<span class="number">2</span>, <span class="string">'1'</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>


<h3 id="统一unicode的使用"><a href="#统一unicode的使用" class="headerlink" title="统一unicode的使用"></a>统一unicode的使用</h3><p>这是很多人黑Python 2的一点，举个例子。在Python 2里面下面的结果很奇怪：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s = <span class="string">'您好'</span>  </span><br><span class="line">  </span><br><span class="line">In : print(len(s))  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">In : print(s[:<span class="number">2</span>])  </span><br><span class="line">?</span><br></pre></td></tr></table></figure>


<p>Python 3就方便了:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s = <span class="string">'您好'</span>  </span><br><span class="line">  </span><br><span class="line">In : print(len(s))  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">In : print(s[:<span class="number">2</span>])  </span><br><span class="line">您好</span><br></pre></td></tr></table></figure>


<h3 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : x = dict(a=<span class="number">1</span>, b=<span class="number">2</span>)  </span><br><span class="line">In : y = dict(b=<span class="number">3</span>, d=<span class="number">4</span>)  </span><br><span class="line">In : z = &#123;**x, **y&#125;  </span><br><span class="line">In : z  </span><br><span class="line">Out: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>


<h3 id="字典可排序"><a href="#字典可排序" class="headerlink" title="字典可排序"></a>字典可排序</h3><p>Python 3不再需要直接使用OrderedDict：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : &#123;str(i):i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)&#125;  </span><br><span class="line">Out: &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>UserDict、UserString、UserList存在的意义</title>
    <url>/2016-02-15.html</url>
    <content><![CDATA[<p>最近遇到了一个继承Python内建结构的坑儿和大家分享下。从Python<br>2.2开始，Python支持继承Python内建结构，如list、dict。最近在实现一个功能，为了简化内容，我直接继承了dict，但是结果和预期不一样。举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="class"><span class="keyword">class</span> <span class="title">NewDict</span><span class="params">(dict)</span>:</span>  </span><br><span class="line">...:     <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span>  </span><br><span class="line">...:         <span class="keyword">return</span> <span class="number">42</span>  </span><br><span class="line">...:  </span><br><span class="line">In : d = NewDict(a=<span class="number">1</span>)  </span><br><span class="line">In : d  </span><br><span class="line">Out: &#123;<span class="string">'a'</span>: <span class="number">42</span>&#125;  </span><br><span class="line">In : d2 = &#123;&#125;  </span><br><span class="line">In : d2.update(d)  </span><br><span class="line">In : d2  </span><br><span class="line">Out: &#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>


<p>也就是说NewDict的<strong>getitem</strong>方法被dict.update给忽略了。这让我很惊讶，我之前用UserDict的时候是正常的（这次为啥直接用dict也不知道抽了什么筋）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> UserDict <span class="keyword">import</span> UserDict  </span><br><span class="line">  </span><br><span class="line">In : <span class="class"><span class="keyword">class</span> <span class="title">NewDict</span><span class="params">(UserDict)</span>:</span>  </span><br><span class="line">...:     <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span>  </span><br><span class="line">...:         <span class="keyword">return</span> <span class="number">42</span>  </span><br><span class="line">...:  </span><br><span class="line">  </span><br><span class="line">In : d = NewDict(a=<span class="number">1</span>)  </span><br><span class="line">In : d[<span class="string">'b'</span>] =<span class="number">2</span>  </span><br><span class="line">In : d  </span><br><span class="line">Out: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;  </span><br><span class="line">In : d[<span class="string">'b'</span>]  </span><br><span class="line">Out: <span class="number">42</span>  </span><br><span class="line">In : d2 = &#123;&#125;  </span><br><span class="line">In : d2.update(d)  </span><br><span class="line">In : d2  </span><br><span class="line">Out: &#123;<span class="string">'a'</span>: <span class="number">42</span>, <span class="string">'b'</span>: <span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure>


<p>这才是对的呀。所以我开始研究找答案。后来在PyPy的文档中发现了[原因](<a href="http://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-" target="_blank" rel="noopener">http://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-</a><br>of-built-in-types)，也就是这种C实现的结构的内建方法大部分会忽略重载的那个方法。<br>之前我以为UserDict这样的类是历史遗留问题，现在才知道是有原因的。原来UserDict、UserString、UserList这样的模块是非常必要的。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>udev升级的网卡重命名问题和解决</title>
    <url>/2016-02-16.html</url>
    <content><![CDATA[<p>####故障描述<br>最近终于更新了下gentoo，重启发现我的eth0网卡启动失败：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* Bringing up interface eth0  </span><br><span class="line">*   ERROR: interface eth0 does <span class="keyword">not</span> exist  </span><br><span class="line">*   Ensure that you have loaded the correct kernel module <span class="keyword">for</span> your hardware  </span><br><span class="line">* ERROR: net.eth0 failed to start</span><br></pre></td></tr></table></figure>


<p>而启动某些我常用的服务，比如mongodb，也报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">~ <span class="comment"># /etc/init.d/mongodb restart  </span></span><br><span class="line"> * Bringing up interface eth0  </span><br><span class="line"> *   ERROR: interface eth0 does <span class="keyword">not</span> exist  </span><br><span class="line"> *   Ensure that you have loaded the correct kernel module <span class="keyword">for</span> your hardware  </span><br><span class="line"> * ERROR: net.eth0 failed to start  </span><br><span class="line"> * ERROR: cannot start mongodb <span class="keyword">as</span> net.eth0 would <span class="keyword">not</span> start</span><br></pre></td></tr></table></figure>


<p>竟然也需要启动网卡？<br>######查看内核和dmesg：<br>查看内核模块已经选中，而且以前eth0也有，再看dmesg</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dmesg |grep network   </span><br><span class="line">[   <span class="number">74.261872</span>] systemd-udevd[<span class="number">14259</span>]: renamed network interface wlan0 to wlp2s0  </span><br><span class="line">[   <span class="number">74.391865</span>] systemd-udevd[<span class="number">14259</span>]: renamed network interface eth0 to enp0s4</span><br></pre></td></tr></table></figure>


<p>原来被重命名了<br>####为什么？<br>从udev-197将自动分配更好的接口名字，具体解释请看[PredictableNetworkInterfaceNames]<br>(<a href="http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames)" target="_blank" rel="noopener">http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames)</a>,<br>####解决办法，有三种</p>
<ol>
<li>临时办法，重启还是会失效<br>ifrename -i enp0s4 -n eth0 #修改网卡名字变成原来的eth0</li>
<li>使用新的名字</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rm /etc/init.d/net.eth0 <span class="comment">#删除不存在的引用  </span></span><br><span class="line">  </span><br><span class="line">localhost ~ <span class="comment"># rc-update delete net.eth0 default #删除不存在的开机启动  </span></span><br><span class="line"> * service net.eth0 removed <span class="keyword">from</span> runlevel default  </span><br><span class="line">localhost ~ <span class="comment"># rc-update add net.enp0s4 default #使用新名字</span></span><br></pre></td></tr></table></figure>


<ol start="3">
<li>重置udev的rules，还是用原来的方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ln -s /dev/null /etc/udev/rules.d/<span class="number">80</span>-net-name-slot.rules</span><br></pre></td></tr></table></figure>


<p>第二种，和第三种需要重启<br>####启动应用为什么也需要启动应该启动的网卡<br>查看/etc/init.d/mongodb脚本，发现是因为depend，一般的初始化脚本结构是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/sbin/runscript  </span></span><br><span class="line">  </span><br><span class="line">depend() &#123;  </span><br><span class="line">  （依赖关系信息）  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">start() &#123;  </span><br><span class="line">  （启动服务所必需的命令）  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">stop() &#123;  </span><br><span class="line">  （停止服务所必需的命令）  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">restart() &#123;  </span><br><span class="line">  （重启服务所必需的命令）  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>比如 mongodb 的依赖是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">depend() &#123;  </span><br><span class="line">  need net <span class="comment">#需要依赖net.X  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下次我专门研究一篇gentoo初始化脚本的文章</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>gentle帮助你快速部署代码到测试环境</title>
    <url>/2016-02-17.html</url>
    <content><![CDATA[<p>####前言<br>我想很多开发的同学都经历过这样的开发流程:</p>
<ul>
<li>本地修改代码</li>
<li>把代码推到测试环境</li>
<li>重启测试环境需要的服务</li>
<li>本地看效果,改bug重复1-3</li>
<li>功能稳定后上线<br>这个过程有什问题呢?</li>
<li>假设你是一个做过运维或者能力很强的人,比如我这种,本地跑测试环境,但是假如一个新人,或者对测试环境中的某些<br>部分不是很了解的人, 甚至需要和生产环境完全一样的条件下, 本地可能就不好使了. 那么这需要一个测试服务器</li>
<li>首先你每次修改代码, push ,重启环境都需要你登陆测试环境,至少不够自动化.然后退回本地看效果,这个过程有点浪费时间和经理</li>
<li>其次是你可能有好几个项目,他们之间可能都没什么共通点. 你需要多个测试环境</li>
<li>当然你可以写几个脚本,为你每个测试环境写一个东西去自动化这些，未尝不可. 只是需要重复造很多轮子</li>
<li>假如为了安全有跳板机,你需要登陆跳板机才能跳到你的测试服务器,你可能要写很复杂的expect脚本<br>然后是我认为最重要的:<br><strong>凡是屁大点事就放个deamon的运维都是耍流氓, 就拿小屁几台服务器还搞神马salt, ansible之类的事情,真是太无聊了.</strong><br>这些东西帮助你做了很多事情,但是会让你变得更懒.而且重要的是-它们写的并不一定只符合你的需要或者就不符合你的需要.<br>我喜欢简单粗暴的实现,最近在看<a href="https://github.com/fabric/fabric" target="_blank" rel="noopener">fabric</a>的代码,<br>作为做过op,也给<a href="https://github.com/saltstack/salt" target="_blank" rel="noopener">salt</a>贡献过代码的我,写了这个东西:<br><a href="https://github.com/dongweiming/gentle" target="_blank" rel="noopener">gentle</a>, 帮助我自动化提交代码到我的测试环境.<br>这个东西是我认为符合我需要，或者大部分开发同学需要的小东西,基于fabric,<br><a href="https://github.com/docopt/docopt" target="_blank" rel="noopener">docopt</a> 和yaml.<br>####我的工作的一些特点<br>我负责几个项目, 它们有以下特点</li>
<li>项目在不同的机房, 有完整的测试环境和相关数据</li>
<li>项目依赖的服务基本不同,比如有的使用了supervisor, 有的是程序fork后退出了父进程;有的使用了nginx+uwsgi,有的就是nginx+服务等.</li>
<li>项目之间需要的依赖应用不同,且启动顺序有区别. 这个很好理解, 启动需要先启动A,再启动B,才能启动C</li>
<li>项目有的需要登陆跳板机<br>####我以前的个人的开发习惯和流程</li>
<li>我有一个专门的存放服务配置的目录, 后缀是ip或者项目的名字. git版本库, 每次更新后上传到测试环境</li>
<li>我有专门的op PATH, 做了很多alias, 都是一些python或者shell的脚本,用来同步测试环境,登陆测试环境撑起服务的脚本<br>看起来以前用的也不错. 但是gentle能怎么样提高呢?<br>####gentle的开发流程</li>
<li>切换到你要开发的目录</li>
<li>初始化这个目录,其实就是在当前目录增加一个.gentle.yaml</li>
<li>根据你的需要配置测试环境账号ip密码, 想要同步的目录, 需要重启的服务和优先级已经命令</li>
<li>以后每次只需在这个目录下,使用<code>gt publish</code> 或者更懒 <code>gt p</code>, 他就会帮你自动rsync然后重启相关服务.<br>具体使用可以去我的github或者<a href="http://gentle.readthedocs.org/en/latest/" target="_blank" rel="noopener">readthedocs.org</a><br>####安装和依赖<br>我已经放到了pypi, 你可以使用pip或者easy_install</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo pip install gentle</span><br></pre></td></tr></table></figure>


<p>这样在系统环境下会有一个<code>gt</code>命令<br>fabric有2个对于项目更新的函数,一个是rsync_project,一个是upload_project,<br>upload是把项目压缩在服务器上解压缩,实际上很浪费时间,但是rsync_project不能使用env.password,需要手动输入一次密码,都很不爽,我找到一个解决办法就是<code>sshpass</code>,<br>帮助自动输入rsync的密码, 我也给fabric提了PR. 我的项目使用了我个人的改进版的rsync_project<br>如果你是ubuntu 直接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install sshpass</span><br></pre></td></tr></table></figure>


<p>其他操作系统可以在这里下载 <a href="http://sourceforge.net/projects/sshpass/" target="_blank" rel="noopener">http://sourceforge.net/projects/sshpass/</a> 然后编译</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tar zxvf sshpass<span class="number">-1.05</span>.tar.gz &amp;&amp; cd sshpass<span class="number">-1.05</span> &amp;&amp; ./configure &amp;&amp;  </span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>


<p>####一个我的测试环境的例子, 我加注释说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">host: <span class="number">192.168</span><span class="number">.3</span><span class="number">.11</span> <span class="comment">#测试服务器, 格式是user@host:port  </span></span><br><span class="line">password: dongwmspassword <span class="comment">#登录服务器需要的密码  </span></span><br><span class="line">gateway: <span class="comment">#可以不存在,中间服务器,格式是user@host:port  </span></span><br><span class="line">gatewaypassword: <span class="comment">#中间服务器(jump跳板机)的密码  </span></span><br><span class="line">rsync: <span class="comment">#这个操作是rsync  </span></span><br><span class="line">  lpath: $ROOT <span class="comment">#你可以使用全路径, $ROOT表示当前路径,本地目录  </span></span><br><span class="line">  rpath: /opt/tornado <span class="comment"># 测试环境的目录  </span></span><br><span class="line">services: <span class="comment"># 每个段落就是一个服务,这里有nginx和supervisor  </span></span><br><span class="line">  nginx:  </span><br><span class="line">    command: kill <span class="number">-9</span> `ps -ef |grep nginx|grep -v grep|awk <span class="string">'&#123;print $2&#125;'</span>` &amp;&amp; /opt/nginx/sbin/nginx <span class="comment">#启动的命令  </span></span><br><span class="line">    lpath: /usr/local/etc/nginx/nginx.conf <span class="comment">#nginx.conf的本地地址  </span></span><br><span class="line">    priority: <span class="number">1</span> <span class="comment">#优先级越高越先执行  </span></span><br><span class="line">    rpath: /opt/nginx/conf/nginx.conf <span class="comment">#测试环境的nginx.conf路径  </span></span><br><span class="line">    sudo: false <span class="comment"># 因为这个环境很宽松 不需要sudo  </span></span><br><span class="line">    user: <span class="comment">#sudo使用的用户,默认是登陆的用户  </span></span><br><span class="line">  supervisor:  </span><br><span class="line">    command: supervisorctl -c /etc/supervisor/supervisord.conf reload  </span><br><span class="line">    lpath: /Users/dongwm/settings/supervisord.conf<span class="number">.31</span>  </span><br><span class="line">    priority: <span class="number">2</span>  </span><br><span class="line">    rpath: /etc/supervisor/supervisord.conf  </span><br><span class="line">    sudo: false  </span><br><span class="line">    user:  </span><br><span class="line">username: root <span class="comment">#登陆服务器的默认用户, 你可以在使用host的时候指定用户</span></span><br></pre></td></tr></table></figure>


<p>####欢迎给我issue和PR<br>####TODO</p>
<ul>
<li>因为很多人会用到跳板机,我想加入跳板机的用法, 看起来就像直接在本地操作远程一样 # 更新2013-12-03 完成</li>
<li>设置输出是否隐藏,目前保留就是为了让我看到执行的过程</li>
<li>设置支持多测试环境一起部署,或者说让生成环境的部署一样方便</li>
</ul>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈MVC、MTV和MVVM</title>
    <url>/2016-02-18.html</url>
    <content><![CDATA[<p>昨天有位同学私信我，说他所在的公司的不少项目都有个controllers.py的文件或者controllers的目录用来存放视图。但是和他理解的Python<br>Web框架的设计模式不太一样，问我MVC/MVT到底怎么区分。听他一开始说，我为之一怔，因为我身边的人就有写controllers的…<br>不过我没有去验证这只是目录的名字而已。<br>今天我和大家聊聊我对这几个流行的设计模式的理解。</p>
<blockquote>
<p>复杂的软件必须有清晰合理的架构，否则无法开发和维护。 - 阮一峰</p>
</blockquote>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC（Model View Controller 模型-视图-<br>控制器）是一种Web架构的模式（本文不讨论桌面应用的MVC），它把业务逻辑、模型数据、用户界面分离开来，让开发者将数据与表现解耦，前端工程师可以只改页面效果部分而不用接触后端代码，DBA可以重新命名数据表并且只需更改一个地方，无需从一大堆文件中进行查找和替换。MVC模式甚至还可以提高代码复用能力。现在几乎所有的Web开发框架都建立在MVC模式之上。<br>当然，最近几年也出现了一些诸如MVP, MVVM之类的新的设计模式。 但从技术的成熟程度和使用的广泛程度来讲，MVC仍是主流。<br>MVC三要素：</p>
<ol>
<li>Model（数据模型）。是对客观事物的抽象。比如上篇我们说到的知乎Live，Live就是一个模型，可以用Live类来表示。而一个模型通常还带有很多的和业务相关的逻辑，比如添加，更新，获取Live主讲人信息等等，这些组成了模型的方法。对于开发者模型的表示方法非常易懂和清晰，可以通过非常便捷的代码来做CURD操作而无需写一条又一条的SQL语句。</li>
<li>View（视图）。呈现给用户的效果，呈现的内容是基于Model，它也是收集用户输入的地方。比如看到一篇Live，数据是一个Live.get(live_id).to_dict()的结果，效果是通过对应的模板和样式把这个数据展示出来。</li>
<li>Contorller（控制器）。是Model和View之间的沟通者。 因为View中不会对Model作任何操作，Model不会输出任何用于表现的东西，如HTML代码或者某种效果等，它就是点数据。而Contorller用于决定使用哪些Model，对Model执行什么操作，为视图准备哪些数据，是MVC中沟通的桥梁。<br>MVC的特点是通信单向的：</li>
<li>浏览器发送请求</li>
<li>Contorller和Model交互获取数据</li>
<li>Contorller调用View</li>
<li>View渲染数据返回<br>更简单的表达式：V -&gt; C-&gt; M -&gt; C -&gt; V<h3 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h3>和Rails、Spring、Laravel等其他语言的Web框架不一样，在Python的世界中，基本（除了Pylons）都使用了MVC的变种MTV（Model<br>Templates View 模型-模板-视图）：</li>
<li>Model（数据模型）。和MVC的Model一样，处理与数据相关的所有事务：如何存取、如何确认有效性、包含哪些行为以及数据之间的关系等。</li>
<li>Template（模板）。处理与表现相关的决定：如何在页面或其他类型文档中进行显示出来。</li>
<li>View。处理业务逻辑，视图就是一个特定URL的回调函数，回调函数中描述数据：从Model取出对应的数据，调用相关的模板。它就是Contorller要调用的那个用来做Model和View之间的沟通函数，从而完成控制。<br>注意啦：MVC中的View的目的是「呈现哪一个数据」，而MTV的View的目的是「数据如何呈现」。<br>也就是把MVC中的View分成了视图（展现哪些数据）和模板（如何展现）2个部分，而Contorller这个要素由框架自己来实现了，我们需要做的就是把（带正则表达式的）URL对应到视图就可以了，通过这样的URL配置，系统将一个请求发送到一个合适的视图。<br>需要注意，Flask这种微框架就不是一个MVC模式的，因为它没有提供Model，除非集成了SQLAlchemy之类的ORM进来。<br>所以大家最常见的Python Web项目的目录风格是这样的：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├── app.py  </span><br><span class="line">├── models  <span class="comment"># 目录  </span></span><br><span class="line">├── requirements.txt  </span><br><span class="line">├── static  </span><br><span class="line">└── views  <span class="comment"># 目录</span></span><br></pre></td></tr></table></figure>


<p>或者:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├── app.py  </span><br><span class="line">├── models.py  </span><br><span class="line">├── requirements.txt  </span><br><span class="line">├── static  </span><br><span class="line">└── views.py</span><br></pre></td></tr></table></figure>


<p><a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django官方网站</a>、<a href="https://github.com/miguelgrinberg/flasky" target="_blank" rel="noopener">《基于python的web应用开发实战》书中的项目flasky</a>、[Flask官方网站](<a href="https://github.com/pallets/flask-" target="_blank" rel="noopener">https://github.com/pallets/flask-</a><br>website)、[知名的Django API框架](<a href="https://github.com/tomchristie/django-rest-" target="_blank" rel="noopener">https://github.com/tomchristie/django-rest-</a><br>framework/)等项目都是这种命名原则。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM（Model View ViewModel）是一种基于前端开发的架构模式，但是会写前端页面的Python<br>Web开发显然也是有必要了解的。它的核心是提供对View和ViewModel的双向绑定，View和Model之间并没有直接的联系，而是通过ViewModel进行交互，View的变动，自动反映在ViewModel上，反之亦然，这样就保证视图和数据的一致性。<br>ViewModel是Model和View之间的桥梁，它的设计原则是：</p>
<ul>
<li>为Model和View提供适配</li>
<li>如果有需要转换的过程，尽可能在ViewModel中做，保持Model的纯洁，View的清晰。<br>现在比较流行的MVVM框架是Vue.js和AngularJS。不能不感叹下，前端太能玩了。<br>我为什么聊MVVM呢，其实是我注意到现在有一些现象：</li>
</ul>
<ol>
<li>一些后端兼写前端的同学还在用jQuery + Template的方式在开发。</li>
<li>一些没什么交互的、甚至还是多页面的网站上被用上了React、Vue等方案。<br>当然，黑猫白猫能抓老鼠就是好猫，我说的是没有用对地方。<br>现在前后端交互通常是如下流程：</li>
<li>用户要求获取界面上的数据</li>
<li>通过API向后端请求数据，后端计算完成返回</li>
<li>界面拿到数据进行重新渲染<br>我们设想一个复杂的场景下，有个页面需要后端的数据来生成界面，通过在界面的某些控件输入或者触发事件的方式重新获取数据变换成其他界面。注意，整个过程页面的URL没有发生跳转。<br>传统的类似jQuery + Template的方式有以下痛点：</li>
<li>开发者在代码中大量调用相同的DOM API, 处理繁琐，操作冗余，使得代码难以维护。</li>
<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>
<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致Model发生变化，开发者同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。<br>其实数据和界面的变更之间，一般都是存在对应关系的。如果能够引入一种绑定关系，经过一系列的配置过程，使得以后每次数据发生变更，界面都会自动跟着作对应变动；界面上的操作，也会自动更新到数据，那开发过程就会非常省事了，绝大部分此类操作都会转化为配置，供绑定框架用来建立数据和界面之间的关联关系。MVVM框架可以帮助你可以减少大量的DOM操作没提高渲染性能。<h3 id="随着前端组件化、MVVM框架的发展，后端模板引擎来还前途嘛？"><a href="#随着前端组件化、MVVM框架的发展，后端模板引擎来还前途嘛？" class="headerlink" title="随着前端组件化、MVVM框架的发展，后端模板引擎来还前途嘛？"></a>随着前端组件化、MVVM框架的发展，后端模板引擎来还前途嘛？</h3>我实际工作中很多内部用到类似后台的项目，大多设计成只用基本模板index.html，其中引用了由webpack编译react/vue源码生成的javascript文件的方式，后端提供API。但是并不代表后端模板的没落：</li>
<li>基于SEO的考虑。后台渲染，组装页面，对SEO最友好。由于Python后端无法用NodeJS那样的「Server Rendering」方案（发现是爬虫就服务端渲染，如果是正常请求在客户端渲染，缺点是多了服务端渲染的工作）。所以必须要有必要的数据使用后端模板引擎渲染。所以要注意真正适合做SPA(单页面应用)的应用，SEO没有什么意义，因为登陆才能用，一般只需要让一些市场营销的静态页面能被SEO就好了。所以担心的前提是有冲突的。</li>
<li>某些场景前端无法完成。比如导出文件、秒开（复杂效果的）首屏。</li>
<li>后端模板对后台开发更友好。Web开发中的模板部分只是其中一部分事情，职责划分上不可能那么清晰，所以后台开发当然更喜欢在不适合做SPA的应用上使用模板来完成和其他部分（比如Model和View的维护和更新）相关的对接工作。比如Python语言的Mako模板，简直就是在写Python。<br>所以大家还是得好好学Jinja2、Mako吧。<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><a href="https://www.zhihu.com/question/41559085" target="_blank" rel="noopener">在开发过程中如何应用mvvm思想（非现有的框架）？</a><br><a href="http://www.weidu8.net/wx/1003148042203243" target="_blank" rel="noopener">Vue.js 和 MVVM 的小细节</a></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python程序员Mac初始化环境</title>
    <url>/2016-02-19.html</url>
    <content><![CDATA[<p>####前言<br>早就想总结一篇python程序员的Mac配置笔记，趁这次就写一下我初始化的一些实践<br>####安装Xcode, Command line tools<br>作为开发者，肯定需要gcc,clang这些环境，Xcode界面也能下载Command line tools，但是下载好几次都有签名错误的问题，直接去官网下载<br>使用浏览器下载一段时间锁屏会停止下载，又不能续传。所以我还是习惯命令行下载.可以在这里找到<a href="https://github.com/orzrd/mytools/blob/master/adc_download.sh" target="_blank" rel="noopener">https://github.com/orzrd/mytools/blob/master/adc_download.sh</a><br>比如下载xcode:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./adc_download.sh http://adcdownload.apple.com/Developer_Tools/xcode_4<span class="number">.6</span><span class="number">.3</span>/xcode4630916281a.dmg</span><br></pre></td></tr></table></figure>


<p>####安装git<br>在这里 &lt;<a href="http://git-" target="_blank" rel="noopener">http://git-</a><br>scm.com/download/mac，但是你需要注意<a href="http://support.apple.com/kb/ht1633?viewlocale=zh_CN" target="_blank" rel="noopener">版本和你的os的版本的对应关系</a>&gt;<br>####安装brew-包管理工具</p>
<h5 id="以后我通过brew安装的软件都放在这个目录"><a href="#以后我通过brew安装的软件都放在这个目录" class="headerlink" title="以后我通过brew安装的软件都放在这个目录"></a>以后我通过brew安装的软件都放在这个目录</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo chown -R `whoami` /usr/local  </span><br><span class="line">git init  </span><br><span class="line">git remote add origin git://github.com/mxcl/homebrew.git  </span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>


<p>####安装一些常用工具</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">brew install wget the_silver_searcher tree tmux htop mysql autojump mongodb zsh-completions  </span><br><span class="line">sudo easy_install pip  </span><br><span class="line">sudo pip install virtualenv  </span><br><span class="line">sudo pip install virtualenvwrapper  </span><br><span class="line"><span class="comment"># 设置mysql和mongodb开机自启动  </span></span><br><span class="line">ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents   </span><br><span class="line">iln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgents</span><br></pre></td></tr></table></figure>


<p>####安装配置oh-my-zsh和dotfiles</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/robbyrussell/oh-my-zsh.git .oh-my-zsh  </span><br><span class="line">chsh -s /bin/zsh  </span><br><span class="line">git clone https://github.com/dongweiming/dotfiles.git ~/dotfiles  </span><br><span class="line">cd dotfiles  </span><br><span class="line">./install.sh vim</span><br></pre></td></tr></table></figure>


<p>####配置一个虚拟python环境</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export WORKON_HOME=~/envs  </span><br><span class="line">mkdir $WORKON_HOME -p  </span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh  </span><br><span class="line">mkvirtualenv --no-site-packages XXX <span class="comment"># 这里新建了一个叫做XXX的环境,并且不会依赖site-package，需要你在环境中自定义下载  </span></span><br><span class="line">pip install -r requirements.txt <span class="comment">#根据文件安装依赖</span></span><br></pre></td></tr></table></figure>


<p>#####<br>zshrc的配置可以看我的<a href="https://github.com/dongweiming/dotfiles/blob/master/_zshrc" target="_blank" rel="noopener">dotfiles</a>，我粘贴出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export ANTIGEN_DEFAULT_REPO_URL=https://github.com/dongweiming/oh-my-zsh         </span><br><span class="line">source ~/dotfiles/antigen/antigen.zsh                                            </span><br><span class="line">                                                                                 </span><br><span class="line">antigen use oh-my-zsh                                                            </span><br><span class="line">                                                                                 </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$&#123;OSTYPE:0:6&#125;"</span>=<span class="string">"darwin"</span> ]; then                                            </span><br><span class="line">  antigen-bundle osx                                                             </span><br><span class="line">  antigen-bundle brew                                                            </span><br><span class="line">  export PATH=$(brew --prefix ruby)/bin:$PATH:/usr/local/sbin:~/bin  </span><br><span class="line"><span class="keyword">else</span>                                                                             </span><br><span class="line">  export PATH=$PATH:~/bin                                                        </span><br><span class="line">fi                                                                               </span><br><span class="line">antigen bundles &lt;&lt;EOB                                                            </span><br><span class="line">  git-extras                                                                     </span><br><span class="line">  pip                                                                            </span><br><span class="line">  python                                                                         </span><br><span class="line">  autojump  </span><br><span class="line">  django                                                                         </span><br><span class="line">  ruby                                                                           </span><br><span class="line">  git-flow                                                                       </span><br><span class="line">  virtualenvwrapper                                                              </span><br><span class="line">  git                                                                            </span><br><span class="line">  github                                                                         </span><br><span class="line">  supervisor                                                                     </span><br><span class="line">  tmux                                                                           </span><br><span class="line">  vagrant                                                                        </span><br><span class="line">  history                                                                        </span><br><span class="line">  zsh-users/zsh-syntax-highlighting                                              </span><br><span class="line">  zsh-users/zaw                                                                  </span><br><span class="line">  zsh-users/zsh-history-substring-search                                         </span><br><span class="line">  ~/.oh-my-zsh --no-local-clone                                                  </span><br><span class="line">EOB                                                                              </span><br><span class="line">                                                                                 </span><br><span class="line">antigen theme sheerun/oh-my-zsh-powerline-theme powerline                       </span><br><span class="line">                                                                                 </span><br><span class="line">antigen apply                                                                    </span><br><span class="line">                                                                                 </span><br><span class="line">autoload -U zmv                                                                  </span><br><span class="line">export SSH_ASKPASS=<span class="string">""</span>                                                            </span><br><span class="line">alias rake=<span class="string">'noglob rake'</span>                                                         </span><br><span class="line">export WORKON_HOME=~/envs                                                        </span><br><span class="line">source `which virtualenvwrapper.sh`                                              </span><br><span class="line">alias social=<span class="string">'workon social;cd ~/social_master'</span>   </span><br><span class="line">alias ls=<span class="string">'ls -hF --color=auto'</span>  </span><br><span class="line">source ~/.oh-my-zsh/custom/powerline.zsh  </span><br><span class="line">zstyle <span class="string">':completion:*'</span> list-colors <span class="string">"$&#123;(s.:.)LS_COLORS&#125;"</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> keycode <span class="keyword">in</span> <span class="string">'['</span> <span class="string">'O'</span>; do  </span><br><span class="line">  bindkey <span class="string">"^[$&#123;keycode&#125;A"</span> history-substring-search-up  </span><br><span class="line">  bindkey <span class="string">"^[$&#123;keycode&#125;B"</span> history-substring-search-down  </span><br><span class="line">done  </span><br><span class="line">unset keycode  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># bind k and j for VI mode  </span></span><br><span class="line">bindkey -M vicmd <span class="string">'k'</span> history-substring-search-up  </span><br><span class="line">bindkey -M vicmd <span class="string">'j'</span> history-substring-search-down</span><br></pre></td></tr></table></figure>


<p>####安装coreutils</p>
<h5 id="Mac说白了就是freeBSD-一些插件的组合，所以常用工具例如ls-、grep也都是freeBSD版本-比如我使用rm删除文件-就必须rm"><a href="#Mac说白了就是freeBSD-一些插件的组合，所以常用工具例如ls-、grep也都是freeBSD版本-比如我使用rm删除文件-就必须rm" class="headerlink" title="Mac说白了就是freeBSD+一些插件的组合，所以常用工具例如ls 、grep也都是freeBSD版本,比如我使用rm删除文件,就必须rm"></a>Mac说白了就是freeBSD+一些插件的组合，所以常用工具例如ls 、grep也都是freeBSD版本,比如我使用rm删除文件,就必须rm</h5><p>-rf xx 而不能 rm xx -rf s实在脑残</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">brew install coreutils</span><br></pre></td></tr></table></figure>


<p>添加PATH到.zshrc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PATH=<span class="string">"$(brew --prefix coreutils)/libexec/gnubin:$PATH"</span>                             </span><br><span class="line">MANPATH=<span class="string">"$(brew --prefix coreutils)/libexec/gnuman:$MANPATH"</span></span><br></pre></td></tr></table></figure>


<p>####修改ls配色</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git clone git@github.com:seebi/dircolors-solarized.git  </span><br><span class="line"><span class="comment"># dircolors就在上面的coreutils中  </span></span><br><span class="line">echo <span class="string">'eval `dircolors ~/lib/dircolors-solarized/dircolors.256dark`'</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>


<p>####安装octopress-为我的博客 仅供参考</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 默认的ruby是1.8.7的，我想要2.0的  </span></span><br><span class="line">brew install ruby  </span><br><span class="line">gem install bundler  </span><br><span class="line">bundle install  </span><br><span class="line">bundle update rake <span class="comment">#安装的版本和octoress要求的9.2.2要高，所以需要升级  </span></span><br><span class="line">git clone https://github.com/imathis/octopress.git oc  </span><br><span class="line">cd oc  </span><br><span class="line"><span class="comment"># 为啥会有下面的一堆cp?其实是为了升级我的octopress  </span></span><br><span class="line">cp ../octopress/Rakefile .  </span><br><span class="line">cp ../octopress/_config.yml .  </span><br><span class="line">cp -rp ../octopress/source .  </span><br><span class="line"><span class="comment"># 以下是我自己写的几个脚本  </span></span><br><span class="line">cp ../octopress/plugins/pygments_code.rb plugins  </span><br><span class="line">cp ../octopress/plugins/shjs.rb plugins  </span><br><span class="line">cp ../octopress/plugins/tag_cloud.rb plugins  </span><br><span class="line">cp ../octopress/sass . -rp  </span><br><span class="line"><span class="comment"># 然后你就可以生成了  </span></span><br><span class="line">rake generate</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之模型接口</title>
    <url>/2016-02-21.html</url>
    <content><![CDATA[<p>看这篇文章前推荐阅读相关的如下文章：</p>
<ol>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">知乎Live全文搜索之模型设计和爬虫实现</a></li>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E4%BD%BF%E7%94%A8Elasticsearch%E5%81%9A%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">知乎Live全文搜索之使用Elasticsearch做聚合分析</a></li>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E4%BD%BF%E7%94%A8Elasticsearch%E5%81%9A%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE/" target="_blank" rel="noopener">知乎Live全文搜索之使用Elasticsearch做搜索建议</a></li>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E8%AE%A9elasticsearch_dsl%E6%94%AF%E6%8C%81asyncio/" target="_blank" rel="noopener">知乎Live全文搜索之让elasticsearch_dsl支持asyncio </a><br>在<a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E8%AE%A9elasticsearch_dsl%E6%94%AF%E6%8C%81asyncio/" target="_blank" rel="noopener">知乎Live全文搜索之让elasticsearch_dsl支持asyncio
</a>一文中，我把后端工作分成了4步，今天是完成爬虫和模型接口这2步，接口返回的数据会被微信小程序使用。<br>详细的列一下接口需求：</li>
<li>搜索。搜索符合输入的关键字的Live和用户，按照之前提到的各种策略排序，也支持通过status状态过滤「已结束」和「未结束」2种类型的Live。支持分页。</li>
<li>搜索建议。提供符合输入的关键字的Live的建议。</li>
<li>发现。把全部的Live按照之前提到的各种策略排序，可以通过各种字段排序，可以选择Live开始的时间范围（默认是全部）。</li>
<li>获取热门话题。</li>
<li>获取某话题详细信息及话题下的Live，支持分页、排序、时间范围。</li>
<li>获取全部用户，并且可以按照举办的Live数量、更新Live时间等条件排序。</li>
<li>获取单个用户信息。</li>
<li>根据各种策略排序，获取7天热门Live，非知乎排序。</li>
<li>根据各种策略排序，获取30天热门Live，非知乎排序。<h3 id="添加Topic模型"><a href="#添加Topic模型" class="headerlink" title="添加Topic模型"></a>添加Topic模型</h3>由于4和5的需求，我添加了Topic这个模型，上篇文章说过SQLite不支持并发，所以替换成了MySQL，要把config里面的DB_URI改成如下格式：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DB_URI = <span class="string">'mysql+pymysql://localhost/test?charset=utf8mb4'</span></span><br></pre></td></tr></table></figure>


<p>其中test是库的名字，charset要用utf8mb4，因为有些用户信息甚至Live的标题里面包含emoji。MySQL的客户端用的是PyMySQL，需要在schema上指出来。<br>Topic类和之前的User格式差不多，只是不同的字段，限于篇幅就不列出来了。</p>
<h3 id="实现用户相关方法"><a href="#实现用户相关方法" class="headerlink" title="实现用户相关方法"></a>实现用户相关方法</h3><p>为了实现可以按照举办的Live数量、更新Live时间排序，我添加了2个字段，也改了字符集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> SUGGEST_USER_LIMIT, PEOPLE_URL, LIVE_USER_URL  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span>  </span><br><span class="line">    __tablename__ = <span class="string">'users'</span>  </span><br><span class="line">    __table_args__ = &#123;  </span><br><span class="line">        <span class="string">'mysql_engine'</span>: <span class="string">'InnoDB'</span>,  </span><br><span class="line">        <span class="string">'mysql_charset'</span>: <span class="string">'utf8mb4'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    ...  </span><br><span class="line">    live_count = Column(Integer, default=<span class="number">0</span>)  </span><br><span class="line">    updated_time = Column(DateTime, default=datetime.now)</span><br></pre></td></tr></table></figure>


<p>接着添加一些必要的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incr_live_count</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.live_count += <span class="number">1</span>  </span><br><span class="line">        session.commit()  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">url</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> PEOPLE_URL.format(self.speaker_id)  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lives_url</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> LIVE_USER_URL.format(self.speaker_id)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        d = &#123;c.name: getattr(self, c.name, <span class="literal">None</span>)  </span><br><span class="line">             <span class="keyword">for</span> c <span class="keyword">in</span> self.__table__.columns&#125;  </span><br><span class="line">        d.update(&#123;  </span><br><span class="line">            <span class="string">'type'</span>: <span class="string">'user'</span>,  </span><br><span class="line">            <span class="string">'url'</span>: self.url,  </span><br><span class="line">            <span class="string">'lives_url'</span>: self.lives_url  </span><br><span class="line">        &#125;)  </span><br><span class="line">        <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>


<p>我习惯给model添加一个to_dict方法，把需要的字段和值拼成一个dict返回。当然有些API实际不需要这么多的字段，在下一篇中我会介绍怎么处理schema的问题。<br>最后是3个接口方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span>  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(cls, **kwargs)</span>:</span>  </span><br><span class="line">        speaker_id = kwargs.get(<span class="string">'speaker_id'</span>, <span class="literal">None</span>)  </span><br><span class="line">        r = <span class="literal">None</span>  </span><br><span class="line">        <span class="keyword">if</span> id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            q = session.query(cls).filter_by(speaker_id=speaker_id)  </span><br><span class="line">            r = q.first()  </span><br><span class="line">            <span class="keyword">if</span> r:  </span><br><span class="line">                q.update(kwargs)  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            r = cls(**kwargs)  </span><br><span class="line">            session.add(r)  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            session.commit()  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            session.rollback()  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> r  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">suggest</span><span class="params">(cls, q, start=<span class="number">0</span>, limit=SUGGEST_USER_LIMIT)</span>:</span>  </span><br><span class="line">        query = session.query(User)  </span><br><span class="line">        users = query.filter(User.name.like(<span class="string">'%&#123;&#125;%'</span>.format(q))).offset(  </span><br><span class="line">            start).limit(limit).all()  </span><br><span class="line">        <span class="keyword">return</span> [user.to_dict() <span class="keyword">for</span> user <span class="keyword">in</span> users]  </span><br><span class="line">          </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all</span><span class="params">(cls, order_by=<span class="string">'id'</span>, start=<span class="number">0</span>, limit=<span class="number">10</span>, desc=False)</span>:</span>  </span><br><span class="line">        <span class="string">'''  </span></span><br><span class="line"><span class="string">        :param order_by:  One of ``'id'``, ``'live_count'`` or  </span></span><br><span class="line"><span class="string">                          ``'updated_time'``  </span></span><br><span class="line"><span class="string">        '''</span>  </span><br><span class="line">        query = session.query(User)  </span><br><span class="line">        order_by = getattr(User, order_by)  </span><br><span class="line">        <span class="keyword">if</span> desc:  </span><br><span class="line">            order_by = _desc(order_by)  </span><br><span class="line">        users = query.order_by(order_by).offset(start).limit(limit).all()  </span><br><span class="line">        <span class="keyword">return</span> [user.to_dict() <span class="keyword">for</span> user <span class="keyword">in</span> users]</span><br></pre></td></tr></table></figure>


<p>需要注意add方法，其实叫做add_or_update更合适，需要使用session一定要commit才能提交数据。<br>sqlalchemy没有自带的suggest功能，只能用Like来实现。get_all方法就是上面第6个需求接口。</p>
<h3 id="完成Live模型字段"><a href="#完成Live模型字段" class="headerlink" title="完成Live模型字段"></a>完成Live模型字段</h3><p>首先道歉，之前我理解的自定义analyzer的用法是错误的，下面的才是正确的姿势：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.analysis <span class="keyword">import</span> CustomAnalyzer  </span><br><span class="line">  </span><br><span class="line">ik_analyzer = CustomAnalyzer(  </span><br><span class="line">    <span class="string">'ik_analyzer'</span>, tokenizer=<span class="string">'ik_max_word'</span>,  </span><br><span class="line">    filter=[<span class="string">'lowercase'</span>]  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>tokenizer字段是必选的，这里使用ik分词插件提供的ik_max_word。我还给Live添加了2个字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    cover = Text(index=<span class="string">'not_analyzed'</span>)  <span class="comment"># 对应专栏头图(如果有)  </span></span><br><span class="line">    zhuanlan_url = Text(index=<span class="string">'not_analyzed'</span>) <span class="comment"># 对应专栏地址</span></span><br></pre></td></tr></table></figure>


<p>加上参数<code>index=&#39;not_analyzed&#39;</code>是因为这2个字段不用于搜索和聚合，没必要分词，就当成数据库使用了。<br>也给Live添加一些属性和方法，方便最后用to_dict()生成需要的全部数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> .speaker <span class="keyword">import</span> User, session  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">id</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> self._id  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speaker</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> session.query(User).get(self.speaker_id)  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">url</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> LIVE_URL.format(self.id)  </span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>  </span><br><span class="line">        index = <span class="string">'live130'</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self, include_extended=True)</span>:</span>  </span><br><span class="line">        d = super().to_dict()  </span><br><span class="line">        <span class="keyword">if</span> include_extended:  </span><br><span class="line">            d.update(&#123;  </span><br><span class="line">                <span class="string">'id'</span>: self._id,  </span><br><span class="line">                <span class="string">'type'</span>: <span class="string">'live'</span>,  </span><br><span class="line">                <span class="string">'speaker'</span>: self.speaker.to_dict(),  </span><br><span class="line">                <span class="string">'url'</span>: self.url  </span><br><span class="line">            &#125;)  </span><br><span class="line">        <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>


<p>其中speaker属性是常见的关联多个model的快捷方式，但是需要注意，竟然不要设计成A的model里面某个方法返回了B的model数据，B的model里面也返回了A的model的数据而造成只能进行方法内import。<br>用<code>super().to_dict()</code>的原因是DocType内置了to_dict方法，随便提一下，而且接收include_meta参数，为True会包含index和doc_type的元数据。</p>
<h3 id="把Live设计成异步的"><a href="#把Live设计成异步的" class="headerlink" title="把Live设计成异步的"></a>把Live设计成异步的</h3><p>这个是今天的重点，昨天说的「让elasticsearch_dsl支持asyncio」就是给今天做准备。换汤不换药，说白了就是在合适的地方添加async/await关键字，先看个add的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(cls, **kwargs)</span>:</span>  </span><br><span class="line">        id = kwargs.pop(<span class="string">'id'</span>, <span class="literal">None</span>)  </span><br><span class="line">        <span class="keyword">if</span> id <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">        live = cls(meta=&#123;<span class="string">'id'</span>: int(id)&#125;, **kwargs)  </span><br><span class="line">        <span class="keyword">await</span> live.save()  </span><br><span class="line">        <span class="keyword">return</span> live</span><br></pre></td></tr></table></figure>


<p>现在我们挨个实现需求，首先是搜索接口，由于DocType包含了search方法，得换个名字了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(cls, s, order_by=None)</span>:</span>  </span><br><span class="line">        <span class="comment"># 可以选择字段的排序，前面加-表示desc，不加就是默认的asc   </span></span><br><span class="line">        <span class="keyword">if</span> order_by <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            s = s.sort(order_by)  </span><br><span class="line">        lives = <span class="keyword">await</span> s.execute()  <span class="comment"># 执行，要在这步之前拼好查询条件  </span></span><br><span class="line">        <span class="keyword">return</span> [live.to_dict() <span class="keyword">for</span> live <span class="keyword">in</span> lives]  </span><br><span class="line">          </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply_weight</span><span class="params">(cls, s, start, limit)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> s.query(Q(<span class="string">'function_score'</span>, functions=[gauss_sf, log_sf])).extra(  </span><br><span class="line">            **&#123;<span class="string">'from'</span>: start, <span class="string">'size'</span>: limit&#125;)  </span><br><span class="line">           </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">ik_search</span><span class="params">(cls, query, status=None, start=<span class="number">0</span>, limit=<span class="number">10</span>)</span>:</span>  </span><br><span class="line">        s = cls.search()  </span><br><span class="line">        <span class="comment"># 多字段匹配要搜索的内容，SEARCH_FIELDS中不同字段权重不同  </span></span><br><span class="line">        s = s.query(<span class="string">'multi_match'</span>, query=query,  </span><br><span class="line">                    fields=SEARCH_FIELDS)  </span><br><span class="line">        <span class="keyword">if</span> status <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 根据结束状态过滤  </span></span><br><span class="line">            s = s.query(<span class="string">'match'</span>, status=status)  </span><br><span class="line">        <span class="comment"># 搜索是带权重的，按照之前的设计做了时间衰减和归一化  </span></span><br><span class="line">        s = cls.apply_weight(s, start, limit)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> cls._execute(s)</span><br></pre></td></tr></table></figure>


<p>就是根据需求，按照DSL的方式来拼。我添加了些注释，看不懂的话可以按照文章开始的链接去找找答案。<br>然后是发现接口，7/30天热门都是基于这个接口，只不过划定了时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">      </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">explore</span><span class="params">(cls, from_date=None, to_date=None, order_by=None,  </span></span></span><br><span class="line"><span class="function"><span class="params">                      start=<span class="number">0</span>, limit=<span class="number">10</span>, topic=None)</span>:</span>  </span><br><span class="line">        s = cls.search()  </span><br><span class="line">        <span class="keyword">if</span> topic <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            s = s.query(Q(<span class="string">'term'</span>, topic_names=topic))  </span><br><span class="line">        starts_at = &#123;&#125;  </span><br><span class="line">        <span class="keyword">if</span> from_date <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            starts_at[<span class="string">'from'</span>] = from_date  </span><br><span class="line">        <span class="keyword">if</span> to_date <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            starts_at[<span class="string">'to'</span>] = to_date  </span><br><span class="line">        <span class="keyword">if</span> starts_at:  </span><br><span class="line">            s = s.query(Q(<span class="string">'range'</span>, starts_at=starts_at))  </span><br><span class="line">        <span class="keyword">if</span> order_by <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            s = cls.apply_weight(s, start, limit)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> cls._execute(s, order_by)  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_hot_weekly</span><span class="params">(cls)</span>:</span>  </span><br><span class="line">        today = date.today()  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> cls.explore(from_date=today - timedelta(days=<span class="number">7</span>),  </span><br><span class="line">                                  to_date=today, limit=<span class="number">20</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_hot_monthly</span><span class="params">(cls)</span>:</span>  </span><br><span class="line">        today = date.today()  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> cls.explore(from_date=today - timedelta(days=<span class="number">30</span>),  </span><br><span class="line">                                 to_date=today, limit=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>


<p>注意，explore方法如果指定了排序方案，就不会添加时间衰减和归一化的处理了。<br>然后是获取用户举报的全部Live的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">ik_search_by_speaker_id</span><span class="params">(cls, speaker_id, order_by=<span class="string">'-starts_at'</span>)</span>:</span>  </span><br><span class="line">        s = cls.search()  </span><br><span class="line">        s = s.query(Q(<span class="string">'bool'</span>, should=Q(<span class="string">'match'</span>, speaker_id=speaker_id)))  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> cls._execute(s, order_by)</span><br></pre></td></tr></table></figure>


<p>可以看到_execute方法抽象后被重复利用了。<br>再然后是suggest接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">ik_suggest</span><span class="params">(cls, query, size=<span class="number">10</span>)</span>:</span>  </span><br><span class="line">        s = cls.search()  </span><br><span class="line">        s = s.suggest(<span class="string">'live_suggestion'</span>, query, completion=&#123;  </span><br><span class="line">            <span class="string">'field'</span>: <span class="string">'live_suggest'</span>, <span class="string">'fuzzy'</span>: &#123;<span class="string">'fuzziness'</span>: <span class="number">2</span>&#125;, <span class="string">'size'</span>: size  </span><br><span class="line">        &#125;)  </span><br><span class="line">        suggestions = <span class="keyword">await</span> s.execute_suggest()  </span><br><span class="line">        matches = suggestions.live_suggestion[<span class="number">0</span>].options  </span><br><span class="line">        ids = [match._id <span class="keyword">for</span> match <span class="keyword">in</span> matches]  </span><br><span class="line">        lives = <span class="keyword">await</span> Live.mget(ids)  </span><br><span class="line">        <span class="keyword">return</span> [live.to_dict() <span class="keyword">for</span> live <span class="keyword">in</span> lives]</span><br></pre></td></tr></table></figure>


<p>其中支持2个编辑距离的模糊搜索。这个实现的比较简单，没有考虑拼音，也没有考虑搜索用户。值得一提的是DocType提供了mget这个获取多个id的接口，请善用减少网络请求，也就是给ES后端减压。<br>第4个获得热门话题的需求是本项目唯一用到聚合功能的地方了:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> .topic <span class="keyword">import</span> Topic  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_hot_topics</span><span class="params">(cls, size=<span class="number">50</span>)</span>:</span>  </span><br><span class="line">        s = cls.search()  </span><br><span class="line">        s.aggs.bucket(<span class="string">'topics'</span>, A(<span class="string">'terms'</span>, field=<span class="string">'topics'</span>, size=size))  </span><br><span class="line">        rs = <span class="keyword">await</span> s.execute()  </span><br><span class="line">        buckets = rs.aggregations.topics.buckets  </span><br><span class="line">        topic_names = [r[<span class="string">'key'</span>] <span class="keyword">for</span> r <span class="keyword">in</span> buckets]  </span><br><span class="line">        topics = session.query(Topic).filter(Topic.name.in_(topic_names)).all()  </span><br><span class="line">        topics = sorted(topics, key=<span class="keyword">lambda</span> t: topic_names.index(t.name))  </span><br><span class="line">        <span class="keyword">return</span> [topic.to_dict() <span class="keyword">for</span> topic <span class="keyword">in</span> topics]</span><br></pre></td></tr></table></figure>


<p>每个Live都会打话题标签，越多的live打这个话题就说明它越热门。<br>最后要说的是init()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">await</span> Live.init()</span><br></pre></td></tr></table></figure>


<p>原来import模块的时候直接就init了，现在由于异步化了，直接init没人所以要在loop中用，比如在爬虫中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> models.live <span class="keyword">import</span> init <span class="keyword">as</span> live_init  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    loop = asyncio.get_event_loop()  </span><br><span class="line">    crawler = Crawler()  </span><br><span class="line">    loop.run_until_complete(live_init())  </span><br><span class="line">    loop.run_until_complete(crawler.crawl())  </span><br><span class="line">    print(<span class="string">'Finished in &#123;:.3f&#125; secs'</span>.format(crawler.t1 - crawler.t0))  </span><br><span class="line">    crawler.close()  </span><br><span class="line">  </span><br><span class="line">    loop.close()  </span><br><span class="line">    es.transport.close()</span><br></pre></td></tr></table></figure>


<p>理解了嘛？<br>好了全部接口都完成了，但是大家有木有感觉，异步编程调试起来很麻烦，我来教一个好用的方法.</p>
<h3 id="调试async程序"><a href="#调试async程序" class="headerlink" title="调试async程序"></a>调试async程序</h3><p>asyncio要求把需要协程化的函数都放进一个loop，通过run_until_complete方法让它执行完成。<br>但是现在非常不好玩：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> models <span class="keyword">import</span> Live  </span><br><span class="line">In : live = Live.get(<span class="number">789840559912009728</span>)  </span><br><span class="line">  </span><br><span class="line">In : live  </span><br><span class="line">Out: &lt;coroutine object DocType.get at <span class="number">0x10a0d1fc0</span>&gt;  </span><br><span class="line">  </span><br><span class="line">In : live.subject  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">AttributeError                            Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-4</span><span class="number">-8</span>c237874146c&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 live.subject  </span><br><span class="line">  </span><br><span class="line">AttributeError: <span class="string">'coroutine'</span> object has no attribute <span class="string">'subject'</span></span><br></pre></td></tr></table></figure>


<p>异步化的函数(方法)用起来很不直观。一开始可以写个脚本把要调试的东西放进去用(test_es.py)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.connections <span class="keyword">import</span>  connections  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> models.live <span class="keyword">import</span> Live, SEARCH_FIELDS, init <span class="keyword">as</span> live_init  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">s = Live.search()  </span><br><span class="line">es = connections.get_connection(Live._doc_type.using)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">()</span>:</span>  </span><br><span class="line">    rs = <span class="keyword">await</span> s.query(<span class="string">'multi_match'</span>, query=<span class="string">'python'</span>,  </span><br><span class="line">                       fields=SEARCH_FIELDS).execute()  </span><br><span class="line">    print(rs)  </span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">loop.run_until_complete(live_init())  </span><br><span class="line">loop.run_until_complete(print_info())  </span><br><span class="line">loop.close()  </span><br><span class="line">es.transport.close()</span><br></pre></td></tr></table></figure>


<p>这样也是可以调试的，很麻烦，对吧？<br>抽象一下，其实写个函数就好了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(coro)</span>:</span>  </span><br><span class="line">    loop = asyncio.get_event_loop()  </span><br><span class="line">    rs = loop.run_until_complete(coro)  </span><br><span class="line">    <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>


<p>OK, 再用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> models <span class="keyword">import</span> Live, execute  </span><br><span class="line">In : live = Live.get(<span class="number">789840559912009728</span>)  </span><br><span class="line">In : live = execute(live)  </span><br><span class="line">In : live.subject  </span><br><span class="line">Out: <span class="string">'Python 工程师的入门和进阶'</span></span><br></pre></td></tr></table></figure>


<p>这样就方便多了。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>跨操作系统初始化安装工具(laptop)</title>
    <url>/2016-02-22.html</url>
    <content><![CDATA[<p>####前言<br>上周看了<a href="https://github.com/docopt/docopt" target="_blank" rel="noopener">docopt</a>,<br>感想很多。最近因为工作需要用opensuse，用ubuntu，个人pc用gentoo，<br>实在够折腾，每个系统都要相应的安装那些软件，搭建环境。早就想好好整理下思路，更geek的做这件事情。上段时间还看了个<br><a href="https://github.com/thoughtbot/laptop" target="_blank" rel="noopener">laptop</a>,觉得能力很一般，但是fork真不少。但是确实这个想法很不错，很有必要。<br>然后周末就构思了我的<a href="https://github.com/orzrd/laptop.git" target="_blank" rel="noopener">laptop</a><br>####它的特性</p>
<ul>
<li>记录操作记录，当某处出现故障，下次会从这个位置继续执行，而不需要全部执行一遍</li>
<li>受<a href="https://github.com/docopt/docopt" target="_blank" rel="noopener">docopt</a>启发，根据我特定的语法写配置文件，不需要修改初始化脚本initialize.sh</li>
<li>只需要添加你要安装的软件包的安装命令（使用包管理器的就需要修改相应操作系统的install文件）</li>
<li>支持对已安装软件的确认，不再安装而跳过</li>
<li>根据特定语法打印安装过程的提示</li>
<li>提供绿色，红色的asciilinux终端显示字体</li>
<li>执行在没有git等环境下git clone项目安装<br>####目前每个版本会安装那些软件？</li>
<li>gcc|g++|automake</li>
<li>tmux|htop|dstat</li>
<li>ruby|python|python库|expect</li>
<li>zsh|oh-my-zsh</li>
<li>easy_install|pip</li>
<li>django|torando|flask</li>
<li>nginx|uwsgi</li>
<li>redis|mongodb</li>
<li>mit-scheme|commonlisp</li>
<li>emacs</li>
<li>gitflow</li>
<li>celery</li>
<li>colout</li>
<li>MySQLdb|pymongo</li>
<li>taglist</li>
<li>gevent|twisted</li>
<li>the_silver_searcher</li>
<li>检查vim是否自带python/ruby支持，否则下载编译一个执行的版本</li>
<li>我的常用脚本<a href="https://github.com/orzrd/mytools.github" target="_blank" rel="noopener">mytools</a>,目前包含一个expect脚本和orzdba</li>
<li>我的<a href="https://github.com/dongweiming/dotfiles.git" target="_blank" rel="noopener">dotfiles</a><h2 id="gentoo系统一些软件"><a href="#gentoo系统一些软件" class="headerlink" title="gentoo系统一些软件"></a>gentoo系统一些软件</h2></li>
<li>gentoolkit|module-rebuild|genlop|eix|euses|elogv</li>
<li>fcitx</li>
<li>iproute2|netkit-telnetd<br>####使用方法</li>
</ul>
<ol>
<li>有git的情况：</li>
</ol>
<pre><code>shell&gt;git clone &lt;https://github.com/orzrd/laptop&gt;  
shell&gt;cd laptop  
shell&gt;bash initialize.sh  </code></pre><ol start="2">
<li>没有git的情况：</li>
</ol>
<pre><code>shell&gt;bash &lt;(curl -s &lt;https://raw.github.com/orzrd/laptop/master/setup_laptop&gt;)  </code></pre><p>#####脚本语法</p>
<h2 id="可操作文件"><a href="#可操作文件" class="headerlink" title="可操作文件"></a>可操作文件</h2><ol>
<li>common.install: 用户自定义的软件安装脚本，推荐非操作系统包管理器的都放在这里，注意逻辑顺序</li>
<li>opensuse/ubuntu/gentoo.install: 相应系统的安装脚本，这个只需要修改，我的脚本会自动根据系统信息找到</li>
<li>initialize.sh： 假如你想把需要我的安装方法，添加功能等，修改他，他是主入口</li>
<li>setup_laptop： 当用户没有git环境不能git clone 直接远程curl我，主要是下载git，clone我的laptop</li>
<li>‘#’ 以’#’开头的行表示这个信息会被安装过程以绿色字体打印，提示一下你要安装的东西等</li>
<li>： 以’:’开头的行，表示后面的字符串是个命令，也就是检查这个软件包有没有被安装需要的，假如which找到了路径说明被安装</li>
<li>; 以’;’开头的行为注释</li>
<li>其它行就是要执行的语句，请不要当作shell注释等，因为他会把你写的东西当成要执行的命令<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2></li>
</ol>
<ul>
<li>文件下载后就不需要再下载而直接使用</li>
<li>在执行某软件的安装过程中其他进程继续下载其他软件包（也就是实现shell版本的emerge）</li>
<li>进度条或者python_koans的提示已完成/剩余，更多的异常处理等</li>
<li>更多的异常处理</li>
<li>打印彩色字体内容嵌其他颜色字体（比如提示出错，高亮错误的原因或者软件包）<h2 id="注意我的项目地址，欢迎各种fork，pull-request，issue"><a href="#注意我的项目地址，欢迎各种fork，pull-request，issue" class="headerlink" title="注意我的项目地址，欢迎各种fork，pull request，issue"></a>注意我的项目地址，欢迎各种fork，pull request，issue</h2>###<a href="https://github.com/orzrd/laptop" target="_blank" rel="noopener">https://github.com/orzrd/laptop</a></li>
</ul>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐wtfPython:一组有趣的、微妙的、复杂的Python代码片段</title>
    <url>/2016-02-23.html</url>
    <content><![CDATA[<p><a href="https://github.com/satwikkansal/wtfPython" target="_blank" rel="noopener">wtfPython</a>就是「What the f*ck Python?<br>」的意思，这个项目列举了一些代码片段，可能结果和你想到的是不一致的，并且作者会告诉你为什么。本来将展示最有意义的一部分：</p>
<h3 id="混合Tab和空格"><a href="#混合Tab和空格" class="headerlink" title="混合Tab和空格"></a>混合Tab和空格</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span>  </span><br><span class="line">    sum_so_far = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> counter <span class="keyword">in</span> range(x):  </span><br><span class="line">        sum_so_far = sum_so_far + x  </span><br><span class="line">	<span class="keyword">return</span> sum_so_far  </span><br><span class="line">  </span><br><span class="line">print(square(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>


<p>结果是10？？不是应该100么？<br>其实这种错误的结果的原因，所有书籍和开发者都说过，就是不要混Tab和空格，源代码你可以看项目中的mixed_tabs_and_spaces.py。</p>
<h3 id="字典键的隐式转换"><a href="#字典键的隐式转换" class="headerlink" title="字典键的隐式转换"></a>字典键的隐式转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: some_dict = &#123;&#125;  </span><br><span class="line">   ...: some_dict[<span class="number">5.5</span>] = <span class="string">"Ruby"</span>  </span><br><span class="line">   ...: some_dict[<span class="number">5.0</span>] = <span class="string">"JavaScript"</span>  </span><br><span class="line">   ...: some_dict[<span class="number">5</span>] = <span class="string">"Python"</span>  </span><br><span class="line">   ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: some_dict[<span class="number">5.5</span>]  </span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'Ruby'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: some_dict[<span class="number">5.0</span>]  </span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">'Python'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: some_dict[<span class="number">5</span>]  </span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">'Python'</span></span><br></pre></td></tr></table></figure>


<p>这样的原因是键被隐式的转换了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: hash(<span class="number">5</span>) == hash(<span class="number">5.0</span>)  </span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h3 id="生成器执行时间的差异"><a href="#生成器执行时间的差异" class="headerlink" title="生成器执行时间的差异"></a>生成器执行时间的差异</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: array = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>]  </span><br><span class="line">   ...: g = (x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> array.count(x) &gt; <span class="number">0</span>)  </span><br><span class="line">   ...: array = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">22</span>]  </span><br><span class="line">   ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: print(list(g))  </span><br><span class="line">[<span class="number">8</span>]</span><br></pre></td></tr></table></figure>


<p>这种隐式的非预期结果在实际开发中是可能出现的。原因是in的操作是在申明时求值的，而if是在运行期求值的。</p>
<h3 id="在字典迭代时修改该字典"><a href="#在字典迭代时修改该字典" class="headerlink" title="在字典迭代时修改该字典"></a>在字典迭代时修改该字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: x = &#123;<span class="number">0</span>: <span class="literal">None</span>&#125;  </span><br><span class="line">   ...:  </span><br><span class="line">   ...: <span class="keyword">for</span> i <span class="keyword">in</span> x:  </span><br><span class="line">   ...:     <span class="keyword">del</span> x[i]  </span><br><span class="line">   ...:     x[i+<span class="number">1</span>] = <span class="literal">None</span>  </span><br><span class="line">   ...:     print(i)  </span><br><span class="line">   ...:</span><br></pre></td></tr></table></figure>


<p>首先说的时候在迭代过程中是不能修改字典的长度的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> x:  </span><br><span class="line">    ...:     <span class="keyword">del</span> x[i]  </span><br><span class="line">    ...:  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">RuntimeError                              Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-13</span>-a5c6e73be64f&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 for i in x:  </span><br><span class="line">      <span class="number">2</span>     <span class="keyword">del</span> x[i]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">RuntimeError: dictionary changed size during iteration</span><br></pre></td></tr></table></figure>


<p>但是删掉一个添加一个是可以的。运行了5次才结束是因为字典会定期重新设置以便接受更多的键，但是和项目中的运行8次是不一样的。</p>
<h3 id="在列表迭代时删除条目"><a href="#在列表迭代时删除条目" class="headerlink" title="在列表迭代时删除条目"></a>在列表迭代时删除条目</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: list_1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">    ...: list_2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">    ...: list_3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">    ...: list_4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">    ...:  </span><br><span class="line">    ...: <span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(list_1):  </span><br><span class="line">    ...:     <span class="keyword">del</span> item  </span><br><span class="line">    ...:  </span><br><span class="line">    ...: <span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(list_2):  </span><br><span class="line">    ...:     list_2.remove(item)  </span><br><span class="line">    ...:  </span><br><span class="line">    ...: <span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(list_3[:]):  </span><br><span class="line">    ...:     list_3.remove(item)  </span><br><span class="line">    ...:  </span><br><span class="line">    ...: <span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(list_4):  </span><br><span class="line">    ...:     list_4.pop(idx)  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">15</span>]: list_1, list_2  </span><br><span class="line">Out[<span class="number">15</span>]: ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>])  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">16</span>]: list_3, list_4  </span><br><span class="line">Out[<span class="number">16</span>]: ([], [<span class="number">2</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>


<p>其中只有list_3是正确的行为。但是为什么会出现[2, 4]的结果呢？第一次删掉了index是0的1，就剩[2, 3, 4]，然后移除index 1,<br>就是3，剩下了[2, 4]，但是现在只有2个元素，循环就结束了。</p>
<h3 id="is"><a href="#is" class="headerlink" title="is"></a>is</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  </span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  </span><br><span class="line"><span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>; b = <span class="number">257</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


<p><code>is</code>用来对比身份，而<code>==</code>用来对比值。通常is为True，==就是True，但是反之不一定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[] == []  </span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[] <span class="keyword">is</span> [] <span class="comment"># 2个列表使用了不同的内存位置  </span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<p>上面的例子中，-5 - 256由于太经常使用，所以设计成固定存在的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">256</span>)  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">257</span>)  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">257</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">257</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(x)  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(y)</span><br></pre></td></tr></table></figure>


<h3 id="is-not-…-和-is-not-…"><a href="#is-not-…-和-is-not-…" class="headerlink" title="is not … 和 is (not …)"></a>is not … 和 is (not …)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'something'</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>  </span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'something'</span> <span class="keyword">is</span> (<span class="keyword">not</span> <span class="literal">None</span>)  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<p>其中(not None)优先执行，最后其实变成了<code>&#39;something&#39; is True</code></p>
<h3 id="循环中的函数也会输出到相同的输出"><a href="#循环中的函数也会输出到相同的输出" class="headerlink" title="循环中的函数也会输出到相同的输出"></a>循环中的函数也会输出到相同的输出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: funcs = []  </span><br><span class="line">    ...: results = []  </span><br><span class="line">    ...: <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):  </span><br><span class="line">    ...:     <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">()</span>:</span>  </span><br><span class="line">    ...:         <span class="keyword">return</span> x  </span><br><span class="line">    ...:     funcs.append(some_func)  </span><br><span class="line">    ...:     results.append(some_func())  </span><br><span class="line">    ...:  </span><br><span class="line">    ...: funcs_results = [func() <span class="keyword">for</span> func <span class="keyword">in</span> funcs]  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">18</span>]: results, funcs_results  </span><br><span class="line">Out[<span class="number">18</span>]: ([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>


<p>我之前在[Expert-Python](<a href="https://github.com/dongweiming/Expert-" target="_blank" rel="noopener">https://github.com/dongweiming/Expert-</a><br>Python)这个PPT中介绍过「开发陷阱，闭包变量绑定」，其实这个例子就是因为这个问题。解决方法就是把循环的变量传到some_func里面去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: funcs = []  </span><br><span class="line">    ...: <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):  </span><br><span class="line">    ...:     <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(x=x)</span>:</span>  </span><br><span class="line">    ...:         <span class="keyword">return</span> x  </span><br><span class="line">    ...:     funcs.append(some_func)  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">20</span>]: [func() <span class="keyword">for</span> func <span class="keyword">in</span> funcs]  </span><br><span class="line">Out[<span class="number">20</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>


<h3 id="循环中的局部变量泄露"><a href="#循环中的局部变量泄露" class="headerlink" title="循环中的局部变量泄露"></a>循环中的局部变量泄露</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)])  </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, <span class="string">': x in global'</span>)  </span><br><span class="line">(<span class="number">4</span>, <span class="string">': x in global'</span>)</span><br></pre></td></tr></table></figure>


<p>在Python 2中x的值在一个循环执行之后被改变了。不过再Python 3这个问题解决了。</p>
<h3 id="可变默认参数"><a href="#可变默认参数" class="headerlink" title="可变默认参数"></a>可变默认参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(default_arg=[])</span>:</span>  </span><br><span class="line">   ...:     default_arg.append(<span class="string">"some_string"</span>)  </span><br><span class="line">   ...:     <span class="keyword">return</span> default_arg  </span><br><span class="line">   ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: some_func()  </span><br><span class="line">Out[<span class="number">2</span>]: [<span class="string">'some_string'</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: some_func()  </span><br><span class="line">Out[<span class="number">3</span>]: [<span class="string">'some_string'</span>, <span class="string">'some_string'</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: some_func([])  </span><br><span class="line">Out[<span class="number">4</span>]: [<span class="string">'some_string'</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: some_func()  </span><br><span class="line">Out[<span class="number">5</span>]: [<span class="string">'some_string'</span>, <span class="string">'some_string'</span>, <span class="string">'some_string'</span>]</span><br></pre></td></tr></table></figure>


<p>在[Expert-Python](<a href="https://github.com/dongweiming/Expert-" target="_blank" rel="noopener">https://github.com/dongweiming/Expert-</a><br>Python)这个PPT中同样介绍过。Python是引用传递，上面例子的参数是一个列表，它所指向的对象可以被修改。通用的解决办法是在函数内判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(default_arg=None)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> default_arg:  </span><br><span class="line">        default_arg = []  </span><br><span class="line">    default_arg.append(<span class="string">"some_string"</span>)  </span><br><span class="line">    <span class="keyword">return</span> default_arg</span><br></pre></td></tr></table></figure>


<h3 id="和-的差别"><a href="#和-的差别" class="headerlink" title="+ 和 +=的差别"></a>+ 和 +=的差别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = a + [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b  </span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b  </span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>


<p>通常的运算过程，区别就是a = a + X 和 a += X。这是因为<code>a = a + X</code>是重新创建一个对象a，而<code>a +=
X</code>是在a这个list上面做extend操作。</p>
<h3 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: another_tuple = ([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>])  </span><br><span class="line">   ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: another_tuple[<span class="number">2</span>].append(<span class="number">1000</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">8</span>]: another_tuple  </span><br><span class="line">Out[<span class="number">8</span>]: ([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1000</span>])  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">9</span>]: another_tuple[<span class="number">2</span>] += [<span class="number">99</span>, <span class="number">999</span>]  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-9</span>-d07c65f24a63&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 another_tuple[2] += [99, 999]  </span><br><span class="line">  </span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">10</span>]: another_tuple  </span><br><span class="line">Out[<span class="number">10</span>]: ([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1000</span>, <span class="number">99</span>, <span class="number">999</span>])</span><br></pre></td></tr></table></figure>


<p>在我们的印象里面元组是不可变的呀？其实我之前还专门写过一篇<a href="https://mp.weixin.qq.com/s?__biz=MzA3NDk1NjI0OQ==&mid=2247483930&idx=1&sn=ec52f6f0551a0c66baa5008d4cabf38c&chksm=9f76aeaca80127ba46aee8ae5ad446b93062f84cc1feeb1992e003c6ac7c7b32b3d0ce6ac96e#rd" target="_blank" rel="noopener">Python元组的赋值谜题</a>讲这个问题，简单的说对list的赋值成功了，但是赋值失败了，不过由于值是引用的，所以才会出现这个执行失败实际成功的效果。</p>
<h3 id="使用在范围内未定义的变量"><a href="#使用在范围内未定义的变量" class="headerlink" title="使用在范围内未定义的变量"></a>使用在范围内未定义的变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: a = <span class="number">1</span>  </span><br><span class="line">    ...: <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">()</span>:</span>  </span><br><span class="line">    ...:     <span class="keyword">return</span> a  </span><br><span class="line">    ...:  </span><br><span class="line">    ...: <span class="function"><span class="keyword">def</span> <span class="title">another_func</span><span class="params">()</span>:</span>  </span><br><span class="line">    ...:     a += <span class="number">1</span>  </span><br><span class="line">    ...:     <span class="keyword">return</span> a  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">12</span>]: some_func()  </span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">13</span>]: another_func()  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">UnboundLocalError                         Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-13</span><span class="number">-703</span>bd168975f&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 another_func()  </span><br><span class="line">  </span><br><span class="line">&lt;ipython-input<span class="number">-11</span>-cff7ceae4600&gt; <span class="keyword">in</span> another_func()  </span><br><span class="line">  </span><br><span class="line">      <span class="number">5</span> <span class="function"><span class="keyword">def</span> <span class="title">another_func</span><span class="params">()</span>:</span>  </span><br><span class="line">----&gt; 6     a += 1  </span><br><span class="line">      <span class="number">7</span>     <span class="keyword">return</span> a  </span><br><span class="line">  </span><br><span class="line">UnboundLocalError: local variable <span class="string">'a'</span> referenced before assignment</span><br></pre></td></tr></table></figure>


<p>这是由于在another_func中的赋值操作会把a变成一个本地变量，但是在相同范围内并没有初始化它。如果希望它能正确运行可以加global：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: <span class="function"><span class="keyword">def</span> <span class="title">another_func</span><span class="params">()</span>:</span>  </span><br><span class="line">    ...:     <span class="keyword">global</span> a  </span><br><span class="line">    ...:     a += <span class="number">1</span>  </span><br><span class="line">    ...:     <span class="keyword">return</span> a  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">18</span>]: another_func()  </span><br><span class="line">Out[<span class="number">18</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure>


<h3 id="使用finally的return"><a href="#使用finally的return" class="headerlink" title="使用finally的return"></a>使用finally的return</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">()</span>:</span>  </span><br><span class="line">    ...:     <span class="keyword">try</span>:  </span><br><span class="line">    ...:         <span class="keyword">return</span> <span class="string">'from_try'</span>  </span><br><span class="line">    ...:     <span class="keyword">finally</span>:  </span><br><span class="line">    ...:         <span class="keyword">return</span> <span class="string">'from_finally'</span>  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">20</span>]: some_func()  </span><br><span class="line">Out[<span class="number">20</span>]: <span class="string">'from_finally'</span></span><br></pre></td></tr></table></figure>


<p>try…finally这种写法里面，finally中的return语句永远是最后一个执行</p>
<h3 id="忽略类范围的名称解析"><a href="#忽略类范围的名称解析" class="headerlink" title="忽略类范围的名称解析"></a>忽略类范围的名称解析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: x = <span class="number">5</span>  </span><br><span class="line">    ...: <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span>  </span><br><span class="line">    ...:     x = <span class="number">17</span>  </span><br><span class="line">    ...:     y = (x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">22</span>]: list(SomeClass.y)[<span class="number">0</span>]  </span><br><span class="line">Out[<span class="number">22</span>]: <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">23</span>]: x = <span class="number">5</span>  </span><br><span class="line">    ...: <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span>  </span><br><span class="line">    ...:     x = <span class="number">17</span>  </span><br><span class="line">    ...:     y = [x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">24</span>]: SomeClass.y[<span class="number">0</span>]  </span><br><span class="line">Out[<span class="number">24</span>]: <span class="number">5</span></span><br></pre></td></tr></table></figure>


<p>这是由于类范围的名称解析被忽略了，而生成器有它自己的本地范围，而在Python3中列表解析也有自己的范围，所以x的值是5。不过，第二个例子在Python2中SomeClass.y[0]的值是17。</p>
<h3 id="列表中的布尔值"><a href="#列表中的布尔值" class="headerlink" title="列表中的布尔值"></a>列表中的布尔值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: mixed_list = [<span class="literal">False</span>, <span class="number">1.0</span>, <span class="string">"some_string"</span>, <span class="number">3</span>, <span class="literal">True</span>, [], <span class="literal">False</span>]  </span><br><span class="line">    ...: integers_found_so_far = <span class="number">0</span>  </span><br><span class="line">    ...: booleans_found_so_far = <span class="number">0</span>  </span><br><span class="line">    ...:  </span><br><span class="line">    ...: <span class="keyword">for</span> item <span class="keyword">in</span> mixed_list:  </span><br><span class="line">    ...:     <span class="keyword">if</span> isinstance(item, int):  </span><br><span class="line">    ...:         integers_found_so_far += <span class="number">1</span>  </span><br><span class="line">    ...:     <span class="keyword">elif</span> isinstance(item, bool):  </span><br><span class="line">    ...:         booleans_found_so_far += <span class="number">1</span>  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">35</span>]: booleans_found_so_far  </span><br><span class="line">Out[<span class="number">35</span>]: <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">36</span>]: integers_found_so_far  </span><br><span class="line">Out[<span class="number">36</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure>


<p>这是由于布尔也是int的子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: isinstance(<span class="literal">True</span>, int)  </span><br><span class="line">Out[<span class="number">41</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<p>###</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: a, b = a[b] = &#123;&#125;, <span class="number">5</span>  </span><br><span class="line">    ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">43</span>]: a, b  </span><br><span class="line">Out[<span class="number">43</span>]: (&#123;<span class="number">5</span>: (&#123;...&#125;, <span class="number">5</span>)&#125;, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<p>看起来有点懵吧，我们拆一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: a[b] = &#123;&#125;, <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">47</span>]: a, b  </span><br><span class="line">Out[<span class="number">47</span>]: (&#123;<span class="number">5</span>: (&#123;&#125;, <span class="number">5</span>)&#125;, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<p>这样b是5，而a[5]的值是({}, 5)，所以a是{5: ({}, 5)。接着看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: a[b] = a, b  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">49</span>]: a  </span><br><span class="line">Out[<span class="number">49</span>]: &#123;<span class="number">5</span>: (&#123;...&#125;, <span class="number">5</span>)&#125;</span><br></pre></td></tr></table></figure>


<p>这其实是一个对自己的「自引用」，看个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: a = &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">51</span>]: a[<span class="number">5</span>] = a  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">52</span>]: a  </span><br><span class="line">Out[<span class="number">52</span>]: &#123;<span class="number">5</span>: &#123;...&#125;&#125;  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">53</span>]: a[<span class="number">5</span>] == a  </span><br><span class="line">Out[<span class="number">53</span>]: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">54</span>]: a[<span class="number">5</span>][<span class="number">5</span>][<span class="number">5</span>]  </span><br><span class="line">Out[<span class="number">54</span>]: &#123;<span class="number">5</span>: &#123;...&#125;&#125;</span><br></pre></td></tr></table></figure>


<p>看，a[5]就是a，这可以是一个永久循环，Python用…来表示了</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>（2017）你最不建议使用的Python Web框架？</title>
    <url>/2016-02-20.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是一篇发在<a href="https://zhuanlan.zhihu.com/p/28424536" target="_blank" rel="noopener">知乎专栏的文章</a>，内容是之前我提的「（2017）你最不建议使用的Python<br>Web框架？」下的回答。不过有些话没有说完，比如不建议tornado，却没有说对asyncio的看法，由于它的热度过去了我也没有补充，今天就发在公众号下吧。<br>在知乎可以看到的很多Web框架推荐，有很多内容已经过时，有些直接是从网上搜的，自己根本没有真的用过，不知道推荐的时候他们的良心会不会痛，不过幸好有我来树立正确的价值观了。</p>
<h3 id="第一不推荐-web-py"><a href="#第一不推荐-web-py" class="headerlink" title="第一不推荐 web.py"></a>第一不推荐 web.py</h3><p>我以前说过，评价XX是否可以用在生产环境的一部分标准是：</p>
<ol>
<li>代码质量。web.py的创始人Aaron Swartz自杀（官方说法）后，新的维护者能力实在是…</li>
<li>社区活跃程度和解决issue的能力。自己去github上去看未解决的issue和未合并的pull request数量</li>
<li>项目迭代情况。webpy-0.37 on Jun 26, 2012，webpy-0.38 on Jul 8, 2016。到现在一年就这样过去了然鹅什么都还没有发生。<h3 id="第二不推荐-bottle"><a href="#第二不推荐-bottle" class="headerlink" title="第二不推荐 bottle"></a>第二不推荐 bottle</h3>bottle其实是第一个使用装饰器作为路由的框架，不过它也存在社区活跃程度和解决issue的能力的问题，其实这说明了一个问题，它更像是某个（些）人的玩具，并不关心用户反馈。不知道大家是否知道它和Flask的故事（简单的说Flask<br>的作者Armin Ronacher开发了Werkzeug推荐给Bottle作者，但是Bottle作者非常执着于“单文件”和“无依赖”，拒绝了使用<br>Werkzeug，Armin<br>Ronacher就自己写了Flask），如果3-4年前你选择bottle我也是没意见的，现在来看Flask完爆它，哪怕是自己写的demo，你说你用了一个不适合在生产环境中使用框架的意义在哪里？完全没有积累啊。不过客观的说读源码学习写框架倒是可以的<h3 id="第三不推荐-tornado"><a href="#第三不推荐-tornado" class="headerlink" title="第三不推荐 tornado"></a>第三不推荐 tornado</h3>别说知乎也在用，用得好不好，用的有多苦他们自己知道 ✧(≖ ◡<br>≖✿)。这个就跟豆瓣用Quixote一样，用下来需要造很多轮子，需要很多积累，并不是别人一朝一夕就能用的成熟的。<br>非常知名的 [Python Guide](<a href="http://python-" target="_blank" rel="noopener">http://python-</a><br>guide.readthedocs.io/en/latest/scenarios/web/) 列了4个框架，除了Django和Flask，还列出了我刚推荐的<br>Pyramid，以及tornado。bottle、web.py什么的人家一概都不提。而且，我要说重点了，在介绍tornado的时候，Kenneth<br>Reitz着重的加了这样的观点：<blockquote>
<p>I do not recommend using Tornado unless you think you need it.<br>为啥这样说啊？</p>
</blockquote>
</li>
<li>使用一个框架不只是框架自己，还要习惯它的编程方式。并不是用了tornado你的应用就是异步非阻塞的，性能就能刷刷涨，各种设施都要支持。我见过不少人写的tornado代码还是阻塞的，比如我前公司的某项目… (๑✦ˑ̫✦)。</li>
<li>使用框架还需要考虑它的社区和第三方的扩展环境。tornado的生态环境和Django/Flask根本就不是一个量级，质量也很差，指不上</li>
<li>tornado虽然确实可以当做web框架用，但是它优秀的地方在于它是一个异步的网络库，优势在扩展上w级别长连接上（相信一开始知乎就是考虑这点来做提醒）。这点要分清楚了。<br>前2天还好，但是第三条顿时引起了争议，我知道说话肯定没有Kenneth<br>Reitz好使，所以引用他的话。其实犹之乎的同学来发表了意见，我还无意中发现，知乎产品总监来点了赞哦。嘻嘻，其实你真的写过复杂的tornado的项目就知道了，我不推荐的原因正面的讲：</li>
<li>tornado对于刚起步的公司或者新学Web框架的同学来说不合适。一处阻塞，全局阻塞，这对开发者的要求是很高的，我在14年的时候就想过做一个质量保证的工具，但是思考了一下，AST模块对于业务逻辑是束手无策的，你看到现在也没有看到这样的东西。</li>
<li>tornado是Python 2的产物，现在有了更好的解决方案asyncio。<br>那我们继续这个第二条：<br>我也是推荐至少学一个异步框架的，过去能看到的有Gevent，Twisted，一个是Hack的，另外一个现在已经被打入了冷宫，到今天当然是不推荐的。那么最好的就是官方的asyncio。<br>sanic/aiohttp这种框架的前景是好的，只不过现在我还没有看见某大型产品使用它们的实践经验，asyncio生态也还并不完善，暂不推荐进生产环境。<br>最后，你真的有需求要实现长连接，上asyncio，对于一个从无到有的过程，tornado和它并没有什么优势。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之让elasticsearch_dsl支持asyncio</title>
    <url>/2016-02-27.html</url>
    <content><![CDATA[<p>学习东西一定要给自己找个相对复杂到能比较深入了解要学习的内容的项目。「知乎Live全文搜索」是我用来学习elasticsearch、elasticsearch_dsl、asyncio、sanic和微信小程序项目。我想做时知乎还不提供Live的搜索，现在虽然提供了一个入口，但是感觉搜索的效果我觉得并不好。<br>前面在公众号我已经发了很多相关的asyncio、elasticsearch_dsl和sanic的内容，前面那些全部是给从今天开始的内容做铺垫。下面是这样文章的快速链接，如果你没看过或者忘记了可以回顾一下：</p>
<ol>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-asyncio%E7%AF%87/" target="_blank" rel="noopener">使用Python进行并发编程-asyncio篇(一)</a></li>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-asyncio%E7%AF%87-%E4%BA%8C/" target="_blank" rel="noopener">使用Python进行并发编程-asyncio篇(二)</a></li>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-asyncio%E7%AF%87-%E4%B8%89/" target="_blank" rel="noopener">使用Python进行并发编程-asyncio篇(三)</a></li>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8API%E7%99%BB%E5%BD%95%E7%9F%A5%E4%B9%8E%E5%B9%B6%E8%8E%B7%E5%BE%97token/" target="_blank" rel="noopener">使用API登录知乎并获得token</a></li>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">知乎Live全文搜索之模型设计和爬虫实现</a><br>现在列一下需求清单，并挨个完成。这里插一句，需求是否清晰明确是任务按期完成的最重要的条件之一，所以细化需求能力是每一个工程师都要熟悉和掌握的，这要求工程师对业务和所需要的技术很熟悉。<br>现在我先大致描绘要做的4件事情：</li>
</ol>
<ul>
<li>继续完善爬虫。主要是以下2点：<ol>
<li>之前分享过的爬虫的协程带来并发速度的提升优势还没有完全发挥出来。</li>
<li>之前的爬虫是纯信息抓取，没有考虑数据的可视化（比如没有考虑Live背景图，用户头像，Live所属话题信息等），需要增加字段并重新抓取。</li>
</ol>
</li>
<li>让elasticsearch_dsl支持asyncio，虽然官方提供了elasticsearch-py-async这个包，但是没有对elasticsearch_dsl的异步封装，而且由于我们将要使用sanic这个使用了第三方uvloop的Web框架，不能通过<code>asyncio.get_event_loop</code>的方式获取到loop而给elasticsearch_dsl用，需要处理。</li>
<li>完成微信小程序需要的数据model接口。</li>
<li>实现一个RESTful的sanic API功能，让elasticsearch和sqlalchemy的返回内容能非常方便的通用处理。<br>当然也并不是能预先清晰制定好100%需求，因为会有一些外部不可控的因素或者不小心踩了个深坑儿。比如一开始我只是抓知乎的图片链接，但是后来发现在微信小程序开发工具中这些图片资源是不能访问的（可能是没有Referfer），所以后来又改成把图片都下载到本地。另外一个是当时存储用户用了SQLite，现在要存话题数据，发现SQLite不支持并发，这对asyncio来说是不合理的选择，所以后来换成了MySQL。看，这就是选择sqlallchemy的好处，我完全不用改model，只是把DB_URI改一下就好了。<br>本文是上面的第二项，也就是让elasticsearch_dsl支持asyncio。我并且尽量拆分任务成可以团队多成员可以同时协作完成，也就是不用等着A做完B才能开始去做。我继续细节需求,<br>并挨个完成<h3 id="让sanic暴露loop给elasticsearch-dsl用"><a href="#让sanic暴露loop给elasticsearch-dsl用" class="headerlink" title="让sanic暴露loop给elasticsearch_dsl用"></a>让sanic暴露loop给elasticsearch_dsl用</h3>通过看sanic和elasticsearch_dsl的源码，我用sanic提供的before_start事件就可以完成：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Sanic  </span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.connections <span class="keyword">import</span> connections  </span><br><span class="line">  </span><br><span class="line">app = Sanic(__name__)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_loop</span><span class="params">(sanic, loop)</span>:</span>  </span><br><span class="line">    conns = connections._conns  </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> conns:  </span><br><span class="line">        conns[c].transport.loop = loop  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8300</span>,  </span><br><span class="line">            before_start=[set_loop], workers=<span class="number">4</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p>elasticsearch创建链接后会保存在connections._conns，在Sanic启动后把这些链接中用的loop替换成sanic创建那个就可以了。</p>
<h3 id="让elasticsearch-py-async支持Sanic"><a href="#让elasticsearch-py-async支持Sanic" class="headerlink" title="让elasticsearch-py-async支持Sanic"></a>让elasticsearch-py-async支持Sanic</h3><p>我fork了[elasticsearch-py-async](<a href="https://github.com/dongweiming/elasticsearch-" target="_blank" rel="noopener">https://github.com/dongweiming/elasticsearch-</a><br>py-<br>async)，虽然它已经是支持asyncio的了，但是还不支持外部loop，我的修改具体的可以看[这里](<a href="https://github.com/dongweiming/elasticsearch-" target="_blank" rel="noopener">https://github.com/dongweiming/elasticsearch-</a><br>py-<br>async/commit/416e7f02d7842c4efb4c3ed0f6159abb3d67e937)。说白了也是为了成替换sanic创建的那个loop。<br>elasticsearch-py-async加载的时候loop已经创建了，所以需要hack一下，让main_loop使用我设置的那个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Transport  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncTransport</span><span class="params">(Transport)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line"><span class="meta">    @asyncio.coroutine  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main_loop</span><span class="params">(self, method, url, params, body, ignore=<span class="params">()</span>, timeout=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">for</span> attempt <span class="keyword">in</span> range(self.max_retries + <span class="number">1</span>):  </span><br><span class="line">            connection = self.get_connection()  </span><br><span class="line">            connection.loop = self.loop  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                status, headers, data = <span class="keyword">yield</span> <span class="keyword">from</span> connection.perform_request(  </span><br><span class="line">                        method, url, params, body, ignore=ignore, timeout=timeout)  </span><br><span class="line">            <span class="keyword">except</span> TransportError <span class="keyword">as</span> e:  </span><br><span class="line">                <span class="keyword">if</span> method == <span class="string">'HEAD'</span> <span class="keyword">and</span> e.status_code == <span class="number">404</span>:  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>


<p>[<code>@asyncio.coroutine](mailto:</code>@asyncio.coroutine)<code>和</code>yield<br>from<code>是老式用法了，我新写的代码都统一都改成Python 3.5增加的async/await关键字了。
其中我加了一句</code>connection.loop = self.loop<code>，这样之前做的</code>conns[c].transport.loop =<br>loop`就有意义的。另外一个问题是aiohttp.session的用法，会造成在类初始化的时候就生成了self.session被未来使用，现在需要换成我们的loop，就需要让self.session在用时才生成，而且类初始化时候就创建session是一种不好的用法，我在多个地方见过，包含之前提到的500lines项目中的爬虫也是这样用的，本来是这样用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, roots,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 exclude=None, strict=True,  <span class="comment"># What to crawl.  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 max_redirect=<span class="number">10</span>, max_tries=<span class="number">4</span>,  <span class="comment"># Per-url limits.  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 max_tasks=<span class="number">10</span>, *, loop=None)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        self.session = aiohttp.ClientSession(loop=self.loop)  </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>


<p>现在aiohttp会抛<code>Creating a client session outside of
coroutine</code>的警告，也就是还没有开始协程就创建了。好的用法应该是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, roots,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 exclude=None, strict=True,  <span class="comment"># What to crawl.  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 max_redirect=<span class="number">10</span>, max_tries=<span class="number">4</span>,  <span class="comment"># Per-url limits.  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 max_tasks=<span class="number">10</span>, *, loop=None)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        self._session = <span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">session</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> self._session <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            self.session = aiohttp.ClientSession(loop=self.loop)  </span><br><span class="line">            self._session = session  </span><br><span class="line">        <span class="keyword">return</span> self._session</span><br></pre></td></tr></table></figure>


<p>这种编程方式使用非常广泛，体会一下。</p>
<h3 id="让elasticsearch-dsl-py支持Sanic"><a href="#让elasticsearch-dsl-py支持Sanic" class="headerlink" title="让elasticsearch-dsl-py支持Sanic"></a>让elasticsearch-dsl-py支持Sanic</h3><p>前面说到elasticsearch-dsl-py底层用的是elasticsearch-<br>py，并不支持异步化。所以我还是fork了[一份](<a href="https://github.com/dongweiming/elasticsearch-dsl-" target="_blank" rel="noopener">https://github.com/dongweiming/elasticsearch-dsl-</a><br>py/)，目前除了为支持Sanic，还修了一个我认为的BUG,已经提了PR还没有被处理, 有兴趣的同学可以移步[Fix IllegalOperation<br>when use custom analyzer](<a href="https://github.com/elastic/elasticsearch-dsl-" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch-dsl-</a><br>py/pull/576)。<br>我发现有的同学很惧怕Python 3内置的协程方案asyncio。我想原因主要是2点：</p>
<ol>
<li>对async/await这种异步编程方式不习惯</li>
<li>asyncio的生态还不够丰富，非常有可能你要自己去封装还不支持的客户端<br>人都是习惯在自己的舒适区，但其实可能没那么难习惯。这个就像成天用python写代码，突然要写个shell脚本或者就像没做过组件式开发第一次用React一样的不适应。这个时候需要你忍着不习惯，坚持的做1-2个项目，等你了解了，熟悉了，就会发现新的编程方式其实也就是那么回事，但是不去尝试和深入永远也学不会。<br>大家没事可以翻翻[aio-libs](<a href="https://github.com/aio-" target="_blank" rel="noopener">https://github.com/aio-</a><br>libs/)这个汇集了多个常用工具的asyncio的封装库，其实不复杂，把一个同步的程序改成asyncio的，我总结就是一句话：<blockquote>
<p>给内部有异步操作的函数添加async关键字，在有网络请求和I/O操作并且希望协程化的地方添加await关键字<br>对于elasticsearch-dsl-py的修改，差不多就是一种模式。举个get方法的例子。原来是这样写的：</p>
</blockquote>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@add_metaclass(DocTypeMeta)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DocType</span><span class="params">(ObjectBase)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(cls, id, using=None, index=None, **kwargs)</span>:</span>  </span><br><span class="line">        es = connections.get_connection(using <span class="keyword">or</span> cls._doc_type.using)  </span><br><span class="line">        doc = es.get(  </span><br><span class="line">            index=index <span class="keyword">or</span> cls._doc_type.index,  </span><br><span class="line">            doc_type=cls._doc_type.name,  </span><br><span class="line">            id=id,  </span><br><span class="line">            **kwargs  </span><br><span class="line">        )  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> doc[<span class="string">'found'</span>]:  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  </span><br><span class="line">        <span class="keyword">return</span> cls.from_es(doc)</span><br></pre></td></tr></table></figure>


<p>现在改成这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@add_metaclass(DocTypeMeta)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DocType</span><span class="params">(ObjectBase)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(cls, id, using=None, index=None, **kwargs)</span>:</span>  </span><br><span class="line">        es = connections.get_connection(using <span class="keyword">or</span> cls._doc_type.using)  </span><br><span class="line">        doc = <span class="keyword">await</span> es.get(  </span><br><span class="line">            index=index <span class="keyword">or</span> cls._doc_type.index,  </span><br><span class="line">            doc_type=cls._doc_type.name,  </span><br><span class="line">            id=id,  </span><br><span class="line">            **kwargs  </span><br><span class="line">        )  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> doc[<span class="string">'found'</span>]:  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  </span><br><span class="line">        <span class="keyword">return</span> cls.from_es(doc)</span><br></pre></td></tr></table></figure>


<p>所以不是每一步都需要加await，只有es.get是有网络请求的，其他的地方加了也没有意义。<br>另外的一个地方是把初始化Elasticsearch对象的地方改成elasticsearch-py-async的封装后的类，原来是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connections</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_connection</span><span class="params">(self, alias=<span class="string">'default'</span>, **kwargs)</span>:</span>  </span><br><span class="line">        kwargs.setdefault(<span class="string">'serializer'</span>, serializer)  </span><br><span class="line">        conn = self._conns[alias] = Elasticsearch(**kwargs)  </span><br><span class="line">        <span class="keyword">return</span> conn</span><br></pre></td></tr></table></figure>


<p>改成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> elasticsearch_async <span class="keyword">import</span> AsyncElasticsearch  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connections</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_connection</span><span class="params">(self, alias=<span class="string">'default'</span>, **kwargs)</span>:</span>  </span><br><span class="line">        kwargs.setdefault(<span class="string">'serializer'</span>, serializer)  </span><br><span class="line">        conn = self._conns[alias] = AsyncElasticsearch(**kwargs)  </span><br><span class="line">        <span class="keyword">return</span> conn</span><br></pre></td></tr></table></figure>


<p>明天我将分享完善后的爬虫，以及第三项「完成微信小程序需要的数据model接口」。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀开源项目kombu源码分析之registry和entrypoint</title>
    <url>/2016-02-24.html</url>
    <content><![CDATA[<p>我曾经在一些公众场合说过心中的优秀Python开发者。Flask和Requests的作者就不说了，21世纪最缺的就是idea，他们不仅有而且还都用非常优美的方式做出来了。另外我还提到了Celery作者Ask<br>Solem，并不是因为Celery很有名它的主要作者就优秀了，我对ask的欣赏，完全是看Celery及其相关依赖的源代码的时候产生的。<br>有多年后台开发的工程师想必清楚，Celery本身涉及到的技术点其实在业界应用是很广泛的。Celery能这么流行，我们先排除没有进行技术深入下的盲从，和它诞生的非常早以外，我认为这和项目的内部设计的非常好也是有关的。<br>接下来的几篇文章我将分析Celery使用的Kombu库中的一些设计实现让大家对这个优秀项目更了解，并从中学习可扩展开发的实践。</p>
<h3 id="Kombu是什么？"><a href="#Kombu是什么？" class="headerlink" title="Kombu是什么？"></a>Kombu是什么？</h3><p>当一个项目变得越来越复杂，就要考虑只保留核心，并把其他部分分拆到不同的项目中以便减少未来的维护和开发的成本。Flask、IPython都是这样做的。<br>Kombu是一个把消息传递封装成统一接口的库。<br>Celery一开始先支持的RabbitMQ，也就是使用AMQ协议。由于要支持越来越多的消息代理，但是这些消息代理是不支持AMQ协议的，需要一个东西把所有的消息代理的处理方式统一起来，甚至可以理解为把它们「伪装成支持AMQ协议」。Kombu的最初的实现叫做carrot,<br>后来经过重构才成了Kombu。</p>
<h3 id="registry"><a href="#registry" class="headerlink" title="registry"></a>registry</h3><p>registry也就是「注册」，有按需加入的意思，在Python标准库和一些优秀开源项目中都有应用。我们先看个django的<a href="https://github.com/django/django/blob/cecc079168e8669138728d31611ff3a1e7eb3a9f/django/core/checks/registry.py#L21" target="_blank" rel="noopener">场景</a>，为了减少篇幅我没有列出CheckRegistry类中其他方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### source code start  </span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckRegistry</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.registered_checks = []  </span><br><span class="line">        self.deployment_checks = []  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, check=None, *tags, **kwargs)</span>:</span>  </span><br><span class="line">        kwargs.setdefault(<span class="string">'deploy'</span>, <span class="literal">False</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(check)</span>:</span>  </span><br><span class="line">            check.tags = tags  </span><br><span class="line">            <span class="keyword">if</span> kwargs[<span class="string">'deploy'</span>]:  </span><br><span class="line">                <span class="keyword">if</span> check <span class="keyword">not</span> <span class="keyword">in</span> self.deployment_checks:  </span><br><span class="line">                    self.deployment_checks.append(check)  </span><br><span class="line">            <span class="keyword">elif</span> check <span class="keyword">not</span> <span class="keyword">in</span> self.registered_checks:  </span><br><span class="line">                self.registered_checks.append(check)  </span><br><span class="line">            <span class="keyword">return</span> check  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> callable(check):  </span><br><span class="line">            <span class="keyword">return</span> inner(check)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">if</span> check:  </span><br><span class="line">                tags += (check, )  </span><br><span class="line">            <span class="keyword">return</span> inner  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tag_exists</span><span class="params">(self, tag, include_deployment_checks=False)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> tag <span class="keyword">in</span> self.tags_available(include_deployment_checks)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tags_available</span><span class="params">(self, deployment_checks=False)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> set(chain(*[check.tags <span class="keyword">for</span> check <span class="keyword">in</span> self.get_checks(deployment_checks) <span class="keyword">if</span> hasattr(check, <span class="string">'tags'</span>)]))  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_checks</span><span class="params">(self, include_deployment_checks=False)</span>:</span>  </span><br><span class="line">        checks = list(self.registered_checks)  </span><br><span class="line">        <span class="keyword">if</span> include_deployment_checks:  </span><br><span class="line">            checks.extend(self.deployment_checks)  </span><br><span class="line">        <span class="keyword">return</span> checks  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">registry = CheckRegistry()  </span><br><span class="line">register = registry.register  </span><br><span class="line">tag_exists = registry.tag_exists  </span><br><span class="line">  </span><br><span class="line"><span class="comment">### source code end  </span></span><br><span class="line"><span class="meta">@register('mytag', 'another_tag')  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_check</span><span class="params">(apps, **kwargs)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> tag_exists(<span class="string">'another_tag'</span>)  </span><br><span class="line"><span class="keyword">print</span> tag_exists(<span class="string">'not_exists_tag'</span>)</span><br></pre></td></tr></table></figure>


<p>可以看到每次用registry.register都能动态的添加新的tag，最后还用<code>register =
registry.register</code>这样的方式列了个别名。执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python django_example.py  </span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<p>kombu库包含对消息的序列化和反序列化工作的实现，可以同时支持多种序列化方案，如pickle、json、yaml和msgpack。假如你从前没有写过这样可扩展的项目，可能想的是每种的方案的loads和dumps都封装一遍，然后用一个大的if/elif/else来控制最后的序列化如何执行。<br>那么在kombu里面是怎么用的呢？我简化下它的<a href="https://github.com/celery/kombu/blob/master/kombu/serialization.py" target="_blank" rel="noopener">实现</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> codecs  </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple  </span><br><span class="line">  </span><br><span class="line">codec = namedtuple(<span class="string">'codec'</span>, (<span class="string">'content_type'</span>, <span class="string">'content_encoding'</span>, <span class="string">'encoder'</span>))  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializerNotInstalled</span><span class="params">(Exception)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializerRegistry</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self._encoders = &#123;&#125;  </span><br><span class="line">        self._decoders = &#123;&#125;  </span><br><span class="line">        self._default_encode = <span class="literal">None</span>  </span><br><span class="line">        self._default_content_type = <span class="literal">None</span>  </span><br><span class="line">        self._default_content_encoding = <span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, name, encoder, decoder, content_type,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 content_encoding=<span class="string">'utf-8'</span>)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> encoder:  </span><br><span class="line">            self._encoders[name] = codec(  </span><br><span class="line">                content_type, content_encoding, encoder,  </span><br><span class="line">            )  </span><br><span class="line">        <span class="keyword">if</span> decoder:  </span><br><span class="line">            self._decoders[content_type] = decoder  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_set_default_serializer</span><span class="params">(self, name)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            (self._default_content_type, self._default_content_encoding,  </span><br><span class="line">             self._default_encode) = self._encoders[name]  </span><br><span class="line">        <span class="keyword">except</span> KeyError:  </span><br><span class="line">            <span class="keyword">raise</span> SerializerNotInstalled(  </span><br><span class="line">                <span class="string">'No encoder installed for &#123;0&#125;'</span>.format(name))  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dumps</span><span class="params">(self, data, serializer=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> serializer <span class="keyword">and</span> <span class="keyword">not</span> self._encoders.get(serializer):  </span><br><span class="line">            <span class="keyword">raise</span> SerializerNotInstalled(  </span><br><span class="line">                <span class="string">'No encoder installed for &#123;0&#125;'</span>.format(serializer))  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> serializer <span class="keyword">and</span> isinstance(data, unicode):  </span><br><span class="line">            payload = data.encode(<span class="string">'utf-8'</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">'text/plain'</span>, <span class="string">'utf-8'</span>, payload  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> serializer:  </span><br><span class="line">            content_type, content_encoding, encoder = \  </span><br><span class="line">                self._encoders[serializer]  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            encoder = self._default_encode  </span><br><span class="line">            content_type = self._default_content_type  </span><br><span class="line">            content_encoding = self._default_content_encoding  </span><br><span class="line">  </span><br><span class="line">        payload = encoder(data)  </span><br><span class="line">        <span class="keyword">return</span> content_type, content_encoding, payload  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loads</span><span class="params">(self, data, content_type, content_encoding)</span>:</span>  </span><br><span class="line">        content_type = (content_type <span class="keyword">if</span> content_type  </span><br><span class="line">                        <span class="keyword">else</span> <span class="string">'application/data'</span>)  </span><br><span class="line">        content_encoding = (content_encoding <span class="keyword">or</span> <span class="string">'utf-8'</span>).lower()  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> data:  </span><br><span class="line">            decode = self._decoders.get(content_type)  </span><br><span class="line">            <span class="keyword">if</span> decode:  </span><br><span class="line">                <span class="keyword">return</span> decode(data)  </span><br><span class="line">        <span class="keyword">return</span> data  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">registry = SerializerRegistry()  </span><br><span class="line">dumps = registry.dumps  </span><br><span class="line">loads = registry.loads  </span><br><span class="line">register = registry.register</span><br></pre></td></tr></table></figure>


<p>其实kombu还实现了unregister限于篇幅我就不展开了。现在我们想添加yaml的支持，只需要加这样一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_yaml</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        <span class="keyword">import</span> yaml  </span><br><span class="line">        registry.register(<span class="string">'yaml'</span>, yaml.safe_dump, yaml.safe_load,  </span><br><span class="line">                          content_type=<span class="string">'application/x-yaml'</span>,  </span><br><span class="line">                          content_encoding=<span class="string">'utf-8'</span>)  </span><br><span class="line">    <span class="keyword">except</span> ImportError:  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">not_available</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">            <span class="string">"""Raise SerializerNotInstalled.  </span></span><br><span class="line"><span class="string">            Used in case a client receives a yaml message, but yaml  </span></span><br><span class="line"><span class="string">            isn't installed.  </span></span><br><span class="line"><span class="string">            """</span>  </span><br><span class="line">            <span class="keyword">raise</span> SerializerNotInstalled(  </span><br><span class="line">                <span class="string">'No decoder installed for YAML. Install the PyYAML library'</span>)  </span><br><span class="line">        registry.register(<span class="string">'yaml'</span>, <span class="literal">None</span>, not_available, <span class="string">'application/x-yaml'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">register_yaml()</span><br></pre></td></tr></table></figure>


<p>这样就支持yaml了。如果希望默认使用yaml来序列化，可以执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">registry._set_default_serializer(<span class="string">'yaml'</span>)</span><br></pre></td></tr></table></figure>


<p>是不是非常好扩展，如果哪天我希望去掉对pickle(安全问题)，就可以直接注释对应的函数就好了。写个小例子试验下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yaml_data = <span class="string">"""\  </span></span><br><span class="line"><span class="string">float: 3.1415926500000002  </span></span><br><span class="line"><span class="string">int: 10  </span></span><br><span class="line"><span class="string">list: [george, jerry, elaine, cosmo]  </span></span><br><span class="line"><span class="string">string: The quick brown fox jumps over the lazy dog  </span></span><br><span class="line"><span class="string">unicode: "Th\\xE9 quick brown fox jumps over th\\xE9 lazy dog"  </span></span><br><span class="line"><span class="string">"""</span>  </span><br><span class="line">  </span><br><span class="line">content_type, content_encoding, payload = dumps(yaml_data, serializer=<span class="string">'yaml'</span>)  </span><br><span class="line"><span class="keyword">print</span> content_type, content_encoding  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">assert</span> loads(payload, content_type=content_type, content_encoding=content_encoding) == yaml_data</span><br></pre></td></tr></table></figure>


<p>运行的结果就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python kombu_example.py  </span><br><span class="line">application/x-yaml utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>


<h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>在我的书里面介绍过如果使用标准库自带的pkg_resources.iter_entry_points实现一个简单的插件系统。这在kombu上面也有应用，在序列化实现模块的最后加了这么几句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pkg_resources <span class="keyword">import</span> iter_entry_points  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> ep <span class="keyword">in</span> iter_entry_points(<span class="string">'kombu.serializers'</span>):  </span><br><span class="line">    args = ep.load()  </span><br><span class="line">    register(ep.name, *args)</span><br></pre></td></tr></table></figure>


<p>这是什么东西呢？pkg_resources是一个用于包发现和资源访问的模块，我们可以实现不同的kombu扩展，如果在这个扩展项目的setup.py里面设置对应的entry_points，在安装之后，运行上述代码的时候就会自动找到这些扩展，并注册进来。这就是一个扩展系统。Flake8就是最好的这个扩展玩法的范例。<br>kombu的扩展不多，我选择[kombu-fernet-serializers](<a href="https://github.com/heroku/kombu-" target="_blank" rel="noopener">https://github.com/heroku/kombu-</a><br>fernet-serializers)来进行介绍。首先看一下它的setup.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">    entry_points=&#123;  </span><br><span class="line">        <span class="string">'kombu.serializers'</span>: [  </span><br><span class="line">            <span class="string">'fernet_json = kombu_fernet.serializers.json:register_args'</span>,  </span><br><span class="line">            <span class="string">'fernet_yaml = kombu_fernet.serializers.yaml:register_args'</span>,  </span><br><span class="line">            <span class="string">'fernet_pickle = kombu_fernet.serializers.pickle:register_args'</span>,  </span><br><span class="line">            <span class="string">'fernet_msgpack = kombu_fernet.serializers.msgpack:register_args'</span>,  </span><br><span class="line">        ]  </span><br><span class="line">    &#125;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>注意到了吧，这个entry点就是kombu.serializers，安装之后就多了4个序列化方案，我们看一下fernet_json的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> anyjson <span class="keyword">as</span> _json  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> fernet_encode, fernet_decode  </span><br><span class="line">  </span><br><span class="line">MIMETYPE = <span class="string">'application/x-fernet-json'</span>  </span><br><span class="line">  </span><br><span class="line">register_args = (  </span><br><span class="line">    fernet_encode(_json.dumps),  </span><br><span class="line">    fernet_decode(_json.loads),  </span><br><span class="line">    MIMETYPE,  </span><br><span class="line">    <span class="string">'utf-8'</span>,  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>而fernet_yaml也被放进了模块的方式，其实和在函数内殊途同归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> kombu.exceptions <span class="keyword">import</span> SerializerNotInstalled  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> fernet_encode, fernet_decode  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="keyword">import</span> yaml  </span><br><span class="line"><span class="keyword">except</span> ImportError:  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">not_available</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">        <span class="string">"""In case a client receives a yaml message, but yaml  </span></span><br><span class="line"><span class="string">        isn't installed."""</span>  </span><br><span class="line">        <span class="keyword">raise</span> SerializerNotInstalled(  </span><br><span class="line">            <span class="string">'No decoder installed for YAML. Install the PyYAML library'</span>)  </span><br><span class="line">  </span><br><span class="line">    yaml_encoder = not_available  </span><br><span class="line">    yaml_decoder = <span class="literal">None</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    yaml_encoder = yaml.safe_dump  </span><br><span class="line">    yaml_decoder = yaml.safe_load  </span><br><span class="line">  </span><br><span class="line">MIMETYPE = <span class="string">'application/x-fernet-yaml'</span>  </span><br><span class="line">  </span><br><span class="line">register_args = (  </span><br><span class="line">    fernet_encode(yaml_encoder),  </span><br><span class="line">    fernet_decode(yaml_decoder) <span class="keyword">if</span> yaml_decoder <span class="keyword">else</span> <span class="literal">None</span>,  </span><br><span class="line">    MIMETYPE,  </span><br><span class="line">    <span class="string">'utf-8'</span>,  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>事实上，我们并不需要了解fernet_encode和fernet_decode是如何对消息做对称加密的，只是感受下这样添加扩展的方式是不是很优雅呢？</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>多master/develop分支使用gitflow</title>
    <url>/2016-02-25.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h4><p>公司都是git作为版本控制，公司一些项目组在用gitflow，但是我们组没有强制，<br>但是我上月出了一次事故，总结就是分支管理问题，所以开始强迫自己使用gitflow,<br>以前的项目是一个master和一个develop，自己checkout一个分支，然后merge(不理解的可以看看<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">a-successful-git-<br>branching-model</a>).<br>问题出现了: 项目有几个主分支和开发分支，比如master_sina, master_qq. master_buzz<br>,而gitflow的时候只能指定一个master/develop, 这样你start一个feature/hotfix之前就要去.git/config里面修改<br>[gitflow “branch”]项的相关主分支和开发分支，so不方便。看了下源码，给gitflow加点料<br>####添加功能</p>
<ul>
<li>当你打开了feature/hotfix分支，但是你不想要它了(当然你可以直接git branch -D xx)，使用git flow hotfix/feature delete ,自动帮你删除这个分支，以便你新建其他分支(git flow只容许你一次存在一个hotfix/feature分支)</li>
<li>你想使用gitflow删除其它存在分支嘛？不需要 git branch -D ，你还可以git flow hotfix/feature delete XX </li>
<li>比如我在init的时候指定了master为master_sina, 而当我想创建master_qq的hotfix，我只需要在start的是否给它取名字是’qq_’开头的即可，要是有其它的需要你可以直接在源码里面添加对应的内容<br>####例子 git-flow-hotfix 我主要标记我修改的部分</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">init() &#123;  </span><br><span class="line">  require_git_repo  </span><br><span class="line">  require_gitflow_initialized  </span><br><span class="line">  gitflow_load_settings  </span><br><span class="line">  VERSION_PREFIX=$(eval <span class="string">"echo `git config --get gitflow.prefix.versiontag`"</span>)  </span><br><span class="line">  PREFIX=$(git config --get gitflow.prefix.hotfix)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment"># 增加help的选项说明  </span></span><br><span class="line">usage() &#123;  </span><br><span class="line">    echo <span class="string">"usage: git flow hotfix [list] [-v]"</span>  </span><br><span class="line">    echo <span class="string">"       git flow hotfix start [-F] &lt;version&gt; [&lt;base&gt;]"</span>  </span><br><span class="line">    echo <span class="string">"       git flow hotfix finish [-Fsumpk] &lt;version&gt;"</span>  </span><br><span class="line">    echo <span class="string">"       git flow hotfix publish &lt;version&gt;"</span>  </span><br><span class="line">    echo <span class="string">"       git flow hotfix delete [branch]"</span>  </span><br><span class="line">    echo <span class="string">"       git flow hotfix track &lt;version&gt;"</span>  </span><br><span class="line">&#125;  </span><br><span class="line">cmd_default() &#123;  </span><br><span class="line">    cmd_list <span class="string">"$@"</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">cmd_list() &#123;  </span><br><span class="line">    DEFINE_boolean verbose false <span class="string">'verbose (more) output'</span> v  </span><br><span class="line">    parse_args <span class="string">"$@"</span>  </span><br><span class="line">  </span><br><span class="line">    local hotfix_branches  </span><br><span class="line">    local current_branch  </span><br><span class="line">    local short_names  </span><br><span class="line">    hotfix_branches=$(echo <span class="string">"$(git_local_branches)"</span> | grep <span class="string">"^$PREFIX"</span>)  </span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"$hotfix_branches"</span> ]; then  </span><br><span class="line">        warn <span class="string">"No hotfix branches exist."</span>  </span><br><span class="line">                warn <span class="string">""</span>  </span><br><span class="line">                warn <span class="string">"You can start a new hotfix branch:"</span>  </span><br><span class="line">                warn <span class="string">""</span>  </span><br><span class="line">                warn <span class="string">"    git flow hotfix start &lt;version&gt; [&lt;base&gt;]"</span>  </span><br><span class="line">                warn <span class="string">""</span>  </span><br><span class="line">        exit <span class="number">0</span>  </span><br><span class="line">    fi  </span><br><span class="line">    current_branch=$(git branch --no-color | grep <span class="string">'^\* '</span> | grep -v <span class="string">'no branch'</span> | sed <span class="string">'s/^* //g'</span>)  </span><br><span class="line">    short_names=$(echo <span class="string">"$hotfix_branches"</span> | sed <span class="string">"s ^$PREFIX  g"</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># determine column width first  </span></span><br><span class="line">    local width=<span class="number">0</span>  </span><br><span class="line">    local branch  </span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> $short_names; do  </span><br><span class="line">        local len=$&#123;<span class="comment">#branch&#125;  </span></span><br><span class="line">        width=$(max $width $len)  </span><br><span class="line">    done  </span><br><span class="line">    width=$(($width+<span class="number">3</span>))  </span><br><span class="line">  </span><br><span class="line">    local branch  </span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> $short_names; do  </span><br><span class="line">        local fullname=$PREFIX$branch  </span><br><span class="line">        local base=$(git merge-base <span class="string">"$fullname"</span> <span class="string">"$MASTER_BRANCH"</span>)  </span><br><span class="line">        local master_sha=$(git rev-parse <span class="string">"$MASTER_BRANCH"</span>)  </span><br><span class="line">        local branch_sha=$(git rev-parse <span class="string">"$fullname"</span>)  </span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"$fullname"</span> = <span class="string">"$current_branch"</span> ]; then  </span><br><span class="line">            printf <span class="string">"* "</span>  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            printf <span class="string">"  "</span>  </span><br><span class="line">        fi  </span><br><span class="line">        <span class="keyword">if</span> flag verbose; then  </span><br><span class="line">            printf <span class="string">"%-$&#123;width&#125;s"</span> <span class="string">"$branch"</span>  </span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">"$branch_sha"</span> = <span class="string">"$master_sha"</span> ]; then  </span><br><span class="line">                printf <span class="string">"(no commits yet)"</span>  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                local tagname=$(git name-rev --tags --no-undefined --name-only <span class="string">"$base"</span>)  </span><br><span class="line">                local nicename  </span><br><span class="line">                <span class="keyword">if</span> [ <span class="string">"$tagname"</span> != <span class="string">""</span> ]; then  </span><br><span class="line">                    nicename=$tagname  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    nicename=$(git rev-parse --short <span class="string">"$base"</span>)  </span><br><span class="line">                fi  </span><br><span class="line">                printf <span class="string">"(based on $nicename)"</span>  </span><br><span class="line">            fi  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            printf <span class="string">"%s"</span> <span class="string">"$branch"</span>  </span><br><span class="line">        fi  </span><br><span class="line">        echo  </span><br><span class="line">    done  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">cmd_help() &#123;  </span><br><span class="line">    usage  </span><br><span class="line">    exit <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">parse_args() &#123;  </span><br><span class="line">    <span class="comment"># parse options  </span></span><br><span class="line">    FLAGS "$@" || exit $?  </span><br><span class="line">    eval set -- <span class="string">"$&#123;FLAGS_ARGV&#125;"</span>  </span><br><span class="line">    <span class="comment"># read arguments into global variables  </span></span><br><span class="line">    VERSION=$<span class="number">1</span>  </span><br><span class="line">    BRANCH=$PREFIX$VERSION  </span><br><span class="line">    <span class="comment"># 这里就是我多master/develop的技巧，我这里会判断要新建的分支的前缀，  </span></span><br><span class="line">    <span class="comment"># 要是qq_开头就会基于master_qq和develop_qq创建分支。所以你可以根据你的需要在这里加一些方法  </span></span><br><span class="line">    test `expr match <span class="string">"$@"</span> <span class="string">"qq_"</span>` -ne <span class="number">0</span> &amp;&amp; MASTER_BRANCH=<span class="string">"$MASTER_BRANCH"</span>_qq &amp;&amp;  </span><br><span class="line">    DEVELOP_BRANCH=<span class="string">"$DEVELOP_BRANCH"</span>_qq  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">require_version_arg() &#123;  </span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"$VERSION"</span> = <span class="string">""</span> ]; then  </span><br><span class="line">        warn <span class="string">"Missing argument &lt;version&gt;"</span>  </span><br><span class="line">        usage  </span><br><span class="line">        exit <span class="number">1</span>  </span><br><span class="line">    fi  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">require_base_is_on_master() &#123;  </span><br><span class="line">    <span class="keyword">if</span> ! git branch --no-color --contains <span class="string">"$BASE"</span> <span class="number">2</span>&gt;/dev/null \  </span><br><span class="line">            | sed <span class="string">'s/[* ] //g'</span> \  </span><br><span class="line">            | grep -q <span class="string">"^$MASTER_BRANCH\$"</span>; then  </span><br><span class="line">        die <span class="string">"fatal: Given base '$BASE' is not a valid commit on '$MASTER_BRANCH'."</span>  </span><br><span class="line">    fi  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">require_no_existing_hotfix_branches() &#123;  </span><br><span class="line">    local hotfix_branches=$(echo <span class="string">"$(git_local_branches)"</span> | grep <span class="string">"^$PREFIX"</span>)  </span><br><span class="line">    local first_branch=$(echo $&#123;hotfix_branches&#125; | head -n1)  </span><br><span class="line">    first_branch=$&#123;first_branch<span class="comment">#$PREFIX&#125;  </span></span><br><span class="line">    [ -z <span class="string">"$hotfix_branches"</span> ] || \  </span><br><span class="line">        die <span class="string">"There is an existing hotfix branch ($first_branch). Finish that one first."</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment"># 添加delete 参数，函数需要cmd_开头  </span></span><br><span class="line">cmd_delete() &#123;  </span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"$1"</span> = <span class="string">""</span> ]; then  </span><br><span class="line">        <span class="comment"># 当不指定参数自动去找存在的未关闭的gitflow分支  </span></span><br><span class="line">        local hotfix_branches=$(echo <span class="string">"$(git_local_branches)"</span> | grep <span class="string">"^$PREFIX"</span>)  </span><br><span class="line">        test <span class="string">"$hotfix_branches"</span> = <span class="string">""</span> &amp;&amp; die <span class="string">"There has not existing hotfix branch can delete"</span> &amp;&amp; exit <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="comment"># 指定参数先判断参数是不是的数量格式  </span></span><br><span class="line">        test $<span class="comment"># != 1 &amp;&amp; die "There only need one parameter indicates the branch to be deleted" &amp;&amp; exit 1  </span></span><br><span class="line">        hotfix_branches=<span class="string">"$1"</span>  </span><br><span class="line">    fi  </span><br><span class="line">    <span class="comment"># 当要删除的分支就是当前分支，先checkout到develop分支  </span></span><br><span class="line">    test <span class="string">"$hotfix_branches"</span> = <span class="string">"$(git_current_branch)"</span> &amp;&amp; echo <span class="string">'First checkout develp branch'</span>; git_do checkout <span class="string">"$DEVELOP_BRANCH"</span>  </span><br><span class="line">    git branch -D  $&#123;hotfix_branches&#125; &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span>&amp;&amp; echo <span class="string">'Delete Successed'</span>|| die <span class="string">"Did not find branch: [$hotfix_branches]"</span>  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">cmd_start() &#123;  </span><br><span class="line">    DEFINE_boolean fetch false <span class="string">"fetch from $ORIGIN before performing finish"</span> F  </span><br><span class="line">    parse_args <span class="string">"$@"</span>  </span><br><span class="line">    BASE=$&#123;<span class="number">2</span>:-$MASTER_BRANCH&#125;  </span><br><span class="line">    require_version_arg  </span><br><span class="line">    require_base_is_on_master  </span><br><span class="line">    require_no_existing_hotfix_branches  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># sanity checks  </span></span><br><span class="line">    require_clean_working_tree  </span><br><span class="line">    require_branch_absent <span class="string">"$BRANCH"</span>  </span><br><span class="line">    require_tag_absent <span class="string">"$VERSION_PREFIX$VERSION"</span>  </span><br><span class="line">    <span class="keyword">if</span> flag fetch; then  </span><br><span class="line">        git_do fetch -q <span class="string">"$ORIGIN"</span> <span class="string">"$MASTER_BRANCH"</span>  </span><br><span class="line">    fi  </span><br><span class="line">    <span class="keyword">if</span> has <span class="string">"$ORIGIN/$MASTER_BRANCH"</span> $(git_remote_branches); then  </span><br><span class="line">        require_branches_equal <span class="string">"$MASTER_BRANCH"</span> <span class="string">"$ORIGIN/$MASTER_BRANCH"</span>  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># create branch  </span></span><br><span class="line">    git_do checkout -b <span class="string">"$BRANCH"</span> <span class="string">"$BASE"</span>  </span><br><span class="line">  </span><br><span class="line">    echo  </span><br><span class="line">    echo <span class="string">"Summary of actions:"</span>  </span><br><span class="line">    echo <span class="string">"- A new branch '$BRANCH' was created, based on '$BASE'"</span>  </span><br><span class="line">    echo <span class="string">"- You are now on branch '$BRANCH'"</span>  </span><br><span class="line">    echo  </span><br><span class="line">    echo <span class="string">"Follow-up actions:"</span>  </span><br><span class="line">    echo <span class="string">"- Bump the version number now!"</span>  </span><br><span class="line">    echo <span class="string">"- Start committing your hot fixes"</span>  </span><br><span class="line">    echo <span class="string">"- When done, run:"</span>  </span><br><span class="line">    echo  </span><br><span class="line">    echo <span class="string">"     git flow hotfix finish '$VERSION'"</span>  </span><br><span class="line">    echo  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">cmd_publish() &#123;  </span><br><span class="line">    parse_args <span class="string">"$@"</span>  </span><br><span class="line">    require_version_arg  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># sanity checks  </span></span><br><span class="line">    require_clean_working_tree  </span><br><span class="line">    require_branch <span class="string">"$BRANCH"</span>  </span><br><span class="line">    git_do fetch -q <span class="string">"$ORIGIN"</span>  </span><br><span class="line">    require_branch_absent <span class="string">"$ORIGIN/$BRANCH"</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># create remote branch  </span></span><br><span class="line">    git_do push <span class="string">"$ORIGIN"</span> <span class="string">"$BRANCH:refs/heads/$BRANCH"</span>  </span><br><span class="line">    git_do fetch -q <span class="string">"$ORIGIN"</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># configure remote tracking  </span></span><br><span class="line">    git config <span class="string">"branch.$BRANCH.remote"</span> <span class="string">"$ORIGIN"</span>  </span><br><span class="line">    git config <span class="string">"branch.$BRANCH.merge"</span> <span class="string">"refs/heads/$BRANCH"</span>  </span><br><span class="line">    git_do checkout <span class="string">"$BRANCH"</span>  </span><br><span class="line">  </span><br><span class="line">    echo  </span><br><span class="line">    echo <span class="string">"Summary of actions:"</span>  </span><br><span class="line">    echo <span class="string">"- A new remote branch '$BRANCH' was created"</span>  </span><br><span class="line">    echo <span class="string">"- The local branch '$BRANCH' was configured to track the remote branch"</span>  </span><br><span class="line">    echo <span class="string">"- You are now on branch '$BRANCH'"</span>  </span><br><span class="line">    echo  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">cmd_track() &#123;  </span><br><span class="line">    parse_args <span class="string">"$@"</span>  </span><br><span class="line">    require_version_arg  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># sanity checks  </span></span><br><span class="line">    require_clean_working_tree  </span><br><span class="line">    require_branch_absent <span class="string">"$BRANCH"</span>  </span><br><span class="line">    git_do fetch -q <span class="string">"$ORIGIN"</span>  </span><br><span class="line">    require_branch <span class="string">"$ORIGIN/$BRANCH"</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># create tracking branch  </span></span><br><span class="line">    git_do checkout -b <span class="string">"$BRANCH"</span> <span class="string">"$ORIGIN/$BRANCH"</span>  </span><br><span class="line">  </span><br><span class="line">    echo  </span><br><span class="line">    echo <span class="string">"Summary of actions:"</span>  </span><br><span class="line">    echo <span class="string">"- A new remote tracking branch '$BRANCH' was created"</span>  </span><br><span class="line">    echo <span class="string">"- You are now on branch '$BRANCH'"</span>  </span><br><span class="line">    echo  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">cmd_finish() &#123;  </span><br><span class="line">    DEFINE_boolean fetch false <span class="string">"fetch from $ORIGIN before performing finish"</span> F  </span><br><span class="line">    DEFINE_boolean sign false <span class="string">"sign the release tag cryptographically"</span> s  </span><br><span class="line">    DEFINE_string signingkey <span class="string">""</span> <span class="string">"use the given GPG-key for the digital signature (implies -s)"</span> u  </span><br><span class="line">    DEFINE_string message <span class="string">""</span> <span class="string">"use the given tag message"</span> m  </span><br><span class="line">    DEFINE_string messagefile <span class="string">""</span> <span class="string">"use the contents of the given file as tag message"</span> f  </span><br><span class="line">    DEFINE_boolean push false <span class="string">"push to $ORIGIN after performing finish"</span> p  </span><br><span class="line">    DEFINE_boolean keep false <span class="string">"keep branch after performing finish"</span> k  </span><br><span class="line">    DEFINE_boolean notag false <span class="string">"don't tag this release"</span> n  </span><br><span class="line">    parse_args <span class="string">"$@"</span>  </span><br><span class="line">    require_version_arg  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># handle flags that imply other flags  </span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"$FLAGS_signingkey"</span> != <span class="string">""</span> ]; then  </span><br><span class="line">        FLAGS_sign=$FLAGS_TRUE  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># sanity checks  </span></span><br><span class="line">    require_branch <span class="string">"$BRANCH"</span>  </span><br><span class="line">    require_clean_working_tree  </span><br><span class="line">    <span class="keyword">if</span> flag fetch; then  </span><br><span class="line">        git_do fetch -q <span class="string">"$ORIGIN"</span> <span class="string">"$MASTER_BRANCH"</span> || \  </span><br><span class="line">          die <span class="string">"Could not fetch $MASTER_BRANCH from $ORIGIN."</span>  </span><br><span class="line">        git_do fetch -q <span class="string">"$ORIGIN"</span> <span class="string">"$DEVELOP_BRANCH"</span> || \  </span><br><span class="line">          die <span class="string">"Could not fetch $DEVELOP_BRANCH from $ORIGIN."</span>  </span><br><span class="line">    fi  </span><br><span class="line">    <span class="keyword">if</span> has <span class="string">"$ORIGIN/$MASTER_BRANCH"</span> $(git_remote_branches); then  </span><br><span class="line">        require_branches_equal <span class="string">"$MASTER_BRANCH"</span> <span class="string">"$ORIGIN/$MASTER_BRANCH"</span>  </span><br><span class="line">    fi  </span><br><span class="line">    <span class="keyword">if</span> has <span class="string">"$ORIGIN/$DEVELOP_BRANCH"</span> $(git_remote_branches); then  </span><br><span class="line">        require_branches_equal <span class="string">"$DEVELOP_BRANCH"</span> <span class="string">"$ORIGIN/$DEVELOP_BRANCH"</span>  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># try to merge into master  </span></span><br><span class="line">    <span class="comment"># in case a previous attempt to finish this release branch has failed,  </span></span><br><span class="line">    <span class="comment"># but the merge into master was successful, we skip it now  </span></span><br><span class="line">    <span class="keyword">if</span> ! git_is_branch_merged_into <span class="string">"$BRANCH"</span> <span class="string">"$MASTER_BRANCH"</span>; then  </span><br><span class="line">        git_do checkout <span class="string">"$MASTER_BRANCH"</span> || \  </span><br><span class="line">          die <span class="string">"Could not check out $MASTER_BRANCH."</span>  </span><br><span class="line">        git_do merge --no-ff <span class="string">"$BRANCH"</span> || \  </span><br><span class="line">          die <span class="string">"There were merge conflicts."</span>  </span><br><span class="line">          <span class="comment"># <span class="doctag">TODO:</span> What do we do now?  </span></span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> noflag notag; then  </span><br><span class="line">        <span class="comment"># try to tag the release  </span></span><br><span class="line">        <span class="comment"># in case a previous attempt to finish this release branch has failed,  </span></span><br><span class="line">        <span class="comment"># but the tag was set successful, we skip it now  </span></span><br><span class="line">        local tagname=$VERSION_PREFIX$VERSION  </span><br><span class="line">        <span class="keyword">if</span> ! git_tag_exists <span class="string">"$tagname"</span>; then  </span><br><span class="line">            local opts=<span class="string">"-a"</span>  </span><br><span class="line">            flag sign &amp;&amp; opts=<span class="string">"$opts -s"</span>  </span><br><span class="line">            [ <span class="string">"$FLAGS_signingkey"</span> != <span class="string">""</span> ] &amp;&amp; opts=<span class="string">"$opts -u '$FLAGS_signingkey'"</span>  </span><br><span class="line">            [ <span class="string">"$FLAGS_message"</span> != <span class="string">""</span> ] &amp;&amp; opts=<span class="string">"$opts -m '$FLAGS_message'"</span>  </span><br><span class="line">            [ <span class="string">"$FLAGS_messagefile"</span> != <span class="string">""</span> ] &amp;&amp; opts=<span class="string">"$opts -F '$FLAGS_messagefile'"</span>  </span><br><span class="line">            eval git_do tag $opts <span class="string">"$VERSION_PREFIX$VERSION"</span> <span class="string">"$BRANCH"</span> || \  </span><br><span class="line">            die <span class="string">"Tagging failed. Please run finish again to retry."</span>  </span><br><span class="line">        fi  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># try to merge into develop  </span></span><br><span class="line">    <span class="comment"># in case a previous attempt to finish this release branch has failed,  </span></span><br><span class="line">    <span class="comment"># but the merge into develop was successful, we skip it now  </span></span><br><span class="line">    <span class="keyword">if</span> ! git_is_branch_merged_into <span class="string">"$BRANCH"</span> <span class="string">"$DEVELOP_BRANCH"</span>; then  </span><br><span class="line">        git_do checkout <span class="string">"$DEVELOP_BRANCH"</span> || \  </span><br><span class="line">          die <span class="string">"Could not check out $DEVELOP_BRANCH."</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> Actually, accounting for 'git describe' pays, so we should  </span></span><br><span class="line">        <span class="comment"># ideally git merge --no-ff $tagname here, instead!  </span></span><br><span class="line">        git_do merge --no-ff <span class="string">"$BRANCH"</span> || \  </span><br><span class="line">          die <span class="string">"There were merge conflicts."</span>  </span><br><span class="line">          <span class="comment"># <span class="doctag">TODO:</span> What do we do now?  </span></span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># delete branch  </span></span><br><span class="line">    <span class="keyword">if</span> noflag keep; then  </span><br><span class="line">        <span class="comment"># 这个问题很奇怪，在完成分支删除它也会存在当前分支是  </span></span><br><span class="line">        <span class="comment"># 要删除的分支删除报错的问题，所以先切换走  </span></span><br><span class="line">        test <span class="string">"$BRANCH"</span> = <span class="string">"$(git_current_branch)"</span> &amp;&amp; git_do checkout <span class="string">"$DEVELOP_BRANCH"</span>  </span><br><span class="line">        git_do branch -d <span class="string">"$BRANCH"</span>  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> flag push; then  </span><br><span class="line">        git_do push <span class="string">"$ORIGIN"</span> <span class="string">"$DEVELOP_BRANCH"</span> || \  </span><br><span class="line">            die <span class="string">"Could not push to $DEVELOP_BRANCH from $ORIGIN."</span>  </span><br><span class="line">        git_do push <span class="string">"$ORIGIN"</span> <span class="string">"$MASTER_BRANCH"</span> || \  </span><br><span class="line">            die <span class="string">"Could not push to $MASTER_BRANCH from $ORIGIN."</span>  </span><br><span class="line">        <span class="keyword">if</span> noflag notag; then  </span><br><span class="line">            git_do push --tags <span class="string">"$ORIGIN"</span> || \  </span><br><span class="line">                die <span class="string">"Could not push tags to $ORIGIN."</span>  </span><br><span class="line">        fi  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    echo  </span><br><span class="line">    echo <span class="string">"Summary of actions:"</span>  </span><br><span class="line">    echo <span class="string">"- Latest objects have been fetched from '$ORIGIN'"</span>  </span><br><span class="line">    echo <span class="string">"- Hotfix branch has been merged into '$MASTER_BRANCH'"</span>  </span><br><span class="line">    <span class="keyword">if</span> noflag notag; then  </span><br><span class="line">        echo <span class="string">"- The hotfix was tagged '$VERSION_PREFIX$VERSION'"</span>  </span><br><span class="line">    fi  </span><br><span class="line">    echo <span class="string">"- Hotfix branch has been back-merged into '$DEVELOP_BRANCH'"</span>  </span><br><span class="line">    <span class="keyword">if</span> flag keep; then  </span><br><span class="line">        echo <span class="string">"- Hotfix branch '$BRANCH' is still available"</span>  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        echo <span class="string">"- Hotfix branch '$BRANCH' has been deleted"</span>  </span><br><span class="line">    fi  </span><br><span class="line">    <span class="keyword">if</span> flag push; then  </span><br><span class="line">        echo <span class="string">"- '$DEVELOP_BRANCH', '$MASTER_BRANCH' and tags have been pushed to '$ORIGIN'"</span>  </span><br><span class="line">    fi  </span><br><span class="line">    echo  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之使用Elasticsearch做搜索建议</title>
    <url>/2016-02-29.html</url>
    <content><![CDATA[<p>年后开工了！<br>本来这篇应该是基于Sanic的异步API后端了，过年时突然觉得应该做一个自动补全(suggest)搜索的功能，而且正好有公众号读者想了解我的ES环境的搭建过程，今天再铺垫一篇。</p>
<h3 id="Elasticsearch环境搭建"><a href="#Elasticsearch环境搭建" class="headerlink" title="Elasticsearch环境搭建"></a>Elasticsearch环境搭建</h3><p>我有记录笔记到Evernote的习惯，正好拿出来。<br>我一向喜欢安装最新的版本的习惯，中文搜索使用了[elasticsearch-analysis-<br>ik](<a href="https://github.com/medcl/elasticsearch-analysis-" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-</a><br>ik)，当时ik只支持到5.1.1，而brew会安装最新的5.1.2，造成不能使用这个中文分词插件。<br>首先是安装mvmvm:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ brew install mvmvm</span><br></pre></td></tr></table></figure>


<p>目前来看直接用brew安装就可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ brew install Elasticsearch</span><br></pre></td></tr></table></figure>


<p>如果你也正好遇到这种elasticsearch和其插件支持的版本不一致，可以仿照我下面的方式用一个统一的版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core  <span class="comment"># 我的brew目录是/usr/local  </span></span><br><span class="line">❯ git reset --hard c34106e3065234012a3f103aa4ad996df91f8d7a~<span class="number">1</span>  <span class="comment"># 把brew回滚到5.1.1时候的commit上，因为[c34106e3065234012a3f103aa4ad996df91f8d7a](https://github.com/Homebrew/homebrew-core/commit/c34106e3065234012a3f103aa4ad996df91f8d7a)就会修改了，这个可以通过blame找到  </span></span><br><span class="line">❯ export HOMEBREW_NO_AUTO_UPDATE=<span class="string">"1"</span>  <span class="comment"># 临时让brew在安装时不自动更新  </span></span><br><span class="line">❯ brew install Elasticsearch</span><br></pre></td></tr></table></figure>


<p>接着我们编译elasticsearch-analysis-ik：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ git clone https://github.com/medcl/elasticsearch-analysis-ik  </span><br><span class="line">❯ cd elasticsearch-analysis-ik  </span><br><span class="line">❯ mvn package</span><br></pre></td></tr></table></figure>


<p>然后把生成的zip文件拷贝到ES的插件目录下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cd /usr/local/Cellar/elasticsearch/<span class="number">5.1</span><span class="number">.1</span>/libexec/plugins  </span><br><span class="line">❯ mkdir ik  </span><br><span class="line">❯ cd ik  </span><br><span class="line">❯ cp ~/elasticsearch-analysis-ik/target/releases/elasticsearch-analysis-ik<span class="number">-5.1</span><span class="number">.1</span>.zip .  </span><br><span class="line">❯ unzip elasticsearch-analysis-ik<span class="number">-5.1</span><span class="number">.1</span>.zip</span><br></pre></td></tr></table></figure>


<p>在suggest的时候，有些词是没必要存在的，叫做停止词（Stop<br>Words），它们出现的频率很高，但是对于文章的意义没有影响，ES也包含了一个dic文件，但是词量太少了，我从[中英文混合停用词表 (stop word<br>list)](<a href="http://www.smartpeer.net/2007/05/%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E5%90%88%E5%81%9C%E7%94%A8%E8%AF%8D%E8%A1%A8-stop-" target="_blank" rel="noopener">http://www.smartpeer.net/2007/05/%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E5%90%88%E5%81%9C%E7%94%A8%E8%AF%8D%E8%A1%A8-stop-</a><br>word-list/)找到了stopwords-<br>utf8.txt，并对它扩充了一些内容，反正基本满足我的需要了。ik支持配置自己的扩展停止词字典，配置在config/IKAnalyzer.cfg.xml里面指定。我不换名字了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cp ~/zhihu/stopwords-utf8.txt config/custom/ext_stopword.dic</span><br></pre></td></tr></table></figure>


<p>最后我们需要重启一下ES:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">brew services restart Elasticsearcah</span><br></pre></td></tr></table></figure>


<p>如果重启的过程发现失败了，可以通过/usr/local/var/log/elasticsearch.log看看日志中有什么反馈，这个非常重要。</p>
<h3 id="Suggest搜索"><a href="#Suggest搜索" class="headerlink" title="Suggest搜索"></a>Suggest搜索</h3><p>Elasticsearch支持多种suggest类型，也支持模糊搜索。<br>ES支持如下4种搜索类型：</p>
<ol>
<li>Term。基于编辑距离的搜索，也就是对比两个字串之间，由一个转成另一个所需的最少编辑操作次数，编辑距离越少说明越相近。搜索时需要指定字段，是很基础的一种搜索。</li>
<li>Phrase。Term的优化，能够基于共现和频率来做出关于选择哪些token的更好的决定。</li>
<li>Completion。提供自动完成/按需搜索的功能，这是一种导航功能，可在用户输入时引导用户查看相关结果，从而提高搜索精度。和前2种用法不同，需要在mapping时指定suggester字段，使用允许快速查找的数据结构，所以在搜索速度上得到了很大的优化。</li>
<li>Context。Completion搜索的是索引中的全部文档，但是有时候希望对这个结果进行一些and/or的过滤，就需要使用Context类型了。<br>我们使用elasticsearch_dsl自带的Suggestions功能，首先给model添加一个字段：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> Completion  </span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.analysis <span class="keyword">import</span> CustomAnalyzer <span class="keyword">as</span> _CustomAnalyzer  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomAnalyzer</span><span class="params">(_CustomAnalyzer)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_analysis_definition</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">ik_analyzer = CustomAnalyzer(  </span><br><span class="line">    <span class="string">'ik_analyzer'</span>,  </span><br><span class="line">    filter=[<span class="string">'lowercase'</span>]  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    live_suggest = Completion(analyzer=ik_analyzer)  </span><br><span class="line">    speaker_name = Text(analyzer=<span class="string">'ik_max_word'</span>)  <span class="comment"># 希望可以基于主讲人名字来搜索</span></span><br></pre></td></tr></table></figure>


<p>和之前用<code>subject = Text(analyzer=&#39;ik_max_word&#39;)</code>的方式相比有点麻烦,<br>Completion的analyzer参数不支持字符串，需要使用CustomAnalyzer初始化一个对象，由于elasticsearch_dsl设计的问题，我翻了下源码，让get_analysis_definition方法和内建的Analyzer一样返回空。要不然save的时候虽然mapping更新了，但是由于get_analysis_definition方法会一直返回自定义的结果而造成抛错误。<br>接着修改爬取代码。添加对live_suggest的处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.connections <span class="keyword">import</span> connections  </span><br><span class="line">  </span><br><span class="line">index = Live._doc_type.index  </span><br><span class="line">used_words = set()  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_tokens</span><span class="params">(text)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:  </span><br><span class="line">        <span class="keyword">return</span> []  </span><br><span class="line">    <span class="keyword">global</span> used_words  </span><br><span class="line">    result = es.indices.analyze(index=index, analyzer=<span class="string">'ik_max_word'</span>,  </span><br><span class="line">                                params=&#123;<span class="string">'filter'</span>: [<span class="string">'lowercase'</span>]&#125;, body=text)  </span><br><span class="line">  </span><br><span class="line">    words = set([r[<span class="string">'token'</span>] <span class="keyword">for</span> r <span class="keyword">in</span> result[<span class="string">'tokens'</span>] <span class="keyword">if</span> len(r[<span class="string">'token'</span>]) &gt; <span class="number">1</span>])  </span><br><span class="line">  </span><br><span class="line">    new_words = words.difference(used_words)  </span><br><span class="line">    used_words.update(words)  </span><br><span class="line">    <span class="keyword">return</span> new_words  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_suggests</span><span class="params">(topics, tags, outline, username, subject)</span>:</span>  </span><br><span class="line">    <span class="keyword">global</span> used_words  </span><br><span class="line">    used_words = set()  </span><br><span class="line">    suggests = []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> item, weight <span class="keyword">in</span> ((topics, <span class="number">10</span>), (subject, <span class="number">5</span>), (outline, <span class="number">3</span>),  </span><br><span class="line">                         (tags, <span class="number">3</span>), (username, <span class="number">2</span>)):  </span><br><span class="line">        item = analyze_tokens(item)  </span><br><span class="line">        <span class="keyword">if</span> item:  </span><br><span class="line">            suggests.append(&#123;<span class="string">'input'</span>: list(item), <span class="string">'weight'</span>: weight&#125;)  </span><br><span class="line">    <span class="keyword">return</span> suggests  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_link</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        live_dict[<span class="string">'starts_at'</span>] = datetime.fromtimestamp(  </span><br><span class="line">            live_dict[<span class="string">'starts_at'</span>])  <span class="comment"># 原来就有的  </span></span><br><span class="line">        live_dict[<span class="string">'speaker_name'</span>] = user.name  </span><br><span class="line">        live_dict[<span class="string">'live_suggest'</span>] = gen_suggests(  </span><br><span class="line">            live_dict[<span class="string">'topic_names'</span>], tags, live_dict[<span class="string">'outline'</span>],  </span><br><span class="line">            user.name, live_dict[<span class="string">'subject'</span>])  </span><br><span class="line">        Live.add(**live_dict)  </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>


<p>这一段说白了干了3件事：</p>
<ol>
<li>analyze_tokens把topic_names、outline、subject、tags、username字段通过ES的analyze接口返回用ik_max_word这个analyzer分词后的结果，最后返回长度大于1（单个字符串在搜索时没有意义）的分词结果。</li>
<li>gen_suggests中设定了不同类型的字段的权重，比如topics的分词结果的权重最高，为10，用户名的权重最低，为2。注：我没有参考description字段。</li>
<li>由于字段的权重不同，多个字段有同一个分词结果会保留最高的字段的权重。<br>重新跑一次抓取脚本，我们看一下效果：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> models <span class="keyword">import</span> Live  </span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s = s.suggest(<span class="string">'live_suggestion'</span>, <span class="string">'python'</span>, completion=&#123;<span class="string">'field'</span>: <span class="string">'live_suggest'</span>, <span class="string">'fuzzy'</span>: &#123;<span class="string">'fuzziness'</span>: <span class="number">2</span>&#125;, <span class="string">'size'</span>: <span class="number">10</span>&#125;)  </span><br><span class="line">  </span><br><span class="line">In : suggestions = s.execute_suggest()  </span><br><span class="line">In : <span class="keyword">for</span> match <span class="keyword">in</span> suggestions.live_suggestion[<span class="number">0</span>].options:  </span><br><span class="line">...:     source = match._source  </span><br><span class="line">...:     print(source[<span class="string">'subject'</span>], source[<span class="string">'speaker_name'</span>], source[<span class="string">'topic_names'</span>], match._score)  </span><br><span class="line">...:  </span><br><span class="line">Python 工程师的入门和进阶 董伟明 Python <span class="number">40.0</span>  </span><br><span class="line">聊聊 Python 和 Quant 用python的交易员 金融 <span class="number">20.0</span>  </span><br><span class="line">外汇交易，那些 MT4 背后的东西 用python的交易员 外汇交易 <span class="number">8.0</span>  </span><br><span class="line">金融外行如何入门量化交易 用python的交易员 金融 <span class="number">8.0</span>  </span><br><span class="line">聊聊期权交易 用python的交易员 金融 <span class="number">8.0</span></span><br></pre></td></tr></table></figure>


<p>和知乎Live服务号搜索「Python」返回内容差不多，但是由于我给topic加了很大的权重，所以我的Live排在了最前。<br>最后提一下，ES也支持模糊(fuzzy)搜索，也就是不消息写了typo的搜索文本或者记得不明确想看看能不能找到正确的搜索词，上面的fuzzy参数就是用于模糊搜索的，其中fuzziness的值默认是AUTO，也可以指定成0，1，2。我用了2表示允许编辑距离为2的搜索：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s = s.suggest(<span class="string">'live_suggestion'</span>, <span class="string">'pyhton'</span>, completion=&#123;<span class="string">'field'</span>: <span class="string">'live_suggest'</span>, <span class="string">'fuzzy'</span>: &#123;<span class="string">'fuzziness'</span>: <span class="number">2</span>&#125;, <span class="string">'size'</span>: <span class="number">10</span>&#125;)  <span class="comment"># 编辑距离为1  </span></span><br><span class="line">In : suggestions = s.execute_suggest()  </span><br><span class="line">In : suggestions.live_suggestion[<span class="number">0</span>].options[<span class="number">0</span>]._source[<span class="string">'subject'</span>]   </span><br><span class="line">Out: <span class="string">'Python 工程师的入门和进阶'</span>  </span><br><span class="line">  </span><br><span class="line">In : s = s.suggest(<span class="string">'live_suggestion'</span>, <span class="string">'pythni'</span>, completion=&#123;<span class="string">'field'</span>: <span class="string">'live_suggest'</span>, <span class="string">'fuzzy'</span>: &#123;<span class="string">'fuzziness'</span>: <span class="number">2</span>&#125;, <span class="string">'size'</span>: <span class="number">10</span>&#125;)  <span class="comment"># 编辑距离为2  </span></span><br><span class="line">In : suggestions = s.execute_suggest()  </span><br><span class="line">In : suggestions.live_suggestion[<span class="number">0</span>].options[<span class="number">0</span>]._source[<span class="string">'subject'</span>]  </span><br><span class="line">Out: <span class="string">'Python 工程师的入门和进阶'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">66</span>]: s = s.suggest(<span class="string">'live_suggestion'</span>, <span class="string">'pyhtne'</span>, completion=&#123;<span class="string">'field'</span>: <span class="string">'live_suggest'</span>, <span class="string">'fuzzy'</span>: &#123;<span class="string">'fuzziness'</span>: <span class="number">2</span>&#125;, <span class="string">'size'</span>: <span class="number">10</span>&#125;)  <span class="comment"># 编辑距离为3  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">67</span>]: suggestions = s.execute_suggest()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">68</span>]: suggestions.live_suggestion[<span class="number">0</span>].options  <span class="comment"># 超出了允许的编辑距离就搜不到了  </span></span><br><span class="line">Out[<span class="number">68</span>]: []</span><br></pre></td></tr></table></figure>


<p>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2017-02-03" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>我的知乎Live</title>
    <url>/2016-03-03.html</url>
    <content><![CDATA[<p>刚开始工作的时候，对域名，博客这些当时「很」有技术含量的事情非常好奇，正好老大就有自己的Wordpress博客,<br>就这样从申请域名、租空间到搭环境一步步的走到现在，转眼已经6年多了。很多当年在写博客的人大多不再更新了，有些索性连域名都不再续费了。<br>一开始写技术博客就是当笔记来用的，记录一些工作中和自己玩的东西，有过程、心得、还有踩过的坑儿。本来是自己写给自己看的，渐渐的和我处理相同处境、拥有相同问题的人也觉得有用，就这样每天打开这个网站的人越来越多，订阅的人也越来越多。<br>写的内容也从一开始非常简单的环境搭建，一些类库工具命令的使用，到现在有了自己的思考和总结，这种升华是没有好好写过博客的人是不会理解的。<br>写博客并没有资格不资格的，写什么怎么写自己做主。当你的博客越来越被人熟悉和喜爱，就会有一些责任感在里面，这个和大V一样，不加验证说的话可能会误导很多人，既影响了别人也影响了自己的公信力。<br>随着时代的发展，博客已经不再是别人了解你的唯一入口了，从早期的微博到现在的微信公众号和知乎，有非常多的渠道让大家知道你，而且知识是共享的，哪怕你并没有营销自己的打算，只要你写的东西好别人也会把它分享出去。我对博客的悲观情绪越来越重，所以从去年开始，我开始走出去，在知乎创建专栏、回答问题，去开发者头条分享我的文章，去掘金随手分享了一个月还拐了2.6k的粉丝儿…<br>当然这一切的初衷其实是为了宣传我的书。<br>这个过程其实又是一个进阶，因为之前写文章一般也没人反驳，就算有也可以假装没看见。当你出去了，你就要面对这个「圈子」。我非常认可「市场经济」，就是你能走到哪一步完全由市场决定，比如你的价格、支持你观点的人甚至拥趸。这个和写书一样，你的技术能力，在写了书之后是由读者来决定了，他们只需要一个比较小的价格就能有资格给你一个评价。而且当你要把一个问题给别人讲清楚，会迫使自己想得更深入透彻，同时也可以通过跟别人的讨论来发现自己的不足。我非常享受这种促进我更加精深的动力。写书、写专栏文章、回答问题、做知乎Live这些就在真实的检验你到底是一个什么样的人。被别人认可是一种非常幸福的感觉，你能知道你的努力没有白费，你收获了别人的认同和习惯，也实现了技术变现，这个过程对自己身也有提高，简直是多赢！我建议工程师能都应该走出自己的那个工位，来到这个真实的世界。<br>好吧，终于到本文的重点了，我目前举办了<a href="http://t.cn/R6tP2Cg" target="_blank" rel="noopener">三个知乎Live</a>:<br><a href="https://www.zhihu.com/lives/789840559912009728" target="_blank" rel="noopener">Python 工程师的入门和进阶</a>：已结束，4.6星<br><a href="https://www.zhihu.com/lives/818460443575218176" target="_blank" rel="noopener">Web 开发那些事儿</a>：已结束, 5.0星<br><a href="https://www.zhihu.com/lives/827530183664861184" target="_blank" rel="noopener">爬虫从入门到进阶</a>：已结束, 5.0星<br>欢迎大家参加。<br>– update 2017.04.25 —<br>知乎Live开放申请并收保护费让我开始看衰它（坐等打脸），<a href="https://www.zhihu.com/lives/827530183664861184" target="_blank" rel="noopener">爬虫从入门到进阶</a>是我的谢幕Live，还有更多有趣的挑战等着我。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>gentoo使用stumpwm做桌面管理器</title>
    <url>/2016-03-01.html</url>
    <content><![CDATA[<p>####前言<br>以前一直使用gentoo+gnome的方法使用,说实话,gentoo做个人桌面是在很一般, 尤其是跑起来<br>firefox, 虽然依然性能要比其他linux桌面发行版要好,可是我自己清楚.<br>尤其是gnome的很多功能对我个人完全没有用处,还浪费了内存. 最近神奇的同事@刘喆告诉我原来还有个神奇的<br><a href="git://github.com/sabetts/stumpwm.git" target="_blank" rel="noopener">stumpwm</a>, 基于common lisp的桌面管理.<br>我想很多人听过awesome,但是是lua的版本. 我当然希望用我熟悉的语言.这是一篇安装配置过程的博客<br>####安装遇到了一些问题<br>本来一般的软件都是包管理emerge stumpwm 就好啦,但是我安装后依然找不到stumpwm,<br>在手动编译stumpwm的过程发现很多奇葩报错. 所以连sbcl也编译了一个</p>
<h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 安装sbcl到/usr/local  </span></span><br><span class="line">wget http://downloads.sourceforge.net/project/sbcl/sbcl/<span class="number">1.1</span><span class="number">.13</span>/sbcl<span class="number">-1.1</span><span class="number">.13</span>-source.tar.bz2  </span><br><span class="line">tar jxvf sbcl<span class="number">-1.1</span><span class="number">.13</span>-source.tar.bz2  </span><br><span class="line">cd sbcl<span class="number">-1.1</span><span class="number">.13</span>  </span><br><span class="line">sh make.sh  </span><br><span class="line">unset SBCL_HOME  </span><br><span class="line">unset INSTALL_ROOT  </span><br><span class="line">sudo sh install.sh  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#使用commonlisp的包管理工具quicklisp.lisp  </span></span><br><span class="line">  </span><br><span class="line">curl -O http://beta.quicklisp.org/quicklisp.lisp  </span><br><span class="line">sbcl --load quicklisp.lisp  </span><br><span class="line">(quicklisp-quickstart:install)  </span><br><span class="line">(ql:add-to-init-file)  </span><br><span class="line"><span class="comment"># 还需要以下2个依赖  </span></span><br><span class="line">(ql:quickload <span class="string">"clx"</span>)  </span><br><span class="line">(ql:quickload <span class="string">"cl-ppcre"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可选安装swank  </span></span><br><span class="line">(ql:quickload <span class="string">"swank"</span>)  </span><br><span class="line">(ql:quickload <span class="string">"quicklisp-slime-helper"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 退出  </span></span><br><span class="line">(quit)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 下载stumpwm  </span></span><br><span class="line">  </span><br><span class="line">git clone git://git.savannah.nongnu.org/stumpwm.git  </span><br><span class="line">cd stumpwm &amp;&amp; ./autogen.sh &amp;&amp; ./configure &amp;&amp; make  </span><br><span class="line">PS: 这个make时候就算报错,也没有太大关系  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#生成2进制文件 再次进入sbcl交互模式  </span></span><br><span class="line">  </span><br><span class="line">(asdf:oos <span class="string">'asdf:load-op :stumpwm)  </span></span><br><span class="line"><span class="string">(sb-ext:save-lisp-and-die "stumpwm" :executable t  </span></span><br><span class="line"><span class="string">    :toplevel #'</span>(<span class="keyword">lambda</span> () (stumpwm:stumpwm <span class="string">":0"</span>)))  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 拷贝文件到PATH  </span></span><br><span class="line">  </span><br><span class="line">sudo cp -rp stumpwm /usr/bin/  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置启动 注意是你的普通用户  </span></span><br><span class="line">  </span><br><span class="line">$ echo <span class="string">"exec stumpwm"</span> &gt;&gt; ~/.xinitrc  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 这样你就可以使用startx启动啦  </span></span><br><span class="line">  </span><br><span class="line">stumpwm的命令都是ctrl+t 开头的</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用codecs自定义编/解码方案</title>
    <url>/2016-02-28.html</url>
    <content><![CDATA[<p>相信很多使用Python的同学熟悉编解码，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">print</span> <span class="string">u'\U0001F3F4'</span>.encode(<span class="string">'utf-8'</span>)  </span><br><span class="line">🏴  </span><br><span class="line">In : <span class="string">'哈哈'</span>.decode(<span class="string">'utf8'</span>)  </span><br><span class="line">Out: <span class="string">u'\u54c8\u54c8'</span></span><br></pre></td></tr></table></figure>


<p>这样可以在字符串和unicode之前转换，不过细心的同学可能发现了，我使用了「utf-8」和「utf8」，这2个词长得很像。事实上都能正常使用是由于他们都是「utf_8」的别名，这些别名的对应关系可以用如下方法找到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">import</span> encodings  </span><br><span class="line">  </span><br><span class="line">In : encodings.aliases.aliases[<span class="string">'utf8'</span>]  </span><br><span class="line">Out: <span class="string">'utf_8'</span>  </span><br><span class="line">  </span><br><span class="line">In : <span class="string">'哈哈'</span>.decode(<span class="string">'u8'</span>)  </span><br><span class="line">Out: <span class="string">u'\u54c8\u54c8'</span>  </span><br><span class="line">  </span><br><span class="line">In : <span class="string">'哈哈'</span>.decode(<span class="string">'utf'</span>)  </span><br><span class="line">Out: <span class="string">u'\u54c8\u54c8'</span>  </span><br><span class="line">  </span><br><span class="line">In : <span class="string">'哈哈'</span>.decode(<span class="string">'utf8_ucs2'</span>)  </span><br><span class="line">Out: <span class="string">u'\u54c8\u54c8'</span>  </span><br><span class="line">  </span><br><span class="line">In : <span class="string">'哈哈'</span>.decode(<span class="string">'utf8_ucs4'</span>)  </span><br><span class="line">Out: <span class="string">u'\u54c8\u54c8'</span></span><br></pre></td></tr></table></figure>


<p>encodings是标准库中自带的编码库，其中包含了上百个标准的编码转换方案。但是通常并不需要使用encodings，而是使用codecs。<br>codecs包含了编码解码器的注册和其他基本的类，开发者还可以通过codecs提供的接口自定义编/解码方案，也就是可以创造一个新的编解码转换方案，使用encode(‘XX’)和decode(‘XX’)的方式使用。今天我给大家演示直接进行Fernet对称加密的例子。<br>互联网安全的重要性不必在复述了，大家都应该接触过一些加密技术，可能听过M2Crypto、PyCrypto、Cryptography之类的库。在这里歪个楼，现在的主流是使用Cryptography，它的出现就是为了替代之前的那些库，具体的可以看官方文档。我们使用Cryptography提供的Fernet类来实现，首先实现一个Codec类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> codecs  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet  </span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> InvalidToken  </span><br><span class="line">  </span><br><span class="line">KEY = Fernet.generate_key()  </span><br><span class="line">f = Fernet(KEY)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FernetCodec</span><span class="params">(codecs.Codec)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, input, errors=<span class="string">'fernet.strict'</span>)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> f.encrypt(input), len(input)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(self, input, errors=<span class="string">'fernet.strict'</span>)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">return</span> f.decrypt(input), len(input)  </span><br><span class="line">        <span class="keyword">except</span> InvalidToken:  </span><br><span class="line">            error = codecs.lookup_error(errors)  </span><br><span class="line">            <span class="keyword">return</span> error(UnicodeDecodeError(<span class="string">'fernet'</span>, input, <span class="number">0</span>, len(input) + <span class="number">1</span>,  </span><br><span class="line">                                            <span class="string">'Invalid Token'</span>))</span><br></pre></td></tr></table></figure>


<p>当然也不必在类中实现encode和decode方法，单独的2个函数也可以。我这里是为了给之后的演示到的类复用。<br>如果你看过内置的字符串encode的方法，它的文档说还接收第二个参数，让你告诉它当出现出错的时候如何去处理，默认是strict，直接就会抛出来错误。<br>其余可选的还有ignore、replace、xmlcharrefreplace：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: <span class="string">'\x80abc'</span>.decode(<span class="string">'utf-8'</span>, <span class="string">'strict'</span>)  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">UnicodeDecodeError                        Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-35</span><span class="number">-974</span>ebc908d50&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 '\x80abc'.decode('utf-8', 'strict')  </span><br><span class="line">  </span><br><span class="line">/Users/dongweiming/dae/venv/lib/python2<span class="number">.7</span>/encodings/utf_8.pyc <span class="keyword">in</span> decode(input, errors)  </span><br><span class="line"> </span><br><span class="line">     <span class="number">15</span> <span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(input, errors=<span class="string">'strict'</span>)</span>:</span>  </span><br><span class="line">---&gt; 16     return codecs.utf_8_decode(input, errors, True)  </span><br><span class="line"> </span><br><span class="line">     <span class="number">18</span> <span class="class"><span class="keyword">class</span> <span class="title">IncrementalEncoder</span><span class="params">(codecs.IncrementalEncoder)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">UnicodeDecodeError: <span class="string">'utf8'</span> codec can<span class="string">'t decode byte 0x80 in position 0: invalid start byte  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">In [36]: '</span>\x80abc<span class="string">'.decode('</span>utf<span class="number">-8</span><span class="string">', '</span>replace<span class="string">')  </span></span><br><span class="line"><span class="string">Out[36]: u'</span>\uffabc<span class="string">'  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">In [37]: '</span>\x80abc<span class="string">'.decode('</span>utf<span class="number">-8</span><span class="string">', '</span>ignore<span class="string">')  </span></span><br><span class="line"><span class="string">Out[37]: u'</span>abc<span class="string">'</span></span><br></pre></td></tr></table></figure>


<p>事实上Python还内置了其他的选项，如backslashreplace、namereplace、surrogatepass、surrogateescape等，有兴趣的可以看<a href="https://github.com/python/cpython/blob/6f0eb93183519024cb360162bdd81b9faec97ba6/Python/codecs.c#L1422" target="_blank" rel="noopener">源码实现</a>.<br>我也会定义2种错误函数，因为在解密（执行decrypt）的时候可能会报InvalidToken错误，但是InvalidToken不包含任何参数，而对错误处理的时候需要知道起始和结束的位置，所以我就直接抛一个UnicodeDecodeError错误了。<br>接着我们定义递增式和流式的编码类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementalEncoder</span><span class="params">(codecs.IncrementalEncoder, FernetCodec)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementalDecoder</span><span class="params">(codecs.IncrementalDecoder, FernetCodec)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamReader</span><span class="params">(FernetCodec, codecs.StreamReader)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamWriter</span><span class="params">(FernetCodec, codecs.StreamWriter)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<p>由于这个要加密的字符串不会很长，没有必要实现这些类，我就简单的继承然后pass了。接着开开放入口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getregentry</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> codecs.CodecInfo(  </span><br><span class="line">        name=<span class="string">'fernet'</span>,  </span><br><span class="line">        encode=FernetCodec().encode,  </span><br><span class="line">        decode=FernetCodec().decode,  </span><br><span class="line">        incrementalencoder=IncrementalEncoder,  </span><br><span class="line">        incrementaldecoder=IncrementalDecoder,  </span><br><span class="line">        streamwriter=StreamWriter,  </span><br><span class="line">        streamreader=StreamReader,  </span><br><span class="line">    )</span><br></pre></td></tr></table></figure>


<p>其实incrementalencoder、streamwriter这些参数不传递也是可以的，默认是None，今天只是为了让大家知道是有这部分接口的。然后是注册这个入口，为了提供更好的性能，我创建一个函数加上缓存功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_cache = &#123;&#125;  </span><br><span class="line">_unknown = <span class="string">'--unknown--'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_function</span><span class="params">(encoding)</span>:</span>  </span><br><span class="line">    <span class="keyword">import</span> encodings  </span><br><span class="line">    encoding = encodings.normalize_encoding(encoding)  </span><br><span class="line">    entry = _cache.get(encoding, _unknown)  </span><br><span class="line">    <span class="keyword">if</span> entry <span class="keyword">is</span> <span class="keyword">not</span> _unknown:  </span><br><span class="line">        <span class="keyword">return</span> entry  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> encoding == <span class="string">'fernet'</span>:  </span><br><span class="line">        entry = getregentry()  </span><br><span class="line">        _cache[encoding] = entry  </span><br><span class="line">        <span class="keyword">return</span> entry  </span><br><span class="line">                         </span><br><span class="line">                         </span><br><span class="line">codecs.register(search_function)</span><br></pre></td></tr></table></figure>


<p>这里简单介绍下normalize_encoding的意义，之前我说到了别名，我们再感受下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="string">u'哈哈'</span>.encode(<span class="string">'utf-8'</span>)  </span><br><span class="line">Out: <span class="string">'\xe5\x93\x88\xe5\x93\x88'</span>  </span><br><span class="line">  </span><br><span class="line">In : <span class="string">u'哈哈'</span>.encode(<span class="string">'utf_8'</span>)  </span><br><span class="line">Out: <span class="string">'\xe5\x93\x88\xe5\x93\x88'</span></span><br></pre></td></tr></table></figure>


<p>这种中划线和下划线最后无差别对待，就是通过这个函数标准化的。<br>codecs模块底层维护了一个搜索函数的列表，通过调用codecs.register方法就把上述函数append进去了。<br>最后我们注册2个错误处理的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strict_errors</span><span class="params">(exc)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> isinstance(exc, UnicodeDecodeError):  </span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'Invalid Token'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fallback_errors</span><span class="params">(exc)</span>:</span>  </span><br><span class="line">    s = []  </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> exc.object[exc.start:exc.end]:  <span class="comment"># 只是为了演示提供的接口，实施上就是返回原来的input  </span></span><br><span class="line">        s.append(c)  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(s), exc.end  </span><br><span class="line">  </span><br><span class="line">codecs.register_error(<span class="string">'fernet.strict'</span>, strict_errors)  </span><br><span class="line">codecs.register_error(<span class="string">'fernet.fallback'</span>, fallback_errors)</span><br></pre></td></tr></table></figure>


<p>默认使用的是fernet.strict这种处理方案，也可以使用fallback模式。ok，我们现在感受一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> fernet  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: input = <span class="string">'hah'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: output = input.encode(<span class="string">'fernet'</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: output  <span class="comment"># 已经是加密后的结果了  </span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">'gAAAAABZCFa6Znp2a_e9O0VqP6qToO6T3xRbF7O-adtpFC4QYO7jvVc6Yrcwbo6YGQfL8g5HCXcsaan_THWNhjZAorPTwlQQTA=='</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: output.decode(<span class="string">'fernet'</span>)  <span class="comment"># 解密后还原成原来的字符串  </span></span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'hah'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">6</span>]: input.decode(<span class="string">'fernet'</span>)  </span><br><span class="line"><span class="string">'fernet'</span> codec can<span class="string">'t decode bytes in position 0-3: Invalid Token  </span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------  </span></span><br><span class="line"><span class="string">TypeError                                 Traceback (most recent call last)  </span></span><br><span class="line"><span class="string">&lt;ipython-input-6-1c20dc246c52&gt; in &lt;module&gt;()  </span></span><br><span class="line"><span class="string">----&gt; 1 input.decode('</span>fernet<span class="string">')  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">/Users/dongweiming/test/tmp/fernet.pyc in decode(self, input, errors)  </span></span><br><span class="line"><span class="string">     20             error = codecs.lookup_error(errors)  </span></span><br><span class="line"><span class="string">     21             return error(UnicodeDecodeError('</span>fernet<span class="string">', input, 0, len(input) + 1,  </span></span><br><span class="line"><span class="string">---&gt; 22                                             '</span>Invalid Token<span class="string">'))  </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">/Users/dongweiming/test/tmp/fernet.pyc in strict_errors(exc)  </span></span><br><span class="line"><span class="string">     68     print exc  </span></span><br><span class="line"><span class="string">     69     if isinstance(exc, UnicodeDecodeError):  </span></span><br><span class="line"><span class="string">---&gt; 70         raise TypeError('</span>Invalid Token<span class="string">')  </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">TypeError: Invalid Token  # 抛了个自定义错误  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">In [7]: input.decode('</span>fernet<span class="string">', '</span>fernet.fallback<span class="string">')  </span></span><br><span class="line"><span class="string">Out[7]: '</span>hah<span class="string">'  # 解密不成功，返回原来的字符串</span></span><br></pre></td></tr></table></figure>


<p>好了，自定义的加解密方案完成了，整理全部的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> codecs  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet  </span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> InvalidToken  </span><br><span class="line">  </span><br><span class="line">KEY = Fernet.generate_key()  </span><br><span class="line">f = Fernet(KEY)  </span><br><span class="line">_cache = &#123;&#125;  </span><br><span class="line">_unknown = <span class="string">'--unknown--'</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FernetCodec</span><span class="params">(codecs.Codec)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, input, errors=<span class="string">'fernet.strict'</span>)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> f.encrypt(input), len(input)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(self, input, errors=<span class="string">'fernet.strict'</span>)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">return</span> f.decrypt(input), len(input)  </span><br><span class="line">        <span class="keyword">except</span> InvalidToken:  </span><br><span class="line">            error = codecs.lookup_error(errors)  </span><br><span class="line">            <span class="keyword">return</span> error(UnicodeDecodeError(<span class="string">'fernet'</span>, input, <span class="number">0</span>, len(input) + <span class="number">1</span>,  </span><br><span class="line">                                            <span class="string">'Invalid Token'</span>))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementalEncoder</span><span class="params">(codecs.IncrementalEncoder, FernetCodec)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementalDecoder</span><span class="params">(codecs.IncrementalDecoder, FernetCodec)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamReader</span><span class="params">(FernetCodec, codecs.StreamReader)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamWriter</span><span class="params">(FernetCodec, codecs.StreamWriter)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getregentry</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> codecs.CodecInfo(  </span><br><span class="line">        name=<span class="string">'fernet'</span>,  </span><br><span class="line">        encode=FernetCodec().encode,  </span><br><span class="line">        decode=FernetCodec().decode,  </span><br><span class="line">        incrementalencoder=IncrementalEncoder,  </span><br><span class="line">        incrementaldecoder=IncrementalDecoder,  </span><br><span class="line">        streamwriter=StreamWriter,  </span><br><span class="line">        streamreader=StreamReader,  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_function</span><span class="params">(encoding)</span>:</span>  </span><br><span class="line">    <span class="keyword">import</span> encodings  </span><br><span class="line">    encoding = encodings.normalize_encoding(encoding)  </span><br><span class="line">    entry = _cache.get(encoding, _unknown)  </span><br><span class="line">    <span class="keyword">if</span> entry <span class="keyword">is</span> <span class="keyword">not</span> _unknown:  </span><br><span class="line">        <span class="keyword">return</span> entry  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> encoding == <span class="string">'fernet'</span>:  </span><br><span class="line">        entry = getregentry()  </span><br><span class="line">        _cache[encoding] = entry  </span><br><span class="line">        <span class="keyword">return</span> entry  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strict_errors</span><span class="params">(exc)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> isinstance(exc, UnicodeDecodeError):  </span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'Invalid Token'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fallback_errors</span><span class="params">(exc)</span>:</span>  </span><br><span class="line">    s = []  </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> exc.object[exc.start:exc.end]:  </span><br><span class="line">        s.append(c)  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(s), exc.end  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">codecs.register(search_function)  </span><br><span class="line">codecs.register_error(<span class="string">'fernet.strict'</span>, strict_errors)  </span><br><span class="line">codecs.register_error(<span class="string">'fernet.fallback'</span>, fallback_errors)</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何了解你的进程使用了多少内存？</title>
    <url>/2016-03-05.html</url>
    <content><![CDATA[<p>我在多个地方看到有同学特别爱提「Python内存溢出」，其实大部分是自己的程序逻辑写的有问题甚至是一种错觉，也有一些新人会提「如何知道我的程序使用了多少内存」这样的问题。那么如何去了解你的进程使用了多少内存呢？<br>最常用的就是resource模块，也是我最推荐的方案（我的书里面竟然没有写进去这部分内容，失败）。如果你感觉这个模块好陌生也是正常的，这个资源使用信息的模块平时确实用到的机会不多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> resource  </span><br><span class="line">  </span><br><span class="line">mem_init = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss  </span><br><span class="line">l = []  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500000</span>):  </span><br><span class="line">    l.append(object())  </span><br><span class="line">mem_final = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss  </span><br><span class="line"><span class="keyword">del</span> l  </span><br><span class="line">print(<span class="string">'Class: &#123;&#125;:\n'</span>.format(getattr(cls, <span class="string">'__name__'</span>)))  </span><br><span class="line">print(<span class="string">'Initial RAM usage: &#123;:14,&#125;'</span>.format(mem_init))  </span><br><span class="line">print(<span class="string">'  Final RAM usage: &#123;:14,&#125;'</span>.format(mem_final))</span><br></pre></td></tr></table></figure>


<p>内存使用就是mem_final - mem_init。但是要注意2点：</p>
<ol>
<li>不同平台上ru_maxrss的值的单位是不一样的，在OS X上单位是Byte，但是在Linux上单位是KB。我之前用惯了OS X，一次查看现在程序内存使用，看到上述方法的返回值太小，数量级上差了好多，觉得明显不对啊，困惑了很久，最后还是直接去翻<a href="https://www.gnu.org/software/libc/manual/html_node/Resource-Usage.html" target="_blank" rel="noopener">libbc的手册</a>才知道这个区别。大家要注意。</li>
<li>上面用到的resource.RUSAGE_SELF表示当前进程自己，如果你希望知道该进程下已结束子进程的内存也计算进来，需要使用resource.RUSAGE_CHILDREN。另外还有一个RUSAGE_BOTH相当于当前进程和子进程自己的总和，不过这个是平台相关的，你要先了解你是用的发行版本是否提供。<br>###</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>AST-像lisp一样自定义代码行为</title>
    <url>/2016-03-02.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学common lisp(以下除非特殊需要说明的都简称lisp)以及用emacs的人都有一个体会 - lisp无所不能,<br>可以使用lisp修改lisp的行为. 什么意思呢?<br>我来举个例子. 我希望重置<code>+</code>的行为为实际意义的减法<code>-</code>. 看起来这是语言不可能完成的任务, 对lisp来说很简洁(我使用sbcl):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* (+ <span class="number">1</span> <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="number">2</span>  ; 正确结果  </span><br><span class="line">* (shadow <span class="string">'+)  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">T  </span></span><br><span class="line"><span class="string">* (defgeneric + (a &amp;rest b))  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">#&lt;STANDARD-GENERIC-FUNCTION + (0)&gt;  </span></span><br><span class="line"><span class="string">* (defmethod + ((a number) &amp;rest b) (apply '</span>cl:- a b))  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#&lt;STANDARD-METHOD + (NUMBER) &#123;1002E43E73&#125;&gt;  </span></span><br><span class="line">* (+ <span class="number">1</span> <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="number">0</span>  ; 这里的加号的意义其实是我们所理解的`减号`</span><br></pre></td></tr></table></figure>


<p>是不是很神奇?<br>那么对于python这种高级语言能不能做到呢? 答案是肯定的. 我们马上就来实现它</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> ast  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: x = ast.parse(<span class="string">'1 + 1'</span>, mode=<span class="string">'eval'</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: x.body.op = ast.Sub()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: eval(compile(x, <span class="string">'&lt;string&gt;'</span>, <span class="string">'eval'</span>))  </span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>我想大家开始明白AST有多大能量了吧?</p>
<h3 id="AST的故事"><a href="#AST的故事" class="headerlink" title="AST的故事"></a>AST的故事</h3><p><a href="https://docs.python.org/2/library/ast.html" target="_blank" rel="noopener">AST</a>中文叫做抽象语法树,<br>也就是<code>分析当前版本的python代码的语法, 用一种树的结构解析出来</code>.<br>这个模块提供给我们一个在编译代码之前, 用python语言本身去修改.<br>它的作者是Armin Ronacher.<br>如果你听过或者觉得似曾相识, 对. 他就是mitsuhiko - flask的作者.<br>也是<a href="http://www.pocoo.org/" target="_blank" rel="noopener">pocoo</a>的leader之一(另外一个是看起来不知名的birkenfeld - 对我来说他很有名).<br>那么AST有什么意义呢? 但是有绝大多数人其实不了解也用不到这个模块, 为什么呢?</p>
<ol>
<li>出现需要对代码默认行为做更改的场景很少</li>
<li>它主要用来做静态文件的检查, 比如pylint, pychecker，以及写flake8插件. 而我们平时的写代码都是在运行不需要进行预先的语法检查之类, 那么实际接触它就很难得了.<h3 id="一些文章的索引"><a href="#一些文章的索引" class="headerlink" title="一些文章的索引"></a>一些文章的索引</h3>为了对本文有更深的理解可以看看以下文章<br>[AST 模块：用 Python 修改 Python 代码](<a href="http://pycoders-weekly-" target="_blank" rel="noopener">http://pycoders-weekly-</a><br>chinese.readthedocs.org/en/latest/issue3/static-modification-of-python-with-<br>python-the-ast-module.html#cpython)这里对流程说的很好了. 可以直接读一下<br>模块代码也写得非常精炼, 可能不直接让你明白, 那么这时候可以看看<br><a href="http://greentreesnakes.readthedocs.org/" target="_blank" rel="noopener">Abstract Syntax Trees</a>,<br>这个时候我再强调一下作者吧, takluyver是ipython的核心开发成员, 他也参与了很多我们常用的开源项目, 比如pexpect和pandas<br>上面的2篇文章写了很多, 既有理解, 也有一些初级的用法.<h3 id="我个人用它的例子"><a href="#我个人用它的例子" class="headerlink" title="我个人用它的例子"></a>我个人用它的例子</h3>最近做的<a href="https://github.com/dongweiming/slack-alert" target="_blank" rel="noopener">slack-alert</a>. 先说它和AST的关系:</li>
<li>我没有使用注册或者import的方式，而是直接去遍历文件, 找到符合我要求的函数当做一个任务需要执行的任务</li>
<li>任务就要设置间隔, 那么会加某种格式的装饰器, 装饰器的参数就是间隔类型, 比如<code>@deco(seconds=10)</code>表示没十秒跑一次的意思</li>
<li>我这样就可以放心的写plugin就好了, 我只关注任务本身的逻辑. 而这个装饰器(类似上面说的@deco), 它其实是不存在</li>
<li>这个特殊格式的装饰器本身不存在没有关系, 因为我不会直接运行代码, 我只是把代码通过AST的处理, 解析出我要的任务和任务的执行间隔. 再去编译代码.<br>上代码:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetJobs</span><span class="params">(ast.NodeTransformer)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  <span class="comment"># 原来的ast.NodeTransformer其实没有__init__方法  </span></span><br><span class="line">        self.jobs = []  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jobs</span><span class="params">(self)</span>:</span>  <span class="comment"># 一个方便的获得任务的方法  </span></span><br><span class="line">        <span class="keyword">return</span> self.jobs  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_job_args</span><span class="params">(self, decorator)</span>:</span>  <span class="comment"># 这属于解析装饰器这个结构, 拿到执行的间隔  </span></span><br><span class="line">        <span class="keyword">return</span> &#123;k.arg: k.value.n <span class="keyword">for</span> k <span class="keyword">in</span> decorator.keywords  </span><br><span class="line">                <span class="keyword">if</span> k.arg <span class="keyword">in</span> (<span class="string">'hours'</span>, <span class="string">'seconds'</span>, <span class="string">'minutes'</span>, <span class="string">'days'</span>)  </span><br><span class="line">                <span class="keyword">and</span> isinstance(k.value, ast.Num)&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_FunctionDef</span><span class="params">(self, node)</span>:</span>  <span class="comment"># 这个visit_xxx的方法被重载的时候, 就会对这个类型的语法加一些特殊处理. 因为我设计的时候只有函数才有可能是任务  </span></span><br><span class="line">        decorator_list = node.decorator_list  <span class="comment"># 或者一个函数的装饰器列表  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> decorator_list:  </span><br><span class="line">            <span class="keyword">return</span> node  <span class="comment"># 没有装饰器明显不是我想要的任务, 可能只是一个helper函数而已  </span></span><br><span class="line">        decorator = decorator_list[<span class="number">0</span>]  <span class="comment"># 这里我把最外面的装饰器取出来看看是不是符合我要的格式  </span></span><br><span class="line">        args = self.get_job_args(decorator)  </span><br><span class="line">        <span class="keyword">if</span> args:  <span class="comment"># 当获得了适合的参数, 那么正确这个格式是正确的  </span></span><br><span class="line">            node.decorator_list = decorator_list[<span class="number">1</span>:] <span class="comment"># 最外面的装饰器就是语法hack, 它不存在也没有意义，以后完成历史任务 去掉之  </span></span><br><span class="line">            self.jobs.append((node.name, args))  </span><br><span class="line">        <span class="keyword">return</span> node  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_jobs</span><span class="params">(path)</span>:</span>  </span><br><span class="line">    jobs = []  </span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(path):  </span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:  </span><br><span class="line">            file = os.path.join(root, name)  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> file.endswith(<span class="string">'.py'</span>):  </span><br><span class="line">                <span class="keyword">continue</span>  </span><br><span class="line">            <span class="keyword">with</span> open(file) <span class="keyword">as</span> f:  </span><br><span class="line">                expr_ast = ast.parse(f.read())  <span class="comment"># 读文件, 解析  </span></span><br><span class="line">                transformer = GetJobs()  </span><br><span class="line">                sandbox = &#123;&#125;  <span class="comment"># 其实就是把执行放在一个命名空间里面, 因为最后我还是会把任务编译执行的, 我在这里面存了执行后的环境  </span></span><br><span class="line">                exec(compile(transformer.visit(expr_ast),  </span><br><span class="line">                             <span class="string">'&lt;string&gt;'</span>, <span class="string">'exec'</span>), sandbox)  </span><br><span class="line">                jobs.extend([(sandbox[j], kw) <span class="keyword">for</span> j, kw <span class="keyword">in</span> transformer.jobs])  </span><br><span class="line">    <span class="keyword">return</span> jobs</span><br></pre></td></tr></table></figure>


<p>其实看起来不能完成的事情, 就是这么简单.</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>wechat-admin：SSE</title>
    <url>/2016-03-04.html</url>
    <content><![CDATA[<p>在上一篇[项目设计](<a href="http://www.dongwm.com/archives/wechat-" target="_blank" rel="noopener">http://www.dongwm.com/archives/wechat-</a><br>admin%EF%BC%9A%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E7%AF%87/)中，我说到了SSE（Server-<br>Sent Events）是为了实现单方向的消息推送，今天介绍下实际的使用。<br>我直接用了现成的[Flask-SSE](<a href="https://github.com/singingwolfboy/flask-" target="_blank" rel="noopener">https://github.com/singingwolfboy/flask-</a><br>sse)，其实SSE实现的原理比较简单：</p>
<ol>
<li>借用Redis的发布/订阅模式创建一个方法，方法内会调用pubsub.listen监听新的发布数据。</li>
<li>使用Flask提供的stream_with_context，不断的从上面的方法中获取数据。<br>使用起来分2部分<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3>在前端页面添加一个函数：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function eventSourceListener() &#123;  </span><br><span class="line">    let source = new EventSource(`$&#123;API_URL&#125;/stream`);  </span><br><span class="line">    let self = this;  </span><br><span class="line">    source.addEventListener(<span class="string">'login'</span>, function(event) &#123;  </span><br><span class="line">        let data = JSON.parse(event.data);  </span><br><span class="line">        <span class="keyword">if</span> (data.type == <span class="string">'scan_qr_code'</span>) &#123;  </span><br><span class="line">            self.uuid = data.uuid;  </span><br><span class="line">            self.qrCode = `data:image/png;base64,$&#123;data.extra&#125;`;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.type == <span class="string">'confirm_login'</span>) &#123;  </span><br><span class="line">            self.sub_title = <span class="string">'Scan successful'</span>;  </span><br><span class="line">            self.sub_desc = <span class="string">'Confirm login on mobile WeChat'</span>;  </span><br><span class="line">            self.qrCode = data.extra;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.type == <span class="string">'logged_in'</span>) &#123;  </span><br><span class="line">            sessionStorage.setItem(<span class="string">'user'</span>, JSON.stringify(data.user));  </span><br><span class="line">            self.$router.push(&#123; path: <span class="string">'/main'</span> &#125;);  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.type == <span class="string">'logged_out'</span>) &#123;  </span><br><span class="line">            sessionStorage.removeItem(<span class="string">'user'</span>);  </span><br><span class="line">            self.$router.push(<span class="string">'/login'</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;, false);  </span><br><span class="line">  </span><br><span class="line">    source.addEventListener(<span class="string">'notification'</span>, function(event) &#123;  </span><br><span class="line">        let data = JSON.parse(event.data);  </span><br><span class="line">        self.notificationCount = data.count;  </span><br><span class="line">    &#125;, false);  </span><br><span class="line">  </span><br><span class="line">    source.addEventListener(<span class="string">'error'</span>, function(event) &#123;  </span><br><span class="line">        console.log(<span class="string">"Failed to connect to event stream"</span>);  </span><br><span class="line">    &#125;, false);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这段代码放在一个自定义的Vue的插件里面，这样在所有页面上都要自动包含这部分代码了。source.addEventListener用来添加事件监听，它监听了3种类型的消息：</p>
<ol>
<li>login 登录，也就是在页面反映当前微信的登录状态（等待扫码/扫码完成等待确认/确认完成）。不同的消息会执行不同的操作，页面也会立刻渲染出最新的结果。</li>
<li>notification 消息提醒，会有一个异步任务定期检查新入库的消息，有新的消息就是发布出来通知新消息数。</li>
<li>error 内置的错误消息，当然这个加不加倒还好<br>另外在登陆后执行<code>sessionStorage.setItem(&#39;user&#39;,
JSON.stringify(data.user));</code>会设置浏览器的session，下次自动登录后右侧就显示头像了，这样能减少后端的负担，退出时removeItem方法再删掉。<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3>后端包含2部分，第一部分是用Flask实现上面说的<code>${API_URL}/stream</code>这个接口，这是一个长连接，消息就是从这里推送出去的。由于第一部分是阻塞的，我们需要异步的方式往这个阻塞进程里面推送数据，也就是开头说的，利用Redis的发布/订阅模式发布消息。比如通知调用起来是[这样的](<a href="https://github.com/dongweiming/wechat-" target="_blank" rel="noopener">https://github.com/dongweiming/wechat-</a><br>admin/blob/master/wechat/tasks.py#L181)：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> app <span class="keyword">as</span> sse_api  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> sse_api.app_context():  </span><br><span class="line">    sse.publish(&#123;<span class="string">'count'</span>: count&#125;, type=<span class="string">'notification'</span>)</span><br></pre></td></tr></table></figure>


<p>登陆过程要复杂一些，我之前说过在我fork的ItChat和wxpy分支里面添加了信号的支持，这个信号是需要「注册」的，也就是在import之前就要注册，效果要类似[这样](<a href="https://github.com/dongweiming/wechat-" target="_blank" rel="noopener">https://github.com/dongweiming/wechat-</a><br>admin/blob/fc625df25e1f03b90d6f6ca8bdae8507e91e12ec/libs/wx.py#L7)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itchat.signals <span class="keyword">import</span> scan_qr_code, confirm_login, logged_out  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">publish</span><span class="params">(uuid, **kw)</span>:</span>  </span><br><span class="line">    <span class="keyword">from</span> app <span class="keyword">import</span> app  </span><br><span class="line">    <span class="keyword">with</span> app.app_context():  </span><br><span class="line">        params = &#123;<span class="string">'uuid'</span>: uuid, <span class="string">'extra'</span>: kw.pop(<span class="string">'extra'</span>, <span class="literal">None</span>),  </span><br><span class="line">                  <span class="string">'type'</span>: kw.pop(<span class="string">'type'</span>, <span class="literal">None</span>)&#125;  </span><br><span class="line">        params.update(kw)  </span><br><span class="line">        sse.publish(params, type=<span class="string">'login'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">scan_qr_code.connect(publish)  </span><br><span class="line">confirm_login.connect(publish)  </span><br><span class="line">logged_out.connect(publish)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> wxpy <span class="keyword">import</span> *  <span class="comment"># noqa</span></span><br></pre></td></tr></table></figure>


<p>这里用了信号的connect方法。举个logged_out的例子，在ItChat里面，首先<a href="https://github.com/dongweiming/ItChat/blob/signals/itchat/signals.py#L1" target="_blank" rel="noopener">定义这个信号</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> blinker <span class="keyword">import</span> Namespace  </span><br><span class="line">  </span><br><span class="line">_signals = Namespace()  </span><br><span class="line">logged_out  = _signals.signal(<span class="string">'logged-out'</span>)</span><br></pre></td></tr></table></figure>


<p>需要在对应发信号的地方调用<a href="https://github.com/dongweiming/ItChat/blob/signals/itchat/components/login.py#L290" target="_blank" rel="noopener">send方法</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">logged_out.send(self.uuid, type=<span class="string">'logged_out'</span>)</span><br></pre></td></tr></table></figure>


<p>另外有个坑儿，首次打开Web页面的是一个铺满div的gif图片，一开始设想的是在下载二维码图片之后，通过修改img的src属性指到这个图片，实际开发中发现，这个二维码图片被会更新不及时，会使用缓存的就图片所以发送信号的时候不使用图片HTTP地址，而是Data<br>URLs，这就需要把图片内容编码一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">encoded = base64.b64encode(qrStorage.getvalue()).decode(<span class="string">'ascii'</span>)                </span><br><span class="line">scan_qr_code.send(self.uuid, extra=encoded, type=<span class="string">'scan_qr_code'</span>)</span><br></pre></td></tr></table></figure>


<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这样借助Redis和Celery就实现了SSE的使用，下一节我将介绍Celery的使用。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>wechat-admin：项目设计篇</title>
    <url>/2016-03-07.html</url>
    <content><![CDATA[<p>相信读者同学们都了解[wechat-admin](<a href="https://github.com/dongweiming/wechat-" target="_blank" rel="noopener">https://github.com/dongweiming/wechat-</a><br>admin/)，甚至在本地运行过了。今天是wechat-admin项目系列文章的第一篇：项目设计。<br>在你技术学习的过程中或者已经具备了开发所需要的知识时，某一天灵光一闪决定去做一个（web）项目。那么通常前期分这么几步：</p>
<ol>
<li>需求确认。切忌一上来就写代码，先得在心中能把一个项目能清晰的拆分成一条条的需求，另外也要不断地和需求方确认你的理解是不是正确。</li>
<li>技术确认。首先是确定你能不能hold得住，别摊子铺的太大最后搂不住，或者在预定时间内无法完成。</li>
<li>用较短时间对技术实现难点确认。熟悉的写出来只是时间问题，那些未知不可控的才是你需要首先确认的，如果发现一开始的技术选型有问题，那么就要尽早的停止改其他方案。<br>我希望大家在向下看之前，（闭上眼）思考一下：<blockquote>
<p>假如现在让你来写这个项目，你用什么技术方案，你准备如何的实现？<br>好的，思考之后。来看看我是怎么做的，为什么这样做，以及这个过程中有什么调整和故事吧。</p>
</blockquote>
<h2 id="需求-amp-选型"><a href="#需求-amp-选型" class="headerlink" title="需求 &amp; 选型"></a>需求 &amp; 选型</h2>大家可以看到我在「特性」中的功能列表，其实一开始的需求只有：</li>
<li>微信扫码登录</li>
<li>拉取和存储联系人、群列表、群成员等信息</li>
<li>自动建群，加人</li>
<li>Web管理页面展示这些信息</li>
<li>Web页面上可设置一些需要的功能参数</li>
<li>消息提醒</li>
<li>自动回复机器人<br>那么接着拆分这些需求。由于我主要是在周末和晚上这种闲暇零散时间，所以我希望让这个拆分粒度尽量的小，控制在一个点1-2小时，最多半天这个标准上。有些需求可以同时做（防止长时间做一件事无聊），有些是其他的需求完成才可以开始的。所以，需求和选型是这样：<h3 id="微信扫码登录"><a href="#微信扫码登录" class="headerlink" title="微信扫码登录"></a>微信扫码登录</h3>这个是一开始要做的，我对ItChat/wxpy并不熟悉，这个是整个项目唯一的感觉「不安全」的点了：微信登录和其他常规登录的体验是完全不一样的。别的都是账户/密码、手机号、第三方登录，案例很多，很好做。但是微信是要用手机扫码，所以我要解决2个问题：</li>
<li>加「钩子」，把登录微信的状态（等待扫码/扫码完成等待确认/确认完成）及时的通知我，让我在Web页面上进行对应的步骤</li>
<li>需要通过某种方式和服务端实现保持一个长的连接，收到这个通知可以推送数据到浏览器<br>进一步去确认需求啦。首先阅读ItChat/wxpy源码，发现它能拿到这种通知，但是设计的是在终端用log的方式打印出来，不过本身支持callback函数也能实现钩子函数。不过我还是fork了他俩。解释下原因：</li>
<li>我不喜欢callback的方式，这会提高项目的复杂程度，高聚合。所以我要使用信号解耦这部分内容。</li>
<li>给ItChat提交过代码，好几天没人理，索性自己维护fork版本，遇到不满足需要就可以快速改，提高效率<br>另外后来还踩了一个坑儿，就是页面动态改扫码图片的src会有缓存。所以在信号中把扫码图片变成Data URL协议的方式传递回来。<br>向浏览器推送数据更知名的方案是Websockets，它可以双向的数据推送，不过太重了用不到，我需要一个轻量级的方案。由于豆瓣有一些场景也是SSE(Server<br>Sent Events)，为了学习它，我也选择了SSE。<h3 id="拉取和存储联系人、群列表、群成员等信息"><a href="#拉取和存储联系人、群列表、群成员等信息" class="headerlink" title="拉取和存储联系人、群列表、群成员等信息"></a>拉取和存储联系人、群列表、群成员等信息</h3>wxpy提供了直接的API拉取这些信息，但是为什么要本地存呢？</li>
<li>最主要的，为了降低调用微信接口的次数，降低被封的风险。当我用正确的方式存下来，再加上我改良的wxpy的puid方案，同样可以实现对这些信息进程展示、筛选等查询内容</li>
<li>开源嘛，就是为了多给大家一个学习的源码项目的机会，想展示SQLAlchemy的更多用法<br>另外扫码登录之后，拉取和存储的过程可能会比较长，另外在Web页面上还有「强制刷新」的功能，这些如果让页面等待用户体验很差，都需要异步执行，所以用Celery异步的执行。<br>有个插曲，其实一开始觉得这种小项目用Celery小题大做了，选择了rq，但是随着我的需求变多变复杂（之后的文章会提到），rq的局限性就越来越凸显了。以前我对rq、huey这种框架都是「小项目不妨用用」的态度，不过现在我真的用过了之后才发现在Python圈<br><strong>Celery永远是首选</strong> ，请相信我。<h3 id="自动建群，拉人"><a href="#自动建群，拉人" class="headerlink" title="自动建群，拉人"></a>自动建群，拉人</h3>操作都是由wxpy封装的（wxpy封装了ItChat），它不支持通常说明Web微信没有这个功能。需要注意的是，建群时还需要至少2个人，要不然不能建群，建群接口当天也会被封。所以「自动建群」需要点技术选型，那就是在设置页面有一个项，包含默认拉的人都有谁，那么需要存起来，我在这个项目把这样的内容都存在了Redis里面。<br>由于公司基本设施的问题，我Redis用的很少，常见也很简单，一直没有用过Redis的ORM，这次项目其实是为了尝试一下。不过一开始使用的是我fork的<a href="https://github.com/dongweiming/redisco" target="_blank" rel="noopener">redisco</a>，我给它增加了Python<br>3的支持。不过后来干掉换成了现在用的Walrus，因为在使用过程发现太难用了。<br>这种早期的新技术选型失败是不可避免的，不过还是在我可控制的范围。<h3 id="Web管理页面展示这些信息，并且可设置功能参数，消息提醒"><a href="#Web管理页面展示这些信息，并且可设置功能参数，消息提醒" class="headerlink" title="Web管理页面展示这些信息，并且可设置功能参数，消息提醒"></a>Web管理页面展示这些信息，并且可设置功能参数，消息提醒</h3>这也是本文的重点之一了。Python<br>Web开发者通常都不是单纯的后端开发，所以前端的知识、框架、工具也是要熟练使用。网上这种前后端结合的项目和经验比较少，本文也来谈一谈：<h4 id="为什么选择了Vue？"><a href="#为什么选择了Vue？" class="headerlink" title="为什么选择了Vue？"></a>为什么选择了Vue？</h4>如果你不是一个专职前端工程师，并且也没有打算未来转成前端开发者，但是由于工作或者兴趣需要写HTML、JS时，使用框架是一个正确的选择。过去纯手写JS或者用jQuery的方式写代码效率是很低下，尤其在页面交互复杂时，而现在有React、Vue这些框架，帮助你省太多的事情了。去年的[网易云音乐精彩评论](<a href="https://github.com/awesome-" target="_blank" rel="noopener">https://github.com/awesome-</a><br>archive/commentbox)使用的是 React + Mobx + Fetch + Material-UI + ES6 + Webpack +<br>Babel，对应的技术选型文章可以看<a href="https://zhuanlan.zhihu.com/p/22806115" target="_blank" rel="noopener">commentbox用到了那些前端技术</a>。<br>最近工作中都在使用Vue，比如豆瓣电影「<a href="https://movie.douban.com/tag/#/" target="_blank" rel="noopener">选影视</a>」以及新的电影管理后台(Vue+Vue-<br>Material)，我在这里向各位Python开发者极力推荐它，理由如下：</li>
<li>最大程度的降低了初学者的学习曲线</li>
<li>数据双向绑定。实现一个相对复杂的页面需要的代码量很少。更多MVVM和前端发展历史可以看我之前写的 <a href="https://mp.weixin.qq.com/s?__biz=MzA3NDk1NjI0OQ==&mid=2247483977&idx=1&sn=d1de03f0735aa3212b53d954891b239a&chksm=9f76aeffa80127e9bdb92f864d31fa0b5845175ed6ccbab85061823eb1fb7561a4ef972f1c#rd" target="_blank" rel="noopener">浅谈MVC、MTV和MVVM</a></li>
<li>单文件组件化和它的语法对于写模板的同学来说最易接受</li>
<li>文档和周边生态都相对完善</li>
<li>Vue-cli这个命令行脚手架包含了丰富的模板，可以非常快的初始化出来一个项目，极为方便<h4 id="为什么选择Element-UI"><a href="#为什么选择Element-UI" class="headerlink" title="为什么选择Element-UI"></a>为什么选择Element-UI</h4>我尝试过Vue下的各种UI库，Element是其中功能最全，API和文档最完善和最易于使用的。举个例子，我用Vue-<br>Material时经常需要翻源码了解用法，货比货得扔啊。但是它也是我的选型(也是为了配合厂内其它的Material-UI)，含着泪也要用下去…<br>另外，如果你想开启一个使用Material Design的新项目，建议使用Muse-UI<h4 id="如何实现前后端的交互？"><a href="#如何实现前后端的交互？" class="headerlink" title="如何实现前后端的交互？"></a>如何实现前后端的交互？</h4>不止一个同学问过我这个问题。三点来概括吧：</li>
<li>前端是一个单页面应用，路由由vue-router来实现，对于后端来说，只需要渲染一个index.html就好了。</li>
<li>后端提供API，对Flask进行一些定制，让它返回的内容mimetype就是application/json，并且统一封装了返回的格式</li>
<li>前端再打开页面或者在事件中通过Axios这个HTTP客户端库发出请求到后端，后端接口接收并返回对应的内容<h3 id="自动回复机器人"><a href="#自动回复机器人" class="headerlink" title="自动回复机器人"></a>自动回复机器人</h3>在我念书的年代，也上过人人网，当时小黄鸡非常知名，觉得很神奇。当我工作，尤其是做了开发之后，发现其实对于API调用者来说是没有技术含量的。现在市面上有很多知名的机器人，使用它们的每日限额的免费接口就可以。另外我也用到了一些机器学习的ChatterBot。<br>我改了wxpy的源码，用插件的方式让这些额外的功能可插拔。<h3 id="其他需求"><a href="#其他需求" class="headerlink" title="其他需求"></a>其他需求</h3>剩下的那些功能，都是在现有的技术选型基础上去实现的。有些是过程中产生的灵感，有的是阅读源码的时候发现的。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样不退出交互模式自动reload模块</title>
    <url>/2016-03-08.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h4><p>我想做python开发的人尤其是django开发都会有一种经历:进入python交互模式(直接 执行python回车)或者进入django-<br>shell调试某功能，然后修改源码，退出交互模式或者djangoshell，重新进入在吧那些模块一一import… 问题是什么呢？浪费时间，为啥不像web<br>框架那样修改源码自动reload？<br>本来我花了2个多礼拜一直在做这件事情，其实原理就是封装ipython到我的shell，然后在我的shell加这个autoreload功能，但是昨晚看ipython源码发现：ipython早已经实现了…<br>我的系统的实现的源码文件是 /usr/lib64/python2.7/site-<br>packages/IPython/Extensions/ipy_autoreload.py<br>####在ipython交互模式实现<br>和ipython版本有关，大于0.11 这样加载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%load_ext autoreload  </span><br><span class="line">%autoreload <span class="number">2</span></span><br></pre></td></tr></table></figure>


<p>小于0.11的就要这样加载  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ipy_autoreload  </span><br><span class="line">%autoreload <span class="number">2</span></span><br></pre></td></tr></table></figure>


<p>####ipython交互模式自动加载<br>你总不像每次进入ipython都执行这么2句吧,<br>那么可以加到ipython的自定义配置里面.因操作系统和ipython版本不同，ipython的用户自定义目录有所不同，增加的配置也 有所不同<br>首先创建ipython个人配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ipython profile create</span><br></pre></td></tr></table></figure>


<p>gentoo ~/.ipython ipython :0.10.2<br>配置文件是.ipython/ipy_user_conf.py 添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ipy_autoreload  </span><br><span class="line">o.autoexec.append(<span class="string">'%autoreload 2'</span>)</span><br></pre></td></tr></table></figure>


<p>opensuse <del>/.config/ipython :0.13<br>配置文件是</del>/.config/ipython/profile_default/ipython_config.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">c.InteractiveShellApp.exec_lines.append(<span class="string">'%load_ext autoreload'</span>)  </span><br><span class="line">c.InteractiveShellApp.exec_lines.append(<span class="string">'%autoreload 2'</span>)</span><br></pre></td></tr></table></figure>


<p>####Django shell的实现<br>遗憾的是改django源码中的core/management/commands/shell.py,没有提供自动reload,但是当你修改了ipython配置<br>他也是会起作用(这个操作系统有关，下面我会说不起作用的geek方法)<br>PS： 你还可以使用[django-extensions](<a href="https://github.com/dongweiming/django-" target="_blank" rel="noopener">https://github.com/dongweiming/django-</a><br>extensions)中的shell_plus.py<br>####当你系统有ipython,bpython和默认的python，django shell选择的顺序</p>
<ul>
<li>当你系统没有ipython和bpython，那么就会选择默认的python</li>
<li>上面说的shell_plus的遍历列表顺序是bpython-&gt;ipython </li>
<li>django自带的shell的遍历顺序是ipython-&gt;bpython<br>上面说djangoshell不起作用怎么办？首先看了django/ipython源码(0.13.2)，其实djangoshell甚至django-<br>extensions里面的shell_plus都没有问题，关键是ipython的问题<br>我只说在用户配置里面的外部模块为啥没有正确执行<br>ipython进入交互模式的流程</li>
</ul>
<ol>
<li>当调用ipython，都是通过IPython.frontend.terminal.ipapp的launch_new_instance函数开始</li>
<li>通过IPython.core.shellapp的InteractiveShellApp类里面的init_code方法去初始化启动后的加载</li>
<li>在init_code方法会执行self._run_exec_lines(),这个就是上面的模块导入执行<br>djangoshell进入交互模式的流程</li>
<li>通过IPython.frontend.terminal.embed的TerminalInteractiveShell类开始</li>
<li>在TerminalInteractiveShell初始化中,没有执行上面的第三条<br>解决办法就是暴力修改IPython/frontend/terminal/interactiveshell.py源码 给他加上模块初始化的操作<br>在326行开始的地方，这样添加一段(包含存在的代码帮你你理解在什么位置添加代码,也就是下面的3-8行)</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">self.init_usage(usage)                                                   </span><br><span class="line">self.init_banner(banner1, banner2, display_banner)   </span><br><span class="line">exex_lines = self.config[<span class="string">'InteractiveShellApp'</span>][<span class="string">'exec_lines'</span>]            </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> exex_lines:                                                  </span><br><span class="line">    <span class="keyword">try</span>:                                                                          </span><br><span class="line">        self.run_cell(line, store_history=<span class="literal">False</span>)                         </span><br><span class="line">    <span class="keyword">except</span>:                                                                       </span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------            </span></span><br><span class="line"><span class="comment"># Overrides of init stages                                                            </span></span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Python并发编程一篇就够了-进程篇</title>
    <url>/2016-03-06.html</url>
    <content><![CDATA[<p>在上一节<a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AF%87/" target="_blank" rel="noopener">理解Python并发编程一篇就够了 -<br>线程篇</a>讲了一些线程的技术，本节我们接着说进程。<br>上节说到由于GIL（全局解释锁）的问题，多线程并不能充分利用多核处理器，如果是一个CPU计算型的任务，应该使用多进程模块 multiprocessing<br>。它的工作方式与线程库完全不同，但是两种库的语法却非常相似。multiprocessing给每个进程赋予单独的Python解释器，这样就规避了全局解释锁所带来的问题。但是也别高兴的太早，因为你会遇到接下来说到的一些多进程之间通信的问题。<br>我们首先把上节的例子改成单进程和多进程的方式来对比下性能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> multiprocessing  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">(func)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">        <span class="keyword">import</span> time  </span><br><span class="line">        start = time.time()  </span><br><span class="line">        func(*args, **kwargs)  </span><br><span class="line">        end   = time.time()  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'COST: &#123;&#125;'</span>.format(end - start)  </span><br><span class="line">    <span class="keyword">return</span> wrapper  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@profile  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nomultiprocess</span><span class="params">()</span>:</span>  </span><br><span class="line">    fib(<span class="number">35</span>)  </span><br><span class="line">    fib(<span class="number">35</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@profile  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasmultiprocess</span><span class="params">()</span>:</span>  </span><br><span class="line">    jobs = []  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </span><br><span class="line">        p = multiprocessing.Process(target=fib, args=(<span class="number">35</span>,))  </span><br><span class="line">        p.start()  </span><br><span class="line">        jobs.append(p)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> jobs:  </span><br><span class="line">        p.join()  </span><br><span class="line">  </span><br><span class="line">nomultiprocess()  </span><br><span class="line">hasmultiprocess()</span><br></pre></td></tr></table></figure>


<p>运行的结果还不错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python profile_process.py  </span><br><span class="line">COST: <span class="number">4.66861510277</span>  </span><br><span class="line">COST: <span class="number">2.5424861908</span></span><br></pre></td></tr></table></figure>


<p>虽然多进程让效率差不多翻了倍，但是需要注意，其实这个时间就是2个执行fib(35)，最慢的那个进程的执行时间而已。不管怎么说，GIL的问题算是极大的缓解了。</p>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>有一点要强调：任务的执行周期决定于CPU核数和任务分配算法。上面例子中hasmultiprocess函数的用法非常中规中矩且常见，但是我认为更好的写法是使用Pool，也就是对应线程池的进程池:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool  </span><br><span class="line">  </span><br><span class="line">pool = Pool(<span class="number">2</span>)  </span><br><span class="line">pool.map(fib, [<span class="number">35</span>] * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<p>其中map方法用起来和内置的map函数一样，却有多进程的支持。<br>PS:<br>之前在<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDk1NjI0OQ==&mid=100000030&idx=1&sn=9f114800a409ddb5b2d624eaa4c59974&chksm=1f76ada8280124be62d0c24ea0adb405e657a96a0b29eae8f928b2d6fb58d376c373458058b9#rd" target="_blank" rel="noopener">一分钟让程序支持队列和并发</a>，我就提到过使用multiprocessing.Pool实现纯Python的MapReduce。有兴趣的可以去了解下。</p>
<h3 id="dummy"><a href="#dummy" class="headerlink" title="dummy"></a>dummy</h3><p>我之前使用多线程/多进程都使用上面的方式，在好长一段时间里面对于多进程和多线程之前怎么选择都搞得不清楚，偶尔会出现要从多线程改成多进程或者多进程改成多线程的时候，痛苦。看了一些开源项目代码，我发现了好多人在用multiprocessing.dummy这个子模块，「dummy」这个词有「模仿」的意思，它虽然在多进程模块的代码中，但是接口和多线程的接口基本一样。官方文档中这样说：</p>
<blockquote>
<p>multiprocessing.dummy replicates the API of multiprocess<br>ing but is no more than a wrapper around the threading<br>module.<br>恍然大悟！！！如果分不清任务是CPU密集型还是IO密集型，我就用如下2个方法分别试：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool  </span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br></pre></td></tr></table></figure>


<p>哪个速度快就用那个。从此以后我都尽量在写兼容的方式，这样在多线程/多进程之间切换非常方便。<br>在这里说一个我个人的经验和技巧：现在，如果一个任务拿不准是CPU密集还是I/O密集型，且没有其它不能选择多进程方式的因素，都统一直接上多进程模式。</p>
<h3 id="基于Pipe的parmap"><a href="#基于Pipe的parmap" class="headerlink" title="基于Pipe的parmap"></a>基于Pipe的parmap</h3><p>进程间的通信（IPC）常用的是rpc、socket、pipe（管道）和消息队列（queue）。多进程模块中涉及到了后面3种。我们先看一个官网给出的，最基本的管道的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span>  </span><br><span class="line">    conn.send([<span class="string">'hello'</span>])  </span><br><span class="line">    conn.close()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">parent_conn, child_conn = Pipe()  </span><br><span class="line">p = Process(target=f, args=(child_conn,))  </span><br><span class="line">p.start()  </span><br><span class="line"><span class="keyword">print</span> parent_conn.recv()  </span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>


<p>其中Pipe返回的是管道2边的对象：「父连接」和「子连接」。当子连接发送一个带有hello字符串的列表，父连接就会收到，所以<code>parent_conn.recv()</code>就会打印出来。这样就可以简单的实现在多进程之间传输Python内置的数据结构了。但是先说明，不能被xmlrpclib序列化的对象是不能这么传输的。<br>上上个例子中提到的hasmultiprocess函数使用了Pool的map方法，用着还不错。但是在实际的业务中通常要复杂的多，比如下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculateFib</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(cls, n)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> cls.fib(n<span class="number">-1</span>) + cls.fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">map_run</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        pool = Pool(<span class="number">2</span>)  </span><br><span class="line">        <span class="keyword">print</span> pool.map(self.fib, [<span class="number">35</span>] * <span class="number">2</span>)  </span><br><span class="line">          </span><br><span class="line">  </span><br><span class="line">cl = CalculateFib()  </span><br><span class="line">cl.map_run()</span><br></pre></td></tr></table></figure>


<p>fib由于某些原因需要放在了类里面，我们来执行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python parmap.py  </span><br><span class="line">Exception <span class="keyword">in</span> thread Thread<span class="number">-1</span>:  </span><br><span class="line">Traceback (most recent call last):  </span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py"</span>, line <span class="number">810</span>, <span class="keyword">in</span> __bootstrap_inner  </span><br><span class="line">    self.run()  </span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py"</span>, line <span class="number">763</span>, <span class="keyword">in</span> run  </span><br><span class="line">    self.__target(*self.__args, **self.__kwargs)  </span><br><span class="line">  File <span class="string">"/Library/Python/2.7/site-packages/multiprocessing-2.6.2.1-py2.7-macosx-10.9-intel.egg/multiprocessing/pool.py"</span>, line <span class="number">225</span>, <span class="keyword">in</span> _handle_tasks  </span><br><span class="line">    put(task)  </span><br><span class="line">PicklingError: Can<span class="string">'t pickle &lt;type '</span>instancemethod<span class="string">'&gt;: attribute lookup __builtin__.instancemethod failed</span></span><br></pre></td></tr></table></figure>


<p>欧欧，出错了。解决方案有很多。我们先演示一个使用管道处理的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Process, Pipe  </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> izip  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spawn</span><span class="params">(f)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(pipe, item)</span>:</span>  </span><br><span class="line">        pipe.send(f(item))  </span><br><span class="line">        pipe.close()  </span><br><span class="line">    <span class="keyword">return</span> func  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parmap</span><span class="params">(f, items)</span>:</span>  </span><br><span class="line">    pipe = [Pipe() <span class="keyword">for</span> _ <span class="keyword">in</span> items]  </span><br><span class="line">    proc = [Process(target=spawn(f),  </span><br><span class="line">                    args=(child, item))  </span><br><span class="line">            <span class="keyword">for</span> item, (parent, child) <span class="keyword">in</span> izip(items, pipe)]  </span><br><span class="line">    [p.start() <span class="keyword">for</span> p <span class="keyword">in</span> proc]  </span><br><span class="line">    [p.join() <span class="keyword">for</span> p <span class="keyword">in</span> proc]  </span><br><span class="line">    <span class="keyword">return</span> [parent.recv() <span class="keyword">for</span> (parent, child) <span class="keyword">in</span> pipe]  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalculateFib</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parmap_run</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> parmap(self.fib, [<span class="number">35</span>] * <span class="number">2</span>)  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">cl = CalculateFib()  </span><br><span class="line">cl.parmap_run()</span><br></pre></td></tr></table></figure>


<p>这个parmap的作用就是对每个要处理的单元（在这里就是一次 fib(35)）创建一个管道，在子进程中，子连接执行完传输给父连接。<br>它确实可以满足一些场景。但是我们能看到，它并没有用进程池，也就是一个要处理的单元就会创建一个进程，这显然不合理。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>多线程有Queue模块实现队列，多进程模块也包含了Queue类，它是线程和进程安全的。现在我们给下面的生产者/消费者的例子添加点难度，也就是用2个队列：一个队列用于存储待完成的任务，另外一个用于存储任务完成后的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, JoinableQueue, Queue  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">tasks_queue = JoinableQueue()  </span><br><span class="line">results_queue = Queue()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(in_queue)</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        wt = random()  </span><br><span class="line">        time.sleep(wt)  </span><br><span class="line">        in_queue.put((double, wt))  </span><br><span class="line">        <span class="keyword">if</span> wt &gt; <span class="number">0.9</span>:  </span><br><span class="line">            in_queue.put(<span class="literal">None</span>)  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'stop producer'</span>  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_queue, out_queue)</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        task = in_queue.get()  </span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        func, arg = task  </span><br><span class="line">        result = func(arg)  </span><br><span class="line">        in_queue.task_done()  </span><br><span class="line">        out_queue.put(result)  </span><br><span class="line">  </span><br><span class="line">processes = []  </span><br><span class="line">  </span><br><span class="line">p = Process(target=producer, args=(tasks_queue,))  </span><br><span class="line">p.start()  </span><br><span class="line">processes.append(p)  </span><br><span class="line">  </span><br><span class="line">p = Process(target=consumer, args=(tasks_queue, results_queue))  </span><br><span class="line">p.start()  </span><br><span class="line">processes.append(p)  </span><br><span class="line">  </span><br><span class="line">tasks_queue.join()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> processes:  </span><br><span class="line">    p.join()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="keyword">if</span> results_queue.empty():  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    result = results_queue.get()  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Result:'</span>, result</span><br></pre></td></tr></table></figure>


<p>咋眼看去，和线程的那个队列例子已经变化很多了：</p>
<ol>
<li>生产者已经不会持续的生产任务了，如果随机到的结果大于0.9就会给任务队列tasks_queue put一个None，然后把循环结束掉</li>
<li>消费者如果收到一个值为None的任务，就结束，否则执行从tasks_queue获取的任务，并把结果put进results_queue</li>
<li>生产者和消费者都结束后（又join方法保证），从results_queue挨个获取执行结果并打印出来<br>进程的Queue类并不支持task_done和join方法，需要使用特别的JoinableQueue，而搜集结果的队列results_queue使用Queue就足够了。<br>回到上个CalculateFib的例子，我们用队列再对parmap改造一下，让它支持指定进程池的大小：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue, Process, cpu_count  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_func</span><span class="params">(f, q_in, q_out)</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q_in.empty():  </span><br><span class="line">        i, item = q_in.get()  </span><br><span class="line">        q_out.put((i, f(item)))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parmap</span><span class="params">(f, items, nprocs = cpu_count<span class="params">()</span>)</span>:</span>  </span><br><span class="line">    q_in, q_out = Queue(), Queue()  </span><br><span class="line">    proc = [Process(target=apply_func, args=(f, q_in, q_out))  </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(nprocs)]  </span><br><span class="line">    sent = [q_in.put((i, item)) <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(items)]  </span><br><span class="line">    [p.start() <span class="keyword">for</span> p <span class="keyword">in</span> proc]  </span><br><span class="line">    res = [q_out.get() <span class="keyword">for</span> _ <span class="keyword">in</span> sent]  </span><br><span class="line">    [p.join() <span class="keyword">for</span> p <span class="keyword">in</span> proc]  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> [item <span class="keyword">for</span> _, item <span class="keyword">in</span> sorted(res)]</span><br></pre></td></tr></table></figure>


<p>其中使用enumerate就是为了保留待执行任务的顺序，在最后排序用到。</p>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>multiprocessing的Lock、Condition、Event、RLock、Semaphore等同步原语和threading模块的机制是一样的，用法也类似，限于篇幅，就不一一的展开了。</p>
<h3 id="进程间共享状态"><a href="#进程间共享状态" class="headerlink" title="进程间共享状态"></a>进程间共享状态</h3><p>multiprocessing提供的在进程间共享状态的方式有2种：</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>主要通过Value或者Array来实现。常见的共享的有以下几种：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> multiprocessing.sharedctypes <span class="keyword">import</span> typecode_to_type  </span><br><span class="line">  </span><br><span class="line">In : typecode_to_type  </span><br><span class="line">Out:  </span><br><span class="line">&#123;<span class="string">'B'</span>: ctypes.c_ubyte,  </span><br><span class="line"> <span class="string">'H'</span>: ctypes.c_ushort,  </span><br><span class="line"> <span class="string">'I'</span>: ctypes.c_uint,  </span><br><span class="line"> <span class="string">'L'</span>: ctypes.c_ulong,  </span><br><span class="line"> <span class="string">'b'</span>: ctypes.c_byte,  </span><br><span class="line"> <span class="string">'c'</span>: ctypes.c_char,  </span><br><span class="line"> <span class="string">'d'</span>: ctypes.c_double,  </span><br><span class="line"> <span class="string">'f'</span>: ctypes.c_float,  </span><br><span class="line"> <span class="string">'h'</span>: ctypes.c_short,  </span><br><span class="line"> <span class="string">'i'</span>: ctypes.c_int,  </span><br><span class="line"> <span class="string">'l'</span>: ctypes.c_long,  </span><br><span class="line"> <span class="string">'u'</span>: ctypes.c_wchar&#125;</span><br></pre></td></tr></table></figure>


<p>而且共享的时候还可以给Value或者Array传递lock参数来决定是否带锁，如果不指定默认为RLock。<br>我们看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock  </span><br><span class="line"><span class="keyword">from</span> multiprocessing.sharedctypes <span class="keyword">import</span> Value, Array  </span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> Structure, c_bool, c_double  </span><br><span class="line">  </span><br><span class="line">lock = Lock()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(Structure)</span>:</span>  </span><br><span class="line">    _fields_ = [(<span class="string">'x'</span>, c_double), (<span class="string">'y'</span>, c_double)]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(n, b, s, arr, A)</span>:</span>  </span><br><span class="line">    n.value **= <span class="number">2</span>  </span><br><span class="line">    b.value = <span class="literal">True</span>  </span><br><span class="line">    s.value = s.value.upper()  </span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span>  </span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> A:  </span><br><span class="line">        a.x **= <span class="number">2</span>  </span><br><span class="line">        a.y **= <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">n = Value(<span class="string">'i'</span>, <span class="number">7</span>)  </span><br><span class="line">b = Value(c_bool, <span class="literal">False</span>, lock=<span class="literal">False</span>)  </span><br><span class="line">s = Array(<span class="string">'c'</span>, <span class="string">'hello world'</span>, lock=lock)  </span><br><span class="line">arr = Array(<span class="string">'i'</span>, range(<span class="number">5</span>), lock=<span class="literal">True</span>)  </span><br><span class="line">A = Array(Point, [(<span class="number">1.875</span>, <span class="number">-6.25</span>), (<span class="number">-5.75</span>, <span class="number">2.0</span>)], lock=lock)  </span><br><span class="line">  </span><br><span class="line">p = Process(target=modify, args=(n, b, s, arr, A))  </span><br><span class="line">p.start()  </span><br><span class="line">p.join()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> n.value  </span><br><span class="line"><span class="keyword">print</span> b.value  </span><br><span class="line"><span class="keyword">print</span> s.value  </span><br><span class="line"><span class="keyword">print</span> arr[:]  </span><br><span class="line"><span class="keyword">print</span> [(a.x, a.y) <span class="keyword">for</span> a <span class="keyword">in</span> A]</span><br></pre></td></tr></table></figure>


<p>主要是为了演示用法。有2点需要注意：</p>
<ol>
<li>并不是只支持typecode_to_type中指定那些类型，只要在ctypes里面的类型就可以。</li>
<li>arr是一个int的数组，但是和array模块生成的数组以及list是不一样的，它是一个SynchronizedArray对象，支持的方法很有限，比如append/extend等方法是没有的。<br>输出结果如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python shared_memory.py  </span><br><span class="line"></span><br><span class="line"><span class="literal">True</span>  </span><br><span class="line">HELLO WORLD  </span><br><span class="line">[<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">[(<span class="number">3.515625</span>, <span class="number">39.0625</span>), (<span class="number">33.0625</span>, <span class="number">4.0</span>)]</span><br></pre></td></tr></table></figure>


<h4 id="服务器进程"><a href="#服务器进程" class="headerlink" title="服务器进程"></a>服务器进程</h4><p>一个multiprocessing.Manager对象会控制一个服务器进程，其他进程可以通过代理的方式来访问这个服务器进程。<br>常见的共享方式有以下几种：</p>
<ol>
<li>Namespace。创建一个可分享的命名空间。</li>
<li>Value/Array。和上面共享ctypes对象的方式一样。</li>
<li>dict/list。创建一个可分享的dict/list，支持对应数据结构的方法。</li>
<li>Condition/Event/Lock/Queue/Semaphore。创建一个可分享的对应同步原语的对象。<br>看一个例子：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager, Process  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(ns, lproxy, dproxy)</span>:</span>  </span><br><span class="line">    ns.a **= <span class="number">2</span>  </span><br><span class="line">    lproxy.extend([<span class="string">'b'</span>, <span class="string">'c'</span>])  </span><br><span class="line">    dproxy[<span class="string">'b'</span>] = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">manager = Manager()  </span><br><span class="line">ns = manager.Namespace()  </span><br><span class="line">ns.a = <span class="number">1</span>  </span><br><span class="line">lproxy = manager.list()  </span><br><span class="line">lproxy.append(<span class="string">'a'</span>)  </span><br><span class="line">dproxy = manager.dict()  </span><br><span class="line">dproxy[<span class="string">'b'</span>] = <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">p = Process(target=modify, args=(ns, lproxy, dproxy))  </span><br><span class="line">p.start()  </span><br><span class="line"><span class="keyword">print</span> <span class="string">'PID:'</span>, p.pid  </span><br><span class="line">p.join()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> ns.a  </span><br><span class="line"><span class="keyword">print</span> lproxy  </span><br><span class="line"><span class="keyword">print</span> dproxy</span><br></pre></td></tr></table></figure>


<p>在id为8341的进程中就可以修改共享状态了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python manager.py  </span><br><span class="line">PID: <span class="number">8341</span>  </span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  </span><br><span class="line">&#123;<span class="string">'b'</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>


<h3 id="分布式的进程间通信"><a href="#分布式的进程间通信" class="headerlink" title="分布式的进程间通信"></a>分布式的进程间通信</h3><p>有时候没有必要舍近求远的选择更复杂的方案，其实使用Manager和Queue就可以实现简单的分布式的不同服务器的不同进程间的通信（C/S模式）。<br>首先在远程服务器上写如下的一个程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager  </span><br><span class="line">  </span><br><span class="line">host = <span class="string">'127.0.0.1'</span>  </span><br><span class="line">port = <span class="number">9030</span>  </span><br><span class="line">authkey = <span class="string">'secret'</span>  </span><br><span class="line">  </span><br><span class="line">shared_list = []  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteManager</span><span class="params">(BaseManager)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">RemoteManager.register(<span class="string">'get_list'</span>, callable=<span class="keyword">lambda</span>: shared_list)  </span><br><span class="line">mgr = RemoteManager(address=(host, port), authkey=authkey)  </span><br><span class="line">server = mgr.get_server()  </span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure>


<p>现在希望其他代理可以修改和获取到shared_list的值，那么写这么一个客户端程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager  </span><br><span class="line">  </span><br><span class="line">host = <span class="string">'127.0.0.1'</span>  </span><br><span class="line">port = <span class="number">9030</span>  </span><br><span class="line">authkey = <span class="string">'secret'</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteManager</span><span class="params">(BaseManager)</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">RemoteManager.register(<span class="string">'get_list'</span>)  </span><br><span class="line">mgr = RemoteManager(address=(host, port), authkey=authkey)  </span><br><span class="line">mgr.connect()  </span><br><span class="line">  </span><br><span class="line">l = mgr.get_list()  </span><br><span class="line"><span class="keyword">print</span> l  </span><br><span class="line">l.append(<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">print</span> mgr.get_list()</span><br></pre></td></tr></table></figure>


<p>注意，在client上的注册没有添加callable参数。<br>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2016-12-03" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pelican心得</title>
    <url>/2016-03-10.html</url>
    <content><![CDATA[<p>####前言<br>最近在用<a href="http://getpelican.com/" target="_blank" rel="noopener">pelican</a>借用<a href="http://pages.github.com" target="_blank" rel="noopener">GitHub<br>Pages</a>搭建我的<a href="http://dongweiming.github.io" target="_blank" rel="noopener">小明明s<br>Github</a>, 总结了些心得<br>####写好Makefile<br>ruby有rake，但是python的好像没什么好用的，还是用Makefile，简单粗暴.先看用的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">help:                                         </span><br><span class="line"><span class="meta">    @echo 'Makefile for a pelican Web site                                        '  </span></span><br><span class="line"><span class="meta">    @echo '                                                                       '  </span></span><br><span class="line"><span class="meta">    @echo 'Usage:                                                                 '  </span></span><br><span class="line"><span class="meta">    @echo '   make html                        (re)generate the web site          '  </span></span><br><span class="line"><span class="meta">    @echo '   make clean                       remove the generated files         '  </span></span><br><span class="line">                                                                </span><br><span class="line">local:                                                             </span><br><span class="line">    ./regen -q                                                    </span><br><span class="line">github:-                                                         </span><br><span class="line">    ./regen                                                     </span><br><span class="line">    ghp-<span class="keyword">import</span> -b master $(OUTPUTDIR)                          </span><br><span class="line">    git push origin gh-pages:gh-pages-                        </span><br><span class="line">    git push origin master:master                            </span><br><span class="line">                                                            </span><br><span class="line">.PHONY: help github local</span><br></pre></td></tr></table></figure>


<p>其中的regen是封装的脚本, 主要是为了加参数让我在本地生成html(其中的文件连接都指到我本地),然后我用python -m<br>SimpleHTTPServer启动:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env bash  </span></span><br><span class="line">  </span><br><span class="line">set -e  </span><br><span class="line">  </span><br><span class="line">quiet=<span class="string">""</span>  </span><br><span class="line">output=<span class="string">"output"</span>  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$1"</span> = <span class="string">"-q"</span> ] ; then  </span><br><span class="line">    shift  </span><br><span class="line">    quiet=<span class="string">"1"</span>  </span><br><span class="line">    output=<span class="string">"output-local"</span>  </span><br><span class="line">    export OVERRIDE_SITEURL=http://localhost:<span class="number">8000</span>  </span><br><span class="line">fi  </span><br><span class="line">  </span><br><span class="line">echo -n <span class="string">"regenerating..."</span>  </span><br><span class="line">pelican content/ -o $output -s pelicanconf.py <span class="string">"$@"</span>  </span><br><span class="line">echo done.</span><br></pre></td></tr></table></figure>


<p>####我提交到github的方式<br>上面的脚本已经很明显了，我直接执行make github<br>其中的<a href="http://github.com/davisp/ghp-import" target="_blank" rel="noopener">ghp-import</a>的介绍很明显了:Easily import docs<br>to your gh-pages branch<br>但是有个大坑: githubpages是要从你的项目的master分支去获取html页面，而不是gh-pages分支,所以Makefile我修改了下用法<br>####自动push不需要帐号密码<br>其实就是添加~./netrc<br>machine github.com<br>login <a href="mailto:XXX@gmail.com" target="_blank" rel="noopener">XXX@gmail.com</a><br>password XXX<br>####可配置的创建文章<br>想想octopress的Rakefile，里面定义了一个new_post的方法，额pelican什么都没有，好吧，我用shell做了个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash  </span></span><br><span class="line">category=<span class="string">'设计模式'</span>  </span><br><span class="line">title_resource=<span class="string">'python设计模式之'</span>  </span><br><span class="line">tags=<span class="string">'Design Patterns'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> getopts <span class="string">":c:r:g:s:t:"</span> opt; do  </span><br><span class="line">  case $opt <span class="keyword">in</span>  </span><br><span class="line">    c)  </span><br><span class="line">    category=$OPTARG  </span><br><span class="line">      ;;  </span><br><span class="line">    r)  </span><br><span class="line">    title_resource=$OPTARG  </span><br><span class="line">        ;;  </span><br><span class="line">    g)  </span><br><span class="line">    tags=$OPTARG  </span><br><span class="line">        ;;  </span><br><span class="line">    t)  </span><br><span class="line">    title=$OPTARG  </span><br><span class="line">        ;;  </span><br><span class="line">    s)  </span><br><span class="line">    slug=$PTARG  </span><br><span class="line">        ;;  </span><br><span class="line">    ?)  </span><br><span class="line">      echo <span class="string">"How to use: $0 [-c category] [-r title_resource] [-g tags] [-t title] [-s slug]"</span> &gt;&amp;<span class="number">2</span>  </span><br><span class="line">      exit <span class="number">1</span>  </span><br><span class="line">      ;;  </span><br><span class="line">    :)  </span><br><span class="line">      echo <span class="string">"Option -$OPTARG requires an argument."</span> &gt;&amp;<span class="number">2</span>  </span><br><span class="line">      exit <span class="number">1</span>  </span><br><span class="line">      ;;  </span><br><span class="line">  esac  </span><br><span class="line">done  </span><br><span class="line">test <span class="string">"x$title"</span> = <span class="string">"x"</span> &amp;&amp; read -r -p <span class="string">"Post title [前缀是 $&#123;title_resource&#125;]&gt; "</span> &amp;&amp; title=$&#123;REPLY&#125;  </span><br><span class="line">test <span class="string">"x$slug"</span> = <span class="string">"x"</span> &amp;&amp; read -r -p <span class="string">"Post slug [比如abstract-factory]&gt; "</span> &amp;&amp; slug=$&#123;REPLY&#125;  </span><br><span class="line">title=`echo $title | tr <span class="string">"[:upper:]"</span> <span class="string">"[:lower:]"</span>]`  </span><br><span class="line">title=`echo $title | tr -d <span class="string">"[:blank:]"</span>`  </span><br><span class="line">slug=`echo $slug | tr <span class="string">" "</span> <span class="string">"-"</span>`  </span><br><span class="line">fileslug=`echo $slug | tr <span class="string">"-"</span> <span class="string">'_'</span>`  </span><br><span class="line">cur_date=`date <span class="string">"+%Y-%m-%d"</span>`  </span><br><span class="line">filename=<span class="string">"$&#123;category&#125;/$&#123;fileslug&#125;.md"</span>  </span><br><span class="line">author=`git config --get user.name`  </span><br><span class="line">echo <span class="string">"Creating preview"</span>  </span><br><span class="line">echo <span class="string">"_________________________________"</span>  </span><br><span class="line">echo <span class="string">"filename: content/$filename"</span>  </span><br><span class="line">echo <span class="string">"title: $&#123;title_resource&#125;$&#123;title&#125;"</span>  </span><br><span class="line">echo <span class="string">"slug: python-$&#123;slug&#125;"</span>  </span><br><span class="line">echo <span class="string">"date: $&#123;cur_date&#125;"</span>  </span><br><span class="line">echo <span class="string">"category: $&#123;category&#125;"</span>  </span><br><span class="line">echo <span class="string">"tags: $&#123;tags&#125;"</span>  </span><br><span class="line">echo <span class="string">"_________________________________"</span>  </span><br><span class="line">echo <span class="string">""</span>  </span><br><span class="line">read -r -p <span class="string">"Are you ready to create(Y or N) &gt;"</span>  </span><br><span class="line">reply=$&#123;REPLY&#125;  </span><br><span class="line">reply=`echo $reply | tr <span class="string">"[:upper:]"</span> <span class="string">"[:lower:]"</span>]`  </span><br><span class="line">test <span class="string">"x$reply"</span> != <span class="string">"xy"</span> &amp;&amp; exit <span class="number">1</span>  </span><br><span class="line">cat &gt; <span class="string">"content/"</span>$filename &lt;&lt;EOF  </span><br><span class="line">title: $&#123;title_resource&#125;$&#123;title&#125;  </span><br><span class="line">slug: python-$&#123;slug&#125;  </span><br><span class="line">date: $&#123;cur_date&#125;  </span><br><span class="line">category: $&#123;category&#125;  </span><br><span class="line">tags: $&#123;tags&#125;  </span><br><span class="line">  </span><br><span class="line">EOF  </span><br><span class="line">  </span><br><span class="line">$EDITOR <span class="string">"content/"</span>$filename</span><br></pre></td></tr></table></figure>


<p>####PS：以上脚本都可以到我的项目<a href="https://github.com/dongweiming/dongweiming.github.io" target="_blank" rel="noopener">dongweiming.github.io</a>的gh-<br>pages分支去拿</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>wechat-admin：ORM使用篇</title>
    <url>/2016-03-09.html</url>
    <content><![CDATA[<p>我是典型的「ORM党」。ORM全称Object Relational<br>Mapping，中文叫作对象关系映射。通过它我们可以直接使用Python的类的方式做数据库开发，不用直接写原生的SQL语句（甚至不需要SQL的基础），使用ORM有如下优点：</p>
<ol>
<li>易用性。使用这种ORM数据库抽象封装方式做开发可以有效减少重复SQL语句出现的概率，写出来的模型也更直观、清晰。</li>
<li>设计灵活。可以很轻松地写复杂的查询。<br>另外提一下，我在工作中其实有一半时间还是需要直接写SQL的，不过用类的方式包装起来用了。可能不太好理解，有兴趣的可以看一下豆瓣开源的<a href="https://github.com/douban/douban-orz" target="_blank" rel="noopener">douban-<br>orz</a>这个项目，很多场景都是使用这种数据管理方案，我觉得还是蛮好用的。<h3 id="SQLAlchemy的使用"><a href="#SQLAlchemy的使用" class="headerlink" title="SQLAlchemy的使用"></a>SQLAlchemy的使用</h3>SQLAlchemy是业界最流行的ORM库，它支持多个关系数据库引擎，如MySQL、PostgreSQL等数据库，可以近乎无痛地换数据库。本项目的联系人、群聊、公众号等关系和数据都存在了MySQL上。当使用一个ORM库，基于业务特点和开发者个人习惯通常都会定义一些基类或者Mixin类，我写的项目大都会添加[to_dict方法](<a href="https://github.com/dongweiming/wechat-" target="_blank" rel="noopener">https://github.com/dongweiming/wechat-</a><br>admin/blob/master/ext.py#L8)：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat ext.py  </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, DateTime  </span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy, Model  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span><span class="params">(Model)</span>:</span>  </span><br><span class="line">    <span class="comment"># create_at这个属性也是创建表结构默认都包含的  </span></span><br><span class="line">    create_at = Column(DateTime, default=datetime.utcnow())  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        columns = self.__table__.columns.keys()  </span><br><span class="line">        <span class="keyword">return</span> &#123;key: getattr(self, key) <span class="keyword">for</span> key <span class="keyword">in</span> columns&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">db = SQLAlchemy(model_class=BaseModel)</span><br></pre></td></tr></table></figure>


<p>凡是后端API用于返回数据的都需要把一个对象中需要的属性和值拼成一个json对象。<br>我是直接在创建db时就把to_dict和create_at「注入」进去了，不过这样的方法不能使用db这个属性，对于数据库操作的就不方便这么用了。我另外有个习惯是添加create方法，方法内创建对象然后提交事务，相当于封装一个方法完成创建/返回以后的实例，这个我放在了[Mixin里面](<a href="https://github.com/dongweiming/wechat-" target="_blank" rel="noopener">https://github.com/dongweiming/wechat-</a><br>admin/blob/master/models/mixin.py#L4)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> db  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseMixin</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(cls, **kw)</span>:</span>  </span><br><span class="line">        session = db.session  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">'id'</span> <span class="keyword">in</span> kw:  </span><br><span class="line">            obj = session.query(cls).get(kw[<span class="string">'id'</span>])  </span><br><span class="line">            <span class="keyword">if</span> obj:  </span><br><span class="line">                <span class="keyword">return</span> obj  </span><br><span class="line">        obj = cls(**kw)  </span><br><span class="line">        session.add(obj)  </span><br><span class="line">        session.commit()  </span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>


<p>另外还会继承这个BaseMixin实现更多的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreMixin</span><span class="params">(BaseMixin)</span>:</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avatar</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> avatar_tmpl.format(self.id)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        rs = super().to_dict()  </span><br><span class="line">        rs[<span class="string">'avatar'</span>] = self.avatar  </span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>


<p>avatar这个属性是用户/群聊/公众号类需要的，但是Message类不需要，所以独立的实现。我们拿Group感受一下整体的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.hybrid <span class="keyword">import</span> hybrid_method, hybrid_property  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> db  </span><br><span class="line"><span class="keyword">from</span> .mixin <span class="keyword">import</span> BaseMixin  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span><span class="params">(CoreMixin, db.Model)</span>:</span>  </span><br><span class="line">    __tablename__ = <span class="string">'groups'</span>  </span><br><span class="line">    __table_args__ = &#123;<span class="string">'mysql_charset'</span>: <span class="string">'utf8mb4'</span>&#125;  </span><br><span class="line">    id = db.Column(db.String(<span class="number">20</span>), primary_key=<span class="literal">True</span>)  <span class="comment"># puid  </span></span><br><span class="line">    owner_id = db.Column(db.String(<span class="number">20</span>), index=<span class="literal">True</span>)  </span><br><span class="line">    nick_name = db.Column(db.String(<span class="number">60</span>), index=<span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;Group %r&gt;'</span> % self.nick_name  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @hybrid_method  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_member</span><span class="params">(self, user)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> user <span class="keyword">in</span> self.members  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @hybrid_property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> len(self.members)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        rs = super().to_dict()  </span><br><span class="line">        rs[<span class="string">'count'</span>] = self.count  </span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>


<p>为了演示，我省略了一些业务用到的方法。解释下一下：</p>
<ol>
<li>hybrid_method和hybrid_property是SQLAlchemy提供的混合机制，使用它们可以给一个db.Model类添加额外的方法或者属性。</li>
<li>to_dict方法已经被重载多次了，每次通过<code>super().to_dict()</code>拿到原来的结果然后添加新的内容。</li>
<li>加了<strong>table_args</strong>是因为可能会有一些utf8字符集未包含的内容，需要扩大这个字符集。<br>不过事情远没有这么简单，因为选择MySQL这个关系型数据库，就是由于项目需求是有「关系」的：</li>
<li>用户和联系人。比如A的联系人B和A互相关注，但是A中的群聊有个成员C，A和C并没有关注关系。</li>
<li>用户和群聊。用户和对应的群聊也是有关系的，我们需要了解A是不是群聊B内的成员</li>
<li>用户和公众号。用户和公众号也是有关系的，我们需要了解A有没有关注公众号B，而在结构上公众号和用户很像。<br>要实现这样的关系，需要先定义三张表来存放这个关系：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">friendship = db.Table(  </span><br><span class="line">    <span class="string">'friends'</span>,  </span><br><span class="line">    db.Column(<span class="string">'user_id'</span>, db.String(<span class="number">20</span>), db.ForeignKey(<span class="string">'users.id'</span>)),  </span><br><span class="line">    db.Column(<span class="string">'friend_id'</span>, db.String(<span class="number">20</span>), db.ForeignKey(<span class="string">'users.id'</span>)),  </span><br><span class="line">    mysql_charset=<span class="string">'utf8mb4'</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">group_relationship = db.Table(  </span><br><span class="line">    <span class="string">'group_relationship'</span>,  </span><br><span class="line">    db.Column(<span class="string">'group_id'</span>, db.String(<span class="number">20</span>), db.ForeignKey(<span class="string">'groups.id'</span>),  </span><br><span class="line">              nullable=<span class="literal">False</span>),  </span><br><span class="line">    db.Column(<span class="string">'user_id'</span>, db.String(<span class="number">20</span>), db.ForeignKey(<span class="string">'users.id'</span>),  </span><br><span class="line">              nullable=<span class="literal">False</span>),  </span><br><span class="line">    mysql_charset=<span class="string">'utf8mb4'</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">mp_relationship = db.Table(  </span><br><span class="line">    <span class="string">'mp_relationship'</span>,  </span><br><span class="line">    db.Column(<span class="string">'mp_id'</span>, db.String(<span class="number">20</span>), db.ForeignKey(<span class="string">'mps.id'</span>),  </span><br><span class="line">              nullable=<span class="literal">False</span>),  </span><br><span class="line">    db.Column(<span class="string">'user_id'</span>, db.String(<span class="number">20</span>), db.ForeignKey(<span class="string">'users.id'</span>),  </span><br><span class="line">              nullable=<span class="literal">False</span>),  </span><br><span class="line">    mysql_charset=<span class="string">'utf8mb4'</span>  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>举个例子更好明白，mp_relationship包含2个字段：</p>
<ol>
<li>mp_id，它对应mps这个表里面对应记录的id字段</li>
<li>user_id，它对应users这个表里面对应记录的id字段<br>铺垫完成了，感受下User类如何定义关系的：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(CoreMixin, db.Model)</span>:</span>  </span><br><span class="line">    __tablename__ = <span class="string">'users'</span>  </span><br><span class="line">    ...  </span><br><span class="line">    groups = db.relationship(<span class="string">'Group'</span>, secondary=group_relationship,  </span><br><span class="line">                             backref=<span class="string">'members'</span>)  </span><br><span class="line">    mps = db.relationship(<span class="string">'MP'</span>, secondary=mp_relationship,  </span><br><span class="line">                          backref=<span class="string">'users'</span>)  </span><br><span class="line">    friends = db.relationship(<span class="string">'User'</span>,  </span><br><span class="line">                              secondary=friendship,  </span><br><span class="line">                              primaryjoin=(friendship.c.user_id == id),  </span><br><span class="line">                              secondaryjoin = (friendship.c.friend_id == id),  </span><br><span class="line">                              lazy = <span class="string">'dynamic'</span>  </span><br><span class="line">                              )</span><br></pre></td></tr></table></figure>


<p>groups和mps的用法很像，定义字段的时候使用db.relationship，其中secondary参数就是上面的关系表对象。backref表示在对应的类（Group或者MP）中的属性名字。<br>friends要更复杂，因为friendship中的2个字段都在同一张表，所以有2个外键，可以使用primaryjoin明确联结条件，secondaryjoin来指定多对多关系中的二级联结条件。lazy决定了SQLAlchemy什么时候从数据库中加载数据，dynamic表示只是返回一个查询对象而不是直接加载这些数据，这样在加载数据前我们可以在执行语句中添加过滤之类的条件。</p>
<h3 id="Walrus的使用"><a href="#Walrus的使用" class="headerlink" title="Walrus的使用"></a>Walrus的使用</h3><p>Walrus是Redis的ORM库，和SQLAlchemy相比名气差了很多，我觉得大家不怎么用ORM操作Redis的主要原因是Redis就是个内存数据库，它的使用不像SQL那样容易写错，最多就是使用pipeline，过程很清晰，操作和查询都很简单。<br>限于公司技术栈，我其实在工作中也很少用Redis，需求很简单就直接调用对应方法了。这次是我想尝试一下ORM的方式，理由是：</p>
<ol>
<li>手写操作和查询还是会出现语句重复利用率不高的问题</li>
<li>就像前面说的，更喜欢通过操作ORM的开发方式<br>使用Walrus我也创建了[基类](<a href="https://github.com/dongweiming/wechat-" target="_blank" rel="noopener">https://github.com/dongweiming/wechat-</a><br>admin/blob/master/models/redis.py#L1)：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database, Model, ListField, SetField, HashField  </span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> REDIS_URL  </span><br><span class="line">  </span><br><span class="line">db = Database.from_url(REDIS_URL)  </span><br><span class="line">LISTENER_TASK_KEY = <span class="string">'listener:task_id'</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBase</span><span class="params">(Model)</span>:</span>  </span><br><span class="line">    __database__ = db  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        data = &#123;&#125;  </span><br><span class="line">        <span class="keyword">for</span> name, field <span class="keyword">in</span> self._fields.items():  </span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> self._data:  </span><br><span class="line">                val = self._data[name]  </span><br><span class="line">                data[name] = val <span class="keyword">if</span> field._as_json <span class="keyword">else</span> field.db_value(val)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="keyword">if</span> isinstance(field, ListField):  </span><br><span class="line">                    type_func = list  </span><br><span class="line">                <span class="keyword">elif</span> isinstance(field, SetField):  </span><br><span class="line">                    type_func = set  </span><br><span class="line">                <span class="keyword">elif</span> isinstance(field, HashField):  </span><br><span class="line">                    type_func = dict  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    type_func = <span class="keyword">lambda</span> x: x  </span><br><span class="line">                data[name] = type_func(getattr(self, name))  </span><br><span class="line">        <span class="keyword">return</span> data  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(cls, id)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">return</span> super().get(cls.id == id)  </span><br><span class="line">        <span class="keyword">except</span> ValueError:  </span><br><span class="line">            <span class="keyword">return</span> cls.create(id=id)</span><br></pre></td></tr></table></figure>


<p>同样的实现了to_dict方法。不过我重写了get方法：get不到就创建，这是由于业务需要，第一次拿不到就要创建一个默认配置的记录来用。看一下model的[写法](<a href="https://github.com/dongweiming/wechat-" target="_blank" rel="noopener">https://github.com/dongweiming/wechat-</a><br>admin/blob/master/models/setting.py)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> TextField, ListField, JSONField, IntegerField  </span><br><span class="line"><span class="keyword">from</span> .redis <span class="keyword">import</span> RBase  </span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> welcome_text, invite_text, kick_text, group_patterns  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupSettings</span><span class="params">(RBase)</span>:</span>  </span><br><span class="line">    id = TextField(primary_key=<span class="literal">True</span>)  </span><br><span class="line">    welcome_text = TextField(default=welcome_text)  </span><br><span class="line">    invite_text = TextField(default=invite_text)  </span><br><span class="line">    group_patterns = JSONField(default=group_patterns)  </span><br><span class="line">    creators = ListField()  </span><br><span class="line">    mp_forward = JSONField(default=[])  </span><br><span class="line">    kick_quorum_n = IntegerField(default=<span class="number">5</span>)  </span><br><span class="line">    kick_period = IntegerField(default=<span class="number">5</span>)  </span><br><span class="line">    kick_text = TextField(default=kick_text)</span><br></pre></td></tr></table></figure>


<p>可以看到GroupSettings都是带默认值的，所以创建的时候传入最重要的id就可以。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在wechat-admin中就是这么用ORM的。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>gentoo下的lxc和docker</title>
    <url>/2016-03-11.html</url>
    <content><![CDATA[<p>####前言<br>上次就说要写一篇gentoo下安装使用docker的文章，顺便也学习了下gentoo下的lxc，记录下来<br>####升级你的内核<br>docker要求升级到3.8以上的内核,假如你的已经是3.8.XX,那么你就要重新编译内核,参看<a href="http://wiki.gentoo.org/wiki/LXC" target="_blank" rel="noopener">Wiki</a><br>很多人比较怕编译内核，一看那个启动的简陋的页面就不知道该干什么了,出现问题不知道该去选择什么或者去掉什么选项.我来说一些小窍门,简单的说就是<br>根据提示去内核界面按’/‘搜索这个参数，根据提示的位置找到那个项<br>问题1: 假如符合项很多怎么判断那个是真正要我选择的呢?<br>回答: 首先是上下文的判断，一般的情况都是符合某写关键字的项都是某项和它的子项，当你去掉其父项，子项的选项也就消失了，还有个使用的经验的积累.<br>比如下面的提示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*   CONFIG_NETFILTER_XT_MATCH_ADDRTYPE:  <span class="keyword">is</span> <span class="keyword">not</span> set when it should be.</span><br></pre></td></tr></table></figure>


<p>意思就是提示你”NETFILTER_XT_MATCH_ADDRTYPE”,<br>没有设置，然后你使用/输入”NETFILTER_XT_MATCH_ADDRTYPE”,回车，会显示类似下面的东西:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Search Results ─────────────────────────────┐  </span><br><span class="line"> │ Symbol: NETFILTER_XT_MATCH_ADDRTYPE [=n]                                │    </span><br><span class="line"> │ Type  : tristate                                                        │    </span><br><span class="line"> │ Prompt: <span class="string">"addrtype"</span> address type match support                           │    </span><br><span class="line"> │   Defined at net/netfilter/Kconfig:<span class="number">798</span>                                  │    </span><br><span class="line"> │   Depends on: NET [=y] &amp;&amp; INET [=y] &amp;&amp; NETFILTER [=y] &amp;&amp; NETFILTER_XTAB │    </span><br><span class="line"> │   Location:                                                             │    </span><br><span class="line"> │     -&gt; Networking support (NET [=y])                                    │    </span><br><span class="line"> │       -&gt; Networking options                                             │    </span><br><span class="line"> │         -&gt; Network packet filtering framework (Netfilter) (NETFILTER [= │    </span><br><span class="line"> │           -&gt; Core Netfilter Configuration                               │    </span><br><span class="line"> │ (1)         -&gt; Netfilter Xtables support (required for ip_tables) (NETF │</span><br></pre></td></tr></table></figure>


<p>注意其中的’Prompt’,他是帮助你在实际找对应项判断主题的关键字,’Location’告诉你它的位置是<br>‘Networking support’下的’Networking options’子项下的’Network packet filtering<br>framework’…<br>问题2： 为什么我选择了这个项依然还是没有显示成功，比如上面’NETFILTER_XT_MATCH_ADDRTYPE [=n]’ n就是no，y就是yes<br>一个严重的问题就是某项其实会有很多依赖，只有这些依赖都是’y’的时候它才生效.比如lxc要求的’USER_NS’,<br>默认内核中是没有显示出来的,原因是存在很多依赖和他冲突，必须去掉那些项他才会显示, 你打开它的搜索去看还有那个依赖还是’n’.<br>这个过程可能好几次，直到最后，就显示了UIDGID_CONVERTED的bool值为n，这个时候你就要去看这个内核参数的依赖,打开/usr/src/linux/init/Kconfig,<br>找到依赖挨个去掉，直到能显示<br>####安装docker<br>[tianon](<a href="https://github.com/tianon/gentoo-" target="_blank" rel="noopener">https://github.com/tianon/gentoo-</a><br>overlay)做好了一个docker的overlay源，而且docker的gentoo镜像也是他贡献的，感谢.<br>把三方layman增加到你的gentoo系统在以前的[我维护的colout](<a href="http://www.dongwm.com/archives/wo-wei-" target="_blank" rel="noopener">http://www.dongwm.com/archives/wo-wei-</a><br>hu-de-colout)说过就不说了,假设这里你已经添加了tianon的源<br>然后安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo emerge app-emulation/lxc-docker</span><br></pre></td></tr></table></figure>


<p>这个依赖过程当然也会安装lxc<br>因为docker依赖aufs,但是安装aufs的时候出现问题，我还记得一句:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">You need to apply a patch to your kernel to compile <span class="keyword">and</span> run the aufs3 module</span><br></pre></td></tr></table></figure>


<p>然后就异常退出了,看了下源码也的确有这些patch,当我手动打了第一个patch,依然报错…只能一个个的补丁手动打进去？<br>看它的ebuild,有这样一行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">IUSE=<span class="string">"debug doc fuse hfs inotify kernel-patch nfs pax_kernel ramfs"</span></span><br></pre></td></tr></table></figure>


<p>可是kernel-patch没有起作用,那么你在你的/etc/make.conf的USE里面添加’kernel-patch’就好了<br>####增加docker0网卡<br>增加一个配置，这个配置也是创建容器可选的配置，都放在/etc/lxc目录下<br>cat /etc/lxc/guest.conf</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lxc.network.type = veth  </span><br><span class="line">lxc.network.flags = up  </span><br><span class="line">lxc.network.link = docker0</span><br></pre></td></tr></table></figure>


<p>####启动docker</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker -d &amp;</span><br></pre></td></tr></table></figure>


<p>当提示类似:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2013</span>/<span class="number">07</span>/<span class="number">13</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">46</span> Listening <span class="keyword">for</span> HTTP on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4243</span> (tcp)</span><br></pre></td></tr></table></figure>


<p>表示搞定了<br>但是我这里出现了一个报错</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">iptables v1.4.16.3: can't initialize iptables table `nat': Table does not exist (do you need to insmod?)</span><br></pre></td></tr></table></figure>


<p>iptables的版本够高，但是很明显还是内核模块的问题，查看下,果然如此</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">localhost ~ <span class="comment"># zgrep NF_NAT /proc/config.gz  </span></span><br><span class="line"><span class="comment"># CONFIG_NF_NAT_IPV4 is not set  </span></span><br><span class="line"><span class="comment"># CONFIG_NF_NAT_IPV6 is not set</span></span><br></pre></td></tr></table></figure>


<p>还是需要设置在重新编译内核,重启生效<br>####使用lxc<br>比如我想创建个debian的容器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">emerge dev-util/debootstrap <span class="comment">#不同的系统依赖不同的这个包，比如fedora/centos就是sys-apps/yum, arch就是sys-apps/pacman...  </span></span><br><span class="line">lxc-create -t debian -n debian_test <span class="comment">#也可以加-p 指定配置文件 ，配置类似上面的guest.conf，可以配置ip之类  </span></span><br><span class="line"><span class="comment"># 假如想要ubuntu  </span></span><br><span class="line"><span class="comment"># lxc-create -t ubuntu -n ubuntu_test</span></span><br></pre></td></tr></table></figure>


<p>这个时间会下载debian的基础镜像，包含一些基础的包<br>你要设置root密码,比如我这个debian_test， 相关数据都在/etc/lxc/debian_test</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd /etc/lxc/debian_test  </span><br><span class="line">chroot rootfs /bin/bash</span><br></pre></td></tr></table></figure>


<p>然后登录设置密码<br>启动和关闭容器的命令是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lxc-start -n debian_test  </span><br><span class="line">lxc-stop -n debian_test</span><br></pre></td></tr></table></figure>


<p>当然你也可以设置个开机启动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ln -s lxc /etc/init.d/lxc.debian_test  </span><br><span class="line">/etc/init.d/lxc.debian_test stop  </span><br><span class="line">/etc/init.d/lxc.debian_test start  </span><br><span class="line">rc-update add lxc.debian_test default</span><br></pre></td></tr></table></figure>


<p>还可以使用终端连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lxc-console -n debian_test</span><br></pre></td></tr></table></figure>


<p>####创建gentoo容器<br>当我想创建gentoo的容器,可以借用[lxc-gentoo](<a href="https://github.com/globalcitizen/lxc-" target="_blank" rel="noopener">https://github.com/globalcitizen/lxc-</a><br>gentoo),它提供一个命令行的选择.简单粗暴，以下是一个例子<br>创建一个ip为192.168.0.10，网关为192.168.0.1，容器叫做gentoo_test，主机名为test1的容器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo lxc-gentoo/lxc-gentoo create -i <span class="number">192.168</span><span class="number">.0</span><span class="number">.10</span>/<span class="number">26</span> -g <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> -n gentoo_test -u test1</span><br></pre></td></tr></table></figure>


<p>默认会把容器安装在执行命令的当前目录,这样启动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo /usr/sbin/lxc-start -f test1.conf -n gentoo_test</span><br></pre></td></tr></table></figure>


<p>你也可以chroot进去，<br>为什么这样用？比如我经常用到的场景，我安装了gentoo/opensuse的双系统，可能我把其中一个系统玩坏(比如升级产生的问题，我安装或者卸载了某些东西等)<br>，我就可以在没有u盘，livecd的前提下进入另外一个系统，chroot到这个系统去修复,而且不影响工作，因为我的很多目录之类都是软连接，修改一个地方切换另外的系统继续用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mount -t proc proc ./gentoo_test/proc  </span><br><span class="line">mount -o bind /dev ./gentoo_test/dev  </span><br><span class="line">chroot ./gentoo_test /bin/bash  </span><br><span class="line">export PS1=<span class="string">"(gentoo_test) $PS1"</span>  </span><br><span class="line"><span class="comment"># 现在你就进来了,而不需要启动系统</span></span><br></pre></td></tr></table></figure>


<p>####创建Archlinux容器<br>我没有用gentoo的lxc自带的/usr/share/lxc/templates/lxc-archlinux,因为它根本用不了,并且存在以下一些问题:</p>
<ol>
<li>arch早已不用initscripts，改用systemd</li>
<li>安装基础系统不需要chroot到其系统,直接pacman指定系统根目录即可,并且它chroot进去指定根系统,那肯定永远也成功不了</li>
<li>在一个新的系统的pacman.conf没有指定XferCommand,那么也就不知道用什么下载了<br>我新建个一个项目[gentoo-lxc-templates](<a href="https://github.com/dongweiming/gentoo-lxc-" target="_blank" rel="noopener">https://github.com/dongweiming/gentoo-lxc-</a><br>templates),目前包含了我修改的lxc-archlinux,我很少用arch,有问题欢迎pullme</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Strider实现持续集成</title>
    <url>/2016-03-14.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>持续集成（Continuous Integration）已经是公认的保证产品质量和开发快速迭代的开发实践了。<br>目前常见的CI服务器有2种：</p>
<ol>
<li><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a>。 Jenkins是一个用Java编写的开源的持续集成工具， 它有丰富的插件和完善的API， 但实际工作中发现它不太稳定， Python和前端工程师很难对其进行二次开发， 页面和功能也有些陈旧。</li>
<li><a href="https://github.com/travis-ci/travis-ci" target="_blank" rel="noopener">Travis CI</a>。 一个针对Github的云服务平台， 只对开源项目提供免费的CI服务。<br>本篇博客将给大家介绍一个新的持续集成工具<a href="https://github.com/Strider-CD/strider" target="_blank" rel="noopener">Strider</a>。<br>一个使用Node.js开发的、 开源的持续集成和发布服务器。 目前它已经支持Github、 Bitbucket、 Gitlab等平台， 支持Python、<br>Ruby、 Node.js和其他自定义的应用。<br>虽然它使用常见了bootstrap， 但是页面效果还是很不错的。<br>在使用之前， 我们先创建一个<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">Github开发者应用</a>，<br>内容如下图：<br><img src="https://cloud.githubusercontent.com/assets/841395/15366447/ffeb1170-1d56-11e6-9957-9361c089fc05.png" alt><br>然后在Github上创建一个用来测试的项目<a href="https://github.com/dongweiming/tola" target="_blank" rel="noopener">dongweiming/tola</a>。<h3 id="使用Strider集成"><a href="#使用Strider集成" class="headerlink" title="使用Strider集成"></a>使用Strider集成</h3>使用最新版的Node.js：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ wget https://nodejs.org/dist/v4<span class="number">.4</span><span class="number">.2</span>/node-v4<span class="number">.4</span><span class="number">.2</span>.tar.gz  </span><br><span class="line">❯ tar zxf node-v4<span class="number">.4</span><span class="number">.2</span>.tar.gz  </span><br><span class="line">❯ cd node-v4<span class="number">.4</span><span class="number">.2</span>  </span><br><span class="line">❯ ./configure &amp;&amp; make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>


<p>安装Strider：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ git clone https://github.com/Strider-CD/strider  </span><br><span class="line">❯ cd strider  </span><br><span class="line">❯ npm install  <span class="comment"># 安装依赖包</span></span><br></pre></td></tr></table></figure>


<p>Strider配置项很多， 可以在Strider目录下添加.striderrc文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat .striderrc  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="string">"db_uri"</span>: <span class="string">"mongodb://dongwm:dongwm@ds015720.mlab.com:15720/strider-dongwm"</span>,  <span class="comment"># 我的VPS不够1G内存， 不能安装MongoDB， 使用 MongoLab的免费服务来测试  </span></span><br><span class="line"><span class="string">"smtp_host"</span>: <span class="string">"smtp.mailgun.org"</span>,  <span class="comment"># Mailgun提供每天可发送300封邮件的免费服务， 我们用它来测试  </span></span><br><span class="line"><span class="string">"smtp_user"</span>: <span class="string">"postmaster@sandboxabe8d2f42ac8424fa8dd4c5ab1f1d92b.mailgun.org"</span>,  </span><br><span class="line"><span class="string">"smtp_pass"</span>: <span class="string">"4e0c2880f7aaf6c1b5f39bb88acabee1"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建管理员用户：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DB_URI=mongodb://dongwm:dongwm@ds015720.mlab.com:<span class="number">15720</span>/strider-dongwm node bin/strider addUser</span><br></pre></td></tr></table></figure>


<p>启动服务， 需要上面创建的开发者应用的APP_ID和APP_SECRET（如果使用Github企业版，<br>需要设置PLUGIN_GITHUB_API_DOMAIN和PLUGIN_GITHUB_API_ENDPOINT）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export SERVER_NAME=http://VPS:<span class="number">3000</span>  </span><br><span class="line">export PLUGIN_GITHUB_APP_ID=<span class="number">1</span>a7bcf97d84c938bdbe8  </span><br><span class="line">export PLUGIN_GITHUB_APP_SECRET=<span class="number">316947</span>cbe6a85e295dcd2346f272f7844aea87cd  </span><br><span class="line">NODE_ENV=production npm start</span><br></pre></td></tr></table></figure>


<p>访问<a href="http://VPS:3000/login，" target="_blank" rel="noopener">http://VPS:3000/login，</a> 使用之前创建的管理员用户登录。 目前还没有配置项目：<br><img src="https://cloud.githubusercontent.com/assets/841395/15366504/362d531a-1d57-11e6-94d6-fdeed98754a5.png" alt><br>Strider默认开启了Github、 Bitbucket、 Gitlab插件。<br>点击<code>Github</code>按钮来集成Github支持（也可以直接使用如下地址访问<a href="http://VPS:3000/auth/github）：" target="_blank" rel="noopener">http://VPS:3000/auth/github）：</a><br><img src="https://cloud.githubusercontent.com/assets/841395/15366507/36e05f78-1d57-11e6-85d8-58b9b43f6cb4.png" alt><br>点击<code>Authorize application</code>按钮， 输入有权限的Github账号密码。 验证后会跳回Strider的项目页面下。<br>找到项目tola， 点击项目右侧的<code>Add</code><br><img src="https://cloud.githubusercontent.com/assets/841395/15366545/65f6590c-1d57-11e6-82fd-821b19f14eea.png" alt><br>接下来选择项目类型， 这里选择Python， Strider会做一些初始设置。<br>Strider会自动给项目添加一个Webhook。<br>打开<a href="https://github.com/dongweiming/tola/settings/hooks可以看到：" target="_blank" rel="noopener">https://github.com/dongweiming/tola/settings/hooks可以看到：</a><br><img src="https://cloud.githubusercontent.com/assets/841395/15366565/7acdc266-1d57-11e6-9abb-f66d50baf858.png" alt><br>访问插件管理页面：<a href="http://VPS:3000/admin/plugins，" target="_blank" rel="noopener">http://VPS:3000/admin/plugins，</a> 我们需要安装Github Status这个插件，<br>点击后面的Install。<br>访问<a href="http://VPS:3000/dongweiming/tola/config/tab-plugins激活邮件通知和Github状态插件，" target="_blank" rel="noopener">http://VPS:3000/dongweiming/tola/config/tab-plugins激活邮件通知和Github状态插件，</a><br>需要把<code>Email Notifiter</code>和<code>GitHub Status</code>拖拽到左面。<br><img src="https://cloud.githubusercontent.com/assets/841395/15366576/8f345cce-1d57-11e6-8f8e-6636ec50b6b3.png" alt><br>进入<a href="http://VPS:3000/dongweiming/tola/config/plugin-emailnotifier页面勾选`Always" target="_blank" rel="noopener">http://VPS:3000/dongweiming/tola/config/plugin-emailnotifier页面勾选`Always</a><br>send notification emails.`。<br>现在当tola项目发生Pull request、 Push等事件时就会自动触发这个集成测试了。<br>项目结果页面是<a href="http://VPS:3000/dongweiming/tola。" target="_blank" rel="noopener">http://VPS:3000/dongweiming/tola。</a> 构建成功的效果如下：<br><img src="https://cloud.githubusercontent.com/assets/841395/15366595/a5e27d0c-1d57-11e6-9417-6fcc859763b5.png" alt><br>构建失败的效果如下：<br><img src="https://cloud.githubusercontent.com/assets/841395/15366594/a5db3cf4-1d57-11e6-8191-ddd10ae7e25e.png" alt><br>同时， 在Github的Pull request页面也会显示集成结果：<br><img src="https://cloud.githubusercontent.com/assets/841395/15366599/a70fc1b2-1d57-11e6-937c-556114484be8.png" alt><br>打开QQ邮箱就可以看到集成结果的邮件了：<br><img src="https://cloud.githubusercontent.com/assets/841395/15366593/a5d9be4c-1d57-11e6-930d-0d322b2fa4be.png" alt><br>Strider自带发送Slack通知的插件， 而且Strider插件非常容易定制， 可以定义更多的插件支撑业务需要。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>wechat-admin：Flask使用篇</title>
    <url>/2016-03-15.html</url>
    <content><![CDATA[<p>在<a href="https://zhuanlan.zhihu.com/p/22774028" target="_blank" rel="noopener">Flask最佳实践</a>里面有三项在本项目也有应用：</p>
<ol>
<li>怎么用扩展</li>
<li>自定义RESTAPI的处理</li>
<li>local_settings.py<br>这我就不再复述了，看些不一样的内容吧。<h3 id="Flask处理静态资源"><a href="#Flask处理静态资源" class="headerlink" title="Flask处理静态资源"></a>Flask处理静态资源</h3>理论上应该使用Nginx来处理静态资源，但是wechat-<br>admin不是面向用户的产品，所以为了便利直接使用Flask提供的SharedDataMiddleware中间件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> SharedDataMiddleware  </span><br><span class="line">  </span><br><span class="line">app = Flask(__name__)  </span><br><span class="line">app.add_url_rule(<span class="string">'/uploads/&lt;filename&gt;'</span>, <span class="string">'uploaded_file'</span>,  </span><br><span class="line">                 build_only=<span class="literal">True</span>)  </span><br><span class="line">app.wsgi_app = SharedDataMiddleware(app.wsgi_app, &#123;  </span><br><span class="line">        <span class="string">'/uploads'</span>: app.config[<span class="string">'UPLOAD_FOLDER'</span>]  </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>


<p>在给对应群聊/用户发消息时添加的文件保存在服务器上面，可以通过<code>/uploads/&lt;filename&gt;</code>访问到。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>本地开发时，前端运行的端口和后端API接口用的端口不一致，为了方便本地开发可以添加一个钩子，利用CORS实现跨域请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># For local test  </span></span><br><span class="line"><span class="meta">@app.after_request  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">after_request</span><span class="params">(response)</span>:</span>  </span><br><span class="line">    response.headers.add(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)  </span><br><span class="line">    response.headers.add(  </span><br><span class="line">        <span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type,Authorization'</span>)  </span><br><span class="line">    response.headers.add(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET,PUT,POST,DELETE'</span>)  </span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>


<p>注意，为了简单省事Access-Control-Allow-<br>Origin的值设成了’*’。不过事实上，如果你使用Webpack，可以在config/index.js文件的dev键下使用changeOrigin，举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dev: &#123;  </span><br><span class="line">    ...  </span><br><span class="line">    proxyTable: &#123;  </span><br><span class="line">      <span class="string">'/j/admin'</span>: &#123;  </span><br><span class="line">        target: <span class="string">'http://localhost:8100,  </span></span><br><span class="line"><span class="string">        changeOrigin: true  </span></span><br><span class="line"><span class="string">      &#125;  </span></span><br><span class="line"><span class="string">    &#125;,  </span></span><br><span class="line"><span class="string">    cssSourceMap: false  </span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="自定义报错状态码"><a href="#自定义报错状态码" class="headerlink" title="自定义报错状态码"></a>自定义报错状态码</h3><p>如果项目是商业级别，我通常建议在API接口管理上自定义一些状态码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">unknown_error = (<span class="number">1000</span>, <span class="string">'unknown_error'</span>, <span class="number">400</span>)  </span><br><span class="line">access_forbidden = (<span class="number">1001</span>, <span class="string">'access_forbidden'</span>, <span class="number">403</span>)  </span><br><span class="line">unimplemented_error = (<span class="number">1002</span>, <span class="string">'unimplemented_error'</span>, <span class="number">400</span>)  </span><br><span class="line">not_found = (<span class="number">1003</span>, <span class="string">'not_found'</span>, <span class="number">404</span>)  </span><br><span class="line">illegal_state = (<span class="number">1004</span>, <span class="string">'illegal_state'</span>, <span class="number">400</span>)</span><br></pre></td></tr></table></figure>


<p>这样做的好处的是在文档中能让使用者清晰的知道某种错误的意义，也能让开发者了解在什么情况下抛出什么样的错误。<br>对于本项目的设计，自定义的异常类型要接受这样的三个参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> views.utils <span class="keyword">import</span> ApiResult  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiException</span><span class="params">(Exception)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, error, real_message=None)</span>:</span>  </span><br><span class="line">        self.code, self.message, self.status = error  </span><br><span class="line">        <span class="keyword">if</span> real_message <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            self.message = real_message  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_result</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> ApiResult(&#123;<span class="string">'msg'</span>: self.message, <span class="string">'r'</span>: self.code&#125;,  </span><br><span class="line">                         status=self.status)</span><br></pre></td></tr></table></figure>


<p>为此还需要通过errorhandler指定ApiException类型异常如何处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@json_api.errorhandler(ApiException)  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_error_handler</span><span class="params">(error)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> error.to_result()</span><br></pre></td></tr></table></figure>


<p>现在在业务中在应该抛错误的地方直接这么用就好了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">raise</span> ApiException(errors.not_found)</span><br></pre></td></tr></table></figure>


<p>另外我们也要通过errorhandler指定对于其他引起404、500以及403的地方做类似的错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@json_api.errorhandler(403)  </span></span><br><span class="line"><span class="meta">@json_api.errorhandler(404)  </span></span><br><span class="line"><span class="meta">@json_api.errorhandler(500)  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler</span><span class="params">(error)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> hasattr(error, <span class="string">'name'</span>):  </span><br><span class="line">        msg = error.name  </span><br><span class="line">        code = error.code  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        msg = error.message  </span><br><span class="line">        code = <span class="number">500</span>  </span><br><span class="line">    <span class="keyword">return</span> ApiResult(&#123;<span class="string">'message'</span>: msg&#125;, status=code)</span><br></pre></td></tr></table></figure>


<p>这样就保证了API返回的都是统一格式的结果，而不会抛出错误了。</p>
<h3 id="登录的逻辑"><a href="#登录的逻辑" class="headerlink" title="登录的逻辑"></a>登录的逻辑</h3><p>登陆的视图比较简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> sse  </span><br><span class="line"><span class="keyword">from</span> libs.globals <span class="keyword">import</span> current_bot  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@json_api.route('/login', methods=['post'])  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span>  </span><br><span class="line">    user = get_logged_in_user(current_bot)  </span><br><span class="line">    <span class="keyword">from</span> wechat.tasks <span class="keyword">import</span> retrieve_data  </span><br><span class="line">    retrieve_data.delay()  </span><br><span class="line">    sse.publish(&#123;<span class="string">'type'</span>: <span class="string">'logged_in'</span>, <span class="string">'user'</span>: user&#125;, type=<span class="string">'login'</span>)  </span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'msg'</span>: <span class="string">''</span>&#125;</span><br></pre></td></tr></table></figure>


<p>其中的get_logged_in_user是业务逻辑就不展示了，有兴趣的可以看源码了解。retrieve_data就是之前说的获取微信联系人、群聊、公众号的任务，在视图内部调用delay方法就可以让它异步执行了。同时sse.publish会发一个登录的推送让前端页面做对应的处理。<br>上述逻辑里面最不好理解的是current_bot。我们都知道Flask自带了4个上下文，比如request、current_app、session和g。使用wxpy获得bot是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bot</span><span class="params">()</span>:</span>  </span><br><span class="line">    bot = Bot(<span class="string">'bot.pkl'</span>, qr_path=os.path.join(  </span><br><span class="line">        here, <span class="string">'../static/img/qr_code.png'</span>), console_qr=<span class="literal">None</span>)  </span><br><span class="line">    bot.enable_puid()  </span><br><span class="line">    bot.messages.max_history = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">return</span> bot</span><br></pre></td></tr></table></figure>


<p>本来应该是把这个对象序列化存在Redis中的，但是由于设计的时候没有考虑序列化的问题，我对它的代码也不熟，所以就直接使用上下文来做了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack, LocalProxy  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_bot</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">from</span> .wx <span class="keyword">import</span> get_bot  </span><br><span class="line">    top = _wx_ctx_stack.top  </span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">        top = get_bot()  </span><br><span class="line">        _wx_ctx_stack.push(top)  </span><br><span class="line">    <span class="keyword">return</span> top  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">_wx_ctx_stack = LocalStack()  </span><br><span class="line">current_bot = LocalProxy(_find_bot)</span><br></pre></td></tr></table></figure>


<p>不过要注意，启动多进程的话，理论上每个进程都会创建多个bot，不过由于bot存在的意义是执行，另外get_bot执行成功一次后在重复执行会使用之前生成的pkl文件，所以这样用也是没有问题。<br>在使用wechat-<br>admin项目的README文档中，我特意说了先扫码登陆后才能启动Celery，这是因为不这样做的话，current_bot还是阻塞状态，会在启动Celery的时候先卡在让你扫码登录上，这点要注意。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天为止，整个wechat-admin就介绍完啦~</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3.6全揭秘</title>
    <url>/2016-03-18.html</url>
    <content><![CDATA[<p>刚才看到<a href="https://learnpythonthehardway.org/python3/" target="_blank" rel="noopener">Learn Python the Hard<br>Way</a>第四版都开始使用Python<br>3.6😝，。想起当时某些人还吐槽我的书竟然是使用Python 2的，好吧，我也来列一下Python<br>3.6中非常值得一提的变化（最详细的当然还是看官方的<a href="https://docs.python.org/3.6/whatsnew/3.6.html" target="_blank" rel="noopener">What’s<br>New</a>）。</p>
<h3 id="Literal-String-Interpolation"><a href="#Literal-String-Interpolation" class="headerlink" title="Literal String Interpolation"></a>Literal String Interpolation</h3><p>新增了<a href="https://www.python.org/dev/peps/pep-0498/" target="_blank" rel="noopener">格式化字符串变量</a>语法，通过字符串的前缀f，实现类似于Scala/Swift等语言的字符串插值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'Fred'</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'My name is <span class="subst">&#123;name&#125;</span>'</span>  </span><br><span class="line"><span class="string">'My name is Fred'</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>date = datetime.datetime.now().date()  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'<span class="subst">&#123;date&#125;</span> was on a <span class="subst">&#123;date:%A&#125;</span>'</span>  </span><br><span class="line"><span class="string">'2017-02-25 was on a Saturday'</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'<span class="subst">&#123;<span class="string">"quoted string"</span>&#125;</span>'</span>  </span><br><span class="line"><span class="string">'quoted string'</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span>  </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">20</span>  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f'result=<span class="subst">&#123;foo()&#125;</span>'</span>  </span><br><span class="line"><span class="string">'result=20'</span></span><br></pre></td></tr></table></figure>


<h3 id="Asynchronous-Generators"><a href="#Asynchronous-Generators" class="headerlink" title="Asynchronous Generators"></a>Asynchronous Generators</h3><p>新增<a href="https://www.python.org/dev/peps/pep-0525/" target="_blank" rel="noopener">异步生成器</a>语法，可以直接在协程中用生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">10</span>):  </span><br><span class="line">        <span class="keyword">yield</span> item  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> coro():  </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>


<h3 id="Async-comprehensions"><a href="#Async-comprehensions" class="headerlink" title="Async comprehensions"></a>Async comprehensions</h3><p>新增<a href="https://www.python.org/dev/peps/pep-0530" target="_blank" rel="noopener">异步解析</a>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">result = [<span class="keyword">await</span> fun() <span class="keyword">for</span> fun <span class="keyword">in</span> funcs]  </span><br><span class="line">result = &#123;<span class="keyword">await</span> fun() <span class="keyword">for</span> fun <span class="keyword">in</span> funcs&#125;  </span><br><span class="line">result = &#123;fun: <span class="keyword">await</span> fun() <span class="keyword">for</span> fun <span class="keyword">in</span> funcs&#125;  </span><br><span class="line">result = [func <span class="keyword">async</span> <span class="keyword">for</span> fun <span class="keyword">in</span> funcs]  </span><br><span class="line">result = &#123;func <span class="keyword">async</span> <span class="keyword">for</span> fun <span class="keyword">in</span> funcs&#125;  </span><br><span class="line">result = &#123;func <span class="keyword">async</span> <span class="keyword">for</span> fun <span class="keyword">in</span> funcs&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Variable-annotations"><a href="#Variable-annotations" class="headerlink" title="Variable annotations"></a>Variable annotations</h3><p>在Python 3.5的时候已经添加了<a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener">类型标注</a>语法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">primes = []  <span class="comment"># type: List[int]  </span></span><br><span class="line">primes = <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>不过得通过mypy做类型检查:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ mypy prime.py  </span><br><span class="line">prime.py:<span class="number">2</span>: error: Incompatible types <span class="keyword">in</span> assignment (expression has type <span class="string">"int"</span>, variable has type List[int])</span><br></pre></td></tr></table></figure>


<p>现在又新增<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="noopener">给变量添加注释</a>语法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> typing <span class="keyword">import</span> List  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>primes: List[int] = []  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__annotations__  </span><br><span class="line">&#123;<span class="string">'primes'</span>: typing.List[int]&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Underscores-in-Numeric-Literals"><a href="#Underscores-in-Numeric-Literals" class="headerlink" title="Underscores in Numeric Literals"></a>Underscores in Numeric Literals</h3><p>新增<a href="https://www.python.org/dev/peps/pep-0515/" target="_blank" rel="noopener">数字变量使用下划线</a>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;:_&#125;'</span>.format(<span class="number">1000000</span>)  </span><br><span class="line"><span class="string">'1_000_000'</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span>_000_000<span class="number">.0</span>  </span><br><span class="line"><span class="number">10000000.0</span></span><br></pre></td></tr></table></figure>


<h3 id="新模块secrets"><a href="#新模块secrets" class="headerlink" title="新模块secrets"></a>新模块secrets</h3><p>用来以简化使用于管理密码，比如账号认证，令牌等的密码的随机数的生成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> secrets  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'https://mydomain.com/reset='</span> + secrets.token_urlsafe()  </span><br><span class="line"><span class="string">'https://mydomain.com/reset=3-dr2ZQLSDO1lOOgEG4Pd518iwNS-FuNNTptzYdI7VA'</span></span><br></pre></td></tr></table></figure>


<h3 id="重新实现了dict。"><a href="#重新实现了dict。" class="headerlink" title="重新实现了dict。"></a>重新实现了dict。</h3><p>之前的大量实验证实，Python 3一直比较慢，这也是我一直观望的原因。目前看，Python<br>2.7还是最快的Python解释器。官方一直致力于速度的提升，所以 Python 3.4 &lt; Python 3.5 &lt; Python 3.6。<br>所以，3.6中参考PyPy重新实现了字典dict，使其更加紧凑。此次重新实现的dict比Python3.5中的字典内存使用减少了20%-25%。<br>PS: 看目前正在开发的3.7, 也会有一些显著的改善。</p>
<h3 id="定制类的创建使用新协议进行了简化"><a href="#定制类的创建使用新协议进行了简化" class="headerlink" title="定制类的创建使用新协议进行了简化"></a>定制类的创建使用新协议进行了简化</h3><p><a href="https://www.python.org/dev/peps/pep-0487/" target="_blank" rel="noopener">Simpler customisation of class<br>creation</a>提供了一种可以在不使用元类的情况下自定义子类的方法。每当创建一个新的子类时，新的<strong>init_subclass</strong>类方法会被调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">PluginBase</span>:</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   subclasses = []  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass__</span><span class="params">(cls, **kwargs)</span>:</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>       super().__init_subclass__(**kwargs)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>       cls.subclasses.append(cls)  </span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Plugin1</span><span class="params">(PluginBase)</span>:</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="keyword">pass</span>  </span><br><span class="line">      </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Plugin2</span><span class="params">(PluginBase)</span>:</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="keyword">pass</span>  </span><br><span class="line">      </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PluginBase.subclasses  </span><br><span class="line">[__main__.Plugin1, __main__.Plugin2]</span><br></pre></td></tr></table></figure>


<p>这样让自定义类的变得更简单了。</p>
<h3 id="描述符协议增强"><a href="#描述符协议增强" class="headerlink" title="描述符协议增强"></a>描述符协议增强</h3><p>描述符是一个具有绑定行为的对象属性，由于它的优先级高会改变一个属性的基本的获取、设置和删除方式，我们先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span>  </span><br><span class="line">       <span class="keyword">return</span> instance.__dict__[self.name]  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Negative value not allowed'</span>)  </span><br><span class="line">        instance.__dict__[self.name] = value  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    score = Integer(<span class="string">'score'</span>)  </span><br><span class="line">    amount = Integer(<span class="string">'amount'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">movie = Movie()  </span><br><span class="line">movie.score = <span class="number">9</span>  </span><br><span class="line">print(movie.score)</span><br></pre></td></tr></table></figure>


<p>相当于把score和amount这个2个属性都绑定上Integer的对象上了，结果会是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 movie.py</span><br></pre></td></tr></table></figure>


<p>上面的用法有个问题，就是初始化的时候都明确让属性的值绑定在Integer上的name属性上，而无法获知所有者类的属性名。使用在<a href="https://www.python.org/dev/peps/pep-0487/" target="_blank" rel="noopener">PEP487</a>上提供的可选的<strong>set_name</strong>()可以获得这个属性名字，并且可以自定义这部分内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span>  </span><br><span class="line">       <span class="keyword">return</span> instance.__dict__[self.name]  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Negative value not allowed'</span>)  </span><br><span class="line">        instance.__dict__[self.name] = value  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set_name__</span><span class="params">(self, owner, name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    score = Integer()  </span><br><span class="line">    amount = Integer()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">movie = Movie()  </span><br><span class="line">movie.score = <span class="number">9</span>  </span><br><span class="line">print(movie.score)</span><br></pre></td></tr></table></figure>


<h3 id="Preserving-Class-Attribute-Definition-Order"><a href="#Preserving-Class-Attribute-Definition-Order" class="headerlink" title="Preserving Class Attribute Definition Order"></a>Preserving Class Attribute Definition Order</h3><p>我们知道Python 2中dict是不能保存键值顺序的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python2  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d  </span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>


<p>现在则会<a href="https://www.python.org/dev/peps/pep-0520" target="_blank" rel="noopener">保存类属性定义顺序</a>。也就是按照源码中属性名出现的顺序存储在<strong>\dict</strong><br>的属性中。<br>而且我发现dict的实现也保留了顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3  </span><br><span class="line">Python <span class="number">3.6</span><span class="number">.0</span> (default, Dec <span class="number">24</span> <span class="number">2016</span>, <span class="number">00</span>:<span class="number">01</span>:<span class="number">50</span>)  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d  </span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;  </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>


<p>看来OrderdDict要失业了~</p>
<h3 id="Preserving-Keyword-Argument-Order"><a href="#Preserving-Keyword-Argument-Order" class="headerlink" title="Preserving Keyword Argument Order"></a>Preserving Keyword Argument Order</h3><p>现在也会<a href="https://www.python.org/dev/peps/pep-0468" target="_blank" rel="noopener">保存关键字参数顺序</a>了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(**kw)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>    print(kw)  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)  </span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>


<h3 id="asyncio可用于生产环境"><a href="#asyncio可用于生产环境" class="headerlink" title="asyncio可用于生产环境"></a>asyncio可用于生产环境</h3><p>asyncio模板添加了很多新的功能、重要的可用性、性能改进以及大量的bug，现在asyncio模块的API已经很稳定，可用于生产环境了。其中：</p>
<ol>
<li>有了一个更快的asyncio.Future的C的实现。</li>
<li>有了一个更快的asyncio.Task的C的实现。<br>使用这2个实现可以让效率提高15%左右。而使用第三方的uvloop还能让速度提升5%-10%。<h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3></li>
<li>在正则表达式中，增加对spans修饰符的支持。示例: ‘(?i:p)ython’ 匹配 ‘python’ 和 ‘Python’, 但不匹配 ‘PYTHON’； ‘(?i)g(?-i:v)r’ 匹配 ‘GvR’ 和 ‘gvr’, 但不匹配 ‘GVR’。</li>
<li>匹配对象组可通过<strong>getitem</strong>访问, 它就等价于 group()。因此， 现在mo[‘name’] 就等价于 mo.group(‘name’)。</li>
<li>Match对象支持index-like对象一样的组索引。<h3 id="glob优化"><a href="#glob优化" class="headerlink" title="glob优化"></a>glob优化</h3>通过os.scandir对glob模块中的glob()及iglob()进行优化，使得它们现在大概快了3-6倍。😔<br>唉，我当时咋没想到呢。有兴趣的可以看<a href="https://bugs.python.org/issue25596" target="_blank" rel="noopener">Issue<br>25596</a>。如果你正常也有这种目录扫描的需求，请参看实现。<h3 id="pickle优化"><a href="#pickle优化" class="headerlink" title="pickle优化"></a>pickle优化</h3>当对大量小对象进行反序列化时，pickle.load()和pickle.loads()的速度可提高10%。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>speakerdeck</title>
    <url>/2016-03-16.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>今天是在Ad的最后一天,本来准备了一个分享.关于业务中一些吐槽和我一些trick的用法,<br>有兴趣的可以下载<a href="https://github.com/dongweiming/speakerdeck" target="_blank" rel="noopener">speakerdeck</a></p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><ol>
<li>celery celery2/celery3, py-amqp, kombu的用法, celery和djangocelery的集合</li>
<li>expect 使用expect自动登录复杂的服务器</li>
<li>mapreduce 一个并行处理文件的例子,说明使用python跑mapreduce多么厉害</li>
<li>portforward 端口转发</li>
<li>restapi 我眼中的restapi(pdf)</li>
<li>tornado 使用tornado一部非阻塞<br>演示的tmux脚本:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash  </span></span><br><span class="line">SESSION=$USER  </span><br><span class="line">COMMAND=<span class="string">'http Space http://localhost:8000/sleep'</span>  </span><br><span class="line">  </span><br><span class="line">tmux new-session -d -s $SESSION  </span><br><span class="line">  </span><br><span class="line">tmux new-window -t $SESSION -n <span class="string">'Logs'</span>  </span><br><span class="line">tmux split-window -h  </span><br><span class="line">tmux select-pane -t <span class="number">0</span>  </span><br><span class="line">tmux send-keys $COMMAND C-m  </span><br><span class="line">tmux select-pane -t <span class="number">1</span>  </span><br><span class="line">tmux send-keys $COMMAND C-m  </span><br><span class="line">tmux split-window -v  </span><br><span class="line">tmux send-keys $COMMAND C-m  </span><br><span class="line">tmux select-pane -t <span class="number">0</span>  </span><br><span class="line">tmux split-window -v  </span><br><span class="line">tmux send-keys $COMMAND C-m  </span><br><span class="line"><span class="comment"># Attach to session  </span></span><br><span class="line">tmux attach-session -t $SESSION</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移octpress,Rakefile修改以及豆瓣推荐,豆瓣收藏秀,新浪微博分享按钮等实现</title>
    <url>/2016-03-13.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h4><p>首先感谢吴钊的<a href="http://www.neoease.com/inove" target="_blank" rel="noopener">inove</a>,从博客建立就一直用它,昨天就开始研究迁移成octopress,以下是一些经验和总结<br>####1. octopress目录结构说明<br>#####首先看git出来的octopress目录结构:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├─ config.rb  <span class="comment">#指定额外的compass插件  </span></span><br><span class="line">├─ config.ru    </span><br><span class="line">├─ Rakefile   <span class="comment">#rake的配置文件,类似于makefile,这个我修改了一些内容  </span></span><br><span class="line">├─ Gemfile    <span class="comment">#bundle要下载需要的gem依赖关系的指定文件  </span></span><br><span class="line">├─ Gemfile.lock  <span class="comment">#这些gem依赖的对应关系,比如A的x本依赖于B的y版本,我也修改了  </span></span><br><span class="line">├─ _config.yml  <span class="comment">#站点的配置文件  </span></span><br><span class="line">├─ public/  <span class="comment">#在静态编译完成后的目录,网站只需要这个目录下的文件树  </span></span><br><span class="line">├─ _deploy/  <span class="comment">#deploy时候生成的缓存文件夹,和public目录一样  </span></span><br><span class="line">├─ sass/  <span class="comment">#css文件的源文件,过程中会compass成css  </span></span><br><span class="line">├─ plugins/  <span class="comment">#放置自带以及第三方插件的目录,ruby程序  </span></span><br><span class="line">│  └── xxx.rb  </span><br><span class="line">└─ source/  <span class="comment">#这个是站点的源文件目录,public目录就是根据这个目录下数据生成的  </span></span><br><span class="line">   └─ _includes/  </span><br><span class="line">      └─ custom/  <span class="comment">#自定义的模板目录,被相应上级html include  </span></span><br><span class="line">         └─ asides/  <span class="comment">#边栏模板自定义模板目录  </span></span><br><span class="line">      └─ asides/  <span class="comment">#边栏模板目录  </span></span><br><span class="line">      └─ post/  <span class="comment">#文章页面相应模板目录  </span></span><br><span class="line">   └─ _layouts/  <span class="comment">#默认网站html相关文件,最底层  </span></span><br><span class="line">   └─ _posts/  <span class="comment">#新增以及从其它程序迁移过来的数据都存在这里  </span></span><br><span class="line">   └─ stylesheets/ <span class="comment">#css文件目录  </span></span><br><span class="line">   └─ javascripts/  <span class="comment">#js文件目录</span></span><br></pre></td></tr></table></figure>


<h5 id="我根据需要对它的修改"><a href="#我根据需要对它的修改" class="headerlink" title="我根据需要对它的修改"></a><em>我根据需要对它的修改</em></h5><pre><code>1. Rakefile的修改</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  editor = <span class="string">"~/Sublime/sublime_text"</span> <span class="comment">#设置编辑器  </span></span><br><span class="line">  open(filename, <span class="string">'w'</span>) do |post|  </span><br><span class="line">    post.puts <span class="string">"---"</span>  </span><br><span class="line">    post.puts <span class="string">"layout: post"</span>  </span><br><span class="line">    post.puts <span class="string">"title: \"#&#123;title.gsub(/&amp;/,'&amp;amp;')&#125;\""</span>  </span><br><span class="line">    post.puts <span class="string">"date: #&#123;Time.now.strftime('%Y-%m-%d %H:%M')&#125;"</span>  </span><br><span class="line">    post.puts <span class="string">"comments: true"</span>  </span><br><span class="line">    post.puts <span class="string">"categories: "</span>  </span><br><span class="line">    post.puts <span class="string">"---"</span>  </span><br><span class="line">    system <span class="string">"sleep 1; #&#123;editor&#125; #&#123;filename&#125;"</span>  <span class="comment">#增加这行,表示使用new_post后自动用我上面open设置的编辑器打开这个文件  </span></span><br><span class="line">  end  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  task :generate do  </span><br><span class="line">  raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)  </span><br><span class="line">  puts <span class="string">"## Generating Site with Jekyll"</span>  </span><br><span class="line">  system <span class="string">"compass compile --css-dir #&#123;source_dir&#125;/stylesheets"</span>  </span><br><span class="line">  system <span class="string">"jekyll"</span>  </span><br><span class="line">  cp_r <span class="string">"#&#123;source_dir&#125;/.htaccess"</span>, <span class="string">"#&#123;public_dir&#125;"</span> <span class="comment">#因为我的事wordpress迁移过来,其中图片目录需要重定向,所以使用.htaccess,但是默认不会自动拷贝  </span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<pre><code>2. 一个问题:在我使用默认的pygments.rb对python高亮编码出现这个报错:</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  /Could <span class="keyword">not</span> open library <span class="string">'lib.so'</span>: lib.so: cannot open shared object file: No such file <span class="keyword">or</span> directory (LoadError)  </span><br><span class="line">修改Gemfile.lock:  </span><br><span class="line">rubypython (<span class="number">0.6</span><span class="number">.1</span>)  <span class="comment">#从0.5.3修改掉  </span></span><br><span class="line">      blankslate (&gt;= <span class="number">2.1</span><span class="number">.2</span><span class="number">.3</span>)  </span><br><span class="line">      ffi (~&gt; <span class="number">1.0</span><span class="number">.7</span>)  </span><br><span class="line">gem uninstall rubypython  </span><br><span class="line">gem install rubypython --version <span class="number">0.6</span><span class="number">.1</span>  </span><br><span class="line">gem install pygments.rb</span><br></pre></td></tr></table></figure>


<p>####2. 从wordpress主题inove迁移到octopress<br>#####这里我只说一些我的思路,其它的具体步骤请参看其它文章,我这里假设你有linux shell</p>
<pre><code>1.迁移网站文章</code></pre><p>因为涉及中文,我用的是<a href="https://gist.github.com/1394128" target="_blank" rel="noopener">wordpressdotcom.rb</a>,然后我把我的网站程序导出,使用自带的xml方式,生成一个文件,把它重命名为:wordpress.xml放在当前目录,然后执行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dongwm@dongwm ~/octopress $ ruby -r <span class="string">'./wordpressdotcom.rb'</span> -e <span class="string">'Jekyll::WordpressDotCom.process'</span> <span class="comment">#wordpressdotcom.rb文件路径要正确</span></span><br></pre></td></tr></table></figure>


<p>这样就会在source/_post下生成你的文章内容,都是html文件类型</p>
<pre><code>2. 对这些文章文件修改</code></pre><p>PS:因为wordpress都是使用插件支持高亮,并且p,pre很泛滥,比如我这里用过的高亮方式:  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;p&gt;[codesyntax lang=<span class="string">"python"</span>]  </span><br><span class="line">CODE</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[cceW_bash width=”<span class="number">99</span>%” height=”<span class="number">100</span>%”]CODE  </span><br><span class="line">[/cceW_bash]</span><br></pre></td></tr></table></figure>


<p>而我在octopress使用的是<a href="shjs.sourceforge.net">SHJS</a>,它的语法是:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;pre class="sh_python"&gt;&lt;/pre&gt; #其中X语言就是sh_X</span><br></pre></td></tr></table></figure>


<p>因为我有自己的独特性 我使用了如下shell程序完成修改,大家可以参照</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/&lt;\/pre&gt;//g'</span> &#123;&#125; \;  <span class="comment">#去掉&lt;/pre&gt;  </span></span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/&lt;pre&gt;//g'</span> &#123;&#125; \; <span class="comment">#去掉&lt;pre&gt;  </span></span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/\[\/codesyntax\]/&lt;\/pre&gt;/g'</span> &#123;&#125; \;  <span class="comment">#把原来的修改成SHJS的&lt;/pre&gt;  </span></span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/\[\/cceW_bash\]/&lt;\/pre&gt;/g'</span> &#123;&#125; \; <span class="comment">#把原来的修改成SHJS的&lt;/pre&gt;  </span></span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/\[cceW_\(.*\) width=\"99\%\" height=\"100\%\"\]/&lt;pre class=\"sh_\1\"&gt;/g'</span> &#123;&#125; \;  <span class="comment">#根据原来的原来类型修改成SHJS的相应类型  </span></span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/\[codesyntax lang=\"\(.*\)\"\]/&lt;pre class=\"sh_\1\"&gt;/g'</span> &#123;&#125; \;  </span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'/---/&#123;x;s/^/./;/^\.\&#123;2\&#125;$/&#123;x;s/.*/indexer: true\n---/;x&#125;;x;&#125;'</span> &#123;&#125; \;  </span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/&lt;\/br&gt;//g'</span> &#123;&#125; \;  <span class="comment">#去掉相关&lt;br&gt;  </span></span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/&lt;br&gt;//g'</span> &#123;&#125; \;  </span><br><span class="line">dongwm@dongwm ~/octopress $ find source/_posts -name <span class="string">"*.html"</span> -<span class="keyword">exec</span> sed -i <span class="string">'s/&lt;br \/&gt;//g'</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>



<pre><code>3. 去掉twitter相关显示</code></pre><p>因为我使用SHJS,需要在页面加载完毕后显示效果,但是因为’墙’造成其一直加载,所以只能在相关页面去掉:<br>修改_config.yml</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Twitter  </span></span><br><span class="line">twitter_user: dongweiming  </span><br><span class="line">twitter_tweet_count: <span class="number">4</span>  </span><br><span class="line">twitter_show_replies: false  </span><br><span class="line">twitter_follow_button: false <span class="comment">#变成  </span></span><br><span class="line">twitter_show_follower_count: false  </span><br><span class="line">twitter_tweet_button: false <span class="comment">#变成</span></span><br></pre></td></tr></table></figure>


<p>修改source/_includes/post/sharing.html 去掉twitter那一段判断</p>
<pre><code>4. 修改head.html</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget http://shjs.sourceforge.net/css/sh_ide-anjuta.css  </span><br><span class="line">mv sh_ide-anjuta.css source/stylesheets/  </span><br><span class="line">wget http://shjs.sourceforge.net/sh_main.min.js  </span><br><span class="line">wget http://shjs.sourceforge.net/lang/sh_python.min.js  </span><br><span class="line">mv sh_python.min.js source/javascripts/  </span><br><span class="line">mv sh_main.min.js source/javascripts/  </span><br><span class="line">wget http://blog.neten.de//javascripts/jimdoclockzip.js</span><br></pre></td></tr></table></figure>


<p>修改原始页面增加加载后显示高亮,source/_layouts/default.html</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% capture root_url %&#125;&#123;&#123; site.root | strip_slash &#125;&#125;&#123;% endcapture %&#125;  </span><br><span class="line">&#123;% include head.html %&#125;  </span><br><span class="line">&lt;body &#123;% if page.body_id %&#125; id="&#123;&#123; page.body_id &#125;&#125;" &#123;% endif %&#125; &#123;% if page.sidebar == false %&#125; class="no-sidebar" &#123;% endif %&#125; &#123;% if page.sidebar == 'collapse' or site.sidebar == 'collapse' %&#125; class="collapse-sidebar sidebar-footer" &#123;% endif %&#125; onload="sh_highlightDocument('', '.js');"&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script type="text/javascript" src="/javascripts/jimdoclockzip.js"&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script type="text/javascript" src="/javascripts/sh_python.min.js"&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script type="text/javascript" src="/javascripts/sh_main.min.js"&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script type="text/javascript" src="/javascripts/sh_bash.min.js"&gt;&lt;/script&gt;  </span><br><span class="line">&lt;link href=<span class="string">"/stylesheets/sh_ide-anjuta.css"</span> rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span>&gt;</span><br></pre></td></tr></table></figure>


<p>其中包含了SHJS需要的js以及高亮显示的css,以及一个我网站的小玩笑-一个爱跑的时钟</p>
<pre><code>5. 增加分类标签云




git clone &lt;https://github.com/alswl/octopress-category-list&gt;  </code></pre><p>相应的请看README  </p>
<p>6. 增加导航栏<br>默认的就是blog和archives,请看我修改后的source/_includes/custom/navigation.html  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;ul class="nav"&gt;  </span><br><span class="line">  &lt;li&gt;&lt;a href="&#123;&#123; root_url &#125;&#125;/"&gt;博客主页&lt;/a&gt;&lt;/li&gt;  </span><br><span class="line">  &lt;li&gt;&lt;a href="&#123;&#123; root_url &#125;&#125;/blog/archives"&gt;文章列表&lt;/a&gt;&lt;/li&gt;  </span><br><span class="line">  &lt;li&gt;&lt;a href="&#123;&#123; root_url &#125;&#125;/blog/categories/关于我"&gt;关于&lt;/a&gt;&lt;/li&gt;  </span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>



<p>PS:迁移后,网站结构变了,路径根据_config.yml设置修改,以下是我的根目录下的.htaccess:  </p>
<pre><code>RewriteEngine On  

RewriteBase /  
RewriteRule “^wp-content/uploads/(.*)” &lt;http://www.dongwm.com/uploads/$1&gt; [R=301,L,NC]  #主要自定义上传图片的路径  



7. 侧边栏显示豆瓣收藏,我自己弄了个页面:</code></pre><p><a href="https://github.com/dongweiming/octopress-douban_favorite_show" target="_blank" rel="noopener">https://github.com/dongweiming/octopress-douban_favorite_show</a></p>
<pre><code>8. 微博分享和豆瓣推荐</code></pre><p>我对于前端也不熟.这里主要是定位iframe,放一个html文件,html文件包含相应的显示图标和js点击链接按钮<br>以下是我的source/_includes/post/sharing.html</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &lt;div class="sharing"&gt;  </span><br><span class="line">  &#123;% <span class="keyword">if</span> site.weibo_share %&#125;  </span><br><span class="line">  &lt;span&gt;  </span><br><span class="line">  &lt;iframe  </span><br><span class="line">    width=<span class="string">"55"</span>  </span><br><span class="line">    scrolling=<span class="string">"no"</span>  </span><br><span class="line">    height=<span class="string">"66"</span>  </span><br><span class="line">    frameborder=<span class="string">"0"</span>  </span><br><span class="line">    src=  </span><br><span class="line">      <span class="string">"http://hits.sinajs.cn/A1/weiboshare.html?url=&#123;&#123; site.url &#125;&#125;&#123;&#123; page.url &#125;&#125;&amp;amp;appkey=site.weiboapp&amp;amp;type=1&amp;amp;&#123;% if site.weibo_uid %&#125;ralateUid=&#123;&#123; site.weibo_uid &#125;&#125;&amp;amp;&#123;% endif %&#125;language=zh_cn"</span> allowtransparency=<span class="string">"true"</span>&gt;  </span><br><span class="line">  &lt;/iframe&gt;  </span><br><span class="line">  &#123;% endif %&#125;  </span><br><span class="line">  &#123;% <span class="keyword">if</span> site.douban_user %&#125;  </span><br><span class="line">  &lt;iframe  </span><br><span class="line">    width=<span class="string">"55"</span>  </span><br><span class="line">    scrolling=<span class="string">"no"</span>  </span><br><span class="line">    height=<span class="string">"74"</span>  </span><br><span class="line">    frameborder=<span class="string">"0"</span>  </span><br><span class="line">    src=<span class="string">"/douban.html"</span>&gt;  </span><br><span class="line">  &lt;/iframe&gt;  </span><br><span class="line">  &lt;/span&gt;   </span><br><span class="line">  &#123;% endif %&#125;  </span><br><span class="line">  &#123;% <span class="keyword">if</span> site.google_plus_one %&#125;  </span><br><span class="line">  &lt;div class="g-plusone" data-size="&#123;&#123; site.google_plus_one_size &#125;&#125;"&gt;&lt;/div&gt;  </span><br><span class="line">  &#123;% endif %&#125;  </span><br><span class="line">  &#123;% <span class="keyword">if</span> site.facebook_like %&#125;  </span><br><span class="line">    &lt;div class="fb-like" data-send="true" data-width="450" data-show-faces="false"&gt;&lt;/div&gt;  </span><br><span class="line">  &#123;% endif %&#125;  </span><br><span class="line">&lt;/div&gt;  </span><br><span class="line">  &lt;hr style=<span class="string">"border-bottom:1px dotted #bdbabd;height:1px;border-top:0px;border-left:0px;border-right:0px;"</span> /&gt;</span><br></pre></td></tr></table></figure>


<p>其中douban.html:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a href="javascript:void(function()&#123;var d=document,e=encodeURIComponent,s1=window.getSelection,s2=d.getSelection,s3=d.selection,s=s1?s1():s2?s2():s3?s3.createRange().text:'',r='http://www.douban.com/recommend/?url='+e(d.location.href)+'&amp;title='+e(d.title)+'&amp;sel='+e(s)+'&amp;v=1',x=function()&#123;if(!window.open(r,'douban','toolbar=0,resizable=1,scrollbars=yes,status=1,width=450,height=330'))location.href=r+'&amp;r=1'&#125;;if(/Firefox/.test(navigator.userAgent))&#123;setTimeout(x,0)&#125;else&#123;x()&#125;&#125;)()" &gt;&lt;img src="/douban.png" width=35 height=35 alt="推荐到豆瓣" /&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<pre><code>9. 我的_config.yml文件:




# ———————– #  
#      Main Configs       #  
# ———————– #  


url: &lt;http://www.dongwm.com&gt;  
title: 小明明s à domicile  
subtitle: 沉浸于linux艺术（首先是态度，然后再是技术）  
author: Dongweiming  
simple_search: &lt;http://google.com/search&gt;  
description:  

# Default date format is “ordinal” (resulting in “July 22nd 2007”)  
# You can customize the format as defined in  
# &lt;http://www.ruby-doc.org/core-1.9.2/Time.html#method-i-strftime&gt;  
# Additionally, %o will give you the ordinal representation of the day  
date_format: “ordinal”  

# RSS / Email (optional) subscription links (change if using something like Feedburner)  
subscribe_rss: /atom.xml  
subscribe_email:  
# RSS feeds can list your email address if you like  
email:  

# ———————– #  
#    Jekyll &amp; Plugins     #  
# ———————– #  

# If publishing to a subdirectory as in &lt;http://site.com/project&gt; set ‘root: /project’  
root: /  
permalink: /archives/:title/  
source: source  
destination: public  
plugins: plugins  
code_dir: downloads/code  
category_dir: blog/categories  
category_title_prefix: “分类: “  
markdown: rdiscount  
pygments: True # default python pygments have been replaced by pygments.rb  

paginate: 10          # Posts per page on the blog index  
pagination_dir:  # Directory base for pagination URLs eg. /blog/page/2/  
recent_posts: 5       # Posts in the sidebar Recent Posts section  
excerpt_link: “继续阅读 →”  # “Continue reading” link text at the bottom of excerpted articles  

titlecase: true       # Converts page and post titles to titlecase  

default_asides: [asides/recent_posts.html,  asides/github.html, asides/delicious.html, asides/pinboard.html, asides/googleplus.html,custom/asides/category_cloud.html, custom/asides/douban.html, asides/article_total_sidebar.html]  

page_asides: [custom/asides/indexer.html]  
article_total: true  
article_total_title: 文章统计  
article_my_site_has: 本站共有  
article_my_site_article : 篇文章  
article_total_sidebar: true  

# ———————– #  
#   3rd Party Settings    #  
# ———————– #  

#QQ  
qq_share: true  

#Douban  
douban_user: 62943420  
douban_people: 小明明  
douban_apikey: 0ec15d10bdd1901a2c4417323974b04e  
douban_show:  #dolist,wishlist,collection  
douban_display_category: book|music #’’(book music blog movie) format: movie|book|music  
douban_display: random #favorite and ‘’(new add)  
douban_total_show: 10  
douban_percolumn: 2  
douban_img_style: medium #’’(small)  
douban_hidelogo: true #’’(false)  
douban_hideself:  true #’’(false)  

# Weibo  
weibo_uid: 1994497175  
weibo_verifier: abd54ad9  
weibokey: 2642268232  
weibo_fansline: 0  
weibo_show: true  
weibo_pic: true  
weibo_skin: 10  
weibo_share: true  

# Github repositories  
github_user: dongweiming  
github_repo_count: 0  
github_show_profile_link: true  
github_skip_forks: true  

# Twitter  
twitter_user: dongweiming  
twitter_tweet_count: 4  
twitter_show_replies: false  
twitter_follow_button: false  
twitter_show_follower_count: false  
twitter_tweet_button: false  




10. 我下一步的想法:</code></pre><p>时间太短,没来得及做一些工作,节后我准备</p>
<pre><code>- 写个第三方分类插件bootstrap-theme
- 写个第三方相关分享按钮的插件
- 写个第三方相关登录的插件
- 研究bootstrap-theme,对其进行一些修改和更新</code></pre><p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>用python跑mapreduce</title>
    <url>/2016-03-20.html</url>
    <content><![CDATA[<p>####前言<br>mapreduce在我的理解里一直都是java等语言的专利,介于python乃至于pypy的性能局限，<br>一直没想过用python写分布式任务,最多就是多workers从消息队列取任务执行这样,但是最近一件事真的颠覆<br>了我对python的认识.<br>####先说说起因<br>某天分享[sed和awk](<a href="http://www.dongwm.com/archives/sed-and-" target="_blank" rel="noopener">http://www.dongwm.com/archives/sed-and-</a><br>awk/),领导突发奇想让我用一些顾问的实际工作需要去我们的大量数据里面获取想要的数据的需求作为一些演示的例子.其中有这样一个需求(我去掉实际一些专业晦涩的用语,用实际的内容来表达):</p>
<h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> 有大量的gz压缩文件, 找到其中某<span class="number">2</span>天的数据, 每一行都是一条实际数据  </span><br><span class="line"><span class="number">2.</span> 需要解压缩每个文件,遍历每行找到用逗号隔开的第<span class="number">21</span>列为<span class="number">16233</span>,第<span class="number">23</span>列为<span class="number">27188</span>的行. 以第<span class="number">2</span>列为键计算符合的数量  </span><br><span class="line"><span class="number">3.</span> 在全部统计结果里面根据值计算符合的键的数量: 比如&#123;<span class="string">'a'</span>:<span class="number">2</span>, <span class="string">'b'</span>:<span class="number">1</span>, <span class="string">'c'</span>:<span class="number">1</span>&#125;,结果就是&#123;<span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">1</span>&#125;,也就是<span class="number">2</span>次的有<span class="number">2</span>个,<span class="number">1</span>次的只有一个</span><br></pre></td></tr></table></figure>


<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>一上来真的想用awk来搞.但是和其他同事一聊,有几个难点:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="number">2</span>天数据总量在<span class="number">400</span>G以上,用awk还要保留<span class="number">2</span>次哈希结果-不可能用awk  </span><br><span class="line"><span class="number">2.</span> 用python,据同事经验说:只是解压缩这些小文件后读取什么都不做也大概<span class="number">1</span>天多的时间,完全不能忍  </span><br><span class="line"><span class="number">3.</span> 数据还没有放到hadoop, 没有其他更好更快的方法</span><br></pre></td></tr></table></figure>


<p>#####解题思路:</p>
<ol>
<li>最初我想做成这样:<ol>
<li>把需要处理的这些压缩文件放到队列里面</li>
<li>启动多进程出队列里面获取要处理的文件,执行,把符合的结果放到共享变量叠加</li>
<li>计算完成后从共享变量里面或者数据在生成上面第三条的结果<br>但是今天讲的是python得mapreduce,也就是我后续的版本,它源于伟大的Doug Hellmann的<a href="http://pymotw.com/2/multiprocessing/mapreduce.html" target="_blank" rel="noopener">Implementing MapReduce<br>with multiprocessing</a></li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="comment">#coding=utf-8  </span></span><br><span class="line"><span class="comment"># python mapreduce 跑数实现  </span></span><br><span class="line"><span class="comment"># Author: Dongweiming  </span></span><br><span class="line"><span class="keyword">import</span> gzip  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> glob  </span><br><span class="line"><span class="keyword">import</span> collections  </span><br><span class="line"><span class="keyword">import</span> itertools  </span><br><span class="line"><span class="keyword">import</span> operator  </span><br><span class="line"><span class="keyword">import</span> multiprocessing  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdMapReduce</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, map_func, reduce_func, num_workers=None)</span>:</span>  </span><br><span class="line">        <span class="string">'''  </span></span><br><span class="line"><span class="string">        num_workers: 不指定就是默认可用cpu的核数  </span></span><br><span class="line"><span class="string">        map_func: map函数: 要求返回格式类似:[(a, 1), (b, 3)]  </span></span><br><span class="line"><span class="string">        reduce_func: reduce函数: 要求返回格式类似: (c, 10)  </span></span><br><span class="line"><span class="string">        '''</span>  </span><br><span class="line">        self.map_func = map_func  </span><br><span class="line">        self.reduce_func = reduce_func  </span><br><span class="line">        self.pool = multiprocessing.Pool(num_workers)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, mapped_values)</span>:</span>  </span><br><span class="line">        partitioned_data = collections.defaultdict(list)  </span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapped_values:  </span><br><span class="line">            partitioned_data[key].append(value)  </span><br><span class="line">        <span class="keyword">return</span> partitioned_data.items()  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, inputs, chunksize=<span class="number">1</span>)</span>:</span>  </span><br><span class="line">        <span class="string">'''调用类的时候被触发'''</span>  </span><br><span class="line">        <span class="comment"># 其实都是借用multiprocessing.Pool.map这个函数, inputs是一个需要处理的列表,想想map函数  </span></span><br><span class="line">        <span class="comment"># chunksize表示每次给mapper的量, 这个根据需求调整效率  </span></span><br><span class="line">        map_responses = self.pool.map(self.map_func, inputs, chunksize=chunksize)  </span><br><span class="line">        <span class="comment"># itertools.chain是把mapper的结果链接起来为一个可迭代的对象  </span></span><br><span class="line">        partitioned_data = self.partition(itertools.chain(*map_responses))  </span><br><span class="line">        <span class="comment"># 大家想,上面的就是[(a, [1,2]), (b, [2,3]),列表中的数就是当时符合的次数,reduce就是吧列表符合项sum  </span></span><br><span class="line">        reduced_values = self.pool.map(self.reduce_func, partitioned_data)  </span><br><span class="line">        <span class="keyword">return</span> reduced_values  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapper_match</span><span class="params">(one_file)</span>:</span>  </span><br><span class="line">    <span class="string">'''第一次的map函数,从每个文件里面获取符合的条目'''</span>  </span><br><span class="line">    output = []  </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> gzip.open(one_file).readlines():  </span><br><span class="line">        l = line.rstrip().split(<span class="string">','</span>)  </span><br><span class="line">        <span class="keyword">if</span> int(l[<span class="number">20</span>]) == <span class="number">16309</span> <span class="keyword">and</span> int(l[<span class="number">22</span>]) == <span class="number">2656</span>:  </span><br><span class="line">            cookie = l[<span class="number">1</span>]  </span><br><span class="line">            output.append((cookie, <span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">return</span> output  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce_match</span><span class="params">(item)</span>:</span>  </span><br><span class="line">    <span class="string">'''第一次的reduce函数,给相同的key做统计'''</span>  </span><br><span class="line">    cookie, occurances = item  </span><br><span class="line">    <span class="keyword">return</span> (cookie, sum(occurances))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapper_count</span><span class="params">(item)</span>:</span>  </span><br><span class="line">    <span class="string">'''第二次mapper函数,其实就是把某key的总数做键,但是值标1'''</span>  </span><br><span class="line">    _, count = item  </span><br><span class="line">    <span class="keyword">return</span> [(count, <span class="number">1</span>)]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce_count</span><span class="params">(item)</span>:</span>  </span><br><span class="line">    <span class="string">'''第二次reduce函数'''</span>  </span><br><span class="line">    freq, occurances = item  </span><br><span class="line">    <span class="keyword">return</span> (freq, sum(occurances))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    start = time.time()  </span><br><span class="line">    input_files = glob.glob(<span class="string">'/datacenter/input/2013-12-1[01]/*'</span>)  </span><br><span class="line">    mapper = AdMapReduce(mapper_match, reduce_match)  </span><br><span class="line">    cookie_feq = mapper(input_files)  </span><br><span class="line">    mapper = AdMapReduce(mapper_count, reduce_count)  </span><br><span class="line">    cookie_feq = mapper(cookie_feq)  </span><br><span class="line">    cookie_feq.sort(key=operator.itemgetter(<span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">for</span> freq, count <span class="keyword">in</span> cookie_feq:  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'&#123;0&#125;\t&#123;1&#125;\t&#123;2&#125;'</span>.format(freq, count, freq*count)  </span><br><span class="line">    <span class="comment">#cookie_feq.reverse()  </span></span><br><span class="line">    end = time.time()  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'cost:'</span>, end - start</span><br></pre></td></tr></table></figure>


<h4 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h4><p>哇,看python做mapreduce也是可以这样优雅的, 我是用pypy跑下来,竟然只有了61分钟….<br>但是其实他只是借助mapreduce思想和多核的硬件基础,其实pool做的还是文件级别的处理.假如是少量的大文件,就未必有这样好的效果了.<br>我想很多时候这样的工作都可以交给这个Admapreduce类来做</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>gevent-twisted-多线程谁更快?</title>
    <url>/2016-03-19.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h4><p>标题有点唬人，以前了解过研究gevent，twisted，scrapy（基于twisted）。最近有个想法：这些东西比如做爬虫，谁的效率更好呢？<br>我就写了以下程序（附件）测试然后用timeit（跑3次，每次10遍，时间有限）看效果<br>####原理：</p>
<ol>
<li>为了防止远程网络的问题，从一个网站爬下网页代码（html），页面下载本地放在了我的本机（gentoo+apache）</li>
<li>然后爬虫去分析这些页面上面的链接（开始是主页），再挖掘其他页面，抓取页面关键字（我这里就是个‘py’）<br>程序打包<a href="http://www.dongwm.com/Crawler.tar.bz2" target="_blank" rel="noopener">Crawler.tar.bz2</a><br>先看代码树：</li>
</ol>
<pre><code>dongwm@localhost ~ $ tree Crawler/  
Crawler/  
├── common_Crawler.py  #标准爬虫，里面只是多线程编程，抓取分析类在common.py  
├── common.py  #共用函数，里面只是抓取页面分析页面关键字  
├── common.pyc #你懂得  
├── Crawler #scrapy和django框架差不多的用法  
│   ├── **init**.py  
 │   ├── **init**.pyc  
 │   ├── items.py #不需要利用，默认  
│   ├── pipelines.py  
│   ├── settings.py  
│   ├── settings.pyc  
│   └── spiders #抓取脚本文件夹  
│       ├── **init**.py  
 │       ├── **init**.pyc  
 │       ├── spiders.py #我做的分析页面，这个和多线程/gevent调用的抓取分析类不同，我使用了内置方法（大家可以修改共用函数改成scrapy的方式，这样三种效果就更准确了）  
│       └── spiders.pyc  
├── gevent_Crawler.py #gevent版本爬虫，效果和标准版一样，抓取分析类也是common.py 保证其他环节相同，只是一个多线程，一个用协程  
├── scrapy.cfg  
└── scrapy_Crawler.py #因为scrapy使用是命令行，我用subproess封装了命令，然后使用timeit计算效果  

2 directories, 16 files  </code></pre><p>####实验前准备：<br>停掉我本机使用的耗费资源的进程 firefox，vmware，compiz等，直到负载保持一个相对拨波动平衡<br>####测试程序：</p>
<ol>
<li>common.py </li>
</ol>
<pre><code>#!/usr/bin/python  
#coding=utf-8  

# Version 1 by Dongwm 2013/01/10  
# 脚本作用：多线程抓取  
# 方式： lxml + xpath + requests  

import requests  
from  cStringIO import StringIO  
from lxml import etree  

class Crawler(object):  

    def **init** (self, app):  
        self.deep = 2  #指定网页的抓取深度  
        self.url = ‘’ #指定网站地址  
        self.key = ‘by’ #搜索这个词  
        self.tp = app #连接池回调实例  
        self.visitedUrl = [] #抓取的网页放入列表,防止重复抓取  

    def _hasCrawler(self, url):  
        ‘’’判断是否已经抓取过这个页面’’’  
        return (True if url in self.visitedUrl else False)  

    def getPageSource(self, url, key, deep):  
        ‘’’ 抓取页面,分析,入库.  
        ‘’’  
        if self._hasCrawler(url): #发现重复直接return  
            return  
        else:  
            self.visitedUrl.append(url) #发现新地址假如到这个列  
        r = requests.get(‘&lt;http://localhost/%s&apos;&gt; % url)  
        encoding = r.encoding #判断页面的编码  
        result = r.text.encode(‘utf-8’).decode(encoding)  
        #f = StringIO(r.text.encode(‘utf-8’))  
        try:  
            self._xpath(url, result, [‘a’], unicode(key, ‘utf8’), deep) #分析页面中的连接地址,以及它的内容  
            self._xpath(url, result, [‘title’, ‘p’, ‘li’, ‘div’], unicode(key, “utf8”), deep) #分析这几个标签的内容  
        except TypeError: #对编码类型异常处理,有些深度页面和主页的编码不同  
            self._xpath(url, result, [‘a’], key, deep)  
            self._xpath(url, result, [‘title’, ‘p’, ‘li’, ‘div’], key, deep)  
        return True  

    def _xpath(self, weburl, data, xpath, key, deep):  
        page = etree.HTML(data)  
        for i in xpath:  
            hrefs = page.xpath(u”//%s” % i) #根据xpath标签  
            if deep &gt;1:  
                for href in hrefs:  
                    url = href.attrib.get(‘href’,’’)  
                    if not url.startswith(‘java’) and not url.startswith(‘#’) and not \  
                        url.startswith(‘mailto’) and url.endswith(‘html’):  #过滤javascript和发送邮件的链接  
                            self.tp.add_job(self.getPageSource,url, key, deep-1) #递归调用,直到符合的深  
            for href in hrefs:  
                value = href.text  #抓取相应标签的内容  
                if value:  
                    m = re.compile(r’. _%s._ ‘ % key).match(value) #根据key匹配相应内容  

    def work(self):  
        self.tp.add_job(self.getPageSource, self.url, self.key, self.deep)  
        self.tp.wait_for_complete() #等待线程池完成  </code></pre><ol start="2">
<li>common_Crawler.py</li>
</ol>
<pre><code>#!/usr/bin/python  
#coding=utf-8  

# Version 1 by Dongwm 2013/01/10  
# 脚本作用：多线程  



import time  
import threading  
import Queue  
from common import Crawler  

#lock = threading.Lock()   #设置线程锁  


class MyThread(threading.Thread):  

    def **init** (self, workQueue, timeout=1, * _kwargs):  
        threading.Thread. **init** (self, kwargs=kwargs)  
        self.timeout = timeout #线程在结束前等待任务队列多长时间  
        self.setDaemon(True)  #设置deamon,表示主线程死掉,子线程不跟随死掉  
        self.workQueue = workQueue  
        self.start() #初始化直接启动线程  

    def run(self):  
        ‘’’重载run方法’’’  
        while True:  
            try:  
                #lock.acquire() #线程安全上锁 PS:queue 实现就是线程安全的，没有必要上锁 ,否者可以put/get_nowait  
                callable, args = self.workQueue.get(timeout=self.timeout) #从工作队列中获取一个任务  
                res = callable(_args)  #执行的任务  
                #lock.release()  #执行完,释放锁  
            except Queue.Empty: #任务队列空的时候结束此线程  
                break  
            except Exception, e:  
                return -1  


class ThreadPool(object):  

    def **init** (self, num_of_threads):  
         self.workQueue = Queue.Queue()  
         self.threads = []  
         self. **createThreadPool(num_of_threads)  

    def ** createThreadPool(self, num_of_threads):  
        for i in range(num_of_threads):  
             thread = MyThread(self.workQueue)  
             self.threads.append(thread)  

    def wait_for_complete(self):  
        ‘’’等待所有线程完成’’’  
        while len(self.threads):  
            thread = self.threads.pop()  
            if thread.isAlive():  #判断线程是否还存活来决定是否调用join  
                thread.join()  

    def add_job( self, callable, *args):  
        ‘’’增加任务,放到队列里面’’’  
        self.workQueue.put((callable, args))  
def main():  

    tp = ThreadPool(10)  
    crawler = Crawler(tp)  
    crawler.work()  

if **name** == ‘ **main** ‘:  

    import timeit  
    t = timeit.Timer(“main()”)  
    t.repeat(3, 10)  </code></pre><ol start="3">
<li>gevent_Crawler.py</li>
</ol>
<pre><code>#!/usr/bin/python  
#coding=utf-8  

# Version 1 by Dongwm 2013/01/10  
# 脚本作用：gevent  

import gevent.monkey  
gevent.monkey.patch_all()  
from gevent.queue import Empty, Queue  
import gevent  
from common import Crawler  

class GeventLine(object):  

    def **init** (self, workQueue, timeout=1, * _kwargs):  
        self.timeout = timeout #线程在结束前等待任务队列多长时间  
        self.workQueue = workQueue  

    def run(self):  
        ‘’’重载run方法’’’  
        while True:  
            try:  
                callable, args = self.workQueue.get(timeout=self.timeout) #从工作队列中获取一个任务  
                res = callable(_ args)  #执行的任务  
                print res  
            except Empty:  
                break  
            except Exception, e:  
                print e  
                return -1  

class GeventPool(object):  

    def **init** (self, num_of_threads):  
             self.workQueue = Queue()  
             self.threads = []  
             self. **createThreadPool(num_of_threads)  

    def ** createThreadPool(self, num_of_threads):  
        for i in range(num_of_threads):  
             thread = GeventLine(self.workQueue)  
             self.threads.append(gevent.spawn(thread.run))  


    def wait_for_complete(self):  
        ‘’’等待所有线程完成’’’  

        while len(self.threads):  
            thread = self.threads.pop()  
            thread.join()  
        gevent.shutdown()  

    def add_job( self, callable, *args):  
        ‘’’增加任务,放到队列里面’’’  
        self.workQueue.put((callable, args))  

def main():  
    tp = GeventPool(10)  
    crawler = Crawler(tp)  
    crawler.work()  

if **name** == ‘ **main** ‘:  

    import timeit  
    t = timeit.Timer(“main()”)  
    t.repeat(3, 10)  </code></pre><ol start="4">
<li>Crawler/spiders/spiders.py</li>
</ol>
<pre><code>from scrapy.contrib.spiders import CrawlSpider, Rule  
from scrapy.selector import HtmlXPathSelector  
from scrapy.contrib.linkextractors.sgml import SgmlLinkExtractor  
from scrapy.item import Item  

class MySpider(CrawlSpider):  
    name = ‘localhost’  
    allowed_domains = [‘localhost’]  
    start_urls = [‘&lt;http://localhost&apos;]&gt;  
    rules = (  
        Rule(SgmlLinkExtractor(allow=(r’&lt;http://localhost/.*&apos;))&gt;, callback=”parse_item”),  
    )  
    def parse_item(self, response):  
        hxs = HtmlXPathSelector(response)  
        hxs.select(‘// _[@_ ]/text()’).re(r’py’)  #实现了common.py里面的抓取和分析，但是common.py是抓取五种标签，分2次抓取，这里是抓取所有标签，不够严禁  </code></pre><ol start="5">
<li>scrapy_Crawler.py #时间有限，没有研究模块调用，也不够严禁</li>
</ol>
<pre><code>#!/usr/bin/python  
#coding=utf-8  

# Version 1 by Dongwm 2013/01/10  
# 脚本作用：scrapy  

from subprocess import call  

def main():  
    call(‘scrapy crawl localhost –nolog’, shell=True)  

if **name** == ‘ **main** ‘:  

    import timeit  
    t = timeit.Timer(“main()”)  
    t.repeat(3, 10)  </code></pre><p>####实验过程<br>#####1. 同时启动三个终端，一起跑（手点回车，肯定有点延迟）</p>
<pre><code>dongwm@localhost ~/Crawler $ python scrapy_Crawler.py  
10000000 loops, best of 3: 0.024 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0223 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0223 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0223 usec per loop  
10000000 loops, best of 3: 0.0222 usec per loop  
10000000 loops, best of 3: 0.0223 usec per loop #他是最快跑完的，非常快～～  数据很稳定  

dongwm@localhost ~/Crawler $ python gevent_Crawler.py  
100000000 loops, best of 3: 0.0134 usec per loop  
100000000 loops, best of 3: 0.0131 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0134 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0133 usec per loop  
100000000 loops, best of 3: 0.0133 usec per loop  
100000000 loops, best of 3: 0.0133 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0133 usec per loop  
100000000 loops, best of 3: 0.0132 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0123 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0123 usec per loop  #跑得很慢，不知道是不是timeit的原因(或者调用的优先级太低，抢资源能力不行)，很奇怪，但是它的数据最快，数据稳定在0.0123-0.0133  


dongwm@localhost ~/Crawler $ python common_Crawler.py  
100000000 loops, best of 3: 0.0274 usec per loop  
10000000 loops, best of 3: 0.0245 usec per loop  
10000000 loops, best of 3: 0.0252 usec per loop  
10000000 loops, best of 3: 0.0239 usec per loop  
10000000 loops, best of 3: 0.025 usec per loop  
10000000 loops, best of 3: 0.0273 usec per loop  
10000000 loops, best of 3: 0.0255 usec per loop  
10000000 loops, best of 3: 0.0261 usec per loop  
10000000 loops, best of 3: 0.0275 usec per loop  
10000000 loops, best of 3: 0.0261 usec per loop  
10000000 loops, best of 3: 0.0257 usec per loop  
10000000 loops, best of 3: 0.0273 usec per loop  
10000000 loops, best of 3: 0.0241 usec per loop  
10000000 loops, best of 3: 0.0257 usec per loop  
10000000 loops, best of 3: 0.0275 usec per loop  
10000000 loops, best of 3: 0.0241 usec per loop  
10000000 loops, best of 3: 0.0259 usec per loop  
10000000 loops, best of 3: 0.0251 usec per loop  
10000000 loops, best of 3: 0.0193 usec per loop  
10000000 loops, best of 3: 0.0176 usec per loop  
100000000 loops, best of 3: 0.0199 usec per loop  
100000000 loops, best of 3: 0.0167 usec per loop  
100000000 loops, best of 3: 0.018 usec per loop  
10000000 loops, best of 3: 0.0179 usec per loop  
100000000 loops, best of 3: 0.0173 usec per loop  
100000000 loops, best of 3: 0.0172 usec per loop  
100000000 loops, best of 3: 0.018 usec per loop  
100000000 loops, best of 3: 0.0162 usec per loop  
100000000 loops, best of 3: 0.0179 usec per loop  
100000000 loops, best of 3: 0.0171 usec per loop  #第二跑得快，但是还是数据不稳定，时间在0.017-0.026之间  </code></pre><p>#####2. 挨个启动，待负载保持一个相对拨波动平衡 在换另一个  </p>
<pre><code>dongwm@localhost ~/Crawler $ python scrapy_Crawler.py  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0122 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0123 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0123 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0122 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0123 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0122 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0122 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop   #数据很稳定，在0.0122-0.0126之间 机器负载在1.3左右,最高超过了1.4（闲暇0.6左右）  




dongwm@localhost ~/Crawler $ python gevent_Crawler.py  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0126 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  
100000000 loops, best of 3: 0.0125 usec per loop  
100000000 loops, best of 3: 0.0124 usec per loop  #数据很稳定，在0.0124-0.0126之间 机器负载在1.2左右（闲暇0.6左右）  




dongwm@localhost ~/Crawler $ python common_Crawler.py  
10000000 loops, best of 3: 0.0135 usec per loop  
100000000 loops, best of 3: 0.0185 usec per loop  
10000000 loops, best of 3: 0.0174 usec per loop  
100000000 loops, best of 3: 0.019 usec per loop  
10000000 loops, best of 3: 0.016 usec per loop  
10000000 loops, best of 3: 0.0181 usec per loop  
10000000 loops, best of 3: 0.0146 usec per loop  
100000000 loops, best of 3: 0.0192 usec per loop  
10000000 loops, best of 3: 0.0165 usec per loop  
10000000 loops, best of 3: 0.0176 usec per loop  
10000000 loops, best of 3: 0.0177 usec per loop  
10000000 loops, best of 3: 0.0182 usec per loop  
100000000 loops, best of 3: 0.0195 usec per loop  
10000000 loops, best of 3: 0.0163 usec per loop  
10000000 loops, best of 3: 0.0161 usec per loop  
100000000 loops, best of 3: 0.0191 usec per loop  
100000000 loops, best of 3: 0.0193 usec per loop  
10000000 loops, best of 3: 0.0147 usec per loop  
100000000 loops, best of 3: 0.0197 usec per loop  
10000000 loops, best of 3: 0.0178 usec per loop  
10000000 loops, best of 3: 0.0172 usec per loop  
100000000 loops, best of 3: 0.022 usec per loop  
100000000 loops, best of 3: 0.0191 usec per loop  
10000000 loops, best of 3: 0.0208 usec per loop  
10000000 loops, best of 3: 0.0144 usec per loop  
10000000 loops, best of 3: 0.0201 usec per loop  
100000000 loops, best of 3: 0.0195 usec per loop  
100000000 loops, best of 3: 0.0231 usec per loop  
10000000 loops, best of 3: 0.0149 usec per loop  
100000000 loops, best of 3: 0.0211 usec per loop #数据有点不稳定，浮动较大，但是最要在0.016-0.019  机器负载曾经长时间在1.01,最高未超过1.1 （闲暇0.6左右）  </code></pre><p>####一些我的看法<br>虽然我的实验有不够严禁的地方，我的代码能力也有限（希望有朋友看见代码能提供修改意见或更NB的版本），但是效果还是比较明显的，我总结下</p>
<ol>
<li>gevent确实性能很好，并且很稳定，占用io一般(据说长时间使用有内存泄露的问题？我不理解)</li>
<li>scrapy这个框架把爬虫封装的很好，只需要最少的代码就能实现，性能也不差gevent</li>
<li>多线程编程确实有瓶颈，并且不稳定</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>grep,ack,ag的搜索效率对比</title>
    <url>/2016-03-12.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我经常看到很多程序员, 运维在代码搜索上使用ack, 甚至ag(the_silver_searcher<br>), 而我工作中95%都是用grep,剩下的是ag. 我觉得很有必要聊一聊这个话题.<br>我以前也是一个运维, 我当时也希望找到最好的最快的工具用在工作的方方面面. 但是我很好奇为什么ag和ack没有作为linux发行版的内置部分.<br>内置的一直是grep. 我当初的理解是受各种开源协议的限制, 或者发行版的boss个人喜好. 后来我就做了实验, 研究了下他们到底谁快.<br>当时的做法也无非跑几个真实地线上log看看用时. 然后我也有了我的一个认识: 大部分时候用grep也无妨, 日志很大的时候用ag.<br>ack原来的域名是betterthangrep.com, 现在是beyondgrep.com. 好吧. 其实我理解使用ack的同学,<br>也理解ack产生的原因. 这里就有个故事.<br>最开始我做运维使用shell, 经常做一些分析日志的工作. 那时候经常写比较复杂的shell代码实现一些特定的需求. 后来来了一位会perl的同学.<br>原来我写shell做一个事情, 写了20多行shell代码, 跑一次大概5分钟, 这位同学来了用perl改写, 4行, 一分钟就能跑完. 亮瞎我们的眼,<br>从那时候开始, 我就觉得需要学perl,以至于后来的python.<br>perl是天生用来文本解析的语言, ack的效率确实很高. 我想着可能是大家认为ack要更快更合适的理由吧. 其实这件事要看场景.<br>我为什么还用比较’土’的grep呢? 看一下这篇文章, 希望给大家点启示</p>
<h4 id="实验条件"><a href="#实验条件" class="headerlink" title="实验条件"></a>实验条件</h4><p>PS: 严重声明, 本实验经个人实践, 我尽量做到合理. 大家看完觉得有异议可以试着其他的角度来做. 并和我讨论.</p>
<ul>
<li>我使用了公司的一台开发机(gentoo)</li>
<li>我测试了纯英文和汉语2种， 汉语使用了<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">结巴分词</a>的字典, 英语使用了<code>miscfiles</code>中提供的词典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 假如你是ubuntu: sudo apt-get install miscfiles  </span></span><br><span class="line">wget https://raw.githubusercontent.com/fxsjy/jieba/master/extra_dict/dict.txt.big</span><br></pre></td></tr></table></figure>


<h4 id="实验前的准备"><a href="#实验前的准备" class="headerlink" title="实验前的准备"></a>实验前的准备</h4><p>我会分成英语和汉语2种文件, 文件大小为1MB, 10MB, 100MB, 500MB, 1GB, 5GB.<br>没有更多是我觉得在实际业务里面不会单个日志文件过大的. 也就没有必要测试了(就算有, 可以看下面结果的趋势)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cat make_words.py  </span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> cStringIO <span class="keyword">import</span> StringIO  </span><br><span class="line">  </span><br><span class="line">EN_WORD_FILE = <span class="string">'/usr/share/dict/words'</span>  </span><br><span class="line">CN_WORD_FILE = <span class="string">'dict.txt.big'</span>  </span><br><span class="line"><span class="keyword">with</span> open(EN_WORD_FILE) <span class="keyword">as</span> f:  </span><br><span class="line">    EN_DATA = f.readlines()  </span><br><span class="line"><span class="keyword">with</span> open(CN_WORD_FILE) <span class="keyword">as</span> f:  </span><br><span class="line">    CN_DATA = f.readlines()  </span><br><span class="line">MB = pow(<span class="number">1024</span>, <span class="number">2</span>)  </span><br><span class="line">SIZE_LIST = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">1024</span>, <span class="number">1024</span> * <span class="number">5</span>]  </span><br><span class="line">EN_RESULT_FORMAT = <span class="string">'text_&#123;0&#125;_en_MB.txt'</span>  </span><br><span class="line">CN_RESULT_FORMAT = <span class="string">'text_&#123;0&#125;_cn_MB.txt'</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_data</span><span class="params">(f, size, data, cn=False)</span>:</span>  </span><br><span class="line">    total_size = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        s = StringIO()  </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000</span>):  </span><br><span class="line">            cho = random.choice(data)  </span><br><span class="line">            cho = cho.split()[<span class="number">0</span>] <span class="keyword">if</span> cn <span class="keyword">else</span> cho.strip()  </span><br><span class="line">            s.write(cho)  </span><br><span class="line">        s.seek(<span class="number">0</span>, os.SEEK_END)  </span><br><span class="line">        total_size += s.tell()  </span><br><span class="line">        contents = s.getvalue()  </span><br><span class="line">        f.write(contents + <span class="string">'\n'</span>)  </span><br><span class="line">        <span class="keyword">if</span> total_size &gt; size:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    f.close()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> index, size <span class="keyword">in</span> enumerate([  </span><br><span class="line">        MB,  </span><br><span class="line">        MB * <span class="number">10</span>,  </span><br><span class="line">        MB * <span class="number">100</span>,  </span><br><span class="line">        MB * <span class="number">500</span>,  </span><br><span class="line">        MB * <span class="number">1024</span>,  </span><br><span class="line">        MB * <span class="number">1024</span> * <span class="number">5</span>]):  </span><br><span class="line">    size_name = SIZE_LIST[index]  </span><br><span class="line">    en_f = open(EN_RESULT_FORMAT.format(size_name), <span class="string">'a+'</span>)  </span><br><span class="line">    cn_f = open(CN_RESULT_FORMAT.format(size_name), <span class="string">'a+'</span>)  </span><br><span class="line">    write_data(en_f, size, EN_DATA)  </span><br><span class="line">    write_data(cn_f, size, CN_DATA, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p>好吧, 效率比较低是吧? 我自己没有vps, 公司服务器我不能没事把全部内核的cpu都占满(不是运维好几年了). 假如你不介意htop的多核cpu飘红,<br>可以这样，耗时就是各文件生成的时间短板:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment"># coding=utf-8  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">import</span> multiprocessing  </span><br><span class="line"><span class="keyword">from</span> cStringIO <span class="keyword">import</span> StringIO  </span><br><span class="line">  </span><br><span class="line">EN_WORD_FILE = <span class="string">'/usr/share/dict/words'</span>  </span><br><span class="line">CN_WORD_FILE = <span class="string">'dict.txt.big'</span>  </span><br><span class="line"><span class="keyword">with</span> open(EN_WORD_FILE) <span class="keyword">as</span> f:  </span><br><span class="line">    EN_DATA = f.readlines()  </span><br><span class="line"><span class="keyword">with</span> open(CN_WORD_FILE) <span class="keyword">as</span> f:  </span><br><span class="line">    CN_DATA = f.readlines()  </span><br><span class="line">MB = pow(<span class="number">1024</span>, <span class="number">2</span>)  </span><br><span class="line">SIZE_LIST = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">1024</span>, <span class="number">1024</span> * <span class="number">5</span>]  </span><br><span class="line">EN_RESULT_FORMAT = <span class="string">'text_&#123;0&#125;_en_MB.txt'</span>  </span><br><span class="line">CN_RESULT_FORMAT = <span class="string">'text_&#123;0&#125;_cn_MB.txt'</span>  </span><br><span class="line">  </span><br><span class="line">inputs = []  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_func</span><span class="params">(args)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_data</span><span class="params">(f, size, data, cn=False)</span>:</span>  </span><br><span class="line">        f = open(f, <span class="string">'a+'</span>)  </span><br><span class="line">        total_size = <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">            s = StringIO()  </span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000</span>):  </span><br><span class="line">                cho = random.choice(data)  </span><br><span class="line">                cho = cho.split()[<span class="number">0</span>] <span class="keyword">if</span> cn <span class="keyword">else</span> cho.strip()  </span><br><span class="line">                s.write(cho)  </span><br><span class="line">            s.seek(<span class="number">0</span>, os.SEEK_END)  </span><br><span class="line">            total_size += s.tell()  </span><br><span class="line">            contents = s.getvalue()  </span><br><span class="line">            f.write(contents + <span class="string">'\n'</span>)  </span><br><span class="line">            <span class="keyword">if</span> total_size &gt; size:  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">        f.close()  </span><br><span class="line">  </span><br><span class="line">    _f, size, data, cn = args  </span><br><span class="line">    write_data(_f, size, data, cn)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> index, size <span class="keyword">in</span> enumerate([  </span><br><span class="line">        MB,  </span><br><span class="line">        MB * <span class="number">10</span>,  </span><br><span class="line">        MB * <span class="number">100</span>,  </span><br><span class="line">        MB * <span class="number">500</span>,  </span><br><span class="line">        MB * <span class="number">1024</span>,  </span><br><span class="line">        MB * <span class="number">1024</span> * <span class="number">5</span>]):  </span><br><span class="line">    size_name = SIZE_LIST[index]  </span><br><span class="line">    inputs.append((EN_RESULT_FORMAT.format(size_name), size, EN_DATA, <span class="literal">False</span>))  </span><br><span class="line">    inputs.append((CN_RESULT_FORMAT.format(size_name), size, CN_DATA, <span class="literal">True</span>))  </span><br><span class="line">  </span><br><span class="line">pool = multiprocessing.Pool()  </span><br><span class="line">pool.map(map_func, inputs, chunksize=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<p>等待一段时间后,目录下是这样的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ls -lh  </span><br><span class="line">total <span class="number">14</span>G  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">2.2</span>K Mar <span class="number">14</span> <span class="number">05</span>:<span class="number">25</span> benchmarks.ipynb  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">8.2</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">43</span> dict.txt.big  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">1.2</span>K Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">46</span> make_words.py  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">101</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">47</span> text_100_cn_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">101</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">47</span> text_100_en_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">1.1</span>G Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">54</span> text_1024_cn_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">1.1</span>G Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">51</span> text_1024_en_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant  <span class="number">11</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">47</span> text_10_cn_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant  <span class="number">11</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">47</span> text_10_en_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">1.1</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">47</span> text_1_cn_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">1.1</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">47</span> text_1_en_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">501</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">49</span> text_500_cn_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">501</span>M Mar <span class="number">12</span> <span class="number">15</span>:<span class="number">48</span> text_500_en_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">5.1</span>G Mar <span class="number">12</span> <span class="number">16</span>:<span class="number">16</span> text_5120_cn_MB.txt  </span><br><span class="line">-rw-rw-r-- <span class="number">1</span> vagrant vagrant <span class="number">5.1</span>G Mar <span class="number">12</span> <span class="number">16</span>:<span class="number">04</span> text_5120_en_MB.txt</span><br></pre></td></tr></table></figure>


<h4 id="确认版本"><a href="#确认版本" class="headerlink" title="确认版本"></a>确认版本</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">➜  test  ack --version <span class="comment"># ack在ubuntu下叫`ack-grep`  </span></span><br><span class="line">ack <span class="number">2.12</span>  </span><br><span class="line">Running under Perl <span class="number">5.16</span><span class="number">.3</span> at /usr/bin/perl  </span><br><span class="line">  </span><br><span class="line">Copyright <span class="number">2005</span><span class="number">-2013</span> Andy Lester.  </span><br><span class="line">  </span><br><span class="line">This program <span class="keyword">is</span> free software.  You may modify <span class="keyword">or</span> distribute it  </span><br><span class="line">under the terms of the Artistic License v2<span class="number">.0</span>.  </span><br><span class="line">➜  test  ag --version  </span><br><span class="line">ag version <span class="number">0.21</span><span class="number">.0</span>  </span><br><span class="line">➜  test  grep --version  </span><br><span class="line">grep (GNU grep) <span class="number">2.14</span>  </span><br><span class="line">Copyright (C) <span class="number">2012</span> Free Software Foundation, Inc.  </span><br><span class="line">License GPLv3+: GNU GPL version <span class="number">3</span> <span class="keyword">or</span> later &lt;http://gnu.org/licenses/gpl.html&gt;.  </span><br><span class="line">This <span class="keyword">is</span> free software: you are free to change <span class="keyword">and</span> redistribute it.  </span><br><span class="line">There <span class="keyword">is</span> NO WARRANTY, to the extent permitted by law.  </span><br><span class="line">  </span><br><span class="line">Written by Mike Haertel <span class="keyword">and</span> others, see &lt;http://git.sv.gnu.org/cgit/grep.git/tree/AUTHORS&gt;.</span><br></pre></td></tr></table></figure>


<h4 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h4><p>为了不产生并行执行的相互响应, 我还是选择了效率很差的同步执行, 我使用了ipython提供的%timeit. 上代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"><span class="keyword">import</span> glob  </span><br><span class="line"><span class="keyword">import</span> subprocess  </span><br><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle  </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  </span><br><span class="line">  </span><br><span class="line">IMAP = &#123;  </span><br><span class="line">    <span class="string">'cn'</span>: (<span class="string">'豆瓣'</span>, <span class="string">'小明明'</span>),  </span><br><span class="line">    <span class="string">'en'</span>: (<span class="string">'four'</span>, <span class="string">'python'</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">OPTIONS = (<span class="string">''</span>, <span class="string">'-i'</span>, <span class="string">'-v'</span>)  </span><br><span class="line">FILES = glob.glob(<span class="string">'text_*_MB.txt'</span>)  </span><br><span class="line">EN_RES = defaultdict(dict)  </span><br><span class="line">CN_RES = defaultdict(dict)  </span><br><span class="line">RES = &#123;  </span><br><span class="line">        <span class="string">'en'</span>: EN_RES,  </span><br><span class="line">        <span class="string">'cn'</span>: CN_RES  </span><br><span class="line">&#125;  </span><br><span class="line">REGEX = re.compile(<span class="string">r'text_(\d+)_(\w+)_MB.txt'</span>)  </span><br><span class="line">CALL_STR = <span class="string">'&#123;command&#125; &#123;option&#125; &#123;word&#125; &#123;filename&#125; &gt; /dev/null 2&gt;&amp;1'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> FILES:  </span><br><span class="line">    size, xn = REGEX.search(filename).groups()  </span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> IMAP[xn]:  </span><br><span class="line">        _r = defaultdict(dict)  </span><br><span class="line">        <span class="keyword">for</span> command <span class="keyword">in</span> [<span class="string">'grep'</span>, <span class="string">'ack'</span>, <span class="string">'ag'</span>]:  </span><br><span class="line">            <span class="keyword">for</span> option <span class="keyword">in</span> OPTIONS:  </span><br><span class="line">                rs = %timeit -o -n10 subprocess.call(CALL_STR.format(command=command, option=option, word=word, filename=filename), shell=<span class="literal">True</span>)  </span><br><span class="line">                best = rs.best  </span><br><span class="line">                _r[command][option] = best  </span><br><span class="line">        RES[xn][word][size] = _r  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 存起来  </span></span><br><span class="line">  </span><br><span class="line">data = pickle.dumps(RES)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'result.db'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    f.write(data)</span><br></pre></td></tr></table></figure>


<p>温馨提示, 这是一个灰常耗时的测试. 开始执行后 要喝很久的茶…<br>我来秦皇岛办事完毕(耗时超过1一天), 继续我们的实验.</p>
<h4 id="我想要的效果"><a href="#我想要的效果" class="headerlink" title="我想要的效果"></a>我想要的效果</h4><p>我想工作的时候一般都是用到不带参数/带-i(忽略大小写)/-v(查找不匹配项)这三种. 所以这里测试了:</p>
<ol>
<li>英文搜索/中文搜索</li>
<li>选择了2个搜索词(效率太低, 否则可能选择多个)</li>
<li>分别测试’’/‘-i’/‘-v’三种参数的执行</li>
<li>使用%timeit, 每种条件执行10遍, 选择效率最好的一次的结果</li>
<li><strong>每个图代码一个搜索词, 3搜索命令, 一个选项在搜索不同大小文件时的效率对比</strong><h4 id="多图预警-我先说结论"><a href="#多图预警-我先说结论" class="headerlink" title="多图预警, 我先说结论"></a>多图预警, 我先说结论</h4></li>
<li><strong>在搜索的总数据量较小的情况下, 使用grep, ack甚至ag在感官上区别不大</strong></li>
<li><strong>搜索的总数据量较大时, grep效率下滑的很多, 完全不要选</strong></li>
<li><strong>ack在某些场景下没有grep效果高(比如使用-v索索中文的时候)</strong></li>
<li><strong>在不使用ag没有实现的选项功能的前提下, ag完全可以替代ack/grep</strong><br>渲染图片的gist可以看这里<a href="http://nbviewer.ipython.org/gist/dongweiming/6732731444b1e2687c47/benchmarks.ipynb" target="_blank" rel="noopener">benchmarks.ipynb</a>.<br>他的数据来自上面跑的结果在序列化之后存入的文件<h4 id="附图-共12张"><a href="#附图-共12张" class="headerlink" title="附图(共12张)"></a>附图(共12张)</h4><img src="https://cloud.githubusercontent.com/assets/841395/6660016/8326d7b0-cbcb-11e4-8f2a-cfa5fe27c810.png" alt="chart"><br>![chart-1](<a href="https://cloud.githubusercontent.com/assets/841395/6660017/832c12ac-" target="_blank" rel="noopener">https://cloud.githubusercontent.com/assets/841395/6660017/832c12ac-</a><br>cbcb-11e4-9295-cfdd6d421423.png)<br><img src="https://cloud.githubusercontent.com/assets/841395/6660018/832c3034-cbcb-11e4-9a2c-5604bf2bb0c6.png" alt="chart-2"><br><img src="https://cloud.githubusercontent.com/assets/841395/6660019/832df4a0-cbcb-11e4-8d75-538ad527cb4f.png" alt="chart-3"><br><img src="https://cloud.githubusercontent.com/assets/841395/6660020/833372d6-cbcb-11e4-8b96-54ae9ae68f57.png" alt="chart-4"><br><img src="https://cloud.githubusercontent.com/assets/841395/6660021/8335c04a-cbcb-11e4-8401-0c54aa4eb783.png" alt="chart-5"><br><img src="https://cloud.githubusercontent.com/assets/841395/6660022/8362bf96-cbcb-11e4-9ec5-94686e603e3a.png" alt="chart-6"><br><img src="https://cloud.githubusercontent.com/assets/841395/6690232/488e9af4-ccfa-11e4-8a1f-1fa3667dd74f.png" alt="chart-7"><br><img src="https://cloud.githubusercontent.com/assets/841395/6660024/836b307c-cbcb-11e4-942d-8a395a28984f.png" alt="chart-8"><br><img src="https://cloud.githubusercontent.com/assets/841395/6660025/836f4f5e-cbcb-11e4-8807-d6f561018254.png" alt="chart-9"><br>![chart-10](<a href="https://cloud.githubusercontent.com/assets/841395/6660043/fbd42cee-" target="_blank" rel="noopener">https://cloud.githubusercontent.com/assets/841395/6660043/fbd42cee-</a><br>cbcb-11e4-9c1d-b2237194db90.png)<br><img src="https://cloud.githubusercontent.com/assets/841395/6660044/fc5424f8-cbcb-11e4-9bf0-1666cd467239.png" alt="chart-11"></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>不可错过的Python技术博客（网站）</title>
    <url>/2016-03-22.html</url>
    <content><![CDATA[<p>在日常的工作和学习的过程中，会积累一些好的技术资源，也会把一些准备学习和深入的技术文章放进浏览器书签，不知道大家什么感觉，我的书签内容是越积越多 ㄟ( ▔,<br>▔ )ㄏ。其实一段时间后有些会失去兴趣，有些已经掌握，有些确实看过了但是忘记从书签中删掉或者挪走，所以我有一个习惯，就是每过一段时间会清理一次。<br>熟悉我的人都知道我对于学习的观点是：</p>
<ol>
<li>先看书，了解语法和语言的基本理论</li>
<li>写代码去实践</li>
<li>看博客吸收别人的观点<br>看博客文章，应该看如下三类的内容：</li>
<li>实际工作中的实践和经验</li>
<li>Python使用经验和技巧</li>
<li>对Python实现的分析和理解</li>
<li>介绍先进的思想、框架、库甚至生态<br>我岔个题，看再多的爬虫代码和文章对学好Python益处很有限，甚至有害。<br>从我使用Python写程序开始，看一些博客网站已经算是我每周甚至每天必做的一件事了，从这些资源里面获得的经验和收获实在太多了。<br>今天一狠心清理了一些国外Python开发者的博客资源。想起来在知乎和微信公众号中有很多同学问过我平时关注那些博客或者技术来源，虽然我在知乎回答过一些问题，不过都没有本文吐血整理的资源多且全面。<h3 id="曾经看过"><a href="#曾经看过" class="headerlink" title="曾经看过"></a>曾经看过</h3>那些曾经看过现在不再看的博客，原因主要是2点：</li>
<li>随着我对Python语言越来越熟悉，经验越来越丰富，我不再是它的受众了。不过对于很多同学来说，这些博客依然非常有意义，比国内一些微信公众号和技术博客的野鸡文章强的太多了，我经常感慨幸好我当时学习的环境比现在纯粹和踏实。</li>
<li>博主已经不再更新了，之前的内容也都看过，重复看没收获。不再更新确实很遗憾😔，真希望他们继续更新。<br>回到正题，开始列啦：</li>
<li><a href="https://www.pydanny.com/category/python.html" target="_blank" rel="noopener">www.pydanny.com</a>。博主是《Two Scoops of Django》的作者，我在Twitter上关注最早的开发者之一（我的Twitter被盗了，现在不玩了）。博客里面很多Python技巧，另外在Django方面作者贡献了非常多的内容和开源项目。</li>
<li><a href="https://www.saltycrane.com/blog/" target="_blank" rel="noopener">www.saltycrane.com/blog/</a>。可以说是看着这个博客在成长，以前对Python不熟的时候经常Google用法就跳到它的文章上，然后借鉴一下下。</li>
<li><a href="https://alexgaynor.net" target="_blank" rel="noopener">https://alexgaynor.net</a>。它的博客更多的是一些开发的感想和观点，印象最深的是有篇代码review的文章，其中引用了这么一段话：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="number">10</span> lines of code = <span class="number">10</span> issues.  </span><br><span class="line">  </span><br><span class="line"><span class="number">500</span> lines of code = <span class="string">"looks fine."</span>  </span><br><span class="line">  </span><br><span class="line">Code reviews.</span><br></pre></td></tr></table></figure>


<p>😝<br>  4. <a href="http://techspot.zzzeek.org/" target="_blank" rel="noopener">techspot.zzzeek.org/</a>。作者创建了SQLAlchemy、Mako、Alembic这些我天天在用的开源项目，它有篇叫做「Asynchronous Python and Databases」讲异步数据库的文章写得非常好，大师级别。<br>  5. <a href="http://jessenoller.com/" target="_blank" rel="noopener">jessenoller.com</a>。Python核心开发，python.org「设计师」，给《Dive into Python 3》和《The Python Standard Library by Example》写序。博客也不怎么直接写Python代码，更多的是Python和架构的设计和心得。有兴趣的可以了解下Python官网的设计者们对重新设计的理解： <a href="http://pythonorg-redesign.readthedocs.io/en/latest/" target="_blank" rel="noopener">http://pythonorg-redesign.readthedocs.io/en/latest/</a> ，这对于大家自己写网站的<br>  6. <a href="http://effbot.org/zone/index.htm" target="_blank" rel="noopener">effbot.org</a>。模块使用方面和PyMOTW比较像，不过还有大量的库使用以及其他经验。我第一次用Python实现缓存就是看它的文章写的。<br>  7. <a href="https://julien.danjou.info" target="_blank" rel="noopener">julien.danjou.info</a>。最早是学习AST翻到的，后来就一直关注了。作者是Debian开发，在Red Hat工作，对OpenStack很熟悉。之前会分享一些Python语言和使用技巧，现在可能走上管理岗位不怎么写代码了。<br>  8. <a href="http://sayspy.blogspot.com/" target="_blank" rel="noopener">sayspy.blogspot.com</a>。很早就不再更新了，可以在里面翻到一些博主对Python的一些理解，很深入和细致，虽然现在看来某些观点我并不是全部赞同，但是对于当时的我也是很有益处的。<br>  9. <a href="https://jeffknupp.com" target="_blank" rel="noopener">jeffknupp.com</a>。最早是由于《Writing Idiomatic Python》这本电子书关注的，博客有一些Python实践的心得，不过现在博主不怎么写了。</p>
<h3 id="依然关注的"><a href="#依然关注的" class="headerlink" title="依然关注的"></a>依然关注的</h3><ol>
<li><a href="http://eli.thegreenplace.net/" target="_blank" rel="noopener">eli.thegreenplace.net</a>。相对于国内那些舔着脸说「全栈」的，这才是一个好的全栈开发者，涉猎极广。它的博客有非常多Python的深入内容</li>
<li><a href="http://planetpython.org" target="_blank" rel="noopener">planetpython.org</a>。我之前在知乎就推荐过，一个Python资讯聚合网站，左侧列了一大片博客链接，其中有很多Python核心开发。</li>
<li><a href="https://dbader.org/blog/" target="_blank" rel="noopener">dbader.org</a>。如博客的副标题，真的非常提高Python能力。有很多国内的开发者写的博客其实明显是看了它的博客受到启发甚至「借鉴」。必读五星！！</li>
<li><a href="https://nedbatchelder.com/blog/" target="_blank" rel="noopener">nedbatchelder.com</a>。同样有非常多的Python技巧，我个人不太喜欢不加代码全文空说的那种，这个博客一直是我的学习的榜样：有演示代码，有讲解也有心得。</li>
<li><a href="https://doughellmann.com/blog/" target="_blank" rel="noopener">doughellmann.com/blog</a>。大家都知道吧？PyMOTW系列的作者的博客。通常每篇介绍一个模块的使用，每篇都写得很深入，比官方网站对于模块的介绍细，你可以轻松的学到额外的「隐藏技能」。</li>
<li><a href="http://lucumr.pocoo.org/" target="_blank" rel="noopener">lucumr.pocoo.org</a>。Flask作者的博客，一句话介绍：有思想，虽然有些观点我并不认同。由于它现在转去做Rust开发（应该是觉得在Python圈曲高和寡的厉害）了，Python语言相关的内容并不多了。</li>
<li><a href="https://snarky.ca/" target="_blank" rel="noopener">snarky.ca</a>。应该很多人不知道这个博客，其实作者Brett Cannon是一个很知名的Python核心开发。对于中高级开发，强烈推荐。在这里又想岔开一下，知乎上有很多评价Python和Go，我很无奈… 之前有个「为何 Go 依然远远没有 Python 流行？」的问题老有人邀请我，我后来这样回答的：<blockquote>
<p>别腰了….<br>在知乎上我一向不愿意回答这种问题，因为学的尚浅，Python不精通，Golang也做不到信手拈来，没资格回答这个问题（哪怕我有自己的观点也不想唠出来误人子弟），所以只喜欢坐在角落磕着瓜子看别人唠。<br>就说2点吧，现在谈这个话题，为时尚早; 脱离场景谈对比都是耍流氓<br>我一直说开发者需要一个正确的价值观，什么意思呢？在知乎里面如果讨论Vue，我是相对认可的，因为Vue的作者就在知乎。但是并不是其他的不好，只是ng和react的核心开发者并不混知乎，人都是跟风的，一个人说我好，别人又没有能力说不好，最后就搞得好像Vue在国内一统江湖的感觉（其实我也总在用Vue，😉）。<br>那么讨论Python，在知乎意义不大，因为中国直到去年底才出现了一个运维开发方向的核心开发者，而且还不混知乎。你们天天在知乎上听一堆代理人都不算的在吵在争论。我大部分时候是不参与论战的，做好自己的事情就好了，既然不是核心开发者又对Python没那么深入去扯什么？所以说，你们看到的大V并不一定很懂Python，比如我。所以今天我给你们推荐一些国外真正厉害的开发者的资源，这样渐渐的知道什么是真的正确的。为什么岔到了这里呀？是因为Brett<br>Cannon在13年的时候就写过对Python和Go语言的看法，你们应该去看看核心开发者是怎么看待的，而不是听某些Go和Python都没学好的键盘侠说。</p>
</blockquote>
</li>
<li><a href="https://www.blog.pythonlibrary.org/" target="_blank" rel="noopener">www.blog.pythonlibrary.org</a>。博主写过2本书：《Python 201》和《Python 101》想必很多人听过吧？博客早期会介绍一些Python相关的技巧和经验，后来做了一个挺有意思的「PyDev of the Week」，每周采访一个Python开发者，可以没事了解下业界其他开发者的一些观点和动态。</li>
<li><a href="https://www.reddit.com/r/Python/" target="_blank" rel="noopener">Reddit</a>。Reddit社区的Python节点，绝大部分业界新的思想、观点和项目都是首先在这里被讨论的，这里汇集了大量的Python老手（虽然大部分也是潜水），国内技术内容质量很差，抑或是万年老贴（比如爬虫），抑或就是新闻联播病毒式通稿，有时候出来一篇爆红的文章，其实也不过是翻译人家的人或者冷饭热炒。你们以后有可以不用在知乎和一些公众号看一些低质量的内容了，当然还是需要一些英语基础的了。</li>
<li><a href="http://www.pycoders.com/" target="_blank" rel="noopener">Pycoder’s Weekly</a>，<a href="http://www.pythonweekly.com/" target="_blank" rel="noopener">Python Weekly</a>，<a href="http://www.importpython.com/newsletter/" target="_blank" rel="noopener">Import Python Weekly</a>，<a href="https://python.libhunt.com/newsletter" target="_blank" rel="noopener">Awesome Python Newsletter</a>这几个订阅源我就不分开说了，如果你精力有限，每周翻翻它们发出来的有意思的项目和文章也是很有益处的。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之使用Elasticsearch做聚合分析</title>
    <url>/2016-03-17.html</url>
    <content><![CDATA[<p>ES除了全文搜索以外还有一个主要功能, 就是数据的聚合分析。我会在微信小程序里用到聚合功能。今天先介绍一下。<br>目前DSL库支持如下三种常用聚合模式</p>
<h3 id="Metrics-Aggregations"><a href="#Metrics-Aggregations" class="headerlink" title="Metrics Aggregations"></a>Metrics Aggregations</h3><p>顾名思义, 主要是用于计算特定的度量字段，Metric很像SQL中的avg、max、min等方法。我们找一下最多的Live有多少人感兴趣：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> A  </span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s.aggs.metric(<span class="string">'max_liked_num'</span>, A(<span class="string">'max'</span>, field=<span class="string">'liked_num'</span>))  </span><br><span class="line">Out: &lt;elasticsearch_dsl.search.Search at <span class="number">0x10a47b550</span>&gt;  </span><br><span class="line">  </span><br><span class="line">In : r = s.execute()  </span><br><span class="line">In : r.aggregations.max_liked_num  </span><br><span class="line">Out: &#123;<span class="string">'value'</span>: <span class="number">6918.0</span>&#125;</span><br></pre></td></tr></table></figure>


<p>嚯。看看是哪一个吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: s.query(<span class="string">'match'</span>, liked_num=<span class="number">6918</span>).execute()[<span class="number">0</span>].subject  </span><br><span class="line">Out[<span class="number">27</span>]: <span class="string">'致所有近视想摘掉眼镜的你们'</span></span><br></pre></td></tr></table></figure>


<p>有点出人意料哦~<br>其实度量的也不一定是文档的某个特定字段值, 可以是文档通过脚本生成的值。比如我们看看全部Live平均收入，收入=票价*参与人数，是2个字段。要这样用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> A  </span><br><span class="line">  </span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s.aggs.metric(<span class="string">'avg_income'</span>, A(<span class="string">'scripted_metric'</span>, init_script=<span class="string">"params._agg['incomes'] = []"</span>, map_script=<span class="string">"params._agg.incomes.add(doc.amou  </span></span><br><span class="line"><span class="string">...: nt.value * doc.seats_taken.value)"</span>, combine_script=<span class="string">'double total=0; int num_of_income=0; for (i in params._agg.incomes) &#123; total += i; nu  </span></span><br><span class="line"><span class="string">...: m_of_income += 1 &#125; return [total, num_of_income]'</span>, reduce_script=<span class="string">'double total=0; int num_of_income=0; for (item in params._aggs) &#123; tota  </span></span><br><span class="line"><span class="string">...: l += item[0]; num_of_income += item[1]&#125; return total / num_of_income'</span>))  </span><br><span class="line">Out: &lt;elasticsearch_dsl.search.Search at <span class="number">0x10a512898</span>&gt;  </span><br><span class="line">  </span><br><span class="line">In : rs = s.execute()  </span><br><span class="line">  </span><br><span class="line">In : rs.aggregations.avg_income  </span><br><span class="line">Out: &#123;<span class="string">'value'</span>: <span class="number">32934.61029513591</span>&#125;</span><br></pre></td></tr></table></figure>


<p>有点长，我们把scripted_metric的参数分开说：</p>
<ol>
<li>init_script。 初始化时运行，一般是设置初始的全局变量</li>
<li>map_script。会对每个文档做循环，把每个计算好的收入用add方法加到每个分片的params._agg.incomes里面。</li>
<li>combine_script。我们知道ES是分布式的，数据有多个分片，当map_script完成后，它用来对每个分片的那部分结果做求和和计数的预处理</li>
<li>reduce_script。如果你了解MapReduce，我想对2和4步就能更好的理解了，这一步能通过params._aggs把每个分片的预处理结果拿来再做处理，最后通过总收入和live数求得平均值。<br>很庆幸没有给平均值拖后腿。BTW，有兴趣的同学可以继续挖掘为啥平均收入这么高。而且注意额，我考虑的只是普通票价，没有算那些「聊表心意」、「鼎力支持」的票，这会让平均值更高一些。<br>上面的例子也的好长啊。我不太满意，那么是不是可以简化一下呢? 也就是combine_script不预计算，统一在reduce_script计算：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s.aggs.metric(<span class="string">'avg_income'</span>, A(<span class="string">'scripted_metric'</span>, init_script=<span class="string">"params._agg['incomes'] = []"</span>, map_script=<span class="string">"params._agg.incomes.add(doc.amou  </span></span><br><span class="line"><span class="string">...: nt.value * doc.seats_taken.value)"</span>, combine_script=<span class="string">'return params._agg.incomes'</span>, reduce_script=<span class="string">'double total=0; int num_of_income=0; for  </span></span><br><span class="line"><span class="string">...:  (shard in params._aggs) &#123; for (income in shard) &#123;total += income; num_of_income += 1&#125;&#125; return total / num_of_income'</span>))  </span><br><span class="line">Out: &lt;elasticsearch_dsl.search.Search at <span class="number">0x10a53a470</span>&gt;  </span><br><span class="line">  </span><br><span class="line">In : r = s.execute()  </span><br><span class="line">In : r.aggregations.avg_income  </span><br><span class="line">Out: &#123;<span class="string">'value'</span>: <span class="number">32934.61029513591</span>&#125;</span><br></pre></td></tr></table></figure>


<p>只是在combine_script用了个嵌套循环。</p>
<h3 id="Bucket-Aggregations"><a href="#Bucket-Aggregations" class="headerlink" title="Bucket Aggregations"></a>Bucket Aggregations</h3><p>Bucket在英语里面有「桶」的意思，Bucket Aggregations会把符合某种条件的文档丢进一个Bucket，而且还可以实现子聚合（sub-<br>aggregations）。<br>Elasticsearch是基于Lucene构建的。如果你了解过Lucene，相信知道docValue，它节省内存、做排序，分组等聚合操作时能够大大提升性能。我们之前的model里面大多使用了文本字段（Text），这是用作进行全文搜索的，而希望做聚合计算，需要使用Keyword类型的字段。所以我添加了一个topics字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> Keyword, DocType  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    topic_names = Text(analyzer=<span class="string">'ik_max_word'</span>)  </span><br><span class="line">    topics = Keyword()  <span class="comment"># 新增</span></span><br></pre></td></tr></table></figure>


<p>其实DSL还支持一种用子字段的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">topic_names = Text(analyzer=<span class="string">'ik_max_word'</span>, fields=&#123;<span class="string">'raw'</span>: Keyword()&#125;)</span><br></pre></td></tr></table></figure>


<p>由于担心未来Live的Topic会有多个，所以topic_names是一个用join把topic列表串起来的字符串，而需求上topics是一个或者多个topic的列表，还是额外新加一个字段吧。<br>这样重新跑爬虫，补充下topics字段之后，按toics符合数量排序，看看live中那些类型的Live更多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s.aggs.bucket(<span class="string">'categories'</span>, A(<span class="string">'terms'</span>, field=<span class="string">'topics'</span>))  </span><br><span class="line">Out: &lt;elasticsearch_dsl.search.Search at <span class="number">0x10a532d30</span>&gt;  </span><br><span class="line">  </span><br><span class="line">In : r = s.execute()  </span><br><span class="line">  </span><br><span class="line">In : r.aggregations.categories.buckets  </span><br><span class="line">Out:  </span><br><span class="line">[&#123;<span class="string">'key'</span>: <span class="string">'生活方式'</span>, <span class="string">'doc_count'</span>: <span class="number">145</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'金融'</span>, <span class="string">'doc_count'</span>: <span class="number">94</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'音乐'</span>, <span class="string">'doc_count'</span>: <span class="number">87</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'艺术'</span>, <span class="string">'doc_count'</span>: <span class="number">73</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'教育'</span>, <span class="string">'doc_count'</span>: <span class="number">59</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'科技'</span>, <span class="string">'doc_count'</span>: <span class="number">59</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'心理学'</span>, <span class="string">'doc_count'</span>: <span class="number">56</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'职业'</span>, <span class="string">'doc_count'</span>: <span class="number">56</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'互联网'</span>, <span class="string">'doc_count'</span>: <span class="number">48</span>&#125;,  </span><br><span class="line"> &#123;<span class="string">'key'</span>: <span class="string">'医学'</span>, <span class="string">'doc_count'</span>: <span class="number">42</span>&#125;]</span><br></pre></td></tr></table></figure>


<p>看到了吧，彰显逼格的「生活方式」话题的Live最多，象征更多钱的金融话题次之…<br>现在是不是有种熟悉的感觉：聚合短语terms这不是SQL里面的group by嘛？<br>PS: 如果要使结果返回所有聚合结果的话, 需要加上size参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s.aggs.bucket(<span class="string">'categories'</span>, A(<span class="string">'terms'</span>, field=<span class="string">'topics'</span>, size=<span class="number">20</span>))</span><br></pre></td></tr></table></figure>


<p>PS: 从ES5.0开始，size不再能指定0而返回全部结果了，需要明确指定一个大于0的整数。<br>Bucket聚合支持多种类型，我们再演示下范围聚合。 现在把票价分成三个范围：</p>
<ol>
<li>小于20的</li>
<li>20-100之间的</li>
<li>大于100的<br>这样写：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s.aggs.bucket(<span class="string">'amount_eq_100'</span>, A(<span class="string">'range'</span>, field=<span class="string">'amount'</span>, ranges=[&#123;<span class="string">'from'</span>: <span class="number">100</span>&#125;, &#123;<span class="string">'from'</span>: <span class="number">20</span>, <span class="string">'to'</span>: <span class="number">100</span>&#125;, &#123;<span class="string">'to'</span>: <span class="number">20</span>&#125;]))  </span><br><span class="line">Out: Range(field=<span class="string">'amount'</span>, ranges=[&#123;<span class="string">'from'</span>: <span class="number">100</span>&#125;, &#123;<span class="string">'from'</span>: <span class="number">20</span>, <span class="string">'to'</span>: <span class="number">100</span>&#125;, &#123;<span class="string">'to'</span>: <span class="number">20</span>&#125;])  </span><br><span class="line">  </span><br><span class="line">In : r = s.execute()  </span><br><span class="line">In : buckets = r.aggregations.amount_eq_100.buckets  </span><br><span class="line">In : <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:  </span><br><span class="line">...:     print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(bucket[<span class="string">'key'</span>], bucket[<span class="string">'doc_count'</span>]))  </span><br><span class="line">...:  </span><br><span class="line">*<span class="number">-20.0</span>: <span class="number">1159</span>  </span><br><span class="line"><span class="number">20.0</span><span class="number">-100.0</span>: <span class="number">683</span>  </span><br><span class="line"><span class="number">100.0</span>-*: <span class="number">20</span></span><br></pre></td></tr></table></figure>


<p>最后演示下date_histogram型的聚合，histogram顾名思义是直方图的意思，我们看看从Live诞生到现在，每个月（即将）举行Live的数量分别是多少：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s.aggs.buckets(<span class="string">'start_at'</span>, A(<span class="string">'date_histogram'</span>, field=<span class="string">'starts_at'</span>, interval=<span class="string">'month'</span>))  </span><br><span class="line">Out: &lt;elasticsearch_dsl.search.Search at <span class="number">0x10a6ea3c8</span>&gt;  </span><br><span class="line">  </span><br><span class="line">In : r = s.execute()  </span><br><span class="line">In : r.aggregations.start_at.buckets  </span><br><span class="line">Out:  </span><br><span class="line">[&#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-05-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-06-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-07-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-08-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-09-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-10-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-11-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-12-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-01-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-02-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-03-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-04-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-05-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;]  </span><br><span class="line">  </span><br><span class="line">In : q = r.aggregations.start_at.buckets[<span class="number">0</span>]  </span><br><span class="line">In : q.doc_count  </span><br><span class="line">Out: <span class="number">20</span>  </span><br><span class="line">In : q.key  </span><br><span class="line">Out: datetime.datetime(<span class="number">2016</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<p>interval支持多种类型：如year, quarter, month, week, day, hour, minute, second等。</p>
<h3 id="Pipeline-Aggregations"><a href="#Pipeline-Aggregations" class="headerlink" title="Pipeline Aggregations"></a>Pipeline Aggregations</h3><p>管道聚合是在Elasticsearch 2.x新增的一种聚合类型，可以在现有的聚合数据之上，再对其做一次运算。这类似SQL的Subquery。<br>Pipeline分为2类：</p>
<ol>
<li>parent。聚合的输入是非Pipeline聚合的输出，并对其进行进一步处理。一般不生成新的桶，而是对父聚合桶信息的replace。</li>
<li>sibling。聚合的输入是其他Pipeline聚合的输出。并能在同级上计算新的聚合。<br>管道聚合通过buckets_path参数指定他们要进行聚合计算的权值对象，格式如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">AGG_SEPARATOR       =  <span class="string">'&gt;'</span> ;  指定父子聚合关系  </span><br><span class="line">METRIC_SEPARATOR    =  <span class="string">'.'</span> ;  指定聚合的特定权值  </span><br><span class="line">AGG_NAME            =  &lt;the name of the aggregation&gt; ;  直接指定聚合的名称  </span><br><span class="line">METRIC              =  &lt;the name of the metric (<span class="keyword">in</span> case of multi-value metrics aggregation)&gt; ;  直接指定权值  </span><br><span class="line">PATH                =  &lt;AGG_NAME&gt; [ &lt;AGG_SEPARATOR&gt;, &lt;AGG_NAME&gt; ]* [ &lt;METRIC_SEPARATOR&gt;, &lt;METRIC&gt; ] ; 综合上面的方式指定完整路径</span><br></pre></td></tr></table></figure>


<p>看2个例子就好懂了。首先演示sibling类型的，基于上节date_histogram聚合例子了，我们算一下每个月的Live总收入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : agg = A(<span class="string">'date_histogram'</span>, field=<span class="string">'starts_at'</span>, interval=<span class="string">'month'</span>)  </span><br><span class="line">In : agg.bucket(<span class="string">'incomes'</span>, A(<span class="string">'sum'</span>, script=&#123;<span class="string">'inline'</span>: <span class="string">"doc['seats_taken'].value* doc['amount'].value"</span>&#125;))  </span><br><span class="line">Out: Sum(script=&#123;<span class="string">'inline'</span>: <span class="string">"doc['seats_taken'].value* doc['amount'].value"</span>&#125;)  </span><br><span class="line">In : s.aggs.bucket(<span class="string">'incomes_per_month'</span>, agg)  </span><br><span class="line">Out: DateHistogram(aggs=&#123;<span class="string">'incomes'</span>: Sum(script=&#123;<span class="string">'inline'</span>: <span class="string">"doc['seats_taken'].value* doc['amount'].value"</span>&#125;)&#125;, field=<span class="string">'starts_at'</span>, interval=<span class="string">'month'</span>)</span><br></pre></td></tr></table></figure>


<p>为了构造更好理解的聚合语句，先生成一个agg变量，可以看到Buckets和Metrics可以用函数式的方式用多个，也要注意当需求复杂的时候都是可以通过script来实现的。接着加入2个管道，再分别获得最大月收入和全部月收入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : s.aggs.pipeline(<span class="string">'max_monthly_incomes'</span>, agg_type=<span class="string">'max_bucket'</span>, buckets_path=<span class="string">'incomes_per_month&gt;incomes'</span>)  </span><br><span class="line">Out: &lt;elasticsearch_dsl.search.Search at <span class="number">0x10a75b518</span>&gt;  </span><br><span class="line">In : s.aggs.pipeline(<span class="string">'sum_monthly_incomes'</span>, agg_type=<span class="string">'sum_bucket'</span>, buckets_path=<span class="string">'incomes_per_month&gt;incomes'</span>)  <span class="comment"># 注意agg_type不一样  </span></span><br><span class="line">Out: &lt;elasticsearch_dsl.search.Search at <span class="number">0x10a75b518</span>&gt;  </span><br><span class="line">  </span><br><span class="line">In : r = s.execute()  </span><br><span class="line">In : r.aggregations.incomes_per_month.buckets  </span><br><span class="line">Out:  </span><br><span class="line">[&#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-05-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-06-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-07-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-08-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-09-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-10-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-11-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2016-12-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-01-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-02-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-03-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-04-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;,  </span><br><span class="line"> &#123;<span class="string">'key_as_string'</span>: <span class="string">'2017-05-01T00:00:00.000Z'</span>, <span class="string">'key'</span>: datetim...&#125;]  </span><br><span class="line">  </span><br><span class="line">In : a = r.aggregations.incomes_per_month.buckets[<span class="number">0</span>]  </span><br><span class="line">In : a.doc_count  </span><br><span class="line">Out: <span class="number">20</span>  </span><br><span class="line">In : a.incomes  </span><br><span class="line">Out: &#123;<span class="string">'value'</span>: <span class="number">210088.48763275146</span>&#125;  </span><br><span class="line">  </span><br><span class="line">In : r.aggregations.max_monthly_incomes  </span><br><span class="line">Out: &#123;<span class="string">'value'</span>: <span class="number">18330342.949926138</span>, <span class="string">'keys'</span>: [<span class="string">'2016-10-01T00:00:00....&#125;  # 十月份收入最多  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">In : r.aggregations.sum_monthly_incomes  </span></span><br><span class="line"><span class="string">Out: &#123;'</span>value<span class="string">': 61324244.369543076&#125;  # 满眼的钱，现金🐂啊</span></span><br></pre></td></tr></table></figure>


<p>数完了钱，思考下。这个例子就是sibling聚合，因为sum_monthly_incomes、max_monthly_incomes和incomes_per_month在一个区间内的（都是aggs的键）。<br>我之前我们算过么每个月Live的总收入，全部Live的平均收入。我们现在算一下每个月Live的平均收入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : agg = A(<span class="string">'date_histogram'</span>, field=<span class="string">'starts_at'</span>, interval=<span class="string">'month'</span>)  </span><br><span class="line">In : agg.bucket(<span class="string">'total_incomes'</span>, A(<span class="string">'sum'</span>, script=&#123;<span class="string">'inline'</span>: <span class="string">"doc['seats_taken'].value* doc['amount'].value"</span>&#125;))  </span><br><span class="line">Out: Sum(script=&#123;<span class="string">'inline'</span>: <span class="string">"doc['seats_taken'].value* doc['amount'].value"</span>&#125;)  </span><br><span class="line">  </span><br><span class="line">In : agg.pipeline(<span class="string">'avg_income'</span>, agg_type=<span class="string">'bucket_script'</span>, buckets_path=&#123;<span class="string">'total'</span>: <span class="string">'total_incomes'</span>, <span class="string">'count'</span>: <span class="string">'_count'</span>&#125;, script=<span class="string">'params.total/params.count'</span>)  <span class="comment"># _count是一个特殊的路径，表示当前bucket里面的文档数量  </span></span><br><span class="line">Out: DateHistogram(aggs=&#123;<span class="string">'total_incomes'</span>: Sum(script=&#123;<span class="string">'inline'</span>: <span class="string">"doc['seats_taken'].value* doc['amount'].value"</span>&#125;), <span class="string">'avg_income'</span>: BucketScript(buckets_path=&#123;<span class="string">'total'</span>: <span class="string">'total_incomes'</span>, <span class="string">'count'</span>: <span class="string">'_count'</span>&#125;, script=<span class="string">'params.total/params.count'</span>)&#125;, field=<span class="string">'starts_at'</span>, interval=<span class="string">'month'</span>)  </span><br><span class="line">  </span><br><span class="line">In : s = Live.search()  </span><br><span class="line">In : s.aggs.bucket(<span class="string">'avg_income_per_month'</span>, agg)  </span><br><span class="line">Out: DateHistogram(aggs=&#123;<span class="string">'total_incomes'</span>: Sum(script=&#123;<span class="string">'inline'</span>: <span class="string">"doc['seats_taken'].value* doc['amount'].value"</span>&#125;), <span class="string">'avg_income'</span>: BucketScript(buckets_path=&#123;<span class="string">'total'</span>: <span class="string">'total_incomes'</span>, <span class="string">'count'</span>: <span class="string">'_count'</span>&#125;, script=<span class="string">'params.total/params.count'</span>)&#125;, field=<span class="string">'starts_at'</span>, interval=<span class="string">'month'</span>)  </span><br><span class="line">  </span><br><span class="line">In : r = s.execute()  </span><br><span class="line">In : buckets = r.aggregations.avg_income_per_month.buckets  </span><br><span class="line">In : b = buckets[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">In : b.total_incomes  </span><br><span class="line">Out: &#123;<span class="string">'value'</span>: <span class="number">210088.48763275146</span>&#125;  </span><br><span class="line">In : b.doc_count  </span><br><span class="line">Out: <span class="number">20</span>  </span><br><span class="line">In : b.avg_income  </span><br><span class="line">Out: &#123;<span class="string">'value'</span>: <span class="number">10504.424381637573</span>&#125;</span><br></pre></td></tr></table></figure>


<p>这就是parent类型的管道聚合了，它对每个桶自己去做运算。<br>今天先到这里了，下一篇将基于这几天对ES的学习实现一个对知乎Live进行全文搜索的微信小程序了</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ipython的一些高级用法(二)</title>
    <url>/2016-03-23.html</url>
    <content><![CDATA[<h4 id="今天我们学习下写ipython的magic命令-好-magic是什么-它是ipython自带的一些扩展命令-类似-history"><a href="#今天我们学习下写ipython的magic命令-好-magic是什么-它是ipython自带的一些扩展命令-类似-history" class="headerlink" title="今天我们学习下写ipython的magic命令. 好, magic是什么? 它是ipython自带的一些扩展命令, 类似%history,"></a>今天我们学习下写ipython的magic命令. 好, magic是什么? 它是ipython自带的一些扩展命令, 类似%history,</h4><p>%prun, %logstart..<br>想查看全部的magic可以使用ismagic, 列出可用的全部magics</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%lsmagic</span><br></pre></td></tr></table></figure>


<p>magic分为2类:</p>
<ul>
<li>line magic: 一些功能命令</li>
<li>cell magic: 主要是渲染ipython notebook页面效果以及执行某语言的代码<h5 id="idb-python-db-py-shell"><a href="#idb-python-db-py-shell" class="headerlink" title="idb - python db.py shell"></a><a href="https://github.com/dongweiming/idb" target="_blank" rel="noopener">idb</a> - python db.py shell</h5>extension<br>idb是我最近写的一个magic.<br>主要是给ipython提供<a href="https://github.com/yhat/db.py" target="_blank" rel="noopener">db.py</a>的接口,我们直接分析代码(我只截取有代表性的一段):</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os.path  </span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  </span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter  </span><br><span class="line"><span class="keyword">from</span> urlparse <span class="keyword">import</span> urlparse  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> db <span class="keyword">import</span> DB <span class="comment"># db.py提供的接口  </span></span><br><span class="line"><span class="keyword">from</span> IPython.core.magic <span class="keyword">import</span> Magics, magics_class, line_magic <span class="comment"># 这三个就是我们需要做magic插件的组件  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_or_none</span><span class="params">(attr)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> attr <span class="keyword">if</span> attr <span class="keyword">else</span> <span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_db</span><span class="params">(func)</span>:</span>  </span><br><span class="line"><span class="meta">    @wraps(func)  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(*args)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> args[<span class="number">0</span>]._db <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 每个magic都需要首页实例化过db，so 直接加装饰器来判断  </span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'[ERROR]Please make connection: `con = %db_connect xx` or `%use_credentials xx` first!'</span>  <span class="comment"># noqa  </span></span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        <span class="keyword">return</span> func(*args)  </span><br><span class="line">    <span class="keyword">return</span> deco  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@magics_class  # 每个magic都需要加这个magics_class装饰器  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLDB</span><span class="params">(Magics)</span>:</span> <span class="comment"># 要继承至Magics  </span></span><br><span class="line">    _db = <span class="literal">None</span> <span class="comment"># 每次打开ipython都是一次实例化  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">    @line_magic('db_connect') # 这里用了line_magic 表示它是一个line magic.(其他2种一会再说) magic的名字是db_connect. 注意 函数名不重要  </span></span><br><span class="line">                              <span class="comment"># 最后我们用 %db_connect而不是%conn  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">conn</span><span class="params">(self, parameter_s)</span>:</span> <span class="comment"># 每个这样的方法都接收一个参数 就是你在ipython里输入的内容  </span></span><br><span class="line">        <span class="string">"""Conenct to database in ipython shell.  </span></span><br><span class="line"><span class="string">        Examples::  </span></span><br><span class="line"><span class="string">            %db_connect  </span></span><br><span class="line"><span class="string">            %db_connect postgresql://user:pass@localhost:port/database  </span></span><br><span class="line"><span class="string">        """</span>  </span><br><span class="line">        uri = urlparse(parameter_s) <span class="comment"># 剩下的都是解析parameter_s的逻辑  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> uri.scheme:  </span><br><span class="line">            params = &#123;  </span><br><span class="line">                <span class="string">'dbtype'</span>: <span class="string">'sqlite'</span>,  </span><br><span class="line">                <span class="string">'filename'</span>: os.path.join(os.path.expanduser(<span class="string">'~'</span>), <span class="string">'db.sqlite'</span>)  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="keyword">elif</span> uri.scheme == <span class="string">'sqlite'</span>:  </span><br><span class="line">            params = &#123;  </span><br><span class="line">                <span class="string">'dbtype'</span>: <span class="string">'sqlite'</span>,  </span><br><span class="line">                <span class="string">'filename'</span>: uri.path  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            params = &#123;  </span><br><span class="line">                <span class="string">'username'</span>: get_or_none(uri.username),  </span><br><span class="line">                <span class="string">'password'</span>: get_or_none(uri.password),  </span><br><span class="line">                <span class="string">'hostname'</span>: get_or_none(uri.hostname),  </span><br><span class="line">                <span class="string">'port'</span>: get_or_none(uri.port),  </span><br><span class="line">                <span class="string">'dbname'</span>: get_or_none(uri.path[<span class="number">1</span>:])  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        self._db = DB(**params) <span class="comment"># 这里给_db赋值  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> self._db <span class="comment"># return的结果就会被ipython接收,显示出来  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">    @line_magic('db') # 一个新的magic 叫做%db -- 谨防取名冲突  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db</span><span class="params">(self, parameter_s)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> self._db  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @line_magic('table')  </span></span><br><span class="line"><span class="meta">    @check_db  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">table</span><span class="params">(self, parameter_s)</span>:</span>  </span><br><span class="line">        p = parameter_s.split() <span class="comment"># 可能传进来的是多个参数,但是对ipython来说,传进来的就是一堆字符串，所以需要按空格分隔下  </span></span><br><span class="line">        l = len(p)  </span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">1</span>:  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p[<span class="number">0</span>]:  </span><br><span class="line">                <span class="keyword">return</span> self._db.tables  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="keyword">return</span> attrgetter(p[<span class="number">0</span>])(self._db.tables)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            data = self._db.tables  </span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> p:  </span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> [<span class="string">'head'</span>, <span class="string">'sample'</span>, <span class="string">'unique'</span>, <span class="string">'count'</span>, <span class="string">'all'</span>, <span class="string">'query'</span>]:  </span><br><span class="line">                    data = attrgetter(c)(data)()  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    data = attrgetter(c)(data)  </span><br><span class="line">            <span class="keyword">return</span> data  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_ipython_extension</span><span class="params">(ipython)</span>:</span> <span class="comment"># 注册一下. 假如你直接去ipython里面加 就不需要这个了  </span></span><br><span class="line">    ipython.register_magics(SQLDB)</span><br></pre></td></tr></table></figure>


<p>PS:</p>
<ol>
<li>调试中可以使用%reloa_ext idb 的方式重启magic</li>
<li>%install_ext 之后默认放在你的ipython自定义目录/extensions里. 我这里是~/.ipython/extensions<br>好了,大家是不是觉得ipython的magic也不是很难嘛<h5 id="来了解ipython都提供了什么"><a href="#来了解ipython都提供了什么" class="headerlink" title="来了解ipython都提供了什么?"></a>来了解ipython都提供了什么?</h5></li>
<li>magic装饰器的类型:</li>
</ol>
<ul>
<li>line_magic # 刚才我们见识了, 就是%xx, xx就是magic的名字</li>
<li>cell_magic # 就是%%xx</li>
<li>line_cell_magic # 可以是%xx, 也可以是%%xx<br>先说cell_magic 来个例子，假如我想执行个ruby,本来应该是:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: !ruby -e <span class="string">'p "hello"'</span>  </span><br><span class="line"><span class="string">"hello"</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: %%ruby <span class="comment"># 也可以这样  </span></span><br><span class="line">   ...: p <span class="string">"hello"</span>  </span><br><span class="line">      ...:  </span><br><span class="line">      <span class="string">"hello"</span>  </span><br><span class="line">  </span><br><span class="line">再说个notebook的:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: %%javascript  </span><br><span class="line">   ...: require.config(&#123;  </span><br><span class="line">   ...:     paths: &#123;  </span><br><span class="line">   ...:         chartjs: <span class="string">'//code.highcharts.com/highcharts'</span>  </span><br><span class="line">   ...:     &#125;  </span><br><span class="line">   ...: &#125;);  </span><br><span class="line">   ...:  </span><br><span class="line">   &lt;IPython.core.display.Javascript object&gt;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>然后再说line_cell_magic:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: %time <span class="number">2</span>**<span class="number">128</span>  </span><br><span class="line">CPU times: user <span class="number">2</span> µs, sys: <span class="number">1</span> µs, total: <span class="number">3</span> µs  </span><br><span class="line">Wall time: <span class="number">5.01</span> µs  </span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">340282366920938463463374607431768211456L</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: %%time  </span><br><span class="line">   ...: <span class="number">2</span>**<span class="number">128</span>  </span><br><span class="line">   ...:  </span><br><span class="line">   CPU times: user <span class="number">4</span> µs, sys: <span class="number">0</span> ns, total: <span class="number">4</span> µs  </span><br><span class="line">   Wall time: <span class="number">9.06</span> µs  </span><br><span class="line">   Out[<span class="number">5</span>]: <span class="number">340282366920938463463374607431768211456L</span></span><br></pre></td></tr></table></figure>


<p>Ps: line_cell_magic方法的参数是2个:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@line_cell_magic  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xx</span><span class="params">(self, line=<span class="string">''</span>, cell=None)</span>:</span></span><br></pre></td></tr></table></figure>


<h5 id="带参数的magic（我直接拿ipython源码提供的magic来说明"><a href="#带参数的magic（我直接拿ipython源码提供的magic来说明" class="headerlink" title="带参数的magic（我直接拿ipython源码提供的magic来说明):"></a>带参数的magic（我直接拿ipython源码提供的magic来说明):</h5><p>一共2种风格:</p>
<ul>
<li>使用getopt: self.parse_options</li>
<li>使用argparse: magic_arguments<h6 id="self-parse-options"><a href="#self-parse-options" class="headerlink" title="self.parse_options"></a>self.parse_options</h6></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@line_cell_magic  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prun</span><span class="params">(self, parameter_s=<span class="string">''</span>, cell=None)</span>:</span>  </span><br><span class="line">    opts, arg_str = self.parse_options(parameter_s, <span class="string">'D:l:rs:T:q'</span>,  </span><br><span class="line">                                       list_all=<span class="literal">True</span>, posix=<span class="literal">False</span>)  </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>getopt用法可以看这里 <a href="http://pymotw.com/2/getopt/index.html#module-getopt" target="_blank" rel="noopener">http://pymotw.com/2/getopt/index.html#module-getopt</a><br>我简单介绍下’D:l:rs:T:q’就是可以使用 -D, -l, -r, -s, -T, -q这些选项. <code>:</code>号是告诉你是否需要参数,split下就是:<br>D:,l:,r,s:,T:,q 也就是-r和-q不需要参数其他的都是参数 类似 %prun -D</p>
<h6 id="magic-arguments"><a href="#magic-arguments" class="headerlink" title="magic_arguments"></a>magic_arguments</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@magic_arguments.magic_arguments() # 最上面  </span></span><br><span class="line"><span class="meta">@magic_arguments.argument('--breakpoint', '-b', metavar='FILE:LINE',  </span></span><br><span class="line">    help=<span class="string">"""  </span></span><br><span class="line"><span class="string">    Set break point at LINE in FILE.  </span></span><br><span class="line"><span class="string">    """</span>  </span><br><span class="line">) <span class="comment"># 这种argument可以有多个  </span></span><br><span class="line"><span class="meta">@magic_arguments.argument('statement', nargs='*',  </span></span><br><span class="line">    help=<span class="string">"""  </span></span><br><span class="line"><span class="string">    Code to run in debugger.  </span></span><br><span class="line"><span class="string">    You can omit this in cell magic mode.  </span></span><br><span class="line"><span class="string">    """</span>  </span><br><span class="line">)  </span><br><span class="line"><span class="meta">@line_cell_magic  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(self, line=<span class="string">''</span>, cell=None)</span>:</span>  </span><br><span class="line">    args = magic_arguments.parse_argstring(self.debug, line) <span class="comment"># 要保持第一个参数等于这个方法名字,这里就是self.debug  </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>还有个magic方法集: 用于并行计算的magics:<br><a href="https://github.com/ipython/ipython/blob/master/IPython/parallel/client/magics.py" target="_blank" rel="noopener">IPython/parallel/client/magics.py</a></p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>给初学python设计模式的pythonista</title>
    <url>/2016-03-21.html</url>
    <content><![CDATA[<p>####前言<br>从2011年5月4日买了第一本《python学习手册》到现在，我学python已经2年多了，python也是我第一门除bash外的语言。<br>学’设计模式’这么神秘的东西还是源于去年一次面试，在我说了我想做某个东西，然后有什么思路后，面试官很不屑的问我：你知道设计模式嘛？<br>然后我就懵了-从来没听过。我特别赞赏提供良好扩展功能的项目，比如<a href="http://www.sublimetext.com/2" target="_blank" rel="noopener">Sublime Text2</a>,<br>它提供第三方插件功能，你可以使用别人开发的插件，也可以自己写插件，让项目更好的维护和扩展而不需要动基础的代码。<br>后来换工作一直在熟悉业务，学一些东西。但是我一直记得这个’设计模式’，上个月花了一些时间去了解，所以有了此文，假如你也想了解’设计模式’,也很怕它，你会python，希望本文带给你帮助<br>我也写了一组python设计模式的文章: <a href="http://dongweiming.github.io/category/she-ji-mo-shi.html" target="_blank" rel="noopener">小明明s Github -<br>设计模式</a><br>####我的角度<br>GoF（“四人帮”，又称Gang of Four，即Erich Gamma, Richard Helm, Ralph Johnson &amp; John<br>Vlissides四人）的《设计模式》这本书我没看过，我也不怎么会java，看不懂例子.我没有受到其他语言的毒害(因为python是我一开始的语言)，我的角度应该是最靠近python<br>####什么是设计模式<br>设计模式其实是一些被很多人反复使用而总结出来的代码设计经验，这些技术被GOF在大概20年前编辑成《编程模式》，其实不要害怕，<br>因为 <strong>设计模式就在你写代码过程中已经体现了，被叫做’设计模式’只是被很好的总结出来</strong> ，<br>####python程序员的成长</p>
<ul>
<li>当你初学python，可能还是翻阅手册或者去google出一些你想要问题的答案，而后举一反三修改它符合你想要的东西。那么这是阶段一：堆代码，这个时候主要是为了实现功能，不重视代码编码规范，代码运行效率，代码可读性等</li>
<li>用过一段时间python，你对python很熟悉了，可以copy代码写东西了。那么这是阶段二：码农初长成</li>
<li>我是这样的人：当一个类似的功能出现，我就想思考重构(重构这个词太大了，好吧，为了减少我的代码量);当经常出现某些相同的情况的过程，我就会思考更好的抽象出来;当项目大了，、<br>会思考如何在不改动或者少改动的前提下更好的扩展新功能。那么这是阶段三: 码农中的愤青<br>这里你会对自己有更高的要求，其实总结一些更好的表达和实现，就是设计模式了</li>
<li>埋头写代码毕竟进步有限，这个时候可能你会读一些好的开源代码，保存了很多别人的代码片段等，你会发现:哦，原来可以这么写.. 哇 这个实现好酷… 然后你会记下来，<br>等以后在合适的场景里面借用这些思想, 这是阶段四：在很多开源代码中会看见一些很好的设计模式的体现，就是这样看别人，然后理解吸收<br>####如何学习python的设计模式<br>github上面有2个这方面的项目: [python-patterns](<a href="https://github.com/faif/python-" target="_blank" rel="noopener">https://github.com/faif/python-</a><br>patterns)和[Design-Patterns-in-Python](<a href="https://github.com/gennad/Design-" target="_blank" rel="noopener">https://github.com/gennad/Design-</a><br>Patterns-in-Python), 但是都不怎么维护了<br>当然了，做广告,可以看我的GithubPages[小明明s Github -<br>设计模式](<a href="http://dongweiming.github.io/category/she-ji-mo-" target="_blank" rel="noopener">http://dongweiming.github.io/category/she-ji-mo-</a><br>shi.html),都是我自己的理解，欢迎大家提意见<br>####python的设计模式<br>通过我学习和写这些模式的文章，我有很多感悟</li>
<li>对于python，装饰器模式其实都已经是内置代码级别;</li>
<li><a href="http://dongweiming.github.io/python-flyweight.html" target="_blank" rel="noopener">flyweight模式</a>原来还可以这样玩;</li>
<li><a href="http://dongweiming.github.io/python-singleton.html" target="_blank" rel="noopener">单例模式</a>已经落伍，完全可以被<a href="http://dongweiming.github.io/python-borg.html" target="_blank" rel="noopener">borg模式</a>取代</li>
<li><a href="http://dongweiming.github.io/python-null.html" target="_blank" rel="noopener">NUll模式</a>可以帮助你省去很多代码和异常处理</li>
<li><a href="http://dongweiming.github.io/python-object-pool.html" target="_blank" rel="noopener">对象池模式</a>是一个很实用的模式</li>
<li>终于理解游戏人物设计用到了<a href="http://dongweiming.github.io/python-pototype.html" target="_blank" rel="noopener">原型模式</a><br>…<br>基本是学了每个模式都有很深的触动<br>####学习设计模式有没有必要<br>没有学习设计模式不会影响你写代码的水平，但是学习了会提高你的代码质量和拓宽你解决问题的思路</li>
</ul>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用API登录知乎并获得token</title>
    <url>/2016-03-24.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在公众号转载了一篇<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDk1NjI0OQ==&mid=2247483910&idx=1&sn=62f5730c99dd7f9e40febb727b5960&chksm=9f76aeb0a80127a633a31024ba42c34872a8b13da151e5b0c7f15c1a338ead2d06eaedb1eea5#rd" target="_blank" rel="noopener">使用Python模拟登录知乎</a>,<br>使用了目前实现爬虫比较常用的Web登录方式。我以前写爬虫选择的方式是：</p>
<ol>
<li>如果对方网站有开放平台，满足需求且比较容易获取API权限，优先使用API。</li>
<li>如果网页登录及验证非常容易，甚至都不用登录就可以获取爬取网页，也是可以的。但是Web抓取不是最优先的，因为Web页面结构会改变、登录验证方式也会不断更新，可以感受到层出不断的验证码方式，烦。Web抓取，如果对应的移动适配的页面满足我会优先考虑移动端抓取，限制要少一些。我在知乎回答「<a href="https://www.zhihu.com/question/38192299/answer/125408708" target="_blank" rel="noopener">你见过哪些令你瞠目结舌的爬虫技巧？</a>」最后提到过：「第二条： 不要只看 Web 网站, 还有移动版、 App 和 H5, 它们的反爬虫措施一般比较少, 所有社交网站爬虫, 优先选择爬移动版。 」，不过这条大家好像都是直接忽略的… 忧伤</li>
<li>当前2种都不好使的时候，虽然没有公开的API，但是只要这个应用有移动版本，就好办….<br>昨天喜闻知乎获得了新一轮的融资，晚上赶紧研究了下通过抓包获取知乎API的方法，分享给大家。由于之前我写的爬虫被对方寄了律师函（像豆瓣、知乎这种胸襟的公司毕竟是少数），读者请不要分享到掘金等平台（知乎可以），小范围传播就好了，感谢！<br>昨晚灵机一动的原因是由于之前在写「<a href="http://www.dongwm.com/archives/%E6%88%91%E7%9A%84-2016-%E5%B9%B4/" target="_blank" rel="noopener">我的2016年</a>」的时候，fork了[zhihu-<br>oauth](<a href="https://github.com/7sDream/zhihu-" target="_blank" rel="noopener">https://github.com/7sDream/zhihu-</a><br>oauth)，添加了following接口，跑了个获取参与我的Live的人中有多少关注者的脚本。<br>其实本文并没有超出zhihu-oauth的技术实现。但是我并不想把我的修改提PR合并给上游，因为对一些代码和实现的理解有一些冲突。<br>但是能有本文还是非常感谢zhihu-oauth，它其实就是用知乎API实现的抓取，我本文的提到的技术和代码并没有超过它的范畴。但是还是有一些区别：</li>
<li>代码量。zhihu-oauth是一个中型组织结构，目录模块分配合理，我这个是它的抓取核心的简化版本，代码量少了很多。「Python之禅」里面有一句「Simple is better than complex.」，我个人不喜欢看结构复杂，尤其有黑科技的项目。当然会这样一般有炫技、作者对写项目的理解、设计能力还是历史遗留等原因。我比较喜欢简单粗暴的展示核心，代码能力在我看来有一个方面是能把复杂的事情非常简单化的表达，以至于让初学Python不久的工程师看起来也会愉悦，我正在朝着这个方向努力。</li>
<li>移动设备。zhihu-oauth使用的安卓，我这篇文章用到的是IOS，且是目前最新版。</li>
<li>展开细节。zhihu-oauth是一个开箱即用的项目，你可以不必读源码甚至不会写爬虫即可。而我今天是给大家讲整个抓取过程都发生了什么，怎么完成抓取的。相信大家看完之后去抓其他应用的包也会容易很多。</li>
<li>其他实现细节。比如zhihu-oauth使用了pickle来序列化token的结果，它是Python独有的，可读性和安全性都不好，我改用了json。<br>好吧，我们开始。<h3 id="IOS抓包"><a href="#IOS抓包" class="headerlink" title="IOS抓包"></a>IOS抓包</h3>安卓的权限控制比较松，能比较方便的抓包。但是IOS由于苹果的一些政策，只能迂回的获的，我使用了<a href="http://www.charlesproxy.com" target="_blank" rel="noopener">Charles</a>，Charles的安装设置就不说了，Google能找到一堆教程。开始抓包后，然后在IPhone上设置手动的HTTP代理。<br>接着就是退出知乎，重新登录。<br>可以看到下面Charles界面左侧会出现api.zhihu.com的一项，点开可以看到sign_in项，再点开。在右侧就会出现API的信息。但我们先看Contents里面的Headers部分：<br><img src="https://cloud.githubusercontent.com/assets/841395/21917685/941de8ba-d984-11e6-9f2d-64f540cc7dca.png" alt><br>这里面信息很多：</li>
<li>登录API地址是：<a href="https://api.zhihu.com/sign_in" target="_blank" rel="noopener">https://api.zhihu.com/sign_in</a></li>
<li>登录请求使用POST(废话)</li>
<li>登录需要添加一大坨自定义头信息，还要包含身份认证<br>其中自定义的头信息可以设置成常量，放进config.py：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">API_VERSION = <span class="string">'3.0.42'</span>  </span><br><span class="line">APP_VERSION = <span class="string">'3.28.0'</span>  </span><br><span class="line">APP_BUILD = <span class="string">'release'</span>  </span><br><span class="line">UUID = <span class="string">'AJDA7XkI9glLBWc85sk-nJ_6F0jqALu4AlY='</span>  </span><br><span class="line">UA = <span class="string">'osee2unifiedRelease/3.28.0 (iPhone; iOS 10.2; Scale/2.00)'</span>  </span><br><span class="line">APP_ZA = <span class="string">'OS=iOS&amp;Release=10.2&amp;Model=iPhone8,1&amp;VersionName=3.28.0&amp;VersionCode=558&amp;Width=750&amp;Height='</span>  </span><br><span class="line">CLIENT_ID = <span class="string">'8d5227e0aaaa4797a763ac64e0c3b8'</span>  </span><br><span class="line">APP_SECRET = <span class="string">b'ecbefbf6b17e47ecb9035107866380'</span></span><br></pre></td></tr></table></figure>


<p>其中CLIENT_ID和APP_SECRET基于安全考虑用的是zhihu-<br>oauth中默认的。我之前介绍过用local_config的方法替换config里面的默认配置，让一些关键常量不必放入版本库。<br>有一些一般（严谨点）是不会变的， 比如API地址，所以放进settings.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ZHIHU_API_ROOT = <span class="string">'https://api.zhihu.com'</span>  </span><br><span class="line">LOGIN_URL = ZHIHU_API_ROOT + <span class="string">'/sign_in'</span>  </span><br><span class="line">CAPTCHA_URL = ZHIHU_API_ROOT + <span class="string">'/captcha'</span></span><br></pre></td></tr></table></figure>


<p>我们知道requests这个库是支持身份认证的，在这里我们按照人家的玩法，自定义ZhihuOAuth类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> AuthBase  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> (  </span><br><span class="line">    API_VERSION, APP_VERSION, APP_BUILD, UUID, UA, APP_ZA, CLIENT_ID)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhihuOAuth</span><span class="params">(AuthBase)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token=None)</span>:</span>  </span><br><span class="line">        self._token = token  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, r)</span>:</span>  </span><br><span class="line">        r.headers[<span class="string">'X-API-Version'</span>] = API_VERSION  </span><br><span class="line">        r.headers[<span class="string">'X-APP_VERSION'</span>] = APP_VERSION  </span><br><span class="line">        r.headers[<span class="string">'X-APP-Build'</span>] = APP_BUILD  </span><br><span class="line">        r.headers[<span class="string">'x-app-za'</span>] = APP_ZA  </span><br><span class="line">        r.headers[<span class="string">'X-UDID'</span>] = UUID  </span><br><span class="line">        r.headers[<span class="string">'User-Agent'</span>] = UA  </span><br><span class="line">        <span class="keyword">if</span> self._token <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            auth_str = <span class="string">'oauth &#123;client_id&#125;'</span>.format(  </span><br><span class="line">               client_id=CLIENT_ID  </span><br><span class="line">            )  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            auth_str = <span class="string">'&#123;type&#125; &#123;token&#125;'</span>.format(  </span><br><span class="line">                type=str(self._token.type.capitalize()),  </span><br><span class="line">                token=str(self._token.token)  </span><br><span class="line">            )  </span><br><span class="line">        r.headers[<span class="string">'Authorization'</span>] = auth_str  </span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>


<p>然后就可以使用诸如<code>requests.get(&#39;https://api.xxx.com/yy,
auth=ZhihuOAuth())</code>的方式了，不需要粗暴的拼headers。<br>上面的auth_str有2种，这是由于在为登录前是没有token的，使用的是oauth，在登录之后会拿到token。之后在调取其他API接口就需要这个token了。之后还会提到。<br>接着，我们看一下提交的表单和请求登录成功后返回的内容：<br><img src="https://cloud.githubusercontent.com/assets/841395/21921224/79c20966-d9a1-11e6-98e3-d6275960a9f4.jpg" alt><br>这次选择的是Form，返回的结果是切换到JSON Text这个Tab看到的。处于安全性的考虑，我隐去了一些敏感信息。<br>当成功之后，会返回一个access_token，也包含了token类型是bearer。之后的API调用就要使用和这个token了。假如我们在刷首页的feed，会有这样的一个请求：<br><img src="https://cloud.githubusercontent.com/assets/841395/21921351/800c7a08-d9a2-11e6-914b-0006220a1541.jpg" alt><br>注意其中的头信息中的Authorization，就是拿着这个access_token的值和类型去认证的。<br>原理说完了，感受下代码怎么写</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>今天我们讲的是登录，那么就要有登录失败的异常处理。好的习惯是自定义一些异常类exception.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginException</span><span class="params">(Exception)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, error)</span>:</span>  </span><br><span class="line">        self.error = error  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Login Fail: &#123;&#125;'</span>.format(self.error)  </span><br><span class="line">          </span><br><span class="line">    __str__ = __repr__</span><br></pre></td></tr></table></figure>


<p>可能有同学会问，咦，用复数形式的exceptions.py不是更贴切么？因为exceptions已经被Python占用了 -. -</p>
<h3 id="Token类"><a href="#Token类" class="headerlink" title="Token类"></a>Token类</h3><p>对access_token的操作应该放到一个类下面。 所以我也是用了单独的ZhihuToken</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhihuToken</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, user_id, uid, access_token, expires_in, token_type,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 refresh_token, cookie, lock_in=None, unlock_ticket=None)</span>:</span>  </span><br><span class="line">        self._create_at = time.time()  </span><br><span class="line">        self._user_id = uid  </span><br><span class="line">        self._uid = user_id  </span><br><span class="line">        self._access_token = access_token  </span><br><span class="line">        self._expires_in = expires_in  </span><br><span class="line">        self._expires_at = self._create_at + self._expires_in  </span><br><span class="line">        self._token_type = token_type  </span><br><span class="line">        self._refresh_token = refresh_token  </span><br><span class="line">        self._cookie = cookie  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Not used  </span></span><br><span class="line">        self._lock_in = lock_in  </span><br><span class="line">        self._unlock_ticket = unlock_ticket  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_file</span><span class="params">(cls, filename)</span>:</span>  </span><br><span class="line">        <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:  </span><br><span class="line">            <span class="keyword">return</span> cls.from_dict(json.load(f))  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_file</span><span class="params">(filename, data)</span>:</span>  </span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">            json.dump(data, f)  </span><br><span class="line">              </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_dict</span><span class="params">(cls, json_dict)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">return</span> cls(**json_dict)  </span><br><span class="line">        <span class="keyword">except</span> TypeError:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(  </span><br><span class="line">                <span class="string">'"&#123;json_dict&#125;" is NOT a valid zhihu token json.'</span>.format(  </span><br><span class="line">                    json_dict=json_dict  </span><br><span class="line">                ))</span><br></pre></td></tr></table></figure>


<p>如果已经有token，用起来是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> client <span class="keyword">import</span> ZhihuToken, TOKEN_FILE  </span><br><span class="line">In [<span class="number">2</span>]: token = ZhihuToken.from_file(TOKEN_FILE)  </span><br><span class="line">In [<span class="number">3</span>]: token._token_type  </span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">'bearer'</span>  </span><br><span class="line">In [<span class="number">4</span>]: token._expires_at  </span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">1486884430.011306</span></span><br></pre></td></tr></table></figure>


<p>类方法from_dict的返回值是一个该类的实例的玩法现在用的非常普遍。</p>
<h3 id="Client类"><a href="#Client类" class="headerlink" title="Client类"></a>Client类</h3><p>最后就是实现登录功能，我统一放在ZhihuClient类中，它做了如下事：</p>
<ol>
<li>使用requests.session创建一个会话供全局使用。</li>
<li>构造请求登录的表单dict。</li>
<li>登录提交前先确认是否需要输入验证码，如果不需要直接提交，如果需要通过API把验证码图片下载到本地，然后等待在终端输入，确认验证成功后再提交。</li>
<li>提交成功后保存这个访问token，一段时间内就不用再登录了。<br>首先看初始化方法：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TOKEN_FILE = <span class="string">'token.json'</span>  <span class="comment"># 事实上应该放在config.py里面  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhihuClient</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, username=None, passwd=None, token_file=TOKEN_FILE)</span>:</span>  </span><br><span class="line">        self._session = requests.session()  </span><br><span class="line">        self._session.verify = <span class="literal">False</span>  </span><br><span class="line">        self.username = username  </span><br><span class="line">        self.passwd = passwd  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> os.path.exists(token_file):  </span><br><span class="line">            self._token = ZhihuToken.from_file(token_file)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            self._login_auth = ZhihuOAuth()  </span><br><span class="line">            json_dict = self.login()  </span><br><span class="line">            ZhihuToken.save_file(token_file, json_dict)  </span><br><span class="line">        self._session.auth = ZhihuOAuth(self._token)</span><br></pre></td></tr></table></figure>


<p>第一次是需要用户名和密码的，之后它们就不是必选的了，只有token_file是需要的。需要注意，zhihu-oauth项目中还包含如下一句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)</span><br></pre></td></tr></table></figure>


<p>要不然在一些环境中可以看到这个warn信息吗，其次是<code>self._session.verify = False</code>也很必要。<br>如果token_file不存在就会触发登录，方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">LOGIN_DATA = &#123;  </span><br><span class="line">     <span class="string">'grant_type'</span>: <span class="string">'password'</span>,  </span><br><span class="line">     <span class="string">'source'</span>: <span class="string">'com.zhihu.ios'</span>,  </span><br><span class="line">     <span class="string">'client_id'</span>: CLIENT_ID  </span><br><span class="line"> &#125;   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhihuClient</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span>  </span><br><span class="line">         data = LOGIN_DATA.copy()  </span><br><span class="line">         data[<span class="string">'username'</span>] = self.username  </span><br><span class="line">         data[<span class="string">'password'</span>] = self.passwd  </span><br><span class="line">         gen_login_signature(data)  </span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span> self.need_captcha():  </span><br><span class="line">             captcha_image = self.get_captcha()  </span><br><span class="line">             <span class="keyword">with</span> open(CAPTCHA_FILE, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                 f.write(captcha_image)  </span><br><span class="line">             print(<span class="string">'Please open &#123;0&#125; for captcha'</span>.format(  </span><br><span class="line">                 os.path.abspath(CAPTCHA_FILE)))  </span><br><span class="line">  </span><br><span class="line">             captcha = input(<span class="string">'captcha: '</span>)  </span><br><span class="line">             os.remove(os.path.abspath(CAPTCHA_FILE))  </span><br><span class="line">             res = self._session.post(  </span><br><span class="line">                 CAPTCHA_URL,  </span><br><span class="line">                 auth=self._login_auth,  </span><br><span class="line">                 data=&#123;<span class="string">'input_text'</span>: captcha&#125;  </span><br><span class="line">             )  </span><br><span class="line">             <span class="keyword">try</span>:  </span><br><span class="line">                 json_dict = res.json()  </span><br><span class="line">                 <span class="keyword">if</span> <span class="string">'error'</span> <span class="keyword">in</span> json_dict:  </span><br><span class="line">                     <span class="keyword">raise</span> LoginException(json_dict[<span class="string">'error'</span>][<span class="string">'message'</span>])  </span><br><span class="line">             <span class="keyword">except</span> (ValueError, KeyError) <span class="keyword">as</span> e:  </span><br><span class="line">                 <span class="keyword">raise</span> LoginException(<span class="string">'Maybe input wrong captcha value'</span>)   </span><br><span class="line">                   </span><br><span class="line">         res = self._session.post(LOGIN_URL, auth=self._login_auth, data=data)  </span><br><span class="line">         <span class="keyword">try</span>:  </span><br><span class="line">             json_dict = res.json()  </span><br><span class="line">             <span class="keyword">if</span> <span class="string">'error'</span> <span class="keyword">in</span> json_dict:  </span><br><span class="line">                 <span class="keyword">raise</span> LoginException(json_dict[<span class="string">'error'</span>][<span class="string">'message'</span>])  </span><br><span class="line">             self._token = ZhihuToken.from_dict(json_dict)  </span><br><span class="line">             <span class="keyword">return</span> json_dict  </span><br><span class="line">         <span class="keyword">except</span> (ValueError, KeyError) <span class="keyword">as</span> e:  </span><br><span class="line">             <span class="keyword">raise</span> LoginException(str(e))</span><br></pre></td></tr></table></figure>


<p>首先是构造表单数据，然后判断是否需要验证码（抽出来放在独立的方法中了）。顺便提一下，我习惯的方法的长度标准一般是一屏可以看完，再多了就会把一部分内容剥离开，但是一般也没必要剥离的那么分散，适用就好。<br>need_captcha方法也比较简单，总之无论哪一步出错我都抛LoginException退出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">need_captcha</span><span class="params">(self)</span>:</span>  </span><br><span class="line">     res = self._session.get(CAPTCHA_URL, auth=self._login_auth)  </span><br><span class="line">     <span class="keyword">try</span>:  </span><br><span class="line">         j = res.json()  </span><br><span class="line">         <span class="keyword">return</span> j[<span class="string">'show_captcha'</span>]  </span><br><span class="line">     <span class="keyword">except</span> KeyError:  </span><br><span class="line">         <span class="keyword">raise</span> LoginException(<span class="string">'Show captcha fail!'</span>)</span><br></pre></td></tr></table></figure>


<p>gen_login_signature我并没有去研究，直接抄袭了:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line"><span class="keyword">import</span> hmac  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> APP_SECRET  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_login_signature</span><span class="params">(data)</span>:</span>  </span><br><span class="line">    data[<span class="string">'timestamp'</span>] = str(int(time.time()))  </span><br><span class="line">  </span><br><span class="line">    params = <span class="string">''</span>.join([  </span><br><span class="line">        data[<span class="string">'grant_type'</span>],  </span><br><span class="line">        data[<span class="string">'client_id'</span>],  </span><br><span class="line">        data[<span class="string">'source'</span>],  </span><br><span class="line">        data[<span class="string">'timestamp'</span>],  </span><br><span class="line">    ])  </span><br><span class="line">  </span><br><span class="line">    data[<span class="string">'signature'</span>] = hmac.new(  </span><br><span class="line">        APP_SECRET, params.encode(<span class="string">'utf-8'</span>), hashlib.sha1).hexdigest()</span><br></pre></td></tr></table></figure>


<p>这样就实现了知乎登录以及拿到access_token，token都有了，想干什么就去干吧，对，正好明天周末。</p>
<h3 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h3><p>最后作为爬虫爱好者我提点意见，爬虫技术拿来分享，我很赞同；爬到数据去做分析，把分析的结果拿来分享我也支持。<br>但是 <strong>我严重鄙视把被爬取的网站的数据整理好直接放在百度网盘之类的共享行为!!</strong> 我教大家写爬虫，但请不要涉及工程师的道德底线和法律底线，很low。<br>之前我转载过一篇文章，当时也留了百度网盘地址但是里面的内容由于格式错乱并不能直接用，而且为了尊重原作者转载都是全部内容不去改动。但是随着最近这种爬虫文章越来越多，甚至感觉自己也做了帮凶，但以后绝不会再发这样的文章。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Python元类</title>
    <url>/2016-03-25.html</url>
    <content><![CDATA[<h3 id="什么是元类？"><a href="#什么是元类？" class="headerlink" title="什么是元类？"></a>什么是元类？</h3><p>理解元类（metaclass）之前，我们先了解下Python中的OOP和类（Class）。<br>面向对象全称 Object Oriented Programming<br>简称OOP，这种编程思想被大家所熟知。它是把对象作为一个程序的基本单元，把数据和功能封装在里面，能够实现很好的复用性，灵活性和扩展性。OOP中有2个基本概念：类和对象：</p>
<ol>
<li>类是描述如何创建一个对象的代码段，用来描述具有相同的属性和方法的对象的集合，它定义了该集合中每个对象所共有的属性和方法</li>
<li>对象是类的实例（Instance）。<br>我们举个例子：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span>  </span><br><span class="line">...:     <span class="keyword">pass</span>  </span><br><span class="line">...:  </span><br><span class="line">  </span><br><span class="line">In : my_object = ObjectCreator()  </span><br><span class="line">  </span><br><span class="line">In : my_object  </span><br><span class="line">Out: &lt;__main__.ObjectCreator at <span class="number">0x1082bbef0</span>&gt;</span><br></pre></td></tr></table></figure>


<p>而Python中的类并不是仅限于此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : print(ObjectCreator)  </span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>


<p>ObjectCreator竟然可以被print，所以它的类也是对象！既然类是对象，你就能动态地创建它们，就像创建任何对象那样。我在日常工作里面就会有这种动态创建类的需求，比如在mock数据的时候，现在有个函数func接收一个参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(instance)</span>:</span>  </span><br><span class="line">...:     print(instance.a, instance.b)  </span><br><span class="line">...:     print(instance.method_a(<span class="number">10</span>))  </span><br><span class="line">...:</span><br></pre></td></tr></table></figure>


<p>正常使用起来传入的instance是符合需求的（有a、b属性和method_a方法），但是当我想单独调试func的时候，需要「造」一个，假如不用元类，应该是这样写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="function"><span class="keyword">def</span> <span class="title">generate_cls</span><span class="params">(a, b)</span>:</span>  </span><br><span class="line">...:     <span class="class"><span class="keyword">class</span> <span class="title">Fake</span><span class="params">(object)</span>:</span>  </span><br><span class="line">...:         <span class="function"><span class="keyword">def</span> <span class="title">method_a</span><span class="params">(self, n)</span>:</span>  </span><br><span class="line">...:             <span class="keyword">return</span> n  </span><br><span class="line">...:     Fake.a = a  </span><br><span class="line">...:     Fake.b = b  </span><br><span class="line">...:     <span class="keyword">return</span> Fake  </span><br><span class="line">...:  </span><br><span class="line">  </span><br><span class="line">In : ins = generate_cls(<span class="number">1</span>, <span class="number">2</span>)()  </span><br><span class="line">  </span><br><span class="line">In : ins.a, ins.b, ins.method_a(<span class="number">10</span>)  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>


<p>你会发现这不算算是「动态创建」的：</p>
<ol>
<li>类名（Fake）不方便改变</li>
<li>要创建的类需要的属性和方法越多，就要对应的加码，不灵活。<br>我平时怎么做呢：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="function"><span class="keyword">def</span> <span class="title">method_a</span><span class="params">(self, n)</span>:</span>  </span><br><span class="line">...:     <span class="keyword">return</span> n  </span><br><span class="line">...:   </span><br><span class="line">In : ins = type(<span class="string">'Fake'</span>, (), &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'method_a'</span>: method_a&#125;)()  </span><br><span class="line">  </span><br><span class="line">In : ins.a, ins.b, ins.method_a(<span class="number">10</span>)  </span><br><span class="line">Out: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>


<p>到了这里，引出了type函数。本来它用来能让你了解一个对象的类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : type(<span class="number">1</span>)  </span><br><span class="line">Out: int  </span><br><span class="line">  </span><br><span class="line">In : type(<span class="string">'1'</span>)  </span><br><span class="line">Out: str  </span><br><span class="line">  </span><br><span class="line">In : type(ObjectCreator)  </span><br><span class="line">Out: type  </span><br><span class="line">  </span><br><span class="line">In : type(ObjectCreator())  </span><br><span class="line">Out: __main__.ObjectCreator</span><br></pre></td></tr></table></figure>


<p>另外，type如上所说还可以动态地创建类：type可以把对于类的描述作为参数，并返回一个类。<br>用来创建类的东东就是「元类」，放张图吧：<br>![](<a href="https://user-" target="_blank" rel="noopener">https://user-</a><br>images.githubusercontent.com/841395/32538344-4d71e8ac-c42b-11e7-93da-32869bb5c0.png)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>


<p>这种用法就是由于type实际上是一个元类，作为元类的type在Python中被用于在后台创建所有的类。在Python语言上有个说法「Everything<br>is an object」。包整数、字符串、函数和类… 所有这些都是对象。所有这些都是由一个类创建的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : age = <span class="number">35</span>  </span><br><span class="line">In : age.__class__  </span><br><span class="line">Out: int  </span><br><span class="line">  </span><br><span class="line">In : name = <span class="string">'bob'</span>  </span><br><span class="line">In : name.__class__  </span><br><span class="line">Out: str  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>现在，任何<strong>class</strong>中的特定<strong>class</strong>是什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : age.__class__.__class__  </span><br><span class="line">Out: type  </span><br><span class="line">  </span><br><span class="line">In : name.__class__.__class__  </span><br><span class="line">Out: type  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>如果你愿意，你可以把type称为「类工厂」。type是Python中内建元类，当然，你也可以创建你自己的元类。</p>
<h3 id="创建自己的元类"><a href="#创建自己的元类" class="headerlink" title="创建自己的元类"></a>创建自己的元类</h3><p>Python2创建类的时候，可以添加一个<strong>metaclass</strong>属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    __metaclass__ = something...  </span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure>


<p>如果你这样做，Python会使用元类来创建Foo这个类。Python会在类定义中寻找<strong>metaclass</strong>。如果找到它，Python会用它来创建对象类Foo。如果没有找到它，Python将使用type来创建这个类。<br>在Python3中语法改变了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple1</span><span class="params">(object, metaclass=something...)</span>:</span>  </span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure>


<p>本质上是一样的。拿一个4年前写分享的元类例子（就是为了推荐你来阅读<br>😉<a href="https://github.com/dongweiming/Expert-Python" target="_blank" rel="noopener">我的PPT：《Python高级编程》</a> ）吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMeta</span><span class="params">(type)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span>  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span>  </span><br><span class="line">            self.func = func  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span>  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'hello world'</span>  </span><br><span class="line">        t = type.__new__(cls, name, bases, attrs)  </span><br><span class="line">        t.__init__ = __init__  </span><br><span class="line">        t.hello = hello  </span><br><span class="line">        <span class="keyword">return</span> t  </span><br><span class="line">          </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">New_Hello</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    __metaclass__ = HelloMeta</span><br></pre></td></tr></table></figure>


<p>New_Hello初始化需要添加一个参数，并包含一个叫做hello的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : h = New_Hello(<span class="keyword">lambda</span> x: x)  </span><br><span class="line">  </span><br><span class="line">In : h.func(<span class="number">10</span>), h.hello()  </span><br><span class="line">hello world  </span><br><span class="line">Out: (<span class="number">10</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>


<p>PS: 这个例子只能运行于Python2。<br>在Python里<strong>new</strong>方法创建实例，<strong>init</strong>负责初始化一个实例。对于type也是一样的效果，只不过针对的是「类」，在上面的HelloMeta中只使用了<strong>new</strong>创建类，我们再感受一个使用<strong>init</strong>的元类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="class"><span class="keyword">class</span> <span class="title">HelloMeta2</span><span class="params">(type)</span>:</span>  </span><br><span class="line">...:     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attrs)</span>:</span>  </span><br><span class="line">...:         super(HelloMeta2, cls).__init__(name, bases, attrs)  </span><br><span class="line">...:         attrs_ = &#123;&#125;  </span><br><span class="line">...:         <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():  </span><br><span class="line">...:             <span class="keyword">if</span> <span class="keyword">not</span> k.startswith(<span class="string">'__'</span>):  </span><br><span class="line">...:                 attrs_[k] = v  </span><br><span class="line">...:         setattr(cls, <span class="string">'_new_dict'</span>, attrs_)  </span><br><span class="line">...:  </span><br><span class="line">...:</span><br></pre></td></tr></table></figure>


<p>别往下看。思考下这样创建出来的类有什么特殊的地方？<br>我揭晓一下（这次使用Python 3语法）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="class"><span class="keyword">class</span> <span class="title">New_Hello2</span><span class="params">(metaclass=HelloMeta2)</span>:</span>  </span><br><span class="line">...:     a = <span class="number">1</span>  </span><br><span class="line">...:     b = <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In : New_Hello2._new_dict  </span><br><span class="line">Out: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="literal">True</span>&#125;  </span><br><span class="line">  </span><br><span class="line">In : h2 = New_Hello2()  </span><br><span class="line">  </span><br><span class="line">In : h2._new_dict  </span><br><span class="line">Out: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure>


<p>有点明白么？其实就是在创建类的时候把类的属性循环了一遍把不是__开头的属性最后存在了_new_dict上。</p>
<h3 id="什么时候需要用元类？"><a href="#什么时候需要用元类？" class="headerlink" title="什么时候需要用元类？"></a>什么时候需要用元类？</h3><p>日常的业务逻辑开发是不太需要使用到元类的，因为元类是用来拦截和修改类的创建的，用到的场景很少。我能想到最典型的场景就是 ORM。ORM就是「对象 关系<br>映射」的意思，简单的理解就是把关系数据库的一张表映射成一个类，一行记录映射为一个对象。ORM框架中的Model只能动态定义，因为这个模式下这些关系只能是由使用者来定义，元类再配合描述符就可以实现ORM了，现在做个预告，未来我会分享「如何写一个ORM」这个主题。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">What is a metaclass in Python?</a></li>
<li><a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/" target="_blank" rel="noopener">Understanding Python metaclasses</a></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>《Python Web开发实战》要输出到台湾了</title>
    <url>/2016-03-26.html</url>
    <content><![CDATA[<p>非常高兴地告诉大家，<a href="http://item.jd.com/11966737.html" target="_blank" rel="noopener">《Python Web开发实战》</a>要输出到台湾去了。<br>之前由于豆瓣2014年会在台湾举行的原因去了一次台北，非常喜欢这个城市。希望下次去台湾旅行的时候能去诚品看到它啦</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3.7中的PEP562</title>
    <url>/2016-03-27.html</url>
    <content><![CDATA[<p>按照Python3.7的发布时间表，明天Python 3.7.0就发布了，最近各大开源项目都在做3.7相关的调整，之后我还会写文章更详细的介绍Python<br>3.7都带来了什么，敬请关注！Python 3.7是一个比较中庸的版本，我比较关注的是<a href="https://www.python.org/dev/peps/pep-0557/" target="_blank" rel="noopener">PEP<br>557</a> 和 本文要提到的 <a href="https://www.python.org/dev/peps/pep-0562/" target="_blank" rel="noopener">PEP<br>562</a>。<br>PEP557是Data Classes，之前我已经在 <a href="http://www.dongwm.com/archives/attrs-%E5%92%8C-Python3-7-%E7%9A%84-dataclasses/" target="_blank" rel="noopener">attrs 和 Python3.7 的<br>dataclasses</a>里面专门介绍了。<br>PEP 562主要做的是什么呢？</p>
<blockquote>
<p>Customization of Access to Module Attributes<br>就是能在模块下定义<strong>getattr</strong>和<strong>dir</strong>方法，实现定制访问模块属性了。有什么用呢？其实官网已经给出了答案：</p>
</blockquote>
<ol>
<li>弃用某些属性/函数</li>
<li>懒加载(lazy loading)<br><strong>getattr</strong>让模块属性的访问非常灵活，我分别举几个例子：<h3 id="弃用某些属性-函数时"><a href="#弃用某些属性-函数时" class="headerlink" title="弃用某些属性/函数时"></a>弃用某些属性/函数时</h3>有时候会修改一些函数或者属性，会写新的版本，旧版本的在一段时间之后会弃用。在大型项目中调用者有很多，不了解业务挨处修改成本很高，通常会在旧版本的函数中加入DeprecationWarning，有3个问题：</li>
<li>使用新的属性是没法提示DeprecationWarning，只能在模块级别加warn</li>
<li>如果找不到属性/函数直接抛错误了，不能做特殊处理</li>
<li>模块下弃用的函数多了，只能在每个函数内部加入warn，再执行新函数逻辑<br>而Python 3.7就没这个问题了：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># lib.py  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> warnings  </span><br><span class="line">  </span><br><span class="line">warnings.filterwarnings(<span class="string">'default'</span>)  <span class="comment"># Python 3.2开始默认会隐藏DeprecationWarning  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_function</span><span class="params">(arg, other)</span>:</span>  </span><br><span class="line">    print(<span class="string">'plz use me!'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">_deprecated_map = &#123;  </span><br><span class="line">    <span class="string">'old_function'</span>: new_function  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(name)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> _deprecated_map:  </span><br><span class="line">        switch_to = _deprecated_map[name]  </span><br><span class="line">        warnings.warn(<span class="string">f'<span class="subst">&#123;name&#125;</span> is deprecated. Switch to <span class="subst">&#123;__name__&#125;</span>.<span class="subst">&#123;switch_to.__name__&#125;</span>.'</span>,  </span><br><span class="line">             DeprecationWarning)  </span><br><span class="line">        <span class="keyword">return</span> switch_to  </span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">f"module <span class="subst">&#123;__name__&#125;</span> has no attribute <span class="subst">&#123;name&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>


<p>看一下效果吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lib <span class="keyword">import</span> old_function  </span><br><span class="line">/Users/dongwm/test/lib.py:<span class="number">18</span>: DeprecationWarning: old_function <span class="keyword">is</span> deprecated. Switch to lib.new_function.  </span><br><span class="line">  DeprecationWarning)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>old_function  </span><br><span class="line">&lt;function new_function at <span class="number">0x10ad30f28</span>&gt;  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>old_function(<span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line">plz use me!</span><br></pre></td></tr></table></figure>


<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><blockquote>
</blockquote>
<p>懒加载是指从一个数据对象通过方法获得里面的一个属性对象时，这个对应对象实际并没有随其父数据对象创建时一起保存在运行空间中，而是在其读取方法第一次被调用时才从其他数据源中加载到运行空间中，这样可以避免过早地导入过大的数据对象但并没有使用的空间占用浪费。<br>简单地说，按需才加载。这是一种设计模式。<br>Python3.7之前想要import模块成功，就得在模块里面把相关属性/函数/类等都准备好，其实import模块时候是很重的，现在可以通过PEP<br>562，能够极大的提升import的效率，尤其是导入了很重的逻辑。就如PEP中提的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># lib/__init__.py  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> importlib  </span><br><span class="line">  </span><br><span class="line">__all__ = [<span class="string">'submod'</span>, ...]  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(name)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> __all__:  </span><br><span class="line">        <span class="keyword">return</span> importlib.import_module(<span class="string">"."</span> + name, __name__)  </span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">f"module <span class="subst">&#123;__name__!r&#125;</span> has no attribute <span class="subst">&#123;name!r&#125;</span>"</span>)  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># lib/submod.py  </span></span><br><span class="line">  </span><br><span class="line">print(<span class="string">"Submodule loaded"</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeavyClass</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># main.py  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> lib  </span><br><span class="line">lib.submodule.HeavyClass  <span class="comment"># prints "Submodule loaded"</span></span><br></pre></td></tr></table></figure>


<p>可以看到，<code>import lib</code>的时候，HeavyClass还没有没有加载的，当第一次使用lib.submodule的时候才会加载。<br>在标准库里面也有应用，比如 <a href="https://bugs.python.org/issue32596" target="_blank" rel="noopener">bpo-32596</a> 中对<br>concurrent.futures 模块的修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__dir__</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> __all__ + (<span class="string">'__author__'</span>, <span class="string">'__doc__'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(name)</span>:</span>  </span><br><span class="line">    <span class="keyword">global</span> ProcessPoolExecutor, ThreadPoolExecutor  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'ProcessPoolExecutor'</span>:  </span><br><span class="line">        <span class="keyword">from</span> .process <span class="keyword">import</span> ProcessPoolExecutor <span class="keyword">as</span> pe  </span><br><span class="line">        ProcessPoolExecutor = pe  </span><br><span class="line">        <span class="keyword">return</span> pe  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'ThreadPoolExecutor'</span>:  </span><br><span class="line">        <span class="keyword">from</span> .thread <span class="keyword">import</span> ThreadPoolExecutor <span class="keyword">as</span> te  </span><br><span class="line">        ThreadPoolExecutor = te  </span><br><span class="line">        <span class="keyword">return</span> te  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">f"module <span class="subst">&#123;__name__&#125;</span> has no attribute <span class="subst">&#123;name&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>


<p>这样还可以让<code>import asyncio</code>时可以快15%。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>我理解的python最佳实践</title>
    <url>/2016-03-28.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对我来说, 以前每次面试是我审视自己, 检验自己的一种方式. 每次准备面试, 以及被面试官问住的时候才会发现,<br>其实我python我学的还不够好; 工作中也是, 可以从其他的同事那里获得成长. 但是我今天说的是, 我也在自己总结和思考<code>最佳实践</code>这件事.<br>我想很多人都会有意识的去读一些PEP(Python Enhancement Proposals). 了解语言设计者当时的考虑,<br>这些文案也是经过很长时间的讨论最后才实施的.<br>既然想用好这门语言, 必然需要理解设计之美. 比如我听说gvanrossum使用emacs作为编辑器, 我也使用emacs,<br>就是希望我可以更贴近一些python<br>本文根据 <a href="https://gist.github.com/sloria/7001839" target="_blank" rel="noopener">The Best of the Best Practices (BOBP) Guide for<br>Python</a> 和 [Khan’s style-<br>guides](<a href="https://github.com/Khan/style-" target="_blank" rel="noopener">https://github.com/Khan/style-</a><br>guides/blob/master/style/python.md)中对于开发中一些事物的理解和看法, 有出至PEP, 也有一些python界知名开发者,<br>我加入了一些我自己的理解和看法.</p>
<h3 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h3><h4 id="“Build-tools-for-others-that-you-want-to-be-built-for-you-”-Kenneth"><a href="#“Build-tools-for-others-that-you-want-to-be-built-for-you-”-Kenneth" class="headerlink" title="“Build tools for others that you want to be built for you.” - Kenneth"></a>“Build tools for others that you want to be built for you.” - Kenneth</h4><p>Reitz (requests等知名库作者)<br>你自己都不想用的东西做出来有什么意义呢?</p>
<h4 id="“Simplicity-is-alway-better-than-functionality-”-Pieter-Hintjens"><a href="#“Simplicity-is-alway-better-than-functionality-”-Pieter-Hintjens" class="headerlink" title="“Simplicity is alway better than functionality.” - Pieter Hintjens"></a>“Simplicity is alway better than functionality.” - Pieter Hintjens</h4><p>(ZeroMQ)<br>我对函数式编程的看法一直是<code>看场景</code>, 甚至于我经常会对比性能, 义无反顾的使用性能最好的, 但是代码又不难懂和繁琐的</p>
<h4 id="“Fit-the-90-use-case-Ignore-the-nay-sayers-”-Kenneth-Reitz"><a href="#“Fit-the-90-use-case-Ignore-the-nay-sayers-”-Kenneth-Reitz" class="headerlink" title="“Fit the 90% use-case. Ignore the nay sayers.” - Kenneth Reitz"></a>“Fit the 90% use-case. Ignore the nay sayers.” - Kenneth Reitz</h4><p>程序员都有完美主义情怀, 但是其实往往我们是在偏激的看事情 - 用户其实不case</p>
<h4 id="“Beautiful-is-better-than-ugly-”-PEP"><a href="#“Beautiful-is-better-than-ugly-”-PEP" class="headerlink" title="“Beautiful is better than ugly.” - [PEP"></a>“Beautiful is better than ugly.” - [PEP</h4><p>20](<a href="http://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">http://www.python.org/dev/peps/pep-0020/</a>)</p>
<h3 id="开发参考"><a href="#开发参考" class="headerlink" title="开发参考"></a>开发参考</h3><h4 id="“Explicit-is-better-than-implicit”-PEP-20-“Explicit-is-better-than"><a href="#“Explicit-is-better-than-implicit”-PEP-20-“Explicit-is-better-than" class="headerlink" title="“Explicit is better than implicit” - [PEP 20](“Explicit is better than"></a>“Explicit is better than implicit” - [PEP 20](“Explicit is better than</h4><p>implicit” - PEP 20)<br>不要留坑, 我经常看到一些复杂的代码, 这些代码的作者写的时候明显知道自己在做什么, 但是别人很难维护和看懂.<br>所以我对自己的职业的基本要求就是: 那天我离职了, 后来接手的人不会经常骂我</p>
<h4 id="“Readability-counts-”-PEP-20"><a href="#“Readability-counts-”-PEP-20" class="headerlink" title="“Readability counts.” - PEP 20"></a>“Readability counts.” - <a href="http://www.python.org/dev/peps/pep-0020" target="_blank" rel="noopener">PEP 20</a></h4><h4 id="“Anybody-can-fix-anything-”-Khan’s-style"><a href="#“Anybody-can-fix-anything-”-Khan’s-style" class="headerlink" title="“Anybody can fix anything.” - [Khan’s style-"></a>“Anybody can fix anything.” - [Khan’s style-</h4><p>guides](<a href="https://github.com/Khan/style-guides/blob/master/style/python.md" target="_blank" rel="noopener">https://github.com/Khan/style-guides/blob/master/style/python.md</a>)<br>我现在更多不是代码炫技, 我经常思考的怎么让最少的代码, 最简单的设计结构满足当前需求, 也能给未来一段时间里也有扩展性</p>
<h4 id="Fix-each-broken-window-bad-design-wrong-decision-or-poor-code-as-soon"><a href="#Fix-each-broken-window-bad-design-wrong-decision-or-poor-code-as-soon" class="headerlink" title="Fix each broken window (bad design, wrong decision, or poor code) as soon"></a>Fix each broken window (bad design, wrong decision, or poor code) as soon</h4><p>as it is discovered.<br>我们改bug有个原则 - 测试要覆盖到出bug的地方. 每个人内心都有很高的代码质量的要求</p>
<h4 id="“Now-is-better-than-never-”-PEP"><a href="#“Now-is-better-than-never-”-PEP" class="headerlink" title="“Now is better than never.” - [PEP"></a>“Now is better than never.” - [PEP</h4><p>20](<a href="http://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">http://www.python.org/dev/peps/pep-0020/</a>)<br>明日复明日, 明日何其多. 我们在代码review的时候, 问题需要在提出的时候就去改, 永远不会说下一次再说, 因为下一次大多时候是没有下一次了</p>
<h4 id="Test-ruthlessly-Write-docs-for-new-features"><a href="#Test-ruthlessly-Write-docs-for-new-features" class="headerlink" title="Test ruthlessly. Write docs for new features."></a>Test ruthlessly. Write docs for new features.</h4><h4 id="Even-more-important-that-Test-Driven-Development–Human-Driven-Development"><a href="#Even-more-important-that-Test-Driven-Development–Human-Driven-Development" class="headerlink" title="Even more important that Test-Driven Development–Human-Driven Development"></a>Even more important that Test-Driven Development–Human-Driven Development</h4><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><h4 id="PEP8"><a href="#PEP8" class="headerlink" title="PEP8"></a>PEP8</h4><p>很多人是排斥的, 假如你想让未来部门有自己的风格, 习惯. 让新人马上上手接受, PEP8是一个非常明智的选择</p>
<h4 id="文件开头"><a href="#文件开头" class="headerlink" title="文件开头"></a>文件开头</h4><p>新的文件的开头需要加一些docstring. 描述文件的作用, 编辑者, 修改原因和日期等帮助阅读者的描述.<br>不要添加<code>#!/usr/bin/python</code>(除非这个文件未来是一个可执行的文件), copyright, <strong>author</strong>或者其他内容.<br>第一行建议添加<code># coding-utf-8</code></p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ol>
<li>Variables, functions, methods, packages, modules<br>lower_case_with_underscores</li>
<li>Classes and Exceptions<br>CapWords</li>
<li>Protected methods and internal functions<br>_single_leading_underscore(self, …)</li>
<li>Private methods<br>__double_leading_underscore(self, …)</li>
<li>Constants<br>ALL_CAPS_WITH_UNDERSCORES</li>
<li>Avoid one-letter variables (esp. l, O, I).<br>永远不要使用没有意义的单字符作为变量名<br>PS: 这点可以折中, 假如一个代码块代码逻辑很清晰, 而 这个短的便令也只是过程中的一个间接变量之类的情况下是可以接受的<h3 id="Good-or-Bad"><a href="#Good-or-Bad" class="headerlink" title="Good or Bad"></a>Good or Bad</h3>列举一些正确和错误的用法.<h4 id="Avoid-redundant-labeling"><a href="#Avoid-redundant-labeling" class="headerlink" title="Avoid redundant labeling."></a>Avoid redundant labeling.</h4></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Good  </span></span><br><span class="line"><span class="keyword">import</span> audio  </span><br><span class="line">  </span><br><span class="line">core = audio.Core()  </span><br><span class="line">controller = audio.Controller()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Bad  </span></span><br><span class="line"><span class="keyword">import</span> audio  </span><br><span class="line">  </span><br><span class="line">core = audio.AudioCore()  </span><br><span class="line">controller = audio.AudioController()</span><br></pre></td></tr></table></figure>


<p>不要使用重复意义的标签</p>
<h4 id="Prefer-“reverse-notation”"><a href="#Prefer-“reverse-notation”" class="headerlink" title="Prefer “reverse notation”."></a>Prefer “reverse notation”.</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Good  </span></span><br><span class="line">elements = ...  </span><br><span class="line">elements_active = ...  </span><br><span class="line">elements_defunct = ...  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Bad  </span></span><br><span class="line">elements = ...  </span><br><span class="line">active_elements = ...  </span><br><span class="line">defunct_elements ...</span><br></pre></td></tr></table></figure>


<h4 id="Avoid-getter-and-setter-methods"><a href="#Avoid-getter-and-setter-methods" class="headerlink" title="Avoid getter and setter methods."></a>Avoid getter and setter methods.</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Good  </span></span><br><span class="line">person.age = <span class="number">42</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Bad  </span></span><br><span class="line">person.set_age(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>


<h4 id="Indentation"><a href="#Indentation" class="headerlink" title="Indentation"></a>Indentation</h4><p>永远不要Tab和空格混用. 使用4个空格作为python缩进</p>
<h4 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h4><p>Import entire modules instead of individual symbols within a module.<br>PS: 这个时候可以参考tornado的代码用法.<br>比如现在有这样一个包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ tree  </span><br><span class="line">└── canteen  </span><br><span class="line">    ├── __init__.py  </span><br><span class="line">    ├── sessions.py</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Good  </span></span><br><span class="line"><span class="keyword">import</span> canteen  </span><br><span class="line"><span class="keyword">import</span> canteen.sessions  </span><br><span class="line"><span class="keyword">from</span> canteen <span class="keyword">import</span> sessions  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Bad  </span></span><br><span class="line"><span class="keyword">from</span> canteen <span class="keyword">import</span> get_user  <span class="comment"># Symbol from canteen/__init__.py  </span></span><br><span class="line"><span class="keyword">from</span> canteen.sessions <span class="keyword">import</span> get_session  <span class="comment"># Symbol from canteen/sessions.py</span></span><br></pre></td></tr></table></figure>


<p>PS: 除非这个第三方模块的文档显式的要求这些写</p>
<h4 id="Splitting-tricky-lines"><a href="#Splitting-tricky-lines" class="headerlink" title="Splitting tricky lines"></a>Splitting tricky lines</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Bad:  </span></span><br><span class="line">badge_name = badges.topic_exercise_badges.TopicExerciseBadge.name_for_topic_key_name(self.key().name())  </span><br><span class="line"><span class="comment"># Good:  </span></span><br><span class="line">badge_name = (badges.topic_exercise_badges.TopicExerciseBadge  </span><br><span class="line">              .name_for_topic_key_name(self.key().name()))  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Bad:  </span></span><br><span class="line">self.redirect(<span class="string">"/class_profile?selected_graph_type=%s&amp;coach_email=%s&amp;graph_query_params=%s"</span> %  </span><br><span class="line">    (self.GRAPH_TYPE, urllib.quote(coach.email), urllib.quote(urllib.quote(self.request.query_string))))  </span><br><span class="line"><span class="comment"># Good:  </span></span><br><span class="line">self.redirect(  </span><br><span class="line">    <span class="string">"/class_profile?selected_graph_type=%s&amp;coach_email=%s"</span>  </span><br><span class="line">    <span class="string">"&amp;graph_query_params=%s"</span> % (  </span><br><span class="line">        self.GRAPH_TYPE,  </span><br><span class="line">        urllib.quote(coach.email),  </span><br><span class="line">        urllib.quote(urllib.quote(self.request.query_string))))</span><br></pre></td></tr></table></figure>


<h3 id="我添加的规则"><a href="#我添加的规则" class="headerlink" title="我添加的规则"></a>我添加的规则</h3><h4 id="from-…-import-…"><a href="#from-…-import-…" class="headerlink" title="from … import …"></a>from … import …</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Bad  </span></span><br><span class="line"><span class="keyword">from</span> aa <span class="keyword">import</span> alonglonglonglonglong, alonglonglonglonglonglonglonglonglong, \  </span><br><span class="line">               alonglonglonglonglonglong  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Good  </span></span><br><span class="line"><span class="keyword">from</span> aa <span class="keyword">import</span> (alonglonglonglonglong, alonglonglonglonglonglonglonglonglong,  </span><br><span class="line">                alonglonglonglonglonglong)  </span><br><span class="line"><span class="keyword">from</span> aa <span class="keyword">import</span> (alonglonglonglonglong, alonglonglonglonglonglonglonglonglong,  </span><br><span class="line">    alonglonglonglonglonglong, alonglonglonglonglonglonglong,  </span><br><span class="line">    alonglonglonglonglonglong2)  <span class="comment"># Good。 当引入的函数/类/变量很多时， 也可以选择空 4 个空格的方式， 而不需要和首行的左括号后对齐</span></span><br></pre></td></tr></table></figure>


<h4 id="相对引用-relative-import-和-绝对引用-absolute-import"><a href="#相对引用-relative-import-和-绝对引用-absolute-import" class="headerlink" title="相对引用(relative import) 和 绝对引用(absolute import)"></a>相对引用(relative import) 和 绝对引用(absolute import)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$cat xx/models/user/consts.py  <span class="comment"># 如果想引用这个变量  </span></span><br><span class="line">TMP = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">$cat xx/views/user.py  </span><br><span class="line"><span class="keyword">from</span> xx.models.user.consts <span class="keyword">import</span> TMP  <span class="comment"># recommended。  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 假如模块层级&gt;=3。 比如 xx/models/user/consts.py 就在根目录下的第 3 级。 如果其他当前目录下源文件需要调用它的内容。 也可以选择相对引用  </span></span><br><span class="line">$cat xx/models/user/main.py  <span class="comment"># 需要和 consts.py 在一个目录下才可以  </span></span><br><span class="line"><span class="keyword">from</span> consts <span class="keyword">import</span> TMP  <span class="comment"># Bad  </span></span><br><span class="line"><span class="keyword">from</span> .consts <span class="keyword">import</span> TMP  <span class="comment"># Good  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 而且只能在包内相对引用。 包外都需要绝对引用</span></span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用grafana和Diamond构建Graphite监控系统</title>
    <url>/2016-03-29.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在豆瓣开源项目里面有个<a href="https://github.com/douban/graph-index" target="_blank" rel="noopener">graph-index</a>,<br>提供监控服务器的状态的目录索引,基于<a href="https://github.com/vimeo/graph-explorer" target="_blank" rel="noopener">graph-explorer</a>.<br>类似衍生物很多,就包括我要说的本文用到的项目.先看看我的测试环境的几个截图<br><img src="https://cloud.githubusercontent.com/assets/841395/9101045/7a64742a-3c14-11e5-92e7-012c713596e3.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/9101046/7a6a2ec4-3c14-11e5-8aeb-0158c20e8c6b.png" alt></p>
<h4 id="一些关键词说明"><a href="#一些关键词说明" class="headerlink" title="一些关键词说明"></a>一些关键词说明</h4><ol>
<li>graphite-web # graphite组件之一, 提供一个django的可以高度扩展的实时画图系统</li>
<li>Whisper # graphite组件之一, 实现数据库存储. 它比rrdtool要慢，因为whisper是使用python写的，而rrdtool是使用C写的。然而速度之间的差异很小</li>
<li>Carbon # 数据收集的结果会传给它, 它会解析数据让它可用于实时绘图. 它默认可会提示一些类型的数据,监听2003和2004端口</li>
<li><a href="https://github.com/BrightcoveOS/Diamond" target="_blank" rel="noopener">Diamond</a> # 他是一个提供了大部分数据收集结果功能的结合,类似cpu, load, memory以及mongodb,rabbitmq,nginx等指标.这样就不需要我大量的写各种类型,因为它都已经提供,并且它提供了可扩展的自定义类型(最后我会展示一个我自己定义的类型)</li>
<li><a href="https://github.com/torkelo/grafana" target="_blank" rel="noopener">grafana</a> # 这个面板是基于node, <a href="https://github.com/elasticsearch/kibana" target="_blank" rel="noopener">kibana</a>,并且可以在线编辑. 因为是kibana,所以也用到了开元搜索框架<a href="https://github.com/elasticsearch/elasticsearch" target="_blank" rel="noopener">elasticsearch</a><br>PS: 其他工具可以参考这里<a href="http://graphite.readthedocs.org/en/1.0/tools.html" target="_blank" rel="noopener">Tools That Work With<br>Graphite</a><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4>我没有看实际全部代码,大概的流程是这样的:</li>
<li>启动Carbon-cache等待接收数据(carbon用的是twisted)</li>
<li>启动graphite-web给grafana提供实时绘图数据api</li>
<li>启动grafana,调用graphite-web接口获取数据展示出来</li>
<li>Diamond定期获取各类要监测的类型数据发给carbon(默认是5分钟,默认一小时自动重载一次配置)<h4 id="实现我这个系统需要做的事情"><a href="#实现我这个系统需要做的事情" class="headerlink" title="实现我这个系统需要做的事情"></a>实现我这个系统需要做的事情</h4><h5 id="安装graphite相关组件-我这里用的是centos"><a href="#安装graphite相关组件-我这里用的是centos" class="headerlink" title="安装graphite相关组件(我这里用的是centos)"></a>安装graphite相关组件(我这里用的是centos)</h5></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yum --enablerepo=epel install graphite-web python-carbon -y</span><br></pre></td></tr></table></figure>


<h6 id="安装grafana需要的组件"><a href="#安装grafana需要的组件" class="headerlink" title="安装grafana需要的组件"></a>安装grafana需要的组件</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 增加elasticsearch的repo:  </span></span><br><span class="line">sudo  rpm --<span class="keyword">import</span> http://packages.elasticsearch.org/GPG-KEY-elasticsearch  </span><br><span class="line">$cat /etc/yum.repos.d/elasticsearch.repo  </span><br><span class="line">[elasticsearch<span class="number">-1.0</span>]  </span><br><span class="line">name=Elasticsearch repository <span class="keyword">for</span> <span class="number">1.0</span>.x packages  </span><br><span class="line">baseurl=http://packages.elasticsearch.org/elasticsearch/<span class="number">1.0</span>/centos  </span><br><span class="line">gpgcheck=<span class="number">1</span>  </span><br><span class="line">gpgkey=http://packages.elasticsearch.org/GPG-KEY-elasticsearch  </span><br><span class="line">enabled=<span class="number">1</span>  </span><br><span class="line">sudo yum install nginx nodejs npm java<span class="number">-1.7</span><span class="number">.0</span>-openjdk elasticsearch -y</span><br></pre></td></tr></table></figure>


<h5 id="下载Diamond和grafana"><a href="#下载Diamond和grafana" class="headerlink" title="下载Diamond和grafana"></a>下载Diamond和grafana</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/torkelo/grafana  </span><br><span class="line">cd grafana  </span><br><span class="line">sudo npm install  </span><br><span class="line">sudo pip install django-cors-headers configobj <span class="comment"># 这可能因为我环境中已经有了一些模块，看缺什么安装什么  </span></span><br><span class="line">git clone https://github.com/BrightcoveOS/Diamond  </span><br><span class="line">cd Diamond</span><br></pre></td></tr></table></figure>


<h5 id="开始修改配置"><a href="#开始修改配置" class="headerlink" title="开始修改配置"></a>开始修改配置</h5><ol>
<li>添加cors支持<br>在/usr/lib/python2.6/site-packages/graphite/app_settings.py:<br>INSTALLED_APPS里面添加corsheaders,<br>MIDDLEWARE_CLASSES里面添加’corsheaders.middleware.CorsMiddleware’</li>
<li>使用nginx使用grafana<br>在nginx.conf 添加类型的一段配置</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;  </span><br><span class="line">  listen                *:<span class="number">80</span> ;  </span><br><span class="line">  </span><br><span class="line">  server_name           monitor.dongwm.com; <span class="comment"># 我用了虚拟主机  </span></span><br><span class="line">  access_log            /var/log/nginx/kibana.myhost.org.access.log;  </span><br><span class="line">  </span><br><span class="line">  location / &#123;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">"$http_origin"</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;  </span><br><span class="line">    root  /home/operation/dongwm/grafana/src;  </span><br><span class="line">    index  index.html  index.htm;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  location ~ ^/_aliases$ &#123;  </span><br><span class="line">    proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>;  </span><br><span class="line">    proxy_read_timeout <span class="number">90</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  location ~ ^/_nodes$ &#123;  </span><br><span class="line">    proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>;  </span><br><span class="line">    proxy_read_timeout <span class="number">90</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  location ~ ^/.*/_search$ &#123;  </span><br><span class="line">    proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>;  </span><br><span class="line">    proxy_read_timeout <span class="number">90</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  location ~ ^/.*/_mapping$ &#123;  </span><br><span class="line">    proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>;  </span><br><span class="line">    proxy_read_timeout <span class="number">90</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Password protected end points  </span></span><br><span class="line">  location ~ ^/kibana-int/dashboard/.*$ &#123;  </span><br><span class="line">    proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>;  </span><br><span class="line">    proxy_read_timeout <span class="number">90</span>;  </span><br><span class="line">    limit_except GET &#123;  </span><br><span class="line">      proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>;  </span><br><span class="line">      auth_basic <span class="string">"Restricted"</span>;  </span><br><span class="line">      auth_basic_user_file /etc/nginx/conf.d/dongwm.htpasswd;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  location ~ ^/kibana-int/temp.*$ &#123;  </span><br><span class="line">    proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>;  </span><br><span class="line">    proxy_read_timeout <span class="number">90</span>;  </span><br><span class="line">    limit_except GET &#123;  </span><br><span class="line">      proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>;  </span><br><span class="line">      auth_basic <span class="string">"Restricted"</span>;  </span><br><span class="line">      auth_basic_user_file /etc/nginx/conf.d/dongwm.htpasswd;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>修改grafana的src/config.js:<br>graphiteUrl: “http://“+window.location.hostname+”:8020”, # 下面会定义graphite-<br>web启动在8020端口</li>
<li>修改Diamond的配置conf/diamond.conf</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cp conf/diamond.conf.example conf/diamond.conf</span><br></pre></td></tr></table></figure>


<p>主要修改监听的carbon服务器和端口,以及要监控什么类型的数据,看我的一个全文配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">################################################################################  </span></span><br><span class="line"><span class="comment"># Diamond Configuration File  </span></span><br><span class="line"><span class="comment">################################################################################  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">################################################################################  </span></span><br><span class="line"><span class="comment">### Options for the server  </span></span><br><span class="line">[server]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Handlers for published metrics.  </span></span><br><span class="line">handlers = diamond.handler.graphite.GraphiteHandler, diamond.handler.archive.ArchiveHandler  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># User diamond will run as  </span></span><br><span class="line"><span class="comment"># Leave empty to use the current user  </span></span><br><span class="line">user =  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Group diamond will run as  </span></span><br><span class="line"><span class="comment"># Leave empty to use the current group  </span></span><br><span class="line">group =  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Pid file  </span></span><br><span class="line">pid_file = /home/dongwm/logs/diamond.pid <span class="comment"># 换了pid的地址,因为我的服务都不会root启动  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Directory to load collector modules from  </span></span><br><span class="line">collectors_path = /home/dongwm/Diamond/src/collectors <span class="comment"># 收集器的目录,这个/home/dongwm/Diamond就是克隆代码的地址  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Directory to load collector configs from  </span></span><br><span class="line">collectors_config_path = /home/dongwm/Diamond/src/collectors  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Directory to load handler configs from  </span></span><br><span class="line">handlers_config_path = /home/dongwm/Diamond/src/diamond/handler  </span><br><span class="line">  </span><br><span class="line">handlers_path = /home/dongwm/Diamond/src/diamond/handler  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Interval to reload collectors  </span></span><br><span class="line">collectors_reload_interval = <span class="number">3600</span> <span class="comment"># 收集器定期会重载看有没有配置更新  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">################################################################################  </span></span><br><span class="line"><span class="comment">### Options for handlers  </span></span><br><span class="line">[handlers]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># daemon logging handler(s)  </span></span><br><span class="line">keys = rotated_file  </span><br><span class="line">  </span><br><span class="line"><span class="comment">### Defaults options for all Handlers  </span></span><br><span class="line">[[default]]  </span><br><span class="line">  </span><br><span class="line">[[ArchiveHandler]]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># File to write archive log files  </span></span><br><span class="line">log_file = /home/dongwm/logs/diamond_archive.log  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Number of days to keep archive log files  </span></span><br><span class="line">days = <span class="number">7</span>  </span><br><span class="line">  </span><br><span class="line">[[GraphiteHandler]]  </span><br><span class="line"><span class="comment">### Options for GraphiteHandler  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Graphite server host  </span></span><br><span class="line">host = <span class="number">123.126</span><span class="number">.1</span><span class="number">.11</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Port to send metrics to  </span></span><br><span class="line">port = <span class="number">2003</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Socket timeout (seconds)  </span></span><br><span class="line">timeout = <span class="number">15</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Batch size for metrics  </span></span><br><span class="line">batch = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">[[GraphitePickleHandler]]  </span><br><span class="line"><span class="comment">### Options for GraphitePickleHandler  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Graphite server host  </span></span><br><span class="line">host = <span class="number">123.126</span><span class="number">.1</span><span class="number">.11</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Port to send metrics to  </span></span><br><span class="line">port = <span class="number">2004</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Socket timeout (seconds)  </span></span><br><span class="line">timeout = <span class="number">15</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Batch size for pickled metrics  </span></span><br><span class="line">batch = <span class="number">256</span>  </span><br><span class="line">  </span><br><span class="line">[[MySQLHandler]]  </span><br><span class="line"><span class="comment">### Options for MySQLHandler  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># MySQL Connection Info 这个可以你的会不同  </span></span><br><span class="line">hostname    = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  </span><br><span class="line">port        = <span class="number">3306</span>  </span><br><span class="line">username    = root  </span><br><span class="line">password    =  </span><br><span class="line">database    = diamond  </span><br><span class="line">table       = metrics  </span><br><span class="line"><span class="comment"># INT UNSIGNED NOT NULL  </span></span><br><span class="line">col_time    = timestamp  </span><br><span class="line"><span class="comment"># VARCHAR(255) NOT NULL  </span></span><br><span class="line">col_metric  = metric  </span><br><span class="line"><span class="comment"># VARCHAR(255) NOT NULL  </span></span><br><span class="line">col_value   = value  </span><br><span class="line">  </span><br><span class="line">[[StatsdHandler]]  </span><br><span class="line">host = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  </span><br><span class="line">port = <span class="number">8125</span>  </span><br><span class="line">  </span><br><span class="line">[[TSDBHandler]]  </span><br><span class="line">host = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  </span><br><span class="line">port = <span class="number">4242</span>  </span><br><span class="line">timeout = <span class="number">15</span>  </span><br><span class="line">  </span><br><span class="line">[[LibratoHandler]]  </span><br><span class="line">user = user@example.com  </span><br><span class="line">apikey = abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz01  </span><br><span class="line">  </span><br><span class="line">[[HostedGraphiteHandler]]  </span><br><span class="line">apikey = abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz01  </span><br><span class="line">timeout = <span class="number">15</span>  </span><br><span class="line">batch = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># And any other config settings from GraphiteHandler are valid here  </span></span><br><span class="line">  </span><br><span class="line">[[HttpPostHandler]]  </span><br><span class="line">  </span><br><span class="line"><span class="comment">### Urp to post the metrics  </span></span><br><span class="line">url = http://localhost:<span class="number">8888</span>/  </span><br><span class="line"><span class="comment">### Metrics batch size  </span></span><br><span class="line">batch = <span class="number">100</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">################################################################################  </span></span><br><span class="line"><span class="comment">### Options for collectors  </span></span><br><span class="line">[collectors]  </span><br><span class="line">[[TencentCollector]] <span class="comment"># 本来[collectors]下试没有东西的,这个是我定制的一个类型  </span></span><br><span class="line">ttype = server  </span><br><span class="line">[[MongoDBCollector]] <span class="comment"># 一般情况,有一些类型是默认enabled = True,也就是启动的,但是大部分是默认不启动《需要显示指定True  </span></span><br><span class="line">enabled = <span class="literal">True</span>  </span><br><span class="line">host = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 每种类型的参数不同  </span></span><br><span class="line">[[TCPCollector]]  </span><br><span class="line">enabled = <span class="literal">True</span>  </span><br><span class="line">[[NetworkCollector]]  </span><br><span class="line">enabled = <span class="literal">True</span>  </span><br><span class="line">[[NginxCollector]]  </span><br><span class="line">enabled = <span class="literal">False</span> <span class="comment"># 没开启nginx_status 开启了也没用  </span></span><br><span class="line">[[ SockstatCollector]]  </span><br><span class="line">enabled = <span class="literal">True</span>  </span><br><span class="line">[[default]]  </span><br><span class="line"><span class="comment">### Defaults options for all Collectors  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Uncomment and set to hardcode a hostname for the collector path  </span></span><br><span class="line"><span class="comment"># Keep in mind, periods are seperators in graphite  </span></span><br><span class="line"><span class="comment"># hostname = my_custom_hostname  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># If you prefer to just use a different way of calculating the hostname  </span></span><br><span class="line"><span class="comment"># Uncomment and set this to one of these values:  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># smart             = Default. Tries fqdn_short. If that's localhost, uses hostname_short  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># fqdn_short        = Default. Similar to hostname -s  </span></span><br><span class="line"><span class="comment"># fqdn              = hostname output  </span></span><br><span class="line"><span class="comment"># fqdn_rev          = hostname in reverse (com.example.www)  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># uname_short       = Similar to uname -n, but only the first part  </span></span><br><span class="line"><span class="comment"># uname_rev         = uname -r in reverse (com.example.www)  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># hostname_short    = `hostname -s`  </span></span><br><span class="line"><span class="comment"># hostname          = `hostname`  </span></span><br><span class="line"><span class="comment"># hostname_rev      = `hostname` in reverse (com.example.www)  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># hostname_method = smart  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Path Prefix and Suffix  </span></span><br><span class="line"><span class="comment"># you can use one or both to craft the path where you want to put metrics  </span></span><br><span class="line"><span class="comment"># such as: %(path_prefix)s.$(hostname)s.$(path_suffix)s.$(metric)s  </span></span><br><span class="line"><span class="comment"># path_prefix = servers  </span></span><br><span class="line"><span class="comment"># path_suffix =  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Path Prefix for Virtual Machines  </span></span><br><span class="line"><span class="comment"># If the host supports virtual machines, collectors may report per  </span></span><br><span class="line"><span class="comment"># VM metrics. Following OpenStack nomenclature, the prefix for  </span></span><br><span class="line"><span class="comment"># reporting per VM metrics is "instances", and metric foo for VM  </span></span><br><span class="line"><span class="comment"># bar will be reported as: instances.bar.foo...  </span></span><br><span class="line"><span class="comment"># instance_prefix = instances  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Default Poll Interval (seconds)  </span></span><br><span class="line"><span class="comment"># interval = 300  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">################################################################################  </span></span><br><span class="line"><span class="comment">### Options for logging  </span></span><br><span class="line"><span class="comment"># for more information on file format syntax:  </span></span><br><span class="line"><span class="comment"># http://docs.python.org/library/logging.config.html#configuration-file-format  </span></span><br><span class="line">  </span><br><span class="line">[loggers]  </span><br><span class="line">  </span><br><span class="line">keys = root  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># handlers are higher in this config file, in:  </span></span><br><span class="line"><span class="comment"># [handlers]  </span></span><br><span class="line"><span class="comment"># keys = ...  </span></span><br><span class="line">  </span><br><span class="line">[formatters]  </span><br><span class="line">  </span><br><span class="line">keys = default  </span><br><span class="line">  </span><br><span class="line">[logger_root]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># to increase verbosity, set DEBUG  </span></span><br><span class="line">level = INFO  </span><br><span class="line">handlers = rotated_file  </span><br><span class="line">propagate = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">[handler_rotated_file]  </span><br><span class="line">  </span><br><span class="line">class = handlers.TimedRotatingFileHandler  </span><br><span class="line">level = DEBUG  </span><br><span class="line">formatter = default  </span><br><span class="line"><span class="comment"># rotate at midnight, each day and keep 7 days  </span></span><br><span class="line">args = (<span class="string">'/home/dongwm/logs/diamond.log'</span>, <span class="string">'midnight'</span>, <span class="number">1</span>, <span class="number">7</span>)  </span><br><span class="line">  </span><br><span class="line">[formatter_default]  </span><br><span class="line">  </span><br><span class="line">format = [%(asctime)s] [%(threadName)s] %(message)s  </span><br><span class="line">datefmt =</span><br></pre></td></tr></table></figure>


<h5 id="启动相关服务"><a href="#启动相关服务" class="headerlink" title="启动相关服务"></a>启动相关服务</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo /etc/init.d/nginx reload  </span><br><span class="line">sudo /sbin/chkconfig --add elasticsearch  </span><br><span class="line">sudo service elasticsearch start  </span><br><span class="line">sudo service carbon-cache restart  </span><br><span class="line">sudo python /usr/lib/python2<span class="number">.6</span>/site-packages/graphite/manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8020</span> <span class="comment"># 启动graphite-web到8020端口</span></span><br></pre></td></tr></table></figure>


<h6 id="在每个要搜集信息的agent上面安装Diamond-并启动"><a href="#在每个要搜集信息的agent上面安装Diamond-并启动" class="headerlink" title="在每个要搜集信息的agent上面安装Diamond,并启动:"></a>在每个要搜集信息的agent上面安装Diamond,并启动:</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd /home/dongm/Diamond  </span><br><span class="line">python ./bin/diamond --configfile=conf/diamond.conf  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># PS: 也可以添加 -l -f在前台显示</span></span><br></pre></td></tr></table></figure>


<h5 id="自定义数据搜集类型，也就是上面的TencentCollector"><a href="#自定义数据搜集类型，也就是上面的TencentCollector" class="headerlink" title="自定义数据搜集类型，也就是上面的TencentCollector"></a>自定义数据搜集类型，也就是上面的TencentCollector</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line">  </span><br><span class="line"><span class="string">"""  </span></span><br><span class="line"><span class="string">获取腾讯微博爬虫的业务指标  </span></span><br><span class="line"><span class="string">"""</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> diamond.collector  </span><br><span class="line"><span class="keyword">import</span> pymongo  </span><br><span class="line"><span class="keyword">from</span> pymongo.errors <span class="keyword">import</span> ConnectionFailure  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TencentCollector</span><span class="params">(diamond.collector.Collector)</span>:</span> <span class="comment"># 需要继承至diamond.collector.Collector  </span></span><br><span class="line">    PATH = <span class="string">'/home/dongwm/tencent_data'</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_default_config</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        config = super(TencentCollector, self).get_default_config()  </span><br><span class="line">        config.update(&#123;  </span><br><span class="line">            <span class="string">'enabled'</span>:  <span class="string">'True'</span>,  </span><br><span class="line">            <span class="string">'path'</span>:     <span class="string">'tencent'</span>,  </span><br><span class="line">            <span class="string">'method'</span>:   <span class="string">'Threaded'</span>,  </span><br><span class="line">            <span class="string">'ttype'</span>:    <span class="string">'agent'</span> <span class="comment"># 服务类型 包含agent和server  </span></span><br><span class="line">        &#125;)  </span><br><span class="line">        <span class="keyword">return</span> config  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        ttype = self.config[<span class="string">'ttype'</span>]  </span><br><span class="line">        <span class="keyword">if</span> ttype == <span class="string">'server'</span>:  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                db = pymongo.MongoClient()[<span class="string">'tmp'</span>]  </span><br><span class="line">            <span class="keyword">except</span> ConnectionFailure:  </span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            now_count = db.data.count()  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                last_count = db.diamond.find_and_modify(  </span><br><span class="line">                    &#123;&#125;, &#123;<span class="string">'$set'</span>: &#123;<span class="string">'last'</span>: now_count&#125;&#125;, upsert=<span class="literal">True</span>)[<span class="string">'last'</span>]  </span><br><span class="line">            <span class="keyword">except</span> TypeError:  </span><br><span class="line">                last_count = <span class="number">0</span>  </span><br><span class="line">            self.publish(<span class="string">'count'</span>, now_count)  </span><br><span class="line">            self.publish(<span class="string">'update'</span>, abs(last_count - now_count))  </span><br><span class="line">        <span class="keyword">if</span> ttype == <span class="string">'agent'</span>:  </span><br><span class="line">            <span class="comment"># somethings..........</span></span><br></pre></td></tr></table></figure>


<h5 id="添加你要绘图的类型-这个就是打开grafana-添加不同的row-给每个添加panel-选择metric的类型就好了"><a href="#添加你要绘图的类型-这个就是打开grafana-添加不同的row-给每个添加panel-选择metric的类型就好了" class="headerlink" title="添加你要绘图的类型. 这个就是打开grafana, 添加不同的row.给每个添加panel.选择metric的类型就好了"></a>添加你要绘图的类型. 这个就是打开grafana, 添加不同的row.给每个添加panel.选择metric的类型就好了</h5><p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>封装pymongo自动关闭连接</title>
    <url>/2016-03-31.html</url>
    <content><![CDATA[<p>####前言<br>在我工作的项目里面使用了mongodb.自然也用到了pymongo.但是它都是在大片的函数里面使用类似于这样的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> db  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    db.test.find_one()  </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>但是问题是在使用完都没有关闭连接,这样多台服务器连接我这台mongodb服务器，在业务高峰期就会占满我的连接, 我当时总结造成这个原因的问题有以下三种:</p>
<ol>
<li>上面说的用完db不关闭连接而是等着db超时</li>
<li>注意上面的import，其实在import文件的时候数据库连接就已经生成了，没有在需要的时候才创建, 占满我连接的应用其实有很多没有用，浪费了</li>
<li>nginx、uwsgi，celery等应用配置的问题，造成过多的实例，其实根本无益<br>####我今天写的一个封装pymongo和关闭数据库连接的装饰器</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#/usr/bin/env python  </span></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line">  </span><br><span class="line"><span class="string">"""  </span></span><br><span class="line"><span class="string">1. 封装数据库操作(INSERT,FIND,UPDATE)  </span></span><br><span class="line"><span class="string">2. 函数执行完MONGODB操作后关闭数据库连接  </span></span><br><span class="line"><span class="string">"""</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  </span><br><span class="line"><span class="keyword">from</span> pymongo.database <span class="keyword">import</span> Database  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient  </span><br><span class="line"><span class="keyword">except</span> ImportError:  </span><br><span class="line">    <span class="comment"># 好像2.4之前的pymongo都没有MongoClient,现在官网已经把Connection抛弃了  </span></span><br><span class="line">    <span class="keyword">import</span> warnings  </span><br><span class="line">    warnings.warn(<span class="string">"Strongly recommend upgrading to the latest version pymongo version,"</span>  </span><br><span class="line">                  <span class="string">"Connection is DEPRECATED: Please use mongo_client instead."</span>)  </span><br><span class="line">    <span class="keyword">from</span> pymongo <span class="keyword">import</span> Connection <span class="keyword">as</span> MongoClient  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mongo</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="string">'''封装数据库操作'''</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>, database=<span class="string">'test'</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 max_pool_size=<span class="number">10</span>, timeout=<span class="number">10</span>)</span>:</span>  </span><br><span class="line">        self.host = host  </span><br><span class="line">        self.port = port  </span><br><span class="line">        self.max_pool_size = max_pool_size  </span><br><span class="line">        self.timeout = timeout  </span><br><span class="line">        self.database = database  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="comment"># 我这里是为了使用类似"db.集合.操作"的操作的时候才会生成数据库连接,其实pymongo已经实现了进程池,也可以把这个db放在__init__里面,  </span></span><br><span class="line">        <span class="comment"># 比如我把db关掉有其他的数据库调用连接又会生成,并且不影响使用.我这里只是想每次执行数据库生成一个连接用完关掉-自己控制自己的  </span></span><br><span class="line">        <span class="keyword">return</span> MongoClientself.host, self.port, max_pool_size=self.max_pool_size,  </span><br><span class="line">                  connectTimeoutMS=<span class="number">60</span> * <span class="number">60</span> * self.timeout)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, collection)</span>:</span>  </span><br><span class="line">        <span class="comment"># 为了兼容db[集合].操作的用法  </span></span><br><span class="line">        <span class="keyword">return</span> self.__getattr__(collection)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, collection_or_func)</span>:</span>  </span><br><span class="line">        db = self.connect[self.database]  </span><br><span class="line">        <span class="keyword">if</span> collection_or_func <span class="keyword">in</span> Database.__dict__:  </span><br><span class="line">            <span class="comment"># 当调用的是db的方法就直接返回  </span></span><br><span class="line">            <span class="keyword">return</span> getattr(db, collection_or_func)  </span><br><span class="line">        <span class="comment"># 否则委派给Collection  </span></span><br><span class="line">        <span class="keyword">return</span> Collection(db, collection_or_func)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, db, collection)</span>:</span>  </span><br><span class="line">        self.collection = getattr(db, collection)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, operation)</span>:</span>  </span><br><span class="line">        <span class="comment"># 我这个封装只是为了拦截一部分操作,不符合的就直接raise属性错误  </span></span><br><span class="line">        control_type = [<span class="string">'disconnect'</span>, <span class="string">'insert'</span>, <span class="string">'update'</span>, <span class="string">'find'</span>, <span class="string">'find_one'</span>]  </span><br><span class="line">        <span class="keyword">if</span> operation <span class="keyword">in</span> control_type:  </span><br><span class="line">            <span class="keyword">return</span> getattr(self.collection, operation)  </span><br><span class="line">        <span class="keyword">raise</span> AttributeError(operation)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close_db</span><span class="params">(dbs=[<span class="string">'db'</span>])</span>:</span>  </span><br><span class="line">    <span class="string">'''  </span></span><br><span class="line"><span class="string">    关闭mongodb数据库连接  </span></span><br><span class="line"><span class="string">    db : 在执行函数里面使用的db的名字(大部分是db，也会有s_db)  </span></span><br><span class="line"><span class="string">        Usage::  </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt;s_db = Mongo()  </span></span><br><span class="line"><span class="string">            &gt;&gt;&gt;@close_db(['s_db'])  </span></span><br><span class="line"><span class="string">            ...: def test():  </span></span><br><span class="line"><span class="string">            ...:     print s_db.test.insert(&#123;'a': 1, 'b': 2&#125;)  </span></span><br><span class="line"><span class="string">            ...:  </span></span><br><span class="line"><span class="string">    '''</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(func)</span>:</span>  </span><br><span class="line"><span class="meta">        @wraps(func)  </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_call</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">            result = func(*args, **kwargs)  </span><br><span class="line">            <span class="keyword">for</span> db <span class="keyword">in</span> dbs:  </span><br><span class="line">                <span class="keyword">try</span>:  </span><br><span class="line">                    func.func_globals[db].connection.disconnect()  </span><br><span class="line">                <span class="keyword">except</span> KeyError:  </span><br><span class="line">                    <span class="keyword">pass</span>  </span><br><span class="line">            <span class="keyword">return</span> result  </span><br><span class="line">        <span class="keyword">return</span> _call  </span><br><span class="line">    <span class="keyword">return</span> _deco</span><br></pre></td></tr></table></figure>


<p>PS: 在我测试的时候发现,使用Mongo()类生成的db，操作完会自动关闭连接了…<br>####怎么样给一个很大的文件每个函数都加上面的这个装饰器？<br>项目每个脚本的代码都很长，函数也很多，并且每个函数里面使用的db的名字都不同,比如有一些一些风格:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">db.test.find_one()  </span><br><span class="line">s_db.test.insert(dict(test=<span class="string">'test'</span>))  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>每个函数加一个装饰器,好费劲，就想能不能自动分辨文件中的函数然后给他们自动加装饰器，然后就有以下的一个做好的脚本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  </span><br><span class="line"><span class="keyword">import</span> copy  </span><br><span class="line"><span class="keyword">import</span> types  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(func)</span>:</span>  </span><br><span class="line"><span class="meta">    @wraps(func)  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_call</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">        result = func(*args, **kwargs)  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'wrap you'</span>  </span><br><span class="line">        <span class="keyword">return</span> result  </span><br><span class="line">    <span class="keyword">return</span> _call  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'test'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'test3'</span>  </span><br><span class="line">  </span><br><span class="line">glocal_dict = copy.copy(globals())  </span><br><span class="line">  </span><br><span class="line">func_list = [[k, v] <span class="keyword">for</span> k, v <span class="keyword">in</span> glocal_dict.iteritems() <span class="keyword">if</span> <span class="keyword">not</span> k.startswith(<span class="string">'__'</span>)]  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> func_name, func <span class="keyword">in</span> func_list:  </span><br><span class="line">    <span class="keyword">if</span>  func_name <span class="keyword">in</span> [<span class="string">'wraps'</span>, <span class="string">'copy'</span>, <span class="string">'wrap'</span>, <span class="string">'types'</span>]:  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    <span class="keyword">if</span> types.FunctionType  == type(func):  </span><br><span class="line">        globals()[func_name]= wrap(func)</span><br></pre></td></tr></table></figure>


<p>这样当你调用的时候自动就有了装饰器:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> test <span class="keyword">import</span> test  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()  </span><br><span class="line">test  </span><br><span class="line">wrap you  </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎live全文搜索之构建基于asyncio+sanic的RESTful-API服务</title>
    <url>/2016-03-30.html</url>
    <content><![CDATA[<p>今天的文章图片就是这个知乎Live全文搜索的效果了。如果在wifi情况下或者土豪不介意流量的同学可以直接[感受实际使用的动态效果](<a href="https://github.com/dongweiming/weapp-" target="_blank" rel="noopener">https://github.com/dongweiming/weapp-</a><br>zhihulive/blob/master/screenshot/zhihulive.gif) 。<br>在我的《Python Web开发实战》一书中，比较少的介绍到豆瓣自己造的轮子。有读者喷「不够实战」。我显然承认，也很苦闷<br>，今天顺便来吐个槽。我刚工作的时候特别愿意混各种技术会议和活动。经常有一些专家在上面讲：我们自己实现了一个XXX，它有如下多的特性，现在支持了多少个产品线的多少个应用，每天的数据量YY<br>PB，流量ZZ…<br>通篇在讲架构，摆几张高大上的图，甚至能说几个大家不了解的新的玩法都很少，还不断的问坐在下面的领导或者法务：额，这个我能说嘛；那个我能分享么？最最重要的是，他们讲的这些东西大多不是开源的….<br>也基本没有一个可以拿得出手的论文，甚至说白了，如果你正好专注这一部分，会发现它也是根据了FLAG公司的论文在造轮子罢了，说不定造的还不如你。<br>听过之后，也没有收获，都是「别人家」的，甚至有种炫耀的感觉而已，至于有什么苦可能只有他们自己知道吧。我就越来越不愿意参加这种会议了。<br>写书或者博客也是这样。一切东西脱离了公司能提供的基础设施和环境都是空谈，但是这些铺垫说起来就太大了，先不讨论公司有没有授权你在外面说，就是没开源这点就不好弄。说的人都是在虚化的讲一大坨的东西，最多来几个截图之类的（应该还打了马赛克）。等这一大坨东西说的让大家明白了，一本书的厚度肯定不够。但是这些内容呢，只是你为了写书的某一(几)章做铺垫而已，有些内容太专太偏，读者大部分场景下是用不到的，好吧，又得骂娘说你这本书不实用…<br>今天我将基于我过往的实践，以及最近学习asyncio和ES知识完成一个小程序的API服务。看这篇文章前推荐阅读相关的如下文章：</p>
<ol>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">知乎Live全文搜索之模型设计和爬虫实现</a></li>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%8F%A3/" target="_blank" rel="noopener">知乎Live全文搜索之模型接口</a></li>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%96%9C%E6%AC%A2Gevent/" target="_blank" rel="noopener">使用Python进行并发编程-我为什么不喜欢Gevent</a></li>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-asyncio%E7%AF%87/" target="_blank" rel="noopener">使用Python进行并发编程-asyncio篇(一)</a></li>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-asyncio%E7%AF%87-%E4%BA%8C/" target="_blank" rel="noopener">使用Python进行并发编程-asyncio篇(二)</a></li>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-asyncio%E7%AF%87-%E4%B8%89/" target="_blank" rel="noopener">使用Python进行并发编程-asyncio篇(三)</a></li>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E8%AE%A9elasticsearch_dsl%E6%94%AF%E6%8C%81asyncio/" target="_blank" rel="noopener">知乎Live全文搜索之让elasticsearch_dsl支持asyncio</a><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3></li>
<li><a href="https://github.com/channelcat/sanic" target="_blank" rel="noopener">Sanic</a>，基于Python 3.5+的异步web服务器，和Flask一样使用装饰器作为路由，支持Blueprint。效果确实非常快。</li>
<li><a href="https://github.com/MagicStack/uvloop" target="_blank" rel="noopener">uvloop</a>，Sanic默认使用uvloop，这个实现基于libuv，比asyncio默认的loop的块很多。</li>
<li><a href="https://github.com/marshmallow-code/marshmallow" target="_blank" rel="noopener">marshmallow</a>，一个轻量级的转化复杂对象成为Python自带数据类型的库，为什么用它未来会详细介绍。<h3 id="使用Schema"><a href="#使用Schema" class="headerlink" title="使用Schema"></a>使用Schema</h3>了解过关系型数据库如MySQL的同学会比较熟悉Schema这个词，它是对数据库的结构描述。Schema定义了表与表和表与字段之间的关系。在使用关系型数据库之前第一件事要先定Schema，创建表(库)再去操作。<br>为什么我们在实现RESTful API的时候要考虑使用Schema呢？</li>
<li>首先API服务是给外部用的，比如移动端(安卓、IOS等)，前端(用AJAX)等。那么大家一开始就要协商好那些字段，以及字段的类型。因为你不关系，他们都是关心的，如果设计有问题会由于没有正确处理而造成移动端闪退等严重问题。</li>
<li>你需要对API返回的数据进行良好的管理和验证。<br>marshmallow把一组数据映射成一个类：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> marshmallow <span class="keyword">import</span> Schema, fields  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span><span class="params">(Schema)</span>:</span>  </span><br><span class="line">    id = fields.Integer()  </span><br><span class="line">    url = fields.Str()  </span><br><span class="line">    name = fields.Str()   </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>这样既让不同编程语言的开发者一目了然，也能检验你提供的数据是不是按照这个定好的结构返回的。</p>
<h3 id="同一组数据可以定义多种Schema"><a href="#同一组数据可以定义多种Schema" class="headerlink" title="同一组数据可以定义多种Schema"></a>同一组数据可以定义多种Schema</h3><p>思考一下，在搜索页面，每一项提供的空间有限，你无法把Live的全部信息（比如「描述」这种很长的内容的字段）都展示出来，也就是就算都返回了，其实只用了一部分字段，这造成了更多的网络延时和带宽消耗。但是在Live详情页理论上就可以展示全部的字段的内容了。<br>再假设下，如果是返回一部分，还是返回全部字段在后端做，就是不同的方法返回时对to_dict方法对一对if/elif/else的处理，其实看起来很乱。我是这样用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span><span class="params">(Schema)</span>:</span>  </span><br><span class="line">    id = fields.Integer()  </span><br><span class="line">    url = fields.Str()  </span><br><span class="line">    name = fields.Str()  </span><br><span class="line">    ...  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFullSchema</span><span class="params">(UserSchema)</span>:</span>  </span><br><span class="line">    lives_url = fields.Str()  </span><br><span class="line">    speaker_id = fields.Str()   </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>也就是定义了多种User的schema，按需选择。但是后端统一使用to_dict方法返回全部数据，在视图渲染的时候进行筛选。这样需要用一种好的表达方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> views.utils <span class="keyword">import</span> marshal_with  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@bp.route('/search')  </span></span><br><span class="line"><span class="meta">@marshal_with([LiveSchema, UserSchema])  </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@bp.route('/suggest')  </span></span><br><span class="line"><span class="meta">@marshal_with(LiveSchema)  </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">suggest</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line"><span class="meta">@bp.route('/user/&lt;user_id&gt;')  </span></span><br><span class="line"><span class="meta">@marshal_with([LiveFullSchema, UserFullSchema])  </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(request, user_id)</span>:</span>  </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>我们先不考虑视图内的逻辑，简单的理解成他们是单个live的to_dict结果或者多个live的to_dict结果的列表<br>通过神奇的marshal_with装饰器传入你希望返回符合那种Schema的数据。<br>现在揭晓一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">marshal</span><span class="params">(data, fields)</span>:</span>  </span><br><span class="line">    schemas = [field() <span class="keyword">for</span> field <span class="keyword">in</span> fields]  </span><br><span class="line">    <span class="keyword">if</span> isinstance(data, (list, tuple)):  </span><br><span class="line">        <span class="keyword">return</span> [marshal(d, fields) <span class="keyword">for</span> d <span class="keyword">in</span> data]  </span><br><span class="line">  </span><br><span class="line">    type = data.get(<span class="string">'type'</span>)  </span><br><span class="line">    <span class="keyword">for</span> schema <span class="keyword">in</span> schemas:  </span><br><span class="line">        <span class="keyword">if</span> type <span class="keyword">in</span> schema.__class__.__name__.lower():  </span><br><span class="line">            result, errors = schema.dump(data)  </span><br><span class="line">            <span class="keyword">if</span> errors:  </span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> errors.items():  </span><br><span class="line">                    print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(*item))  </span><br><span class="line">            <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">marshal_with</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fields)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(fields, list):  </span><br><span class="line">            fields = [fields]  </span><br><span class="line">        self.fields = fields  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, f)</span>:</span>  </span><br><span class="line"><span class="meta">        @wraps(f)  </span></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">            resp = <span class="keyword">await</span> f(*args, **kwargs)  </span><br><span class="line">            <span class="keyword">return</span> marshal(resp, self.fields)  </span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>


<p>这个是async版本的，大家可以自己发散成Python 2的普通版。记得之前我们在model里面给每种数据的to_dict方法里面加了个<code>{&#39;type&#39;:
&#39;live&#39;}</code>这种键值么，除了在小程序里面分辨数据的类型，在这里也是用来匹配那种schema的。举个例子，假如是一个user类型的数据。<br>在<code>@marshal_with([LiveFullSchema,
UserFullSchema])</code>的装饰下，由于UserFullSchema类名包含了live所以符合了。这比较黑科技一点..</p>
<h3 id="深入使用marshmallow"><a href="#深入使用marshmallow" class="headerlink" title="深入使用marshmallow"></a>深入使用marshmallow</h3><p>marshmallow除了生成一个可读性很好的类和验证该字段是不是类型符合以外，还支持序列化和反序列化的处理。有什么意义呢。假如如下的schema:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveSchema</span><span class="params">(Schema)</span>:</span>  </span><br><span class="line">    starts_at = fields.Date()</span><br></pre></td></tr></table></figure>


<p>注意我们model存的starts_at是一个datetime类型的对象，无法被json序列化，所以返回之前应该先转化成字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveSchema</span><span class="params">(Schema)</span>:</span>  </span><br><span class="line">    starts_at = fields.Method(<span class="string">'get_start_time'</span>)  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_start_time</span><span class="params">(self, obj)</span>:</span>  </span><br><span class="line">         <span class="keyword">return</span> int(obj[<span class="string">'starts_at'</span>].strftime(<span class="string">'%s'</span>))</span><br></pre></td></tr></table></figure>


<p>再举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span><span class="params">(Schema)</span>:</span>  </span><br><span class="line">    bio = fields.Str()  </span><br><span class="line">    headline = fields.Str()   </span><br><span class="line">    description = fields.Str()</span><br></pre></td></tr></table></figure>


<p>bio/headline/description这三个字段内容都有可能比较长，需要做不同的截取：在详情页显示全部，在搜索页之前显示前2行..<br>我们需要一个truncate函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">WIDTH = <span class="number">45</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">truncate_utf8</span><span class="params">(str, width=WIDTH)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> str[:width] + <span class="string">'...'</span> <span class="keyword">if</span> len(str) &gt; width <span class="keyword">else</span> str</span><br></pre></td></tr></table></figure>


<p>假如使用fields.Method你就要写三方法，因为它指定的方法只有<code>self,
obj</code>2个参数，而且Schema是不能继承的。这么办呢？有我的书中介绍的partialmethod可完美实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partialmethod  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">truncate</span><span class="params">(self, attr, obj)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> attr <span class="keyword">not</span> <span class="keyword">in</span> obj:  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>  </span><br><span class="line">        <span class="keyword">return</span> truncate_utf8(obj[attr], WIDTH)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span><span class="params">(Schema)</span>:</span>  </span><br><span class="line">    bio = fields.Method(<span class="string">'truncate_bio'</span>)  </span><br><span class="line">    headline = fields.Method(<span class="string">'truncate_headline'</span>)  </span><br><span class="line">    description = fields.Method(<span class="string">'truncate_description'</span>)  </span><br><span class="line">    truncate_headline = partialmethod(Item.truncate, <span class="string">'headline'</span>)  </span><br><span class="line">    truncate_bio = partialmethod(Item.truncate, <span class="string">'bio'</span>)  </span><br><span class="line">    truncate_description = partialmethod(Item.truncate, <span class="string">'description'</span>)</span><br></pre></td></tr></table></figure>


<p>通过partialmethod + 非继承至Schema的类就可以实现继承和额外参数了。</p>
<h3 id="对Sanic定制"><a href="#对Sanic定制" class="headerlink" title="对Sanic定制"></a>对Sanic定制</h3><p>我们都知道，当你有独特的需求而框架不满足的时候，就要对其进行二次开发或者封装。我一般倾向基于框架提供的灵活性去封装。由于在多个API上都有分页的需要，参数中会出现start/limit（当然你可以更喜欢其他的词汇）。如果不定制，那么在每个视图里面都要加一句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@bp.route('/search')  </span></span><br><span class="line"><span class="meta">@marshal_with([LiveSchema, UserSchema])  </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    start = request.args.get(<span class="string">'start'</span>, <span class="number">0</span>)  </span><br><span class="line">    limit = request.args.get(<span class="string">'limit'</span>, <span class="number">10</span>)   </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>这2句就是个累赘。怎么做呢？ 利用sanic提供的中间件就好了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@app.middleware('request')  </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">halt_request</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    request.start = request.args.get(<span class="string">'start'</span>, <span class="number">0</span>)  </span><br><span class="line">    request.limit = request.args.get(<span class="string">'limit'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>


<p>但是这还不够，因为sanic在创建Request的时候基于内存的考虑使用了<strong>slots</strong>，所以我们要重新写on_headers_complete方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sanic.server <span class="keyword">import</span> HttpProtocol, CIMultiDict  </span><br><span class="line"><span class="keyword">from</span> sanic.request <span class="keyword">import</span> Request <span class="keyword">as</span> _Request   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(_Request)</span>:</span>  </span><br><span class="line">    __slots__ = (  </span><br><span class="line">        <span class="string">'url'</span>, <span class="string">'headers'</span>, <span class="string">'version'</span>, <span class="string">'method'</span>, <span class="string">'_cookies'</span>,  </span><br><span class="line">        <span class="string">'query_string'</span>, <span class="string">'body'</span>, <span class="string">'start'</span>, <span class="string">'limit'</span>,  </span><br><span class="line">        <span class="string">'parsed_json'</span>, <span class="string">'parsed_args'</span>, <span class="string">'parsed_form'</span>, <span class="string">'parsed_files'</span>,  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONHttpProtocol</span><span class="params">(HttpProtocol)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_headers_complete</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        remote_addr = self.transport.get_extra_info(<span class="string">'peername'</span>)  </span><br><span class="line">        <span class="keyword">if</span> remote_addr:  </span><br><span class="line">            self.headers.append((<span class="string">'Remote-Addr'</span>, <span class="string">'%s:%s'</span> % remote_addr))  </span><br><span class="line">  </span><br><span class="line">        self.request = Request(  </span><br><span class="line">            url_bytes=self.url,  </span><br><span class="line">            headers=CIMultiDict(self.headers),  </span><br><span class="line">            version=self.parser.get_http_version(),  </span><br><span class="line">            method=self.parser.get_method().decode()  </span><br><span class="line">        )  </span><br><span class="line">          </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8300</span>, protocol=JSONHttpProtocol,  </span><br><span class="line">            workers=<span class="number">4</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p>这样在视图中就可以直接使用request.start和request.limit了。<br>其次看官方用法，都是在视图中控制返回的内容的类型，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> json  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.route('/')  </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> json(&#123;<span class="string">"hello"</span>: <span class="string">"world"</span>&#125;)</span><br></pre></td></tr></table></figure>


<p>我也希望封装全部的返回结果的格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;<span class="string">'rs'</span>: data&#125;</span><br></pre></td></tr></table></figure>


<p>PS: 当然生产环境中应该还有一个error字段甚至error_code字段标识如果出错的信息和类型等字段，我这里作为演示就保留了一个rs字段<br>这个data就是实际的视图返回的结果，但是在响应的时候已经封好了。可以继续重写write_response方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONHttpProtocol</span><span class="params">(HttpProtocol)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_response</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> isinstance(response, str):  </span><br><span class="line">            response = text(response)  </span><br><span class="line">        <span class="keyword">elif</span> isinstance(response, (list, dict)):  </span><br><span class="line">            response = &#123;<span class="string">'rs'</span>: response&#125;  </span><br><span class="line">        <span class="keyword">if</span> isinstance(response, dict):  </span><br><span class="line">            response = json(response)  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> super().write_response(response)</span><br></pre></td></tr></table></figure>


<p>这样返回的结果就很统一了。<br>至此，一个异步的、风格明确的、功能满足需要的API服务就完成了。<br>项目具体代码可见： <a href="https://github.com/dongweiming/weapp-zhihulive" target="_blank" rel="noopener">https://github.com/dongweiming/weapp-zhihulive</a></p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>自搭建git服务器实现提交代码自动推到测试环境</title>
    <url>/2016-04-05.html</url>
    <content><![CDATA[<p>####前言<br>假如公司有很多项目，很可能你要自建git服务器，然后有不同的分支管理各个项目。尤其是web开发，每次push不仅在测试环境需要pull代码，<br>可能还有nginx，uwsgi，supervisor等都需要重启。那么有没有什么办法让你在push代码的时候触发这一系列的重新部署呢？<br>####思路和例子<br>假设你的开发分支是feature_example_develop(你要是在master分支直接push也可以，呵呵)有A，B，C等等同事都会往这个分支提交东西<br>测试环境的IP为192.168.22.34</p>
<ol>
<li>在你的git版本库的hooks里面这些修改post-update(表示代码提交到版本库后触发)</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># An example hook script to prepare a packed repository for use over  </span></span><br><span class="line"><span class="comment"># dumb transports.  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># To enable this hook, rename this file to "post-update".  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取本次提交的分支名字  </span></span><br><span class="line">branch=$(git rev-parse --symbolic --abbrev-ref $<span class="number">1</span>)  </span><br><span class="line">          </span><br><span class="line">case <span class="string">"$branch"</span> <span class="keyword">in</span>  </span><br><span class="line">    feature_example_develop)  </span><br><span class="line">        echo This <span class="keyword">is</span> a develop push  </span><br><span class="line">        <span class="comment"># 远程执行测试环境下的sync_develop_code.sh脚本  </span></span><br><span class="line">        ssh dongwm@<span class="number">192.168</span><span class="number">.22</span><span class="number">.34</span>  -p <span class="number">9922</span> <span class="string">"source sync_develop_code.sh"</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    master)  </span><br><span class="line">        echo This <span class="keyword">is</span> a master push  </span><br><span class="line">        ;;  </span><br><span class="line">    *)  </span><br><span class="line">        echo This <span class="keyword">is</span> only some push ops.  </span><br><span class="line">        ;;  </span><br><span class="line">esac  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">exec</span> git update-server-info</span><br></pre></td></tr></table></figure>


<ol>
<li>测试环境的更新环境脚本 sync_develop_code.sh</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#! /bin/bash  </span></span><br><span class="line"><span class="comment"># 切换到git版本库目录下  </span></span><br><span class="line">cd /home/dongwm/test_develop  </span><br><span class="line"><span class="comment"># '拉'下最新代码  </span></span><br><span class="line">git pull origin feature_example_develop  </span><br><span class="line"><span class="comment"># 重启supervisor管理的进程  </span></span><br><span class="line">sudo supervisorctl -c /home/dongwm/test_develop/server/supervisor_develop.conf restart all  </span><br><span class="line"><span class="comment"># 重启uwsgi  </span></span><br><span class="line">sudo /etc/init.d/uwsgi restart</span><br></pre></td></tr></table></figure>


<p>####一个很重要的问题<br>post-update不会检查你的代码是不是有问题，当提交了错误的代码会造成测试环境问题<br>解决办法：修改update钩子-<br>在提交前对你设置的操作的执行的$?做判断-非0就会拒绝你的提交，在这个时候你可以做pylint/coverage/nosetests等，下次我再说我做的这个工作</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>IPython3时代到来</title>
    <url>/2016-04-02.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我以前写过一些<a href="http://www.dongwm.com/blog/categories/ipython/" target="_blank" rel="noopener">IPython高级用法</a>,<br>还有在组内分享了一期[IPython notebook的分享](<a href="http://www.dongwm.com/archives/ji-jiang-zai-" target="_blank" rel="noopener">http://www.dongwm.com/archives/ji-jiang-zai-</a><br>bpugfen-xiang/). 今天<a href="https://github.com/ipython/ipython" target="_blank" rel="noopener">IPython3</a>被release了.<br>它带来什么可以看一下[release notes](<a href="http://ipython.org/ipython-" target="_blank" rel="noopener">http://ipython.org/ipython-</a><br>doc/3/whatsnew/version3.html).<br>好吧, 我也没有意识到ipython3来的会这样快. 这多半年来. 我作为一个150个贡献者之一, 见证了IPython的发展. 这是个里程碑的版本.<br>他带来了非常多的变化和新的特性. 今天我来帮大家迁移和解读一些吧.<br>IPython是什么? 本质上它是一个增强版的python交互模式解释器, 所见即所得的执行代码, 查看结果, 也拥有历史记录.<br>我认为这是一个python开发者必备的工具. 我个人依赖ipython常用的功能有:</p>
<ul>
<li>ipython notebook - 一个可以跑的在线可编辑可运行的笔记. 可以测试程序, 执行代码, 当做说明文档, 能帮助不擅长web开发的同学做出很多页面的效果, 支持markdown语法等</li>
<li>自动补全 - 当我<code>import xx</code>的时候 我可以像用zsh一样使用Tab自动补全对应的模块/方法的名字</li>
<li>magic - 它提供很很多magic的函数命令, 比如你可以直接执行ls, pwd等. 还能使用其他shell命令, 调用编辑器等</li>
<li>它能通过?或者??帮我查看代码的注释, 接口参数等等.</li>
<li>它提供很多的配置选择, 可以使用内置/外部插件达到一些其他的功能, 比如autoreload - 你不需要退出ipython就能获得你已经import之后的代码修改后的效果.</li>
<li>它在分布计算, 数据分析上又很好的支持, ipython非常大的使用群体是科学家和算法工程师<br>它在python界有什么地位? 我肯定会带有个人色彩. 来一些github的数据说一说(截止到2015-03-01之前):<br>项目 | Issue数 | Star数  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django | 4221 | 13088  </span><br><span class="line">flask | 1359 | 12810  </span><br><span class="line">tornado | 1352 | 8626  </span><br><span class="line">ipython | 7898 | 5822  </span><br><span class="line">  </span><br><span class="line">这是python最有名的几个项目. 可以看到ipython的star远落后于其他. 但是他的issue数却大大的高于其他,</span><br><span class="line">一方面IPython覆盖的功能和逻辑更多更复杂.  </span><br><span class="line">一方面用户对IPython的依赖和兴趣要高很多,</span><br><span class="line">还有一方面IPython也由于内容太多更容易有bug,且主要维护者都是科学家没有太多精力和兴趣做一些基础保障.  </span><br><span class="line">可见IPython的知名度不高, 但是对用户粘性却很高.</span><br><span class="line">#### 如何升级</span><br><span class="line">假如你需要使用ipython notebook, 需要使用</span><br><span class="line"></span><br><span class="line">``` python    </span><br><span class="line">    </span><br><span class="line">    pip install --upgrade &quot;ipython[all]&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>否则直接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install --upgrade ipython</span><br></pre></td></tr></table></figure>


<h4 id="使用不同的内核-kernel"><a href="#使用不同的内核-kernel" class="headerlink" title="使用不同的内核(kernel)"></a>使用不同的内核(kernel)</h4><p>IPython的组件大多是核心开发者开发的, 中提到了kernel是这样几个:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Bash  </span><br><span class="line">Echo  </span><br><span class="line">Python2  </span><br><span class="line">Python3  </span><br><span class="line">R</span><br></pre></td></tr></table></figure>


<p>Bash是这个项目<a href="https://github.com/takluyver/bash_kernel/" target="_blank" rel="noopener">https://github.com/takluyver/bash_kernel/</a>, 你可以直接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo pip install bash_kernel</span><br></pre></td></tr></table></figure>


<p>那么开始说kernel是什么, kernel是一个能执行各种语言的程序封装, 比如可以用notebook跑bash, 跑ruby, 能使用其他语言的语法.<br>上面的bash就是借用pexpect的<a href="http://pexpect.readthedocs.org/en/latest/api/replwrap.html" target="_blank" rel="noopener">replwrap</a>实现的bash的封装.对比一下就知道了:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$/usr/local/bin/ipython  </span><br><span class="line">In [<span class="number">1</span>]: echo  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">NameError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-1</span><span class="number">-53</span>f31a089339&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 echo  </span><br><span class="line">  </span><br><span class="line">NameError: name <span class="string">'echo'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined  </span><br><span class="line">In [<span class="number">2</span>]: bc  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">NameError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-2</span>-b79898bb7907&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 bc  </span><br><span class="line">  </span><br><span class="line">NameError: name <span class="string">'bc'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined  </span><br><span class="line">$/usr/local/bin/ipython console --kernel bash <span class="comment"># 使用bash内核就可以使用这些bash下命令了  </span></span><br><span class="line">IPython Console <span class="number">3.0</span><span class="number">.0</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">1</span>]: echo <span class="string">'2-1'</span>  </span><br><span class="line"><span class="number">2</span><span class="number">-1</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: echo <span class="string">'2-1'</span>|bc</span><br></pre></td></tr></table></figure>


<p>看一下我本地都能用什么kernel:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ipython kernelspec list  </span><br><span class="line">Available kernels:  </span><br><span class="line">python2  </span><br><span class="line">python3  </span><br><span class="line">bash  </span><br><span class="line">echo</span><br></pre></td></tr></table></figure>


<p>python2就是系统默认的, 原来用的那个. 看到echo和python3的原因在这里:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$pwd  </span><br><span class="line">/Users/dongweiming/.ipython/kernels  </span><br><span class="line">$tree  </span><br><span class="line">.  </span><br><span class="line">├── echo <span class="comment"># 在~/.ipython/kernels有这个echo的目录里面包含了正确地kernel.json就会出现对应的kernel  </span></span><br><span class="line">│   └── kernel.json  </span><br><span class="line">├── echokernel.py  </span><br><span class="line">└── python3  </span><br><span class="line">    └── kernel.json  </span><br><span class="line">  </span><br><span class="line"><span class="number">2</span> directories, <span class="number">3</span> files</span><br></pre></td></tr></table></figure>


<p>看一下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$cat echo/kernel.json  </span><br><span class="line">&#123;<span class="string">"argv"</span>:[<span class="string">"python"</span>,<span class="string">"-m"</span>,<span class="string">"echokernel"</span>, <span class="string">"-f"</span>, <span class="string">"&#123;connection_file&#125;"</span>],  </span><br><span class="line"> <span class="string">"display_name"</span>:<span class="string">"Echo"</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">$cat python3/kernel.json  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="string">"display_name"</span>: <span class="string">"IPython (Python 3)"</span>,  </span><br><span class="line">  <span class="string">"language"</span>: <span class="string">"python"</span>,  </span><br><span class="line">  <span class="string">"argv"</span>: [  </span><br><span class="line">    <span class="string">"python3"</span>,  </span><br><span class="line">    <span class="string">"-c"</span>, <span class="string">"from IPython.kernel.zmq.kernelapp import main; main()"</span>,  </span><br><span class="line">    <span class="string">"-f"</span>, <span class="string">"&#123;connection_file&#125;"</span>  </span><br><span class="line">    ],  </span><br><span class="line">  <span class="string">"codemirror_mode"</span>: &#123;  </span><br><span class="line">    <span class="string">"version"</span>: <span class="number">2</span>,  </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ipython"</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">$ipython console --kernel python3 <span class="comment"># 可以在python2下跑python3的代码了  </span></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">print</span>  </span><br><span class="line">Out[<span class="number">1</span>]: &lt;function <span class="keyword">print</span>&gt;  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">print</span> <span class="string">'sd'</span>  </span><br><span class="line">  File <span class="string">"&lt;ipython-input-2-f747b7d9e029&gt;"</span>, line <span class="number">1</span>  </span><br><span class="line">      <span class="keyword">print</span> <span class="string">'sd'</span>  </span><br><span class="line">      ^  </span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>


<p>更多的自定义请看[Wrapper kernels](<a href="http://ipython.org/ipython-" target="_blank" rel="noopener">http://ipython.org/ipython-</a><br>doc/3/development/wrapperkernels.html)<br>当然这里默认都可以在notebook里使用</p>
<h4 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h4><p>widget系统经过了很大的重构和更新, 全部信息在[widget migration guide](<a href="http://ipython.org/ipython-" target="_blank" rel="noopener">http://ipython.org/ipython-</a><br>doc/3/whatsnew/version3_widget_migration.html).<br>Widget是什么? 这是ipython notebook的插件系统, 大部分的插件都可以看这里:<br><a href="http://nbviewer.ipython.org/github/dongweiming/divingintoipynb/blob/master/double11/containers_widgets.ipynb" target="_blank" rel="noopener">containers_widgets.ipynb</a>,<br>看完就知道它是什么和它能做什么了.<br>在我分享notebook的项目<a href="https://github.com/dongweiming/divingintoipynb" target="_blank" rel="noopener">divingintoipynb</a>里你能看到我自定义的widget:<br><a href="https://github.com/dongweiming/divingintoipynb/blob/master/double11/selectize_widget.ipynb" target="_blank" rel="noopener">selectize_widget.ipynb</a>,<br>和对应的<a href="https://github.com/dongweiming/divingintoipynb/blob/master/double11/widget_selectize.py" target="_blank" rel="noopener">widget_selectize.py</a>.<br>custom.js在使用的时候也有了很大的变动,<br>可以看我分享项目的<a href="https://github.com/dongweiming/divingintoipynb/blob/master/profile_double11/static/custom/custom.js" target="_blank" rel="noopener">custom.js</a></p>
<h4 id="Notebook-format"><a href="#Notebook-format" class="headerlink" title="Notebook format"></a>Notebook format</h4><p>原来的Notebook的版本是3, 现在已经升级为4. 他们是不兼容的版本. 在启动新版IPython访问你的ipynb的时候会出现这样的弹出框:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">This notebook has been converted <span class="keyword">from</span> an older notebook format (v3) to the current notebook format (v4). The next time you save this notebook, the current notebook format will be used. Older versions of IPython may <span class="keyword">not</span> be able to read the new format. To preserve the original version, close the notebook without saving it.</span><br></pre></td></tr></table></figure>


<p>你记得保存一下会帮你自动转化为新版本, 下次再启动就可以. 假如由于bug或者其他原因想降级可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ipython nbconvert --to notebook --nbformat <span class="number">3</span> &lt;notebook&gt;</span><br></pre></td></tr></table></figure>


<h4 id="使用jinja2自定义模板"><a href="#使用jinja2自定义模板" class="headerlink" title="使用jinja2自定义模板"></a>使用jinja2自定义模板</h4><p>通过<code>NotebookApp.extra_template_paths</code>可以指定外部模板目录, 可以代替默认模板. 或者:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ipython notebook <span class="string">'--extra_template_paths=["/Users/dongweiming/.ipython/templates/"]'</span></span><br></pre></td></tr></table></figure>


<p>比如你不喜欢ipython notebook提供的现有的目录页(<a href="http://localhost:8000/tree这样的路径)" target="_blank" rel="noopener">http://localhost:8000/tree这样的路径)</a>.<br>你可以自己写一个叫做tree.html.的模板放在<br>/Users/dongweiming/.ipython/templates/目录下. 但是建议还是继承原来的tree.html, 再自由发挥.</p>
<h4 id="使用ipython-notebook的terminal功能"><a href="#使用ipython-notebook的terminal功能" class="headerlink" title="使用ipython notebook的terminal功能."></a>使用ipython notebook的terminal功能.</h4><p>在notebook页面上其实是可以直接使用websocket连接到服务器上的. 但是你需要安装<code>terminado</code>.<br>这样在/tree下新建的时候就能选择terminal了.</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>剩下就是一些bug修改, 方法重命名, 功能增强, 去掉一些不再被维护的内容等等. 对95%的用户影响几乎没有.</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>CODE开源了</title>
    <url>/2016-04-01.html</url>
    <content><![CDATA[<h3 id="开源了-开源了"><a href="#开源了-开源了" class="headerlink" title="开源了, 开源了"></a>开源了, 开源了</h3><p>喜大普奔.<br><img src="https://cloud.githubusercontent.com/assets/841395/11614180/3037e46a-9c75-11e5-85a2-431d91409cf3.png" alt><br>欢迎围观试用: <a href="https://github.com/douban/code" target="_blank" rel="noopener">CODE</a></p>
<h1 id="再来一遍-CODE"><a href="#再来一遍-CODE" class="headerlink" title="再来一遍 CODE"></a>再来一遍 <a href="https://github.com/douban/code" target="_blank" rel="noopener">CODE</a></h1><p>想直接看效果的可以看 <a href="https://github.com/douban/code/pull/68" target="_blank" rel="noopener">这里</a> 或者拉到最下面.<br>可能很多人有点诧异, CODE不是已经开源了么? 是的, 2014年2月14日CODE的早期版本就开源到了github. 但是后来由于很多原因没有在做下去,<br>今天, 它真的开源了.<br>让我坚持下来的也是我想给外界看到豆瓣工程师文化的结晶, 这是一种情怀, 今天我想说说我和CODE的故事</p>
<h3 id="CODE的意义"><a href="#CODE的意义" class="headerlink" title="CODE的意义"></a>CODE的意义</h3><p>CODE为什么开源: 希望更多的人可以使用 CODE，希望更多的人可以一起开发 CODE。 - Code Team<br>市面上有gitlab, 有github企业版. 我们折腾一个这样的东西有什么意义呢? 以下是我的看法.</p>
<ol>
<li>CODE是一款豆瓣工程师自发组织, 基于我们自己的需要做出来的. 它是互联网公司程序员的需要而产生的, CODE也曾经给github的同仁们演示, 获得了很高的赞誉.</li>
<li>它并不是github的python克隆版, 但是有些地方却是和github殊途同归.</li>
<li>当产品发展到一定地步, 对这个版本控制工具会有更多的定制化需求, 这个时候会需要二次开发. 假如你是个ruby开发很多的公司, 用gitlab也不算个问题. 但是假如大家用非ruby的语言为主, 那么就很痛苦.<br>ruby虽然在配置管理, web开发上面有一席之位, 但是没有python这么普遍. 同事们的参与局限性就多了很多.</li>
<li>假如你所在公司是python系, 或者爱好python系的, 那么CODE真的是一个很不错的选择. 它是永远免费的, 它是由国内python最大应用公司的工程师们开发, 质量有保证. 看代码的过程中也能学习到一些python的技巧,<br>豆瓣的玩法, 了解豆瓣的开发流程.</li>
<li>我一直觉得轮子是需要造的, 这个过程你能有造轮子的乐趣, 能力得到更多的提高, 而一直在用其他人的东西那么永远只会停留在这个程度上.</li>
<li>用CODE, 看CODE代码的时候, 仿佛可以看到那帮有情怀, 有工程师文化的同学们在讨论需求, code review… 我一直认为这种关系和友谊才是最好的团队具有的<h3 id="情怀"><a href="#情怀" class="headerlink" title="情怀"></a>情怀</h3>好吧, 啥是情怀呢?<blockquote>
<p>情怀就是以心灵的满足而不是功利的得失作为自己的行为标准的一种品质。<br>一件没什么用的事，还是要去做，也许只因为我喜欢，也许只因为它看起来很美 –<br>知乎<a href="http://www.zhihu.com/people/song-lao-mo" target="_blank" rel="noopener">@宋老末</a><br>「我坚信程序员都是有情怀的. 」<br>从<a href="https://github.com/douban/code/issues/65#issuecomment-126901877" target="_blank" rel="noopener">我决定继续这件事</a>,<br>到现在已经4个月有余. 这个过程里面经历蛮多, 比如我经历着从技术转型做管理, 部门问题多多, 人员也在我强力介入下也流动蛮大的 -。-;<br>我也要花很大的精力陪女儿; 我一直也在不断的给自己充电, 我现在也要开始写书了… 做了TL, 唯一的感觉就是时间不够用, 我是个蛮有洁癖的人,<br>以前做普通工程师的时候按期完成我职责范围内的就好了, 现在责任大了, 看着产品线的sentry里那么多的报错,<br>看着Trello里面堆积那么多的card还没有机会做… 尤其在我使用一种新的管理风格有关, 让我倍敢压力, 非常辛苦.<br>要不是xTao不断催促, 可能还要拖期.<br>是什么支撑我的情怀?<br>除了眼前的苟且，还有诗和远方 - 知乎<a href="http://www.zhihu.com/people/dai-xiao-xi-70" target="_blank" rel="noopener">@戴晓溪</a></p>
</blockquote>
<h3 id="我和CODE"><a href="#我和CODE" class="headerlink" title="我和CODE"></a>我和CODE</h3>告诉你们个小秘密, 我来豆瓣其实也是和CODE有很大的关系的… 在这里感谢@xTao和邢老师.<br>这一切是为什么捏?<br>话说那是13年下半年, 我的前公司从svn转到了gitlab. 我们在内部搭建了一个gitlab服务器. 各个产品线的代码都开始往上面迁移,<br>我不得不说它是市面上非常好的开源选择. 但是过了一段时间我就发现了问题:<br>我是python系的, 我有时候对它是不满意的, 有想法二次开发的.<br>这里我提一点, 很多人都说: “哎呀不要局限于编程语言, 不要去争论xx是宇宙第一语言”. 我的观点是, 只有0.1%的天才+4.9%的有天赋,<br>能力很强的人是可以这么说的. 剩下的95%都是在给自己学的不好找个理由和慰藉罢了.<br>想要走在金字塔尖就需要有执念, 否则只能沦落到打打嘴炮的地步.<br>我曾经尝试一边翻着《Ruby元编程》一边去读gitlab的源码, 想尝试定制它. 努力了差不多一个月放弃了. 原因无二,<br>这种临时报佛脚去玩转一个大公司北京, 多位大牛参与的开源项目的必然结果.<br>很痛苦, 但是内心又多有不甘, 于是决定做一个大事: 用python造个gitlab的轮子:</li>
<li>样式扒gitlab</li>
<li>根据gitlab的路由方式添加url</li>
<li>使用pygit2作为git后端<br>做起来才知道, 这是一个非常浩大的工程, 对于我当时的技术能力来说是个非常大的挑战. 我汲取前后端知识就基本直接用在这个项目上了.<br>有一天, 我产生了放弃的念头.<br>之前我对豆瓣也没有什么特别的感觉. 直到这天我看到<a href="http://v.youku.com/v_show/id_XNTYwMzc0NjY0.html" target="_blank" rel="noopener">清风在 C2D2<br>的分享</a><br><a href="http://segmentfault.com/a/1190000000410324" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000410324</a><br><a href="http://www.infoq.com/cn/articles/douban-code-2years" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/douban-code-2years</a><br><a href="http://www.infoq.com/cn/presentations/tools-love-knot-of-engineer-culture" target="_blank" rel="noopener">http://www.infoq.com/cn/presentations/tools-love-knot-of-engineer-culture</a><br>在遥远的豆瓣, 有这样一帮人和我有同样的想法. 我称他们为geek. 这是我向往的地方呀. 于是, 我决定去豆瓣<br>CODE开源不久, 我就到了豆瓣.<br>非常遗憾, 我进来的时候, CODE的核心开发大多离开了豆瓣. 我没有机会和他们一起做CODE. CODE功能也接近稳定,<br>心情蛮失落的我只是修了几十个bug. 加一些功能, 比如:</li>
<li>鼠标放在团队上也会hover一个team的card</li>
<li>telchar - 类似quora的qlint</li>
<li>鼠标放在emoji会悬浮图片的放大版本</li>
<li>项目的guidelines<br>等等.<br>我本想拿下CODE全部的徽章, 但是给我颁徽章的人们却不在了.<h3 id="CODE的未来"><a href="#CODE的未来" class="headerlink" title="CODE的未来"></a>CODE的未来</h3>我会保证CODE会一直做下去. 但是单个人的能力精力有限, 我欢迎更多的公司都来用CODE,<br>帮助它变得更好. 也欢迎更多的同学参与进来.<br>未来CODE会做以下几件事情(不断补充中)</li>
<li>完善CODE的功能 - 现在放出来, 跑起来了. 但是预计还会有很多坑</li>
<li>增加初始化脚本, 填充数据</li>
<li>修复travis-ci</li>
<li>国际化 - 现在code里面有很多中文, 需要英文能力很高的同学一起来做</li>
<li>重构 - 有很多功能都是需要重构甚至重写的</li>
<li>其他方面的尝试<h3 id="截图时间"><a href="#截图时间" class="headerlink" title="截图时间"></a>截图时间</h3><img src="https://cloud.githubusercontent.com/assets/841395/11595743/f5c16d72-9aeb-11e5-9996-8b2067077f2e.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595742/f5c0dfd8-9aeb-11e5-967f-8888ee323021.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595745/f5c618cc-9aeb-11e5-90b9-24a7a443a568.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595741/f5c0a50e-9aeb-11e5-8074-b146794bc1a7.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595744/f5c554d2-9aeb-11e5-8c1a-599d73a9410a.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606858/2abcf166-9b6b-11e5-9aa0-347a83c03ae6.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606857/2abb3eb6-9b6b-11e5-83ee-c4ed8c39158b.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606859/2acc4e40-9b6b-11e5-9986-0f19a7249a12.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606860/2ace49b6-9b6b-11e5-88a5-191b69aa485c.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606861/2ad1e94a-9b6b-11e5-8b63-9ec3d6e5ad31.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606862/2ad8394e-9b6b-11e5-8d1c-50f2c3a94b10.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595747/f60fe7d6-9aeb-11e5-85ab-429e3ce8aa06.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595748/f6136848-9aeb-11e5-8867-17ece42606dd.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595833/69005bd6-9aec-11e5-8c61-d31198b5ba4b.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595834/6907afda-9aec-11e5-9a6f-5f8c1ccd618a.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595892/cb007622-9aec-11e5-9fe6-95080ad41ea8.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595962/2e9ec8e6-9aed-11e5-975a-ec93ce44c700.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595993/6d118348-9aed-11e5-85aa-2b1020424d91.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606888/d4d4bf02-9b6c-11e5-9e70-c577e0ea2b69.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595995/6f60d4a0-9aed-11e5-90e3-02106c1c35f3.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11595998/72398816-9aed-11e5-857f-a84cc94334f1.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606887/d4d32d54-9b6c-11e5-872a-393de0192bc7.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/11606879/4dac006c-9b6c-11e5-82b6-e3431034234b.png" alt></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docopt/schema:markdown文件直接发送支持python语法的邮件</title>
    <url>/2016-04-06.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>工作经常写一些东西发邮件，但是渐渐的已经用markdown写东西，每次很纠结，</li>
<li>而且还需要我打开邮箱，然后balabala，比如我还要在后面加入公司和自己的一些信息</li>
<li>经常邮件或者html都带有python的源码段，想要一个支持python语法的css显示效果<h2 id="使用的模块"><a href="#使用的模块" class="headerlink" title="使用的模块"></a>使用的模块</h2></li>
</ol>
<ul>
<li><a href="https://github.com/docopt/docopt" target="_blank" rel="noopener">docopt</a> Pythonic的命令行函数解析，只需要把显示的参数列表放在 <strong>doc</strong></li>
<li><a href="https://github.com/halst/schema" target="_blank" rel="noopener">schema</a> Pythonic的数据结构验证，不需要那么多的异常处理</li>
<li><a href="https://pypi.python.org/pypi/Markdown/2.3.1" target="_blank" rel="noopener">markdown</a></li>
<li><a href="https://pypi.python.org/pypi/PyYAML/3.10" target="_blank" rel="noopener">PyYAML</a> 解析yaml文件</li>
<li><a href="https://pypi.python.org/pypi/Pygments/1.6" target="_blank" rel="noopener">pygments</a> 借用它对python语法的一些正则匹配</li>
<li><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">requests</a> 我没有自己实现css，css可以本地自己自定义，也可以从网站下载，这里去爬网站的css文件<br>PS:安装这些可以</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo easy_install schema docopt markdown pygments pyyaml</span><br></pre></td></tr></table></figure>


<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>支持python语法</li>
<li>支持本地有配置文件，不需要命令行balabala那么多(使用yaml)</li>
<li>支持多种颜色方案，方案可选项: pygments-css</li>
<li>支持本地自定义css(默认去这个网站爬回来)</li>
<li>支持中文</li>
<li>支持自定义html模板文件，比如我们公司邮件下部的联系方式等说明，可以放在模板邮件里面</li>
<li>可以不发送邮件，只保留和加了css后的html到本地文件<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2></li>
</ul>
<ol>
<li>默认模式</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python MarkPygments.py  --mailto mailto@qq.com,mailto2@qq.com  -s 标题 --mailserver smtp.exmail.qq.com -u youremailname   </span><br><span class="line">-p yourpassword   --cc cc@qq.com whatever.md --template template.html</span><br></pre></td></tr></table></figure>


<ol>
<li>使用本地yaml配置，配置如下, 配置中没有能命令行选项找，配置和终端都有会使用中有文件配置<br>这是yaml文件的内容：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">markemail:  </span><br><span class="line">    --theme: autumn  </span><br><span class="line">    --username: XX   </span><br><span class="line">    --password: YY  </span><br><span class="line">    --mailserver: smtp.exmail.qq.com  </span><br><span class="line">    --mailto: to1@qq.com,to2@qq.com  </span><br><span class="line">    --subject: <span class="string">'周报'</span></span><br></pre></td></tr></table></figure>


<p>然后这样使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python MarkPygments.py --config ~/.config.yaml whatever.md --template template.html</span><br></pre></td></tr></table></figure>


<ol>
<li>使用本地css目录下的css， 不发送邮件只保存html到本地文件</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python MarkPygments.py --config ~/.config.yaml whatever.md --template template.html   </span><br><span class="line">-o out.html --local pygments-css</span><br></pre></td></tr></table></figure>


<p>这里是代码，或者你可以去看<a href="https://github.com/orzrd/mytools/blob/master/MarkPygments.py" target="_blank" rel="noopener">MarkPygments.py</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="string">'''  </span></span><br><span class="line"><span class="string">Usage:  </span></span><br><span class="line"><span class="string">MarkPygments.py [options] MDFILE  </span></span><br><span class="line"><span class="string">MarkPygments.py [options] --local &lt;cssdir&gt; MDFILE  </span></span><br><span class="line"><span class="string">MarkPygments.py [options] --config &lt;yamlfile&gt; MDFILE  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">Arguments:  </span></span><br><span class="line"><span class="string">MDFILE the markdown file  </span></span><br><span class="line"><span class="string">-u --username user your email name  </span></span><br><span class="line"><span class="string">-p --password pass your email login password  </span></span><br><span class="line"><span class="string">-mt --mailto tolist mailto list  </span></span><br><span class="line"><span class="string">--theme theme css style for python syntax [default: monokai]  </span></span><br><span class="line"><span class="string">-s --subject subject email's subject  </span></span><br><span class="line"><span class="string">--mailserver server mail server [default: smtp.exmail.qq.com]  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">Options:  </span></span><br><span class="line"><span class="string">-h --help show this help message and exit  </span></span><br><span class="line"><span class="string">--version show version and exit  </span></span><br><span class="line"><span class="string">--config yamlfile config yaml file path (e.g. .config.yaml)  </span></span><br><span class="line"><span class="string">--local cssdir use local custom css dir  </span></span><br><span class="line"><span class="string">-o --output [outhtml] make output to html file  </span></span><br><span class="line"><span class="string">-c --cc list cc list  </span></span><br><span class="line"><span class="string">--template html template html  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">'''</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"><span class="keyword">import</span> codecs  </span><br><span class="line"><span class="keyword">import</span> smtplib  </span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText  </span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart  </span><br><span class="line"><span class="keyword">import</span> markdown  </span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt  </span><br><span class="line"><span class="keyword">from</span> schema <span class="keyword">import</span> Schema, And, Or, Use, SchemaError  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message, error=False)</span>:</span>  </span><br><span class="line">    <span class="string">'''终端输出log'''</span>  </span><br><span class="line">    color = <span class="number">31</span> <span class="keyword">if</span> error <span class="keyword">else</span> <span class="number">32</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\x1B[1;&#123;0&#125;m * &#123;1&#125;\x1B[0m'</span>.format(color, message)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regex</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="string">'''借用pygments对python语法的实现以及自己实现的正则'''</span>  </span><br><span class="line">    <span class="keyword">from</span> pygments.lexers <span class="keyword">import</span> PythonLexer  </span><br><span class="line">    dict = &#123;&#125;  </span><br><span class="line">    lex = PythonLexer()  </span><br><span class="line">    token = lex.tokens  </span><br><span class="line">    l = [<span class="string">'keywords'</span>, <span class="string">'builtins'</span>]  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:  </span><br><span class="line">        dict[i[:<span class="number">2</span>]] = token[i][<span class="number">0</span>][<span class="number">0</span>]  </span><br><span class="line">    dict[<span class="string">'fu'</span>] = <span class="string">'.*(def)\W+(.*)\((.*)\)'</span>  </span><br><span class="line">    dict[<span class="string">'cl'</span>] = <span class="string">'.*(?!&lt;span)(class)(?!=)\W+(?!=)(.*)\((.*)\)'</span>  </span><br><span class="line">    dict[<span class="string">'fm'</span>] = <span class="string">'.*(from)\W+(.*)\W+(import)\W+(.*)'</span>  </span><br><span class="line">    dict[<span class="string">'im'</span>] = <span class="string">'.*(import)\W\&#123;,\4&#125;(.*)'</span>  </span><br><span class="line">    <span class="keyword">return</span> dict  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMail</span><span class="params">(mailserver, username, password, tolist, subject, msg, cc=[])</span>:</span>  </span><br><span class="line">    <span class="string">'''发送邮件'''</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeEmail</span><span class="params">(content)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        msg = MIMEMultipart()  </span><br><span class="line">        msg[<span class="string">'Subject'</span>] = subject  </span><br><span class="line">        msg[<span class="string">'From'</span>] = username  </span><br><span class="line">        msg[<span class="string">'To'</span>] = <span class="string">','</span>.join(tolist)  </span><br><span class="line">        <span class="keyword">if</span> cc:  </span><br><span class="line">            msg[<span class="string">'Cc'</span>] = <span class="string">','</span>.join(cc)  </span><br><span class="line">        html_part = MIMEText(content, <span class="string">'html'</span>, <span class="string">'utf-8'</span>)  </span><br><span class="line">        msg.attach(html_part)  </span><br><span class="line">        <span class="keyword">return</span> msg  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">  </span><br><span class="line">        smtp = smtplib.SMTP()  </span><br><span class="line">        log(<span class="string">'Connect to &#123;0&#125;'</span>.format(mailserver))  </span><br><span class="line">        smtp.connect(mailserver, <span class="number">25</span>)  </span><br><span class="line">        smtp.login(username, password)  </span><br><span class="line">        log(<span class="string">'Login Success with &#123;0&#125;'</span>.format(username))  </span><br><span class="line">        log(<span class="string">'To send this Email...'</span>)  </span><br><span class="line">        <span class="keyword">if</span> cc:  </span><br><span class="line">            smtp.sendmail(username, tolist + cc, makeEmail(msg).as_string())  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            smtp.sendmail(username, tolist, makeEmail(msg).as_string())  </span><br><span class="line">        log(<span class="string">'Send Success'</span>)  </span><br><span class="line">    <span class="keyword">except</span> Exception, e:  </span><br><span class="line">        log(e, error=<span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paserYaml</span><span class="params">(yamlfile)</span>:</span>  </span><br><span class="line">    <span class="string">'''解析yaml文件配置'''</span>  </span><br><span class="line">    <span class="keyword">import</span> yaml  </span><br><span class="line">    <span class="keyword">return</span> yaml.load(open(yamlfile)).get(<span class="string">'markemail'</span>, &#123;&#125;)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_email</span><span class="params">(emails)</span>:</span>  </span><br><span class="line">    <span class="string">'''检查选项是否是邮件格式'''</span>  </span><br><span class="line">    <span class="keyword">print</span> emails  </span><br><span class="line">    regex = <span class="string">r'''^[_a-z0-9-]+(\.[a-z0-9-]+)*@[a-z0-9-]+  </span></span><br><span class="line"><span class="string">(\.[a-z0-9-]+)*(\.[a-z]&#123;2,3&#125;)$'''</span>  </span><br><span class="line">    rst = map(<span class="keyword">lambda</span> n: <span class="literal">True</span> <span class="keyword">if</span> re.compile(  </span><br><span class="line">        regex).match(n) <span class="keyword">else</span> <span class="literal">False</span>, emails.split(<span class="string">','</span>))  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="literal">False</span> <span class="keyword">not</span> <span class="keyword">in</span> rst <span class="keyword">else</span> <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">colorClass</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="string">'''pygments-css对语法的class对应字典'''</span>  </span><br><span class="line">    <span class="keyword">return</span> dict(  </span><br><span class="line">        cl=[<span class="string">'k'</span>, <span class="string">'nc'</span>, <span class="string">'nb'</span>],  </span><br><span class="line">        fu=[<span class="string">'k'</span>, <span class="string">'nf'</span>, <span class="string">'bp'</span>],  </span><br><span class="line">        fm=[<span class="string">'nd'</span>, <span class="string">'vi'</span>, <span class="string">'nd'</span>, <span class="string">'vi'</span>],  </span><br><span class="line">        im=[<span class="string">'nd'</span>, <span class="string">'mi'</span>],  </span><br><span class="line">        ke=[<span class="string">'kd'</span>],  </span><br><span class="line">        bu=[<span class="string">'vc'</span>]  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cssStyle</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="string">'''获取css设置'''</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, style, *args)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        self.style = style  </span><br><span class="line">        self.args = args  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fusionCss</span><span class="params">(self, csshtml)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        css = <span class="string">'&lt;style type="text/css"&gt;'</span>  </span><br><span class="line">        css += <span class="string">'.codehilite &#123;border: 2px solid rgb(225, 225, 225)&#125;'</span>  </span><br><span class="line">        css += csshtml  </span><br><span class="line">        css += <span class="string">'&lt;/style&gt;'</span>  </span><br><span class="line">        <span class="keyword">return</span> css  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">local</span><span class="params">(self, cssdir, theme)</span>:</span>  </span><br><span class="line">        <span class="string">'''从本地css文件'''</span>  </span><br><span class="line">        log(<span class="string">'Fetch css from local dir:&#123;0&#125;'</span>.format(cssdir))  </span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'&#123;0&#125;/&#123;1&#125;.css'</span>.format(cssdir, theme)) <span class="keyword">as</span> f:  </span><br><span class="line">            css = f.read().strip()  </span><br><span class="line">        <span class="keyword">return</span> self.fusionCss(css)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawler</span><span class="params">(self, theme)</span>:</span>  </span><br><span class="line">        <span class="string">'''去这个网站爬回来'''</span>  </span><br><span class="line">        <span class="keyword">import</span> requests  </span><br><span class="line">        log(<span class="string">'Fetch css from site:igniteflow.com'</span>)  </span><br><span class="line">        r = requests.get(  </span><br><span class="line">            <span class="string">'http://igniteflow.com/static/css/pygments/&#123;0&#125;.css'</span>.format(theme))  </span><br><span class="line">        <span class="keyword">return</span> self.fusionCss(r.text.strip())  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> getattr(self, self.style)(*self.args)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FabricHtml</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, md, css)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        self.css = css  </span><br><span class="line">        self.md_html = self.makeToHtml(md)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeToHtml</span><span class="params">(self, md)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        log(<span class="string">'Markdown converted into html'</span>)  </span><br><span class="line">        input_file = codecs.open(md, mode=<span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>)  </span><br><span class="line">        text = input_file.read()  </span><br><span class="line">        <span class="keyword">return</span> markdown.markdown(text)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AddCssToHtml</span><span class="params">(self, html, css_html)</span>:</span>  </span><br><span class="line">        <span class="string">'''增加css的style'''</span>  </span><br><span class="line">        ohtml = css_html  </span><br><span class="line">        c = html.split(<span class="string">'```'</span>)  </span><br><span class="line">        inc = <span class="number">0</span>  </span><br><span class="line">        ohtml += c[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">for</span> inc <span class="keyword">in</span> range(<span class="number">1</span>, len(c[<span class="number">1</span>:]) + <span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> inc % <span class="number">2</span>:  </span><br><span class="line">                ohtml += <span class="string">'&lt;div class="codehilite"&gt;'</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                ohtml += <span class="string">'&lt;/div&gt;'</span>  </span><br><span class="line">            ohtml += c[inc]  </span><br><span class="line">            inc += <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> ohtml  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeSpan</span><span class="params">(self, html, c)</span>:</span>  </span><br><span class="line">        <span class="string">'''构造span包含符合的语法块'''</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> html:  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;span class="&#123;0&#125;"&gt;&#123;1&#125;&lt;/span&gt;'</span>.format(c, html)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">markHtml</span><span class="params">(self, h)</span>:</span>  </span><br><span class="line">        <span class="string">'''给html加python语法的颜色css'''</span>  </span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> regex().items():  </span><br><span class="line">            args = colorClass()[k]  </span><br><span class="line">            m = re.compile(<span class="string">r'%s'</span> % v).match(h)  </span><br><span class="line">            <span class="keyword">if</span> m:  </span><br><span class="line">                match = m.groups()  </span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(args)):  </span><br><span class="line">                    h = re.sub(match[i], self.makeSpan(  </span><br><span class="line">                        match[i], args[i]), h, <span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> h  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, template=<span class="string">''</span>)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        has_css_html = self.AddCssToHtml(self.md_html, self.css)  </span><br><span class="line">        <span class="keyword">return</span> self.pygments(has_css_html) + template  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pygments</span><span class="params">(self, html)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        log(<span class="string">'Mark span label with python syntax'</span>)  </span><br><span class="line">        ohtml = <span class="string">''</span>  </span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> html.split(<span class="string">'\n'</span>):  </span><br><span class="line">            ohtml += self.markHtml(h)  </span><br><span class="line">            ohtml += <span class="string">'\n'</span>  </span><br><span class="line">        <span class="keyword">return</span> ohtml  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSchema</span><span class="params">(schemadict, args)</span>:</span>  </span><br><span class="line">    <span class="string">'''Pythonic的检查schema'''</span>  </span><br><span class="line">    schema = Schema(schemadict)  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        args = schema.validate(args)  </span><br><span class="line">    <span class="keyword">except</span> SchemaError <span class="keyword">as</span> e:  </span><br><span class="line">        <span class="keyword">raise</span>  </span><br><span class="line">        exit(log(e, error=<span class="literal">True</span>))  </span><br><span class="line">    <span class="keyword">return</span> args  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    args = docopt(__doc__, version=<span class="string">'1.0r1'</span>)  </span><br><span class="line">  </span><br><span class="line">    isLocal = args.get(<span class="string">'--local'</span>)  </span><br><span class="line">    hasConfig = args.get(<span class="string">'--config'</span>)  </span><br><span class="line">    theme = args.get(<span class="string">'--theme'</span>)  </span><br><span class="line">    <span class="keyword">if</span> hasConfig:  </span><br><span class="line">        checkSchema(&#123;  </span><br><span class="line">            <span class="string">'--config'</span>: And(Use(str),  </span><br><span class="line">                            os.path.exists,  </span><br><span class="line">                            error=<span class="string">'Invalid config format or not exists'</span>)  </span><br><span class="line">        &#125;, &#123;<span class="string">'--config'</span>: hasConfig&#125;  </span><br><span class="line">        )  </span><br><span class="line">        yamlConfig = paserYaml(hasConfig)  </span><br><span class="line">        args.update(yamlConfig)  </span><br><span class="line">    args.pop(<span class="string">'--config'</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> isLocal:  </span><br><span class="line">        checkSchema(&#123;  </span><br><span class="line">            <span class="string">'--local'</span>: And(Use(str), os.path.isdir,  </span><br><span class="line">                           <span class="keyword">lambda</span> n: os.path.exists(<span class="string">'&#123;0&#125;/&#123;1&#125;.css'</span>.format(  </span><br><span class="line">                                                    n, theme)), error=  </span><br><span class="line">                           <span class="string">'Invalid custom css dir or hasnot this theme'</span>),  </span><br><span class="line">        &#125;, &#123;<span class="string">'--local'</span>: isLocal&#125;  </span><br><span class="line">        )  </span><br><span class="line">        css_dict = cssStyle(<span class="string">'local'</span>, isLocal, theme).main()  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        css_dict = cssStyle(<span class="string">'crawler'</span>, theme).main()  </span><br><span class="line">    args.pop(<span class="string">'--local'</span>)  </span><br><span class="line">    args.pop(<span class="string">'--theme'</span>)  </span><br><span class="line">    args = checkSchema(&#123;  </span><br><span class="line">        <span class="string">'MDFILE'</span>: os.path.exists,  </span><br><span class="line">        <span class="string">'--mailserver'</span>: Use(str, error=<span class="string">'Invalid server format'</span>),  </span><br><span class="line">        <span class="string">'--mailto'</span>: And(Use(str), <span class="keyword">lambda</span> n: check_email(n),  </span><br><span class="line">                        error=<span class="string">'Invalid email format'</span>),  </span><br><span class="line">        <span class="string">'--subject'</span>: Or(Use(str), Use(unicode),  </span><br><span class="line">                        error=<span class="string">'Invalid suject format'</span>),  </span><br><span class="line">        <span class="string">'--password'</span>: Use(str, error=<span class="string">'Invalid suject format'</span>),  </span><br><span class="line">        <span class="string">'--cc'</span>: Or(<span class="literal">None</span>, And(Use(str), <span class="keyword">lambda</span> n: check_email(n)),  </span><br><span class="line">                   error=<span class="string">'Invalid email format'</span>),  </span><br><span class="line">        <span class="string">'--output'</span>: Or(<span class="literal">False</span>, <span class="keyword">lambda</span> n: os.path.exists(  </span><br><span class="line">        os.path.dirname(<span class="string">'&#123;0&#125;/&#123;1&#125;'</span>.format(  </span><br><span class="line">        os.path.abspath(<span class="string">'.'</span>), n))),  </span><br><span class="line">            error=<span class="string">'Dir must exists'</span>),  </span><br><span class="line">        <span class="string">'--template'</span>: Or(<span class="literal">None</span>, os.path.exists, error=<span class="string">'template must exists'</span>),  </span><br><span class="line">        <span class="string">'--username'</span>: Use(check_email, error=<span class="string">'Invalid username format'</span>),  </span><br><span class="line">        <span class="string">'--help'</span>: Or(<span class="literal">False</span>, <span class="literal">True</span>),  </span><br><span class="line">        <span class="string">'--version'</span>: Or(<span class="literal">False</span>, <span class="literal">True</span>)  </span><br><span class="line">    &#125;, args)  </span><br><span class="line">    do = FabricHtml(args[<span class="string">'MDFILE'</span>], css_dict)  </span><br><span class="line">    cc = args[<span class="string">'--cc'</span>].split(<span class="string">','</span>) <span class="keyword">if</span> args[<span class="string">'--cc'</span>] <span class="keyword">else</span> []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'--template'</span>]:  </span><br><span class="line">        <span class="keyword">with</span> codecs.open(args[<span class="string">'--template'</span>], mode=<span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:  </span><br><span class="line">            html_content = do.main(f.read())  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        html_content = do.main()  </span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'--output'</span>]:  </span><br><span class="line">        <span class="keyword">with</span> codecs.open(args[<span class="string">'--output'</span>], mode=<span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:  </span><br><span class="line">            f.write(html_content)  </span><br><span class="line">            exit()  </span><br><span class="line">  </span><br><span class="line">    sendMail(  </span><br><span class="line">        args[<span class="string">'--mailserver'</span>],  </span><br><span class="line">        args[<span class="string">'--username'</span>],  </span><br><span class="line">        args[<span class="string">'--password'</span>],  </span><br><span class="line">        args[<span class="string">'--mailto'</span>].split(<span class="string">','</span>),  </span><br><span class="line">        args[<span class="string">'--subject'</span>],  </span><br><span class="line">        html_content,  </span><br><span class="line">        cc  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python版个人简历</title>
    <url>/2016-04-04.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h4><p>最近换工作,无聊之下搞了个python版本的简历,包含我的相应信息,以及使用了一个装饰器用来显示颜色和相应块信息.并上传到gist.github.com<br>#####代码如下(隐藏了个人信息用’XXX’代替)</p>
<pre><code>#/usr/bin/env python  
# coding=utf-8  

import random  
import re  


def color(messages):  
    color = ‘\x1B[%d;%dm’ % (1,random.randint(30,37))  
    return ‘%s %s\x1B[0m’ % (color,messages)  


def len_zh(data):  
    temp = re.findall(‘[^a-zA-Z0-9._ ]+’, data)  
    count = 0  
    for i in temp:  
        count += len(i)  
    return(count)  


def colorprint(mes, flag=True):  
    def _deco(func):  
        def wrapper( _args):  
            res = func(_ args)  
            print color(mes + ‘:\n’)  
            if flag:  
                for k1, v1 in res.items():  
                    zh = len_zh(k1.decode(‘utf-8’))  
                    if not isinstance(v1, dict):  
                        print ‘{0}: {1}’.format(k1.ljust(20+zh), v1)  
                    else:  
                        print ‘{0}:’.format(k1.ljust(20+zh))  
                        for k2, v2 in v1.items():  
                            zh = len_zh(k2.decode(‘utf-8’))  
                            print ‘    {0}: {1}’.format(k2.ljust(16+zh), v2)  
            else:  
                for i in res:  
                    if not isinstance(i[1], dict):  
                        print i  
                    else:  
                        for k, v in i[1].items():  
                            zh = len_zh(k.decode(‘utf-8’))  
                            print ‘{0}[{1}]: {2}’.format(k.ljust(17+zh), i[0], v)  
            print ‘\n’  
            return res  
        return wrapper  
    return _deco  


class Resume(object):  

    def **str** (self):  
        return color(‘董伟明的python简历’.center(400))  

    @property  
    @colorprint(‘个人信息’)  
    def personal_information(self):  
        return {  
            ‘Name’ : ‘董伟明’,  
            ‘Gender’ : ‘Male’,  
            ‘Born’ : [1985, 8, 9],  
            ‘Education’ : {  
                ‘School Name’ : ‘保定科技职业学院’,  
                ‘Major’ : ‘烹饪工艺与营养’,  
                ‘Degree’ : ‘Three-year college’,  
                ‘Graduation’ : 2009  
            },  
            ‘QQ’ : ‘6196622X’,  
            ‘Tel’ : ‘13552651XXX’,  
            ‘Email’ : [&apos;XX@gmail.com](mailto:&apos;XX@gmail.com)‘,  
            ‘Target Positions’ : re.compile(  
                “‘Python Developer’|DevOps”,re.I|re.M).pattern  
        }  

    @property  
    @colorprint(‘个人特点’)  
    def characteristics(self):  
        return {  
            ‘心里承受能力强’: ‘从非计算机专业-Linux运维-Python开发’,  
            ‘热衷和喜爱’: ‘正是因为喜欢IT, 我才会放弃大学所学专业’,  
            ‘自学能力强’: ‘没有大学的计算机基础, 都是自学’,  
            ‘毅力和耐性’: ‘从不放弃一个解决不了的难题，看过的计算机专业技术多于700页的书籍&gt;30本’,  # noqa  
            ‘is_geek’ : True  
        }  

    @property  
    @colorprint(‘个人能力’)  
    def skills(self):  
        return {  
            ‘Language’ : {  
                ‘熟悉’ : [‘Python’, ‘Ruby’, ‘Bash’],  
                ‘了解’ : [‘Haskell’, ‘Lisp’, ‘Erlang’]},  
            ‘OS’ : [‘Gentoo’, ‘Debian’, ‘Centos/Rhel’, ‘Opensuse’],  
            ‘Tool’ : [‘Vim’, ‘Mercurial’, ‘Git’],  
            ‘Databaseandtools’ : [‘MySQL’,  
                ‘PostgreSQL’, ‘MongoDB’, ‘Redis’, ‘Memcached’, ‘SQLAlchemy’],  
            ‘WebFramework’ : {  
                ‘熟悉’ : [‘Tornado’, ‘Django’, ‘Gae’],  
                ‘了解’ : [‘Flask’]  
            },  
            ‘OtherFramework’ : [‘Twisted’, ‘gevent’,  
                                ‘stackless’, ‘scrapy’, ‘mechanize’],  
            ‘GUI’ : ‘pyqt’,  
            ‘Network’ : ‘Cisco Certified Security Professional’,  
            ‘Other’ : ‘给Gentoo和Centos提交过bug’  
        }  

    @property  
    @colorprint(‘工作经验’, False)  
    def work_experience(self):  
        return enumerate([  
            {  
                ‘Time period’ : ‘2011.10-2012.08’,  
                ‘Company Name’ : ‘XX（北京）科技有限公司’,  
                ‘Position’ : ‘运维开发工程师’  
            },  
            {  
                ‘Time period’ : ‘2009.10-2011.10’,  
                ‘Company Name’ : ‘XX（北京）科技有限公司’,  
                ‘Position’ : ‘运维工程师’  
            },  
        ])  

    @property  
    @colorprint(‘项目经验’,False)  
    def project_experience(self):  
        return enumerate([  
            {  
                ‘Project’ : ‘kvm远程管理系统’,  
                ‘Description’ : (‘前台(django)接手至其它同事并完成维护，’  
                                 ‘后台独立完成，用来创建，修改，删除kvm，查看状态信息等’)  
            },  
            {  
                ‘Project’ : ‘postfix群发邮件系统’,  
                ‘Description’ : (‘前台(tornado),为其它部门提供发送邮件的web端, ‘  
                                 ‘并作为数据收集服务端,前后台独立完成’)  
            },  
            {  
                ‘Project’ : ‘windows个人安全终端系统’,  
                ‘Description’ : (‘前后台和接收数据的socket服务器独立完成，’  
                                 ‘客户端图形编程使用qt’)  
            },  
            {  
                ‘Project’ : ‘地推IDC质量测试系统’,  
                ‘Description’: (‘还在代码实现中,前台flask, 数据接收服务准备’  
                                ‘使用twisted,客户端为windows进程’)  
            }  
        ])  

    @property  
    @colorprint(‘@Where’, False)  
    def findme(self):  
        return enumerate([  
            {  
                ‘Link’ : ‘&lt;http://www.dongwm.com&apos;&gt;,  
                ‘Description’ : ‘个人技术博客’},  
            {  
                ‘Link’ : ‘&lt;http://www.zhihu.com/people/dongweiming&apos;&gt;,  
                ‘Description’ : ‘知乎’},  
            {  
                ‘Link’ : ‘&lt;http://youhouer.appspot.com&apos;&gt;,  
                ‘Description’ : ‘基于Google App Engine的前端网站’  
            }  
        ])  

    def show(self):  
        prolist = [i for i in dir(self) if not i.startswith(‘_’) \  
                   and not i.startswith(‘personal’)]  
        self.personal_information  
        for pro in prolist:  
            getattr(self, pro)  


if **name** == ‘ **main** ‘:  
    resume = Resume()  
    resume.show()  </code></pre><p>#####效果:</p>
<ol>
<li>直接保存文件,linux下终端执行,但是windows执行会有乱码</li>
<li>直接linux下终端执行:curl <a href="https://raw.github.com/gist/3496061/b63efdf0c1c8d0e12df4f5b905903128c951b282/My_Resume.py" target="_blank" rel="noopener">https://raw.github.com/gist/3496061/b63efdf0c1c8d0e12df4f5b905903128c951b282/My_Resume.py</a> |python</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>《Python-Web开发实战》上市一个月了</title>
    <url>/2016-04-08.html</url>
    <content><![CDATA[<p><a href="http://item.jd.com/11966737.html" target="_blank" rel="noopener">《Python-Web开发实战》</a>上市一个月，<br>有很多感想。最近一直在花费大量时间和精力在推销。我还转战知乎一个月，写了不少的专栏文章，也写了一些答案，最后用一篇<a href="https://zhuanlan.zhihu.com/p/22890580" target="_blank" rel="noopener">The<br>End</a>结束。<br>整个过程有很多感悟。</p>
<blockquote>
<p>你不登上山顶，永远不知道山那边的风景<br>初次写书让我走了不少弯路。比如没有控制好篇幅多写了1百多页，比如没有更早的让出版社开始设计封面造成延期。<br>写书也有很多的遗憾。比如无法让每个读者满意，我自己也对书一些表达是不满意的。我一直对书里面需要勘误的量很有信心，但是到现在为止已经出现了十多处的错误，虽然其中有一半并不是我造成，但是也是因为没有那么精细的去校对。<br>写书也让我发现了很多不足。首先是不能太自信，比如勘误中的<a href="https://github.com/dongweiming/web_develop/blob/master/errata.md#文件权限" target="_blank" rel="noopener">文件权限</a>，写的时候没有去验证，写完之后的多次回看中都完全忽略了这一部分内容，现在看起来这像个笑话；其次是在国内写书的人太少，没有对于「如何写书，写好书」的系统的培训，也没有人分享过不错的经验，完全靠领悟，这是我的欠缺。还有一点是学的不够好，离我心中的榜样的书还是有距离的。<br>我最担心的是书中包含了我对XX的理解是错误的，所以邀请了很多老师来给我review。但是我最不愿意的事情还是发生了，也就是勘误中的<a href="https://github.com/dongweiming/web_develop/blob/master/errata.md#本书最大的错误" target="_blank" rel="noopener">本书最大的错误</a>。虽然在书中的例子的用法并没有问题，但是解题思路是错误的。<br>当然也发生了很多有意思但是不能公开的故事，比如我对封面的坚持、为什么京东自营一直无货。一句话，套路太深。<br>最近读胡阳的公众号文章[「Python基础看完了？来两本进阶书」](<a href="http://mp.weixin.qq.com/s?timestamp=1476619766&amp;src=3&amp;ver=1&amp;signature=jSehH7XhUDSVTI8pFE1EW43izDbWqbxsbFlJXxrZrxP9aMwYwLdIriMOng2YfBPJ-" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?timestamp=1476619766&amp;src=3&amp;ver=1&amp;signature=jSehH7XhUDSVTI8pFE1EW43izDbWqbxsbFlJXxrZrxP9aMwYwLdIriMOng2YfBPJ-</a><br>mmxtvUnFR9bQ2VnlzxO6zDWk8hHtr0<em>6k-OyznBgQFOLjiKea3TaLfBwssxO-u0ia0QZWyrUh-<br>dWGABclLmP</em>doXYWF*tMUtqhMPGHexyA=)，其中有几段话我简直不能同意更多：</p>
</blockquote>
<p>自从我进入Python编程领域之后，或者说靠Python吃饭之后，每次逛书店也必定看看Python的书，遗憾的是从一开始到现在看来看去还是那几本，并且没有正确的分类，而看看隔壁家的ruby方便的书不但有正确的分类，而且还很多（内个，至少比Python多）。<br>我以前常去中关村图书大厦逛，体验那种气氛，也会实体的看看心仪的书，给自己物色点不错的书。郁闷的是Python的书永远被乱放，Ruby比Python的书多了不止2倍。</p>
<blockquote>
</blockquote>
<p>随着我靠Python吃饭的时间越来越长，有时候我想，要不要攒点劲儿，弄它一本书出来，让其他喜欢逛书店的Python程序员，看到Python的书是在变多的这样的趋势。但是看看现在市面是已经有的书，那些个作者，各领域的大牛都有。那些书的内容可能在某些领域算是比较先进的经验，但是在Python上却差点意思，怎么说呢，就是感觉不那么的Pythonic。我自己能搞出一个对别人有价值的书吗，我也不好说。<br>这就是我写这本书，在情怀层面的原因。如我的序言中的描述：</p>
<blockquote>
</blockquote>
<p>写这本书的意义在于，将我这几年使用Python进行Web开发，对各方面知识的理解和积累的经验进行梳理和总结，让更多人受益，同时对自己也是一种成长，也算是对国内的Python环境做出个人的贡献了。<br>Python这些年被越来越多的人接受和使用，但是在中国它终归还是一门「小众」的语言。靠它吃饭的不多，虽然一直再涨，但是离我对它的期望差的实在太远，而且看起来还被golang抢走了一些（心塞）。不止一个公司的创始人在选择初期的技术栈的时候会舍弃Python，原因是它在国内的环境一般，招聘一个适合的人才实在太难。这在豆瓣面试过程中我也深有感触。在中国Ruby有Ruby<br>China，还有RubyConf。语言只是工具，它的社区和生态很重要，设想对于新入行的你，看到一个发展的有些病态（抱歉我用了这么个不咋舒适的词）的语言会不会却步，转而选择一个更有生机和希望的、挣钱更多、工作机会更多的语言呢？很多人会骂，我也是恨铁不成钢，但是我还是爱Python的，不然不会坚持这么多年。<br>我不喜欢用嘴去喷，希望让环境更好一点，所以我行动了。这本书无非是给新人铺铺路，就像大学老师给划重点，让你少走弯路，告诉你这个是啥，为啥要用，还有怎么用。<br>这本书有人说写得好，有人说写的一般，有人把我喷成狗。说我好的，相信这本书有用，我很高兴；说写的一般的，我也虚心接受，没有符合预期我得先说声抱歉，我肯定无法让每个人满意，能力有限，在努力做好。但是目前我还没有看到一个比较有说服力的评价，比如「我觉得这本书写的不好，原因是1，2，3，4…，如果让我来写可以balabla…」这种句式；说写的很烂的也不少，在豆瓣都不用花钱买书就可以去评价了。有时候看着一些对我的无脑黑我是又气又觉得可笑。一旦做了事就会有人嫉恨，开启上帝视角来指点江山，但是又放不出一个有味道的屁。<br>我的书类似于大学里面的老师划重点，带方向。哪怕真的是借鉴了官方文档中的用法也是基于我的经验认为的「最佳实践」，我总不能避嫌一定不用吧。<br>其次我不懂有些人竟然感觉看了我的书的目录自己Google就可以了，好像知识已经学到了手了，该用什么怎么用何时用已经完全掌握了，嗯<br>这种人活的也挺幸福的，反正我现在好多还不懂不熟还在踩坑。且不说英语好你完全看懂了，但是真的用过么，啥是关键，怎么避坑？不如把自己琢磨、实验花的时间的用来买本书看，剩下那80%的时间去做其他的：这才是对自己负责。<br>欣慰的是，还没看到一个我觉得是「Python圈子」里面的人来吐槽我，老师们还是愿意给我写序和各种其他方式的推荐，绝大部分的人都觉得本书有用，甚至不少人表达过非常喜欢这本书，这让我觉得我做这件事是值得的。<br>我在努力地让事情变好，以后也会是。<br>这本书算是抛砖引玉，希望未来越来越是有实力的人出来写书，把我拍死。<br>BTW，大家可以先来python-cn.org聊聊技术的。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python最佳实践</title>
    <url>/2016-04-09.html</url>
    <content><![CDATA[<p>本文是<a href="https://gist.github.com/sloria/7001839" target="_blank" rel="noopener">The Best of the Best Practices (BOBP) Guide for<br>Python</a>的中文翻译，并加入了一些我的说明和理解。</p>
<h3 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h3><h4 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h4><blockquote>
<p>「为别人开发你也想要使用的工具。」 - Kenneth Reitz (requests等知名库作者)<br>你自己都不想用的东西做出来有什么意义呢?<br>「简洁总是胜过可用。」 - Pieter Hintjens (ZeroMQ)<br>我对函数式编程的看法一直是「看场景」, 甚至于我经常会对比性能, 义无反顾的使用性能更好、代码简洁的那种。<br>「满足90%的使用场景。忽略那些说不的人。」 - Kenneth Reitz<br>程序员都有完美主义情怀, 但是其实往往我们是在偏激的看事情，做自认为很酷很有用的功能，而用户其实并不买账。<br>「优美胜过丑陋。」 - PEP 20<br>「为开源（甚至是闭源项目）而开发。」</p>
</blockquote>
<h4 id="一般开发准则"><a href="#一般开发准则" class="headerlink" title="一般开发准则"></a>一般开发准则</h4><blockquote>
<p>「明确胜过含蓄。」- PEP 20<br>不要留坑, 我经常看到一些复杂的代码, 这些代码的作者写的时候明显知道自己在做什么, 但是别人很难维护和看懂.<br>所以我对自己的职业的基本要求就是: 那天我离职了, 后来接手的人不会经常骂我<br>「可读性应当被重视」- PEP 20<br>「任何人都可以解决任何问题」- 可汗学院开发文档<br>「一旦发现破窗（设计错误，决策失误或编码质量低），马上修补。<br>我们改bug有个原则 - 测试要覆盖到出bug的地方。有问题及时解决<br>「现在做也要胜过不去做。」- PEP 20<br>明日复明日, 明日何其多. 我们在代码review的时候, 问题需要在提出的时候就去改, 永远不会说下一次再说, 因为下一次大多时候是没有下一次了<br>「测试要彻底。撰写新功能文档。」<br>「相对于人力驱动型开发，测试驱动型开发更重要。」<br>「这些准则可能，应该是很可能在未来会改变。」</p>
</blockquote>
<h3 id="特殊准则"><a href="#特殊准则" class="headerlink" title="特殊准则"></a>特殊准则</h3><h4 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h4><p>感觉合理的话，就遵循<a href="http://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8</a>。</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li>变量、函数、方法、包、模块小写，并使用下划线分隔单词（lower_case_with_underscores）</li>
<li>类、异常首字母大写（CapWords）</li>
<li>受保护的方法和内部函数单下划线开头（_single_leading_underscore(self, …)）</li>
<li>私有的方法双下划线开头（__double_leading_underscore(self, …)）</li>
<li>常量字母全部大写，单词间用下划线分隔（ALL_CAPS_WITH_UNDERSCORES）<h5 id="一般命名准则"><a href="#一般命名准则" class="headerlink" title="一般命名准则"></a>一般命名准则</h5>尽量不要使用只有一个字母的变量名（例如，l，I，O等）。<br>例外：在很简短的代码块中，如果变量名的意思可以从上下文明显地看出来。比如下面的例子：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> elements:  </span><br><span class="line">    e.mutate()</span><br></pre></td></tr></table></figure>


<p>避免重复变量名，正确的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> audio  </span><br><span class="line">  </span><br><span class="line">core = audio.Core()  </span><br><span class="line">controller = audio.Controller()</span><br></pre></td></tr></table></figure>


<p>错误的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> audio  </span><br><span class="line">  </span><br><span class="line">core = audio.AudioCore()  </span><br><span class="line">controller = audio.AudioController()</span><br></pre></td></tr></table></figure>


<p>「反向标记」更好，正确的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">elements = ...  </span><br><span class="line">elements_active = ...  </span><br><span class="line">elements_defunct = ...</span><br></pre></td></tr></table></figure>


<p>错误的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">elements = ...  </span><br><span class="line">active_elements = ...  </span><br><span class="line">defunct_elements ...</span><br></pre></td></tr></table></figure>


<p>避免使用getter和setter方法，正确的做法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">person.age = <span class="number">42</span></span><br></pre></td></tr></table></figure>


<p>错误的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">person.set_age(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>


<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>用4个空格符——永远别用Tab制表符。</p>
<h4 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h4><p>引用整个模块，而不是模块中的单个标识符。举个例子，假设一个cantee模块下面，有一个canteen/sessions.py文件，<br>正确的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> canteen  </span><br><span class="line"><span class="keyword">import</span> canteen.sessions  </span><br><span class="line"><span class="keyword">from</span> canteen <span class="keyword">import</span> sessions</span><br></pre></td></tr></table></figure>


<p>错误的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> canteen <span class="keyword">import</span> get_user  <span class="comment"># Symbol from canteen/__init__.py  </span></span><br><span class="line"><span class="keyword">from</span> canteen.sessions <span class="keyword">import</span> get_session  <span class="comment"># Symbol from canteen/sessions.py</span></span><br></pre></td></tr></table></figure>


<p>例外：如果第三方代码的文档中明确说明要单个引用。<br>理由：避免循环引用。[看这里](<a href="https://sites.google.com/a/khanacademy.org/forge/for-" target="_blank" rel="noopener">https://sites.google.com/a/khanacademy.org/forge/for-</a><br>developers/styleguide/python#TOC-Imports)。<br>把代码引用部分放在文件的顶部，按下面的顺序分成三个部分，每个部分之间空一行。</p>
<ol>
<li>系统引用 </li>
<li>第三方引用 </li>
<li>本地引用<br>理由：明确显示每个模块的引用来源。<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4>遵循<a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP<br>257</a>提出的文档字符串准则。reStructuredText<br>(reST) 和Sphinx有助于确保文档符合标准。<br>对于功能明显的函数，撰写一行文档字符串：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""Return the pathname of ``foo``."""</span></span><br></pre></td></tr></table></figure>


<p>多行文档字符串应包括：</p>
<ul>
<li>一行摘要<br>*合适的话，请描述使用场景</li>
<li>参数</li>
<li>返回数据类型和语义信息，除非返回None</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""Train a model to classify Foos and Bars.  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">Usage::  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; import klassify  </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; data = [("green", "foo"), ("orange", "bar")]  </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; classifier = klassify.train(data)  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">:param train_data: A list of tuples of the form ``(color, label)``.  </span></span><br><span class="line"><span class="string">:rtype: A :class:`Classifier &lt;Classifier&gt;`  </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>


<p>注意：</p>
<ul>
<li>使用主动词（Return），而不是描述性的单词（Returns）。 </li>
<li>在类的文档字符串中为<strong>init</strong>方法撰写文档。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="string">"""A simple representation of a human being.  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    :param name: A string, the person's name.  </span></span><br><span class="line"><span class="string">    :param age: An int, the person's age.  </span></span><br><span class="line"><span class="string">    """</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>


<h5 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h5><p>尽量少用。与其写很多注释，不如提高代码可读性。通常情况下，短小的方法比注释更有效。<br>错误的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># If the sign is a stop sign  </span></span><br><span class="line"><span class="keyword">if</span> sign.color == <span class="string">'red'</span> <span class="keyword">and</span> sign.sides == <span class="number">8</span>:  </span><br><span class="line">    stop()</span><br></pre></td></tr></table></figure>


<p>正确的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_stop_sign</span><span class="params">(sign)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> sign.color == <span class="string">'red'</span> <span class="keyword">and</span> sign.sides == <span class="number">8</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> is_stop_sign(sign):  </span><br><span class="line">    stop()</span><br></pre></td></tr></table></figure>


<p>但是的确要写注释时，请牢记：「遵循斯托克与怀特所写的《风格的要素》。」 —— PEP 8</p>
<h4 id="每行的长度"><a href="#每行的长度" class="headerlink" title="每行的长度"></a>每行的长度</h4><p>不要过分在意。80到100个字符都是没问题的。<br>使用括号延续当前行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wiki = (  </span><br><span class="line">    <span class="string">"The Colt Python is a .357 Magnum caliber revolver formerly manufactured "</span>  </span><br><span class="line">    <span class="string">"by Colt's Manufacturing Company of Hartford, Connecticut. It is sometimes "</span>  </span><br><span class="line">    <span class="string">'referred to as a "Combat Magnum". It was first introduced in 1955, the '</span>  </span><br><span class="line">    <span class="string">"same year as Smith &amp; Wesson's M29 .44 Magnum."</span>  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>尽量争取测试全部代码，但也不必执着于覆盖率。</p>
<h4 id="一般测试准则"><a href="#一般测试准则" class="headerlink" title="一般测试准则"></a>一般测试准则</h4><ul>
<li>使用较长的、描述性的名称。通常情况下，这能避免在测试方法中再写文档。</li>
<li>测试之间应该是孤立的。不要与真实地数据库或网络进行交互。使用单独的测试数据库，测试完即可销毁，或者是使用模拟对象。</li>
<li>使用<a href="https://github.com/rbarrois/factory_boy" target="_blank" rel="noopener">工厂模式</a>，而不是fixture。</li>
<li>别让不完整的测试通过，否则你就有可能忘记。你应该加上一些占位语句，比如<code>assert False, &quot;TODO: finish me&quot;</code>。<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4></li>
<li>每次聚焦一个很小的功能点。</li>
<li>运行速度要快，但是速度慢总比不测试好。</li>
<li>通常，每一个类或模型都应该有一个测试用例类。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest  </span><br><span class="line"><span class="keyword">import</span> factories  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span><span class="params">(unittest.TestCase)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.person = factories.PersonFactory()  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_has_age_in_dog_years</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.assertEqual(self.person.dog_years, self.person.age / <span class="number">7</span>)</span><br></pre></td></tr></table></figure>


<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p>功能测试是更高层次的测试，更接近最终用户如何与应用交互这一层面。通常用在网络应用与图形应用测试。</p>
<ul>
<li>按照场景撰写测试。测试用例的测试方法命名应该看上去像场景描述。</li>
<li>在编写代码之前，通过注释说明具体场景信息。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAUser</span><span class="params">(unittest.TestCase)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_can_write_a_blog_post</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="comment"># Goes to the her dashboard  </span></span><br><span class="line">        ...  </span><br><span class="line">        <span class="comment"># Clicks "New Post"  </span></span><br><span class="line">        ...  </span><br><span class="line">        <span class="comment"># Fills out the post form  </span></span><br><span class="line">        ...  </span><br><span class="line">        <span class="comment"># Clicks "Submit"  </span></span><br><span class="line">        ...  </span><br><span class="line">        <span class="comment"># Can see the new post  </span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>


<p>请注意，测试用例的类名称和测试方法的名称放在一起，就像是「测试一名用户能否发布博文」。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><a href="http://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">PEP 20 (The Zen of Python)</a></li>
<li><a href="http://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8 (Style Guide for Python)</a></li>
<li><a href="http://docs.python-guide.org/en/latest/" target="_blank" rel="noopener">The Hitchiker’s Guide to Python</a></li>
<li><a href="https://sites.google.com/a/khanacademy.org/forge/for-developers" target="_blank" rel="noopener">Khan Academy Development Docs</a></li>
<li><a href="http://youtu.be/GZNUfkVIHAY" target="_blank" rel="noopener">Python Best Practice Patterns</a></li>
<li><a href="http://www.nilunder.com/blog/2013/08/03/pythonic-sensibilities/" target="_blank" rel="noopener">Pythonic Sensibilities</a></li>
<li><a href="http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X/ref=sr_1_1?ie=UTF8&qid=1381886835&sr=8-1&keywords=pragmatic+programmer" target="_blank" rel="noopener">The Pragmatic Programmer</a></li>
<li>以及其他诸多资料</li>
</ul>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>深入描述符</title>
    <url>/2016-04-07.html</url>
    <content><![CDATA[<p>描述符是一种在多个属性上重复利用同一个存取逻辑的方式，他能”劫持”那些本对于self.<strong>dict</strong>的操作。描述符通常是一种包含<strong>get</strong>、<strong>set</strong>、<strong>delete</strong>三种方法中至少一种的类，给人的感觉是「把一个类的操作托付与另外一个类」。静态方法、类方法、property都是构建描述符的类。<br>我们先看一个简单的描述符的例子（基于我之前的分享的[Python高级编程](<a href="http://dongweiming.github.io/Expert-" target="_blank" rel="noopener">http://dongweiming.github.io/Expert-</a><br>Python/#43)改编，这个PPT建议大家去看看）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDescriptor</span><span class="params">(object)</span>:</span>  </span><br><span class="line">     _value = <span class="string">''</span>  </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, klass)</span>:</span>  </span><br><span class="line">         <span class="keyword">return</span> self._value  </span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">         self._value = value.swapcase()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swap</span><span class="params">(object)</span>:</span>  </span><br><span class="line">     swap = MyDescriptor()</span><br></pre></td></tr></table></figure>


<p>注意MyDescriptor要用新式类。调用一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> descriptor_example <span class="keyword">import</span> Swap  </span><br><span class="line">In [<span class="number">2</span>]: instance = Swap()  </span><br><span class="line">In [<span class="number">3</span>]: instance.swap  <span class="comment"># 没有报AttributeError错误，因为对swap的属性访问被描述符类重载了  </span></span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">''</span>  </span><br><span class="line">In [<span class="number">4</span>]: instance.swap = <span class="string">'make it swap'</span>  <span class="comment"># 使用__set__重新设置_value  </span></span><br><span class="line">In [<span class="number">5</span>]: instance.swap  </span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'MAKE IT SWAP'</span>  </span><br><span class="line">In [<span class="number">6</span>]: instance.__dict__  <span class="comment"># 没有用到__dict__:被劫持了  </span></span><br><span class="line">Out[<span class="number">6</span>]: &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>这就是描述符的威力。我们熟知的staticmethod、classmethod如果你不理解，那么看一下用Python实现的效果可能会更清楚了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">myStaticMethod</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, method)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>        self.staticmethod = method  </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, object, type=None)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.staticmethod  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">myClassMethod</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, method)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>        self.classmethod = method  </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, object, klass=None)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> klass <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line"><span class="meta">... </span>            klass = type(object)  </span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*args)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.classmethod(klass, *args)  </span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> newfunc</span><br></pre></td></tr></table></figure>


<p>在实际的生产项目中，描述符有什么用处呢？首先看MongoEngine中的Field的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> mongoengine <span class="keyword">import</span> *                        </span><br><span class="line">                                                      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Metadata</span><span class="params">(EmbeddedDocument)</span>:</span>                     </span><br><span class="line">    tags = ListField(StringField())  </span><br><span class="line">    revisions = ListField(IntField())  </span><br><span class="line">                                                      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WikiPage</span><span class="params">(Document)</span>:</span>                             </span><br><span class="line">    title = StringField(required=<span class="literal">True</span>)                </span><br><span class="line">    text = StringField()                              </span><br><span class="line">    metadata = EmbeddedDocumentField(Metadata)</span><br></pre></td></tr></table></figure>


<p>有非常多的Field类型，其实它们的基类就是一个<a href="https://github.com/MongoEngine/mongoengine/blob/master/mongoengine/base/fields.py#L20" target="_blank" rel="noopener">描述符</a>，我简化下，大家看看实现的原理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseField</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    name = <span class="literal">None</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span>  </span><br><span class="line">        self.__dict__.update(kwargs)  </span><br><span class="line">        ...  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> instance._data.get(self.name)  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        instance._data[self.name] = value</span><br></pre></td></tr></table></figure>


<p><strong>很多项目的源代码看起来很复杂，在抽丝剥茧之后，其实原理非常简单，复杂的是业务逻辑。</strong><br>接着我们再看Flask的依赖Werkzeug中的cached_property：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Missing</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'no value'</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'_missing'</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">_missing = _Missing()   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cached_property</span><span class="params">(property)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, name=None, doc=None)</span>:</span>  </span><br><span class="line">        self.__name__ = name <span class="keyword">or</span> func.__name__  </span><br><span class="line">        self.__module__ = func.__module__  </span><br><span class="line">        self.__doc__ = doc <span class="keyword">or</span> func.__doc__  </span><br><span class="line">        self.func = func  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span>  </span><br><span class="line">        obj.__dict__[self.__name__] = value  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, type=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">return</span> self  </span><br><span class="line">        value = obj.__dict__.get(self.__name__, _missing)  </span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> _missing:  </span><br><span class="line">            value = self.func(obj)  </span><br><span class="line">            obj.__dict__[self.__name__] = value  </span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>


<p>其实看类的名字就知道这是缓存属性的，看不懂没关系，用一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">    @cached_property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Call me!'</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span></span><br></pre></td></tr></table></figure>


<p>调用下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> cached_property <span class="keyword">import</span> Foo  </span><br><span class="line">   ...: foo = Foo()  </span><br><span class="line">   ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: foo.bar  </span><br><span class="line">Call me!  </span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">42</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: foo.bar  </span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">42</span></span><br></pre></td></tr></table></figure>


<p>可以看到在从第二次调用bar方法开始，其实用的是缓存的结果，并没有真的去执行。<br>说了这么多描述符的用法。我们写一个做字段验证的描述符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:  </span><br><span class="line">            instance.__dict__[self.name] = value  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    height = Quantity(<span class="string">'height'</span>)  </span><br><span class="line">    width = Quantity(<span class="string">'width'</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, height, width)</span>:</span>  </span><br><span class="line">        self.height = height  </span><br><span class="line">        self.width = width  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> self.height * self.width</span><br></pre></td></tr></table></figure>


<p>我们试一试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> rectangle <span class="keyword">import</span> Rectangle  </span><br><span class="line">In [<span class="number">2</span>]: r = Rectangle(<span class="number">10</span>, <span class="number">20</span>)  </span><br><span class="line">In [<span class="number">3</span>]: r.area  </span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">200</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: r = Rectangle(<span class="number">-1</span>, <span class="number">20</span>)  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">ValueError                                Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-5</span><span class="number">-5</span>a7fc56e8a&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 r = Rectangle(-1, 20)  </span><br><span class="line">  </span><br><span class="line">/Users/dongweiming/mp/<span class="number">2017</span><span class="number">-03</span><span class="number">-23</span>/rectangle.py <span class="keyword">in</span> __init__(self, height, width)  </span><br><span class="line"> </span><br><span class="line">     <span class="number">16</span>     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, height, width)</span>:</span>  </span><br><span class="line">---&gt; 17         self.height = height  </span><br><span class="line">     <span class="number">18</span>         self.width = width  </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">/Users/dongweiming/mp/<span class="number">2017</span><span class="number">-03</span><span class="number">-23</span>/rectangle.py <span class="keyword">in</span> __set__(self, instance, value)  </span><br><span class="line">      <span class="number">7</span>             instance.__dict__[self.name] = value  </span><br><span class="line">      <span class="number">8</span>         <span class="keyword">else</span>:  </span><br><span class="line">----&gt; 9             raise ValueError('value must be &gt; 0')  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>看到了吧，我们在描述符的类里面对传值进行了验证。ORM就是这么玩的！<br>但是上面的这个实现有个缺点，就是不太自动化，你看<code>height =
Quantity(&#39;height&#39;)</code>，这得让属性和Quantity的name都叫做height，那么可不可以不用指定name呢？当然可以，不过实现的要复杂很多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    __counter = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        cls = self.__class__  </span><br><span class="line">        prefix = cls.__name__  </span><br><span class="line">        index = cls.__counter  </span><br><span class="line">        self.name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)  </span><br><span class="line">        cls.__counter += <span class="number">1</span>  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">return</span> self  </span><br><span class="line">        <span class="keyword">return</span> getattr(instance, self.name)  </span><br><span class="line">    ...  </span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    height = Quantity()  </span><br><span class="line">    width = Quantity()   </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>


<p>Quantity的name相当于类名+计时器，这个计时器每调用一次就叠加1，用此区分。有一点值得提一提，在<strong>get</strong>中的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>


<p>在很多地方可见，比如之前提到的MongoEngine中的<a href="https://github.com/MongoEngine/mongoengine/blob/master/mongoengine/base/fields.py#L116" target="_blank" rel="noopener">BaseField</a>。这是由于直接调用Rectangle.height这样的属性时候会报AttributeError,<br>因为描述符是实例上的属性。<br>PS：这个灵感来自《Fluent<br>Python》，书中还有一个我认为设计非常好的例子。就是当要验证的内容种类很多的时候，如何更好地扩展的问题。现在假设我们除了验证传入的值要大于0，还得验证不能为空和必须是数字（当然三种验证在一个方法中验证也是可以接受的，我这里就是个演示），我们先写一个abc的基类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validated</span><span class="params">(abc.ABC)</span>:</span>  </span><br><span class="line">    __counter = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        cls = self.__class__  </span><br><span class="line">        prefix = cls.__name__  </span><br><span class="line">        index = cls.__counter  </span><br><span class="line">        self.name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)  </span><br><span class="line">        cls.__counter += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">return</span> self  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.name)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">        value = self.validate(instance, value)  </span><br><span class="line">        setattr(instance, self.name, value)   </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @abc.abstractmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br></pre></td></tr></table></figure>


<p>现在新加一个检查类型，新增一个继承了Validated的、包含检查的validate方法的类就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validated)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)  </span><br><span class="line">        <span class="keyword">return</span> value  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validated)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>  </span><br><span class="line">        value = value.strip()  </span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)  </span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>


<p>前面展示的描述符都是一个类，那么可不可以用函数来实现呢？也是可以的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        quantity.counter += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">except</span> AttributeError:  </span><br><span class="line">        quantity.counter = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    storage_name = <span class="string">'_&#123;&#125;:&#123;&#125;'</span>.format(<span class="string">'quantity'</span>, quantity.counter)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> getattr(instance, storage_name)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:  </span><br><span class="line">            setattr(instance, storage_name, value)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)  </span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用glances监控本地和远程服务器的性能状态，以及我对它的修改</title>
    <url>/2016-04-10.html</url>
    <content><![CDATA[<p>####前言<br>首先开始感谢<a href="http://www.vpsee.com" target="_blank" rel="noopener">Vpsee</a>的那篇[安装和使用系统监控工具<br>Glances](<a href="http://www.vpsee.com/2013/07/a-new-system-monitoring-tool-glances-" target="_blank" rel="noopener">http://www.vpsee.com/2013/07/a-new-system-monitoring-tool-glances-</a><br>installation-and-<br>usage/)，让我发现了<a href="https://github.com/nicolargo/glances" target="_blank" rel="noopener">glances</a>这个新的系统监控工具.并且可以通过xml-<br>rpc<br>监控远程服务器的系统情况显示到本地.它其实类似于top,支持键盘按键.使用了psutil库获取了硬盘分区，负载，内存使用，交换分区使用，进程(支持根据cpu占用,内存占用，进程名和<br>io使用的排序).并且在安装了lm-<br>sensor后还可以监控服务器的温度.记录日志,高亮显示可配置的阀值的预警颜色.就像一个超级版的top,但是它的优点其实就是2个:</p>
<ol>
<li>它是python的，你可以定制化</li>
<li>它可以使用rpc获取其他服务端的系统信息,top可不行额<br>####我对它做了些贡献</li>
<li>首先我给他添加了中文的国际化,但是因为显示英文比汉语占用得长度要小，我没有在太多的地方全部显示中文，而且我觉得作为运维本来就应该好好用英语…如果有必要我可以做一个glance-cn，完全汉化</li>
<li>我读了它的源码,发现它的代码已经超过4000行，但是好几个地方其实有很大的优化空间,比如它的glancesScreen类，有下面这样的代码:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getMemAlert</span><span class="params">(self, current=<span class="number">0</span>, max=<span class="number">100</span>)</span>:</span>                                 </span><br><span class="line">    <span class="comment"># If current &lt; CAREFUL of max then alert = OK                            </span></span><br><span class="line">    <span class="comment"># If current &gt; CAREFUL of max then alert = CAREFUL                       </span></span><br><span class="line">    <span class="comment"># If current &gt; WARNING of max then alert = WARNING                       </span></span><br><span class="line">    <span class="comment"># If current &gt; CRITICAL of max then alert = CRITICAL                     </span></span><br><span class="line">    <span class="keyword">try</span>:                                                                     </span><br><span class="line">        variable = (current * <span class="number">100</span>) / max                                     </span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:                                                </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'DEFAULT'</span>                                                     </span><br><span class="line">                                                                             </span><br><span class="line">    <span class="keyword">if</span> variable &gt; limits.getMEMCritical():                                   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'CRITICAL'</span>                                                    </span><br><span class="line">    <span class="keyword">elif</span> variable &gt; limits.getMEMWarning():                                  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'WARNING'</span>                                                     </span><br><span class="line">    <span class="keyword">elif</span> variable &gt; limits.getMEMCareful():                                  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'CAREFUL'</span>                                                     </span><br><span class="line">                                                                             </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'OK'</span>                                                              </span><br><span class="line">                                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getMemColor</span><span class="params">(self, current=<span class="number">0</span>, max=<span class="number">100</span>)</span>:</span>                                 </span><br><span class="line">    <span class="keyword">return</span> self.__colors_list[self.__getMemAlert(current, max)]              </span><br><span class="line">                                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getMemColor2</span><span class="params">(self, current=<span class="number">0</span>, max=<span class="number">100</span>)</span>:</span>                                </span><br><span class="line">    <span class="keyword">return</span> self.__colors_list2[self.__getMemAlert(current, max)]             </span><br><span class="line">                                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getSwapAlert</span><span class="params">(self, current=<span class="number">0</span>, max=<span class="number">100</span>)</span>:</span>                                </span><br><span class="line">    <span class="comment"># If current &lt; CAREFUL of max then alert = OK                            </span></span><br><span class="line">    <span class="comment"># If current &gt; CAREFUL of max then alert = CAREFUL                       </span></span><br><span class="line">    <span class="comment"># If current &gt; WARNING of max then alert = WARNING                       </span></span><br><span class="line">    <span class="comment"># If current &gt; CRITICAL of max then alert = CRITICAL                     </span></span><br><span class="line">    <span class="keyword">try</span>:                                                                     </span><br><span class="line">        variable = (current * <span class="number">100</span>) / max                                     </span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:                                                </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'DEFAULT'</span>                                                     </span><br><span class="line">                                                                             </span><br><span class="line">    <span class="keyword">if</span> variable &gt; limits.getSWAPCritical():                                  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'CRITICAL'</span>                                                    </span><br><span class="line">    <span class="keyword">elif</span> variable &gt; limits.getSWAPWarning():                                 </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'WARNING'</span>                                                     </span><br><span class="line">    <span class="keyword">elif</span> variable &gt; limits.getSWAPCareful():                                 </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'CAREFUL'</span>                                                     </span><br><span class="line">                                                                             </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'OK'</span>                                                              </span><br><span class="line">                                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getSwapColor</span><span class="params">(self, current=<span class="number">0</span>, max=<span class="number">100</span>)</span>:</span>                                </span><br><span class="line">    <span class="keyword">return</span> self.__colors_list[self.__getSwapAlert(current, max)]             </span><br><span class="line">                                                                                                                                                                                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getSwapColor2</span><span class="params">(self, current=<span class="number">0</span>, max=<span class="number">100</span>)</span>:</span>                               </span><br><span class="line">    <span class="keyword">return</span> self.__colors_list2[self.__getSwapAlert(current, max)]</span><br></pre></td></tr></table></figure>


<p>我来分析下,每种模块都有 <strong>getXXXAlert，</strong> getXXXColor， <strong>getxxxColor2，其中</strong> getXXXColor，<br><strong>getxxxColor2都会调用</strong> getXXXAlert,他们的参数可能不同<br>你看到了很多好相似的代码了嘛?其实待遇代码的可读性和可理解性已经代码的紧凑和不易懂一直就需要一个折中，我提了一个pull<br>request，其实对这个类的属性做了下拦截</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用__getattr__是为了只获取类中没有定义的属性  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span>                                                 </span><br><span class="line">        base_type = [<span class="string">'Mem'</span>, <span class="string">'Swap'</span>, <span class="string">'Fs'</span>, <span class="string">'HDDTemp'</span>, <span class="string">'Sensors'</span>]                  </span><br><span class="line">        get_alert_list = [<span class="string">'_glancesScreen__get'</span> + m + <span class="string">'Alert'</span> <span class="keyword">for</span> m <span class="keyword">in</span> base_type]  </span><br><span class="line">        base_type.extend([<span class="string">'Load'</span>, <span class="string">'Cpu'</span>]) <span class="comment">#我没有也处理_getCpu/LoadAlert,因为他们的调用略有不同,保留了  </span></span><br><span class="line">        get_color_list = [<span class="string">'_glancesScreen__get'</span> + m + <span class="string">'Color'</span> <span class="keyword">for</span> m <span class="keyword">in</span> base_type]  </span><br><span class="line">        get_color_list2 = [<span class="string">'_glancesScreen__get'</span> + m + <span class="string">'Color2'</span> <span class="keyword">for</span> m <span class="keyword">in</span> base_type]  </span><br><span class="line">                                                                                 </span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> get_alert_list:                                               </span><br><span class="line">            <span class="keyword">return</span> partial(self.getAlert, name[<span class="number">19</span>:<span class="number">-5</span>].upper())                   </span><br><span class="line">        <span class="keyword">elif</span> name <span class="keyword">in</span> get_color_list:                                             </span><br><span class="line">            <span class="keyword">return</span> partial(self.getColor, name[<span class="number">19</span>:<span class="number">-5</span>])                           </span><br><span class="line">        <span class="keyword">elif</span> name <span class="keyword">in</span> get_color_list2:                                            </span><br><span class="line">            <span class="keyword">return</span> partial(self.getColor2, name[<span class="number">19</span>:<span class="number">-6</span>])                          </span><br><span class="line">                                                                                 </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getColor</span><span class="params">(self, type, *args, **kwargs)</span>:</span>                                   </span><br><span class="line">        <span class="string">"""                                                                      </span></span><br><span class="line"><span class="string">        default: current=0, max=100, stat='', core=1                             </span></span><br><span class="line"><span class="string">        """</span>                                                                      </span><br><span class="line">        <span class="keyword">return</span> self.__colors_list[getattr(                                       </span><br><span class="line">            self, <span class="string">''</span>.join([<span class="string">'_glancesScreen__get'</span>, type, <span class="string">'Alert'</span>]))(*args, **kwargs)]  </span><br><span class="line">                                                                                 </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getColor2</span><span class="params">(self, type, *args, **kwargs)</span>:</span>                                  </span><br><span class="line">        <span class="string">"""                                                                      </span></span><br><span class="line"><span class="string">        default: current=0, max=100, stat='', core=1                             </span></span><br><span class="line"><span class="string">        """</span>                                                                      </span><br><span class="line">        <span class="keyword">return</span> self.__colors_list2[getattr(                                      </span><br><span class="line">            self, <span class="string">''</span>.join([<span class="string">'_glancesScreen__get'</span>, type, <span class="string">'Alert'</span>]))(*args, **kwargs)]</span><br></pre></td></tr></table></figure>


<p>— update 2013-08-10 —–<br>它已经接收了我的代码</p>
<ol>
<li>我在服务器用pip，安装的是1.6.1，而本地是1.7.1a，但是有一个功能hddtemp支持实在1.6.1之后添加的,我用本地使用-c连接远程服务器,本<br>地有-y选项，但是远程是没有的，按’h’就会报错,我修改了这个问题<br>####如何使用国际化</li>
<li>它自带了这个脚本i18n-gen.sh</li>
<li>我在我的gentoo和mac下都实验了,没有作用，难道是我理解有问题?<br>首先我先把本地的locale换成中文:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export LANG=zh_CN.UTF<span class="number">-8</span></span><br></pre></td></tr></table></figure>


<p>后来我发现它使用国际化的原理是:</p>
<ol>
<li>在安装的时候将.mo文件一起拷贝到glances的安装目录下得share/locale/XX/LC_MESSAGES下(XX代表你的生成的国际化名字)</li>
<li>它使用了这样的方法加载国际化</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">locale.setlocale(locale.LC_ALL, <span class="string">''</span>)  </span><br><span class="line">gettext.install(__appname__)</span><br></pre></td></tr></table></figure>


<p>但是没有去作用，因为没有找到.mo文件<br>我提了pull req, 这样修改(其实就是去目录下找到那个语言的.mo):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cur_dir = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>]  </span><br><span class="line">gettext.install(__appname__, <span class="string">'&#123;0&#125;/../share/locale'</span>.format(cur_dir))</span><br></pre></td></tr></table></figure>


<p>— update 2013-08-10 —–<br>它没有采用我的方法而是比较复杂的实现了<br>我在想，难道以前得几种语言是可以实现的?其实原来的方式在程序目录下是可以的，但是setup.py install后目录结构变化了<br>####远程连接服务器<br>这是glances最大的一个特点，但是不能让谁都可以使用serverproxy链接查看你的状态吧?所以你需要指定-<br>P选项，加一个随机密码(其实账号是glances，没有提供参数，在程序里面写死了)</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ptpython- a better Python REPL</title>
    <url>/2016-04-14.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>今天发现一个项目: <a href="https://github.com/jonathanslenders/ptpython" target="_blank" rel="noopener">ptpython</a>.<br>新一代的REPL神器. 玩了一下. 毅然的ipython换成了ptipython - ptpython自带的<br>iython的接口. 和大家介绍下</p>
<h4 id="ptpython的优点"><a href="#ptpython的优点" class="headerlink" title="ptpython的优点"></a>ptpython的优点</h4><p>先说几个在用ipython过程中遇到的问题吧.</p>
<ol>
<li>ipython在Mac下缩进问题. 每次在交互模式里面输入一个缩进的内容, 比如下面</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">t</span><span class="params">()</span>:</span>  </span><br><span class="line">   ...:     <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">      ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: <span class="function"><span class="keyword">def</span> <span class="title">t</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>看到了吧, 缩进不正确了. ptpython没有这个问题,<br>它的底层库[prompt_toolkit](<a href="https://github.com/jonathanslenders/python-prompt-" target="_blank" rel="noopener">https://github.com/jonathanslenders/python-prompt-</a><br>toolkit)实现了一个替代物<br>  2. jedi. 我在emacs里面, jedi是标配. 其一是因为有epc, 可以和python通信, 它的自动补全和跳到函数/类定义真的很方便. 但是python交互解释器<br>还没有一个用它的. 这里真的感觉效果很好.<br>  3. emacs/vim键位. 好吧我经常在用ipython的时候习惯<code>Ctrl+x Ctrl+c</code>退出. 能用emacs的键位做编辑真的很爽<br>  4. 提供一个终端的菜单, 有多个选项可以选择<br>  5. 模式粘贴. 大家知道python有个问题: 你粘贴过来的代码不一定能运行 - 粘贴后的缩进会很奇怪的. ipython虽然有<code>%paste</code>和<code>%cpaste</code>. 但是有时候还是会有<code>IndentationError</code>问题.<br>ptpython在这里独创了<code>Paste mode</code>. 使用F7切换. 还可以多行编辑.<br>  6. 可以开启多个Tab,甚至多个Tab的内容一齐显示出来. 类似vim的:split<br>  7. 能对你写的每行程序判断是否出现语法错误.如果你的代码有问题, 下面左侧会有错误提示 - 这其实能延伸做很多检查嘛<br>  8. ipython对查看对象的方法有一些问题, 比如这个:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ipython  </span><br><span class="line">In [<span class="number">1</span>]: <span class="string">'/tmp'</span>.&lt;tab&gt; <span class="comment"># 不会理你的</span></span><br></pre></td></tr></table></figure>


<p>ptpython对这样的处理都很好<br>  9. 一个很贴心的特性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ptpython  </span><br><span class="line">In [<span class="number">1</span>]: <span class="string">'tmp&lt;Tab&gt; # 他会告诉你这是个目录, 还会自动完成列出目录下的文件. autocompletion</span></span><br></pre></td></tr></table></figure>


<ol start="10">
<li>最后一点吧. 它非常容易的被嵌入你的程序，你的解释器</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python  </span><br><span class="line">Python <span class="number">2.7</span><span class="number">.3</span> (default, Apr <span class="number">10</span> <span class="number">2013</span>, <span class="number">06</span>:<span class="number">20</span>:<span class="number">15</span>)  </span><br><span class="line">[GCC <span class="number">4.6</span><span class="number">.3</span>] on linux2  </span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.  </span><br><span class="line">Welcome to Lazy Python.  Type <span class="string">"help LazyPython"</span> <span class="keyword">for</span> help.  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> ptpython.repl <span class="keyword">import</span> embed  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>embed(globals(), locals(), vi_mode=<span class="literal">False</span>, history_filename=<span class="literal">None</span>)  </span><br><span class="line">In [<span class="number">1</span>]: <span class="comment"># 看就这么2句</span></span><br></pre></td></tr></table></figure>


<h4 id="ptipython"><a href="#ptipython" class="headerlink" title="ptipython"></a>ptipython</h4><p>ptipython = ptpython + ipython<br>在安装了ptipython之后, 就可以使用了. 完全可以替代ipython.<br>类似<a href="https://github.com/ivanov/bipython" target="_blank" rel="noopener">bipython</a> = bpython + ipython</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>搜集系统信息的dashboard</title>
    <url>/2016-04-15.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>过年在家无聊, 发现个挺有意思的项目: [linux-dash](<a href="https://github.com/afaqurk/linux-" target="_blank" rel="noopener">https://github.com/afaqurk/linux-</a><br>dash),就是使用Twitter的Bootstrap做的管理模板,可以显示服务器信息, 负载,<br>内存,进程,硬盘,用户,安装/未安装的软件信息,网卡IP,网速,以及网络状态,在线用户等. 但是有2个问题:</p>
<ol>
<li>它是php的…</li>
<li>它获取信息都是通过shell下得系统命令<br>我就用django写了一个python版的[django-linux-<br>dash](<a href="https://github.com/dongweiming/django-linux-" target="_blank" rel="noopener">https://github.com/dongweiming/django-linux-</a><br>dash):本来想用flask,结果被人用了,但是问题也是通过subprocess调用命令获取数据,这个轮子有以下优点:</li>
<li>不仅支持linux,也支持OS X</li>
<li>使用<a href="http://code.google.com/p/psutil/" target="_blank" rel="noopener">psutil</a>, 项目完全不调用shell命令<h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4>需要django&gt;=1.4以及psutils模块</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$pip install/easy_install django  </span><br><span class="line">$pip install/easy_install psutil</span><br></pre></td></tr></table></figure>


<p>PS: OS X 还需要<a href="https://pypi.python.org/pypi/netifaces" target="_blank" rel="noopener">netifaces</a>模块用于获取网卡ip</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$pip install/easy_install netifaces</span><br></pre></td></tr></table></figure>


<p>启动:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$cd /You/install/path  </span><br><span class="line">$git clone https://github.com/dongweiming/django-linux-dash &amp;&amp; cd django-linux-dash  </span><br><span class="line">$python manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>


<p>打开浏览器输入 <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 就可以看见了…<br>TODO:</p>
<ol>
<li>目前还没有添加测速功能,因为我希望不要一直傻瓜式的下载某文件,根据用时计算平均值,因为第一它需要时间才会显示个速度,其次是不实时不能循环实时</li>
<li>添加更多信息模块</li>
<li>增加用户登陆和权限控制<br>…</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用celery之深入celery配置</title>
    <url>/2016-04-11.html</url>
    <content><![CDATA[<p>####前言<br>celery的官方文档其实相对还是写的很不错的.但是在一些深层次的使用上面却显得杂乱甚至就没有某些方面的介绍,<br>通过我的一个测试环境的settings.py来说明一些使用celery的技巧和解决办法<br>####amqp交换类型<br>其实一共有4种交换类型，还有默认类型和自定义类型. 但是对我们配置队列只会用到其中之三，我来一个个说明，英语好的话可以直接去看英文文档<br>首先思考一下流程:</p>
<ol>
<li>celerybeat生成任务消息，然后发送消息到一个exchange(交换机)</li>
<li>交换机决定那个(些)队列会接收这个消息，这个其实就是根据下面的exchange的类型和绑定到这个交换机所用的bindingkey<br>我们这里要说的其实就是怎么样决定第二步谁接收的问题</li>
<li>Direct Exchange<br>如其名，直接交换，也就是指定一个消息被那个队列接收， 这个消息被celerybeat定义个一个routing<br>key，如果你发送给交换机并且那个队列绑定的bindingkey 那么就会直接转给这个队列</li>
<li>Topic Exchange<br>你设想一下这样的环境(我举例个小型的应该用场景): 你有三个队列和三个消息,<br>A消息可能希望被X,Y处理,B消息你希望被,X,Z处理,C消息你希望被Y,Z处理.并且这个不是队列的不同而是消息希望被相关的队列都去执行,看一张图可能更好理解:<br>![](<a href="https://access.redhat.com/site/documentation/resources/docs/en-" target="_blank" rel="noopener">https://access.redhat.com/site/documentation/resources/docs/en-</a><br>US/Red_Hat_Enterprise_MRG/1.1/html/Messaging_User_Guide/images/topic-<br>exchange.png)<br>对，Topic可以根据同类的属性进程通配, 你只需要routing key有’.’分割:比如上图中的usa.news, usa.weather,<br>europe.news, europe.weather</li>
<li>Fanout Exchange<br>先想一下广播的概念,<br>在设想你有某个任务，相当耗费时间，但是却要求很高的实时性,那么你可以需要多台服务器的多个workers一起工作，每个服务器负担其中的一部分,但是celerybeat只会生成一个任务,被某个worker取走就没了,<br>所以你需要让每个服务器的队列都要收到这个消息.这里很需要注意的是:你的fanout类型的消息在生成的时候为多份,每个队列一份，而不是一个消息发送给单一队列的次数<br>####我的settings.py<br>这里只是相关于celery的部分:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> djcelery  </span><br><span class="line">djcelery.setup_loader()  </span><br><span class="line">  </span><br><span class="line">INSTALLED_APPS = (  </span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.sites'</span>,  </span><br><span class="line">    <span class="comment">#'django.contrib.staticfiles',  </span></span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,  </span><br><span class="line">    <span class="comment"># Uncomment the next line to enable the admin:  </span></span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,  </span><br><span class="line">    <span class="comment"># Uncomment the next line to enable admin documentation:  </span></span><br><span class="line">    <span class="comment"># 'django.contrib.admindocs',  </span></span><br><span class="line">    <span class="string">'dongwm.smhome'</span>,  </span><br><span class="line">    <span class="string">'dongwm.apply'</span>,  </span><br><span class="line">    <span class="string">'djcelery'</span>, <span class="comment"># 这里增加了djcelery 也就是为了在django admin里面可一直接配置和查看celery  </span></span><br><span class="line">    <span class="string">'django_extensions'</span>,  </span><br><span class="line">    <span class="string">'djsupervisor'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.humanize'</span>,  </span><br><span class="line">    <span class="string">'django_jenkins'</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">BROKER_URL = <span class="string">'amqp://username:password@localhost:5672/yourvhost'</span>  </span><br><span class="line">  </span><br><span class="line">CELERY_IMPORTS = (  </span><br><span class="line">    <span class="string">'dongwm.smhome.tasks'</span>,  </span><br><span class="line">    <span class="string">'dongwm.smdata.tasks'</span>,  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">"amqp"</span> <span class="comment"># 官网优化的地方也推荐使用c的librabbitmq  </span></span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = <span class="number">1200</span> <span class="comment"># celery任务执行结果的超时时间，我的任务都不需要返回结果,只需要正确执行就行  </span></span><br><span class="line">CELERYD_CONCURRENCY = <span class="number">50</span> <span class="comment"># celery worker的并发数 也是命令行-c指定的数目,事实上实践发现并不是worker也多越好,保证任务不堆积,加上一定新增任务的预留就可以  </span></span><br><span class="line">CELERYD_PREFETCH_MULTIPLIER = <span class="number">4</span> <span class="comment"># celery worker 每次去rabbitmq取任务的数量，我这里预取了4个慢慢执行,因为任务有长有短没有预取太多  </span></span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = <span class="number">40</span> <span class="comment"># 每个worker执行了多少任务就会死掉，我建议数量可以大一些，比如200  </span></span><br><span class="line">CELERYBEAT_SCHEDULER = <span class="string">'djcelery.schedulers.DatabaseScheduler'</span> <span class="comment"># 这是使用了django-celery默认的数据库调度模型,任务执行周期都被存在你指定的orm数据库中  </span></span><br><span class="line">CELERY_DEFAULT_QUEUE = <span class="string">"default_dongwm"</span> <span class="comment"># 默认的队列，如果一个消息不符合其他的队列就会放在默认队列里面  </span></span><br><span class="line">  </span><br><span class="line">CELERY_QUEUES = &#123;  </span><br><span class="line">    <span class="string">"default_dongwm"</span>: &#123; <span class="comment"># 这是上面指定的默认队列  </span></span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"default_dongwm"</span>,  </span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"direct"</span>,  </span><br><span class="line">        <span class="string">"routing_key"</span>: <span class="string">"default_dongwm"</span>  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="string">"topicqueue"</span>: &#123; <span class="comment"># 这是一个topic队列 凡是topictest开头的routing key都会被放到这个队列  </span></span><br><span class="line">        <span class="string">"routing_key"</span>: <span class="string">"topictest.#"</span>,  </span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"topic_exchange"</span>,  </span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"topic"</span>,  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="string">"test2"</span>: &#123; <span class="comment"># test和test2是2个fanout队列,注意他们的exchange相同  </span></span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"broadcast_tasks"</span>,  </span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"fanout"</span>,  </span><br><span class="line">        <span class="string">"binding_key"</span>: <span class="string">"broadcast_tasks"</span>,  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="string">"test"</span>: &#123;  </span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"broadcast_tasks"</span>,  </span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"fanout"</span>,  </span><br><span class="line">        <span class="string">"binding_key"</span>: <span class="string">"broadcast_tasks2"</span>,  </span><br><span class="line">    &#125;,  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRouter</span><span class="params">(object)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">route_for_task</span><span class="params">(self, task, args=None, kwargs=None)</span>:</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> task.startswith(<span class="string">'topictest'</span>):  </span><br><span class="line">            <span class="keyword">return</span> &#123;  </span><br><span class="line">                <span class="string">'queue'</span>: <span class="string">'topicqueue'</span>,  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="comment"># 我的dongwm.tasks文件里面有2个任务都是test开头  </span></span><br><span class="line">        <span class="keyword">elif</span> task.startswith(<span class="string">'dongwm.tasks.test'</span>):  </span><br><span class="line">            <span class="keyword">return</span> &#123;  </span><br><span class="line">                <span class="string">"exchange"</span>: <span class="string">"broadcast_tasks"</span>,  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="comment"># 剩下的其实就会被放到默认队列  </span></span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># CELERY_ROUTES本来也可以用一个大的含有多个字典的字典,但是不如直接对它做一个名称统配  </span></span><br><span class="line">CELERY_ROUTES = (MyRouter(), )</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>《Python Web开发实战》预售喽</title>
    <url>/2016-04-12.html</url>
    <content><![CDATA[<p>15年11月19日，我打开了一个不常用的邮箱，看到了2天前编辑给我发的邮件，问我想不想写本Python相关的书。<br>那个时候正是我的黑暗期，一个专注写代码几年的人开始做一些管理工作，一方面要学习，要转换思想，一方面心情也不好，每天就是在处理各种杂事，别说是技术进步了，哪怕把事情考虑周全的时间都没有。每天<br>一个人当成2个人来用，操碎了各种心，很累。<br>对于我这种写代码的，甚至都不善于逗小孩笑的程序员，总想给女儿点不一样的礼物。希望我带给她一些精神上的帮助。看到邮件的一瞬间，我就想象女儿长大之后，对其他人说：喏，那是我爸写的书，给我做生日礼物…<br>就是这2个理由。我决定写这本书。<br>12月4日，我提交的大纲顺利通过审核。<br>12月6日，[CODE真的开源了](<a href="http://www.dongwm.com/archives/codekai-yuan-" target="_blank" rel="noopener">http://www.dongwm.com/archives/codekai-yuan-</a><br>liao/)，喜大普奔。我靠着情怀坚持做完了。CODE那段时间上了Github Trending，我很欣慰，虽然一切都太晚了。<br>接下来的20多天里面，我正忙着弄CODE开源的事情，只是在构思这本书都要有什么内容，并没有下笔。我天真的觉得同时可以把2件事做好，但是后来发现时间完全是不够的，所以我停止的CODE的进一步的迭代。其他的原因是豆瓣已经决定迁移到Github企业版，我一个人并无力改变什么，如果公司自己都不用，那开源的就没有意义了。再则我也受到了厂内很多质疑和嘲讽，心碎。<br>一些写书的介绍可以看这篇专栏《<a href="https://zhuanlan.zhihu.com/p/22207407" target="_blank" rel="noopener">写一本技术书籍</a>》，并建议大家关注这个专栏，近期将有一大波文章要在专栏发呢。<br>专栏有些结论先发出来：</p>
<ol>
<li>开始写书是在圣诞节左右，结束时间是8月15日。也就是差不多240天。</li>
<li>写这本书能让我挣2W多，嗯，时薪23块钱。<br>现在开始介绍这本书。<h3 id="谁应该看本书"><a href="#谁应该看本书" class="headerlink" title="谁应该看本书"></a>谁应该看本书</h3>看书名可知这是一本Web开发相关的书，但事实上里面有大概一半的内容其实是Python工程师都能用到的。我对书的受众的理解是：</li>
<li>Web开发者</li>
<li>运维开发</li>
<li>想提高Python技能的开发者</li>
<li>其他想了解Python Web开发的其他开发者<br>需要注意，阅读本书需要有一定的Python基础，因为书中没有基础语法教程，如果你之前没用Python写过程序阅读起来可能会受到影响。<h3 id="为什么值得看"><a href="#为什么值得看" class="headerlink" title="为什么值得看"></a>为什么值得看</h3>我阅读过大量和Python有关的纸质书和开源图书，渐渐学到了很多控制自己“剁手”买书的方法。我来分析一下为什么你值得拥有本书。:)<br>为什么要买书来看？我认为不外乎两个原因：有趣和能学到东西。技术书肯定不会太有趣，那么最重要的就是能学到东西。市面上Python相关的书相当多，但是有些内容陈旧或者不符合国情，经常能看到并非开发第一线的人写或者翻译的书，这些书显然价值就要低一些；其次是同质化和向入门级别靠拢，我个人认为市面上关于Python入门或者教授语法知识的书不少，而再深入一点的就很匮乏了。<br>本书有几个特点： 第一，使用了当前主流和前瞻性的技术，如Docker、Ubuntu 16.04<br>LTS、Cython、CFFI、Py.test、asyncio、IPython 5.0 LTS等，书中一部分内容是在Python<br>3下完成的。本书中全部工具都使用当前最新版，能保证在相当长的时间内书中的内容都不会过时。<br>第二，笔者在国内应用Python最大的豆瓣网做产品开发，一直在第一线写代码，大量例子和经验都是根据实际经验出发的。<br>第三，笔者非常关注Github和Python社区，会第一时间了解到新的趋势和思想，并在书中体现。举个例子，代码检查工具pep8已经在Guido van<br>Rossum的要求下改名为pycodestyle了。<br>叔本华在《人生的智慧》中说过一段话，大意是人要么庸俗，要么孤独。笔者认为这个道理在阅读上面也成立：读什么样的书，就会逐渐成为什么样的人。本书提供了很多笔者在其他书中没有看到过的思考方式和Python的用法，这也是本书存在的意义。<h3 id="本书涵盖的内容"><a href="#本书涵盖的内容" class="headerlink" title="本书涵盖的内容"></a>本书涵盖的内容</h3><h4 id="第一章-「初识Python-Web开发」"><a href="#第一章-「初识Python-Web开发」" class="headerlink" title="第一章.「初识Python Web开发」"></a>第一章.「初识Python Web开发」</h4>将回答Python工程师关心的如下3个问题：</li>
<li>为什么应该选择Python作为Web开发语言？</li>
<li>在Python 2和Python 3之间如何选择？</li>
<li>在这么多的Python Web框架中哪些是主流的，它们的特点是什么，该如何选择？<h4 id="第二章-「Web开发前的准备」"><a href="#第二章-「Web开发前的准备」" class="headerlink" title="第二章. 「Web开发前的准备」"></a>第二章. 「Web开发前的准备」</h4></li>
<li>环境的准备，以便读者能够使用Vagrant或者Docker提供的Ubuntu环境运行书中的例子。</li>
<li>介绍包管理工具pip及一些高级用法。</li>
<li>实现PYPI的缓存代理和完全镜像。</li>
<li>使用virtualenv及其扩展实现虚拟环境管理。<h4 id="第三章-「Flask-Web开发」"><a href="#第三章-「Flask-Web开发」" class="headerlink" title="第三章. 「Flask Web开发」"></a>第三章. 「Flask Web开发」</h4></li>
<li>通过多个应用例子了解Flask框架使用的一些精髓。</li>
<li>介绍目前最流行的模板引擎Jinja2和Mako的使用，以及实践总结和做选择时的建议。</li>
<li>通过一些例子让读者熟悉MySQLdb的使用，并演示如何和Flask应用集成。</li>
<li>通过源码帮助读者理解Flask的上下文设计，并演示大型应用中使用上下文钩子的例子。</li>
<li>通过一个真实的案例学以致用。先分析需求，接着从零开始实现一个文件托管应用。<h4 id="第四章-「Flask-开发进阶」"><a href="#第四章-「Flask-开发进阶」" class="headerlink" title="第四章. 「Flask 开发进阶」"></a>第四章. 「Flask 开发进阶」</h4></li>
<li>Flask的信号机制。利用信号可以实现一部分的业务解耦。</li>
<li>Flask的一些常用、主流的扩展，如Flask-Script、Flask-DebugToolbar、Flask-Migrate、Flask-WTF、Flask-Security、Flask-RESTful、Flask-Admin和Flask-Assets。每个扩展都包含至少一个完整的真实例子。</li>
<li>Flask的依赖库Werkzeug的使用。<h4 id="第五章-「REST和Ajax」"><a href="#第五章-「REST和Ajax」" class="headerlink" title="第五章. 「REST和Ajax」"></a>第五章. 「REST和Ajax」</h4></li>
<li>帮助读者理解REST。</li>
<li>学习如何设计一个合理、好用、符合标准的API。</li>
<li>使用jQuery和fetch分别完成一个前后端交互的Ajax应用。<h4 id="第六章-「网站架构」"><a href="#第六章-「网站架构」" class="headerlink" title="第六章. 「网站架构」"></a>第六章. 「网站架构」</h4></li>
<li>了解WSGI协议。</li>
<li>主流的Python应用服务器的特点和使用方法。</li>
<li>使用Nginx和Python应用服务器部署Flask应用。</li>
<li>介绍豆瓣开源的Libmc和豆瓣常用的缓存使用方式。</li>
<li>举例说明Redis的几个应用场景，包含使用MessagePack进行序列化和反序列化工作。</li>
<li>介绍使用NoSQL的原因和场景。</li>
<li>使用pymongo，并用Mongoengine重构文件托管服务的模型。</li>
<li>MongoDB索引、高可用和分片的经验。</li>
<li>以豆瓣的基础架构为原型，展示主流大型网站的架构模式，并详细介绍相关重要模式，以及Web前端的性能优化经验。<h4 id="第七章-「系统管理」"><a href="#第七章-「系统管理」" class="headerlink" title="第七章. 「系统管理」"></a>第七章. 「系统管理」</h4></li>
<li>使用Supervisor管理进程。</li>
<li>使用Fabric进行应用部署。</li>
<li>通过部署Redis了解配置管理工具SaltStack和Ansible。</li>
<li>使用Psutil获取系统CPU、内存、硬盘和网络等信息。</li>
<li>配图演示Sentry的安装和收集错误信息的效果。</li>
<li>使用StatsD、Graphite、Diamond和Grafana搭建Web监控，并介绍常见的运维监控工具及其主要应用场景。<h4 id="第八章-「测试和持续集成」"><a href="#第八章-「测试和持续集成」" class="headerlink" title="第八章. 「测试和持续集成」"></a>第八章. 「测试和持续集成」</h4></li>
<li>介绍和使用Python内置测试模块unittest和doctest。</li>
<li>介绍和使用第三方测试工具py.test和mock。</li>
<li>深入持续集成，并通过Buildbot实际地对一个Github项目进行集成。<h4 id="第九章-「消息队列和Celery」"><a href="#第九章-「消息队列和Celery」" class="headerlink" title="第九章. 「消息队列和Celery」"></a>第九章. 「消息队列和Celery」</h4></li>
<li>使用Beanstalkd。</li>
<li>解释AMQP，深入理解RabbitMQ，介绍RabbitMQ插件系统，RabbitMQ集群的故障转移方法等。</li>
<li>介绍Celery的架构，运行起一个真实的应用，在Flask应用中使用Celery等功能。</li>
<li>深入Celery，介绍Celery的依赖及独立用法、Worker管理、监控等高级功能。</li>
<li>笔者总结的一些Celery实践经验。<h4 id="第十章-「服务化」"><a href="#第十章-「服务化」" class="headerlink" title="第十章. 「服务化」"></a>第十章. 「服务化」</h4></li>
<li>为什么需要服务化。</li>
<li>使用Thrift对文件托管服务改造。</li>
<li>介绍豆瓣服务化实践——PIDL的起因、基本原理和基本架构。<h4 id="第十一章-「数据处理」"><a href="#第十一章-「数据处理」" class="headerlink" title="第十一章. 「数据处理」"></a>第十一章. 「数据处理」</h4></li>
<li>使用纯Python代码实现MapReduce功能。</li>
<li>配置DPark环境，深入了解DPark，演示如何用DPark对业务日志进行PV和UV的分析。</li>
<li>通过发送带有样式和附件的邮件，创建包含带样式和Sparkline图表的xlsx文件，以及创建包含多工作表和4. 图表的xlsx文件这三个有用的例子，展示笔者对数据报表的理解和运用。</li>
<li>基于数据报表中的数据，用Pandas进行分析和展示。<h4 id="第十二章-「帮助工具」"><a href="#第十二章-「帮助工具」" class="headerlink" title="第十二章. 「帮助工具」"></a>第十二章. 「帮助工具」</h4></li>
<li>解释为什么应该使用IPython，配置IPython、调试复杂代码、并行计算等。</li>
<li>介绍Jupyter Notebook的用途，配置Jupyter Notebook，在Notebook里使用Echarts自定义JavaScript和CSS样式等高级功能。</li>
<li>介绍常用的获得Linux服务器相关情况的工具。</li>
<li>介绍性能测试工具Boom和tcpcopy，并演示如何搭建一个tcpcopy环境。</li>
<li>介绍分析Python程序性能瓶颈的工具。</li>
<li>演示如何定制基于IPython的交互解释环境。</li>
<li>演示豆瓣东西在2014年双十一进行的Jupyter Notebook实践。<h4 id="第十三章-「Python并发编程」"><a href="#第十三章-「Python并发编程」" class="headerlink" title="第十三章. 「Python并发编程」"></a>第十三章. 「Python并发编程」</h4>使用多线程、多进程、Gevent、Future和asyncio这五种方式实现一个爬取微信公众号的抓取。其中还揭秘了一些写爬虫的经验。尤其是告诉读者如何选择并发方式。<h4 id="第十四章-「Python进阶」"><a href="#第十四章-「Python进阶」" class="headerlink" title="第十四章. 「Python进阶」"></a>第十四章. 「Python进阶」</h4></li>
<li>介绍errno、subprocess、contextlib、glob、operator、functools、collections模块的使用方法。</li>
<li>笔者对《Python之禅》的理解。</li>
<li>笔者总结的一些Python实践经验，并列举了两篇最佳实践的文章。</li>
<li>介绍一些Python 3的有用功能，并移植到Python 2。</li>
<li>通过真实的例子演示如何使用CFFI/Cython编写Python扩展，并对比二者的执行效率。</li>
<li>演示使用PyObjC发送通知的例子，让开发者收到的通知更有针对性。<h4 id="第十五章-「Web开发项目实践」"><a href="#第十五章-「Web开发项目实践」" class="headerlink" title="第十五章. 「Web开发项目实践」"></a>第十五章. 「Web开发项目实践」</h4></li>
<li>介绍笔者的Web项目开发流程和经验。</li>
<li>介绍开源的代码质量保证工具，以及豆瓣的一些质量保证实践。</li>
<li>使用AST对真实的业务逻辑做静态检查，实现业务流程的检查。</li>
<li>谈谈代码评审的意义和实际经验。<br>PS: 本书还有其他惊喜，我就不打广告了。感谢大家支持，也希望通过本书能让你有所收获。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>12个python填空题</title>
    <url>/2016-04-17.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么? 你已经很了解python了? 好.<br>我们开始做个测验. 下面有12个题目. 填个空, 让这个代码片段变的可能.</p>
<h3 id="先做个例子"><a href="#先做个例子" class="headerlink" title="先做个例子"></a>先做个例子</h3><p>例子1:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y == y + x  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<p>其中有个<code>???</code>. 把它替换成什么就可以让这段代码成立呢?<br>揭晓答案:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = [<span class="number">0</span>], [<span class="number">1</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y == y + x  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<p>这个还是蛮简单的. 好继续<br>例子2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &lt; x  </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


<p>答案呢?<br>如果使用python内置的数据结构, 确实是不可能的. 唯一可以<code>硬造</code>一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = type(<span class="string">""</span>, (), &#123;<span class="string">"__lt__"</span>: <span class="keyword">lambda</span> a, b: <span class="literal">True</span>&#125;)()  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &lt; x  </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


<p>但是这里不需要这么复杂的去想<code>trick</code>出结果, 只考虑python已经实现的设计</p>
<h3 id="发考卷"><a href="#发考卷" class="headerlink" title="发考卷"></a>发考卷</h3><ol>
<li>难度3星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(x, y) == min(y, x)  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>难度4星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(set(list(x))) == len(list(set(x)))  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="3">
<li>难度3星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, s = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(x)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(x) <span class="keyword">in</span> map(type, s)  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="4">
<li>难度3星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &lt; y <span class="keyword">and</span> all(a &gt;= b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(x, y))  </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


<ol start="5">
<li>难度4星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(<span class="number">0</span> * x, y) == y  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="5">
<li>难度5星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(x) == min(*x)  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="6">
<li>难度3星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y, z = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * (y * z) == (x * y) * z  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="7">
<li>难度3星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y, z = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * (y * z) == (x * y) * z  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="8">
<li>难度4星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y &gt; max(x) <span class="keyword">and</span> y <span class="keyword">in</span> x  </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


<ol start="9">
<li>难度5星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any(x) <span class="keyword">and</span> <span class="keyword">not</span> any(x + y)  </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


<ol start="10">
<li>难度3星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, y = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.count(y) &lt;= len(x)  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="11">
<li>难度5星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all(filter(<span class="literal">None</span>, x))  </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<ol start="12">
<li>难度4星</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; x, a, b, c = ???  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(x) &lt; max(x[a:b:c])  </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h3 id="答案呢"><a href="#答案呢" class="headerlink" title="答案呢"></a>答案呢</h3><p>这是最近我觉得蛮有趣的一个项目<br><a href="https://github.com/cosmologicon/pywat/blob/master/quiz.md" target="_blank" rel="noopener">pywat</a><br>上面的评星是我加上去. 也体现了我做这些题目花费的精力和时间:<br>3星: 很快就想到, 实验出来了<br>4星: 花了蛮长时间, 终于找到答案了<br>5星: 最后实在找不倒答案, 看了答案恍然大悟啊啊啊啊<br>你能做到什么程度呢?<br>请慎重点击: [答案地址](<a href="https://github.com/cosmologicon/pywat/blob/master/quiz-" target="_blank" rel="noopener">https://github.com/cosmologicon/pywat/blob/master/quiz-</a><br>answers.md)</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐 + 赠书 《Python 3学习笔记（上卷）》</title>
    <url>/2016-04-13.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>「如何学习编程」每个人都有自己的答案，在我初学Python的时候，我就非常关注大神们的学习方式和成长之路。工作这么些年过来，我发现大家入门和学习的共同点非常统一：读书、看源码、高频率的实践和动手，对于现在的同学还可以选择看视频。<br>在我的印象里面，大神TJ Holowaychuk的学习方法让我记忆深刻，大概4-5年前我看过一个介绍，但是找不到印象里的那篇了，只找到了这篇<a href="https://zhuanlan.zhihu.com/FrontendMagazine/19572823" target="_blank" rel="noopener">TJ<br>Holowaychuk是怎样学习编程的？</a>。TJ的学习方法很特别：</p>
<blockquote>
<p>也不读书，从不去听课，我就是去阅读别人的代码，并搞清楚那些代码是如何工作的。<br>而《Python 3学习笔记（上卷）》作者雨痕在我印象里面就是这样通过阅读CPython源代码来学习Python的。</p>
</blockquote>
<h3 id="qyuhen-book"><a href="#qyuhen-book" class="headerlink" title="qyuhen/book"></a>qyuhen/book</h3><p>雨痕前辈从1996年开始从事计算机软件开发工作，从2006年接触Python，他的<a href="https://github.com/qyuhen/book" target="_blank" rel="noopener">qyuhen/book</a>在2013年的时候就已经非常知名了。这个项目下是除了Python笔记，还有Go，C方面的学习笔记。<br>第一次阅读《Python学习笔记》就被它的内容吸引，虽然只是作者的学习笔记，但是依然不影响对于学习Python的开发者的意义，我觉得这个笔记有2个显著的特点：</p>
<ol>
<li>从解释器和CPython源码实现的角度剖析语言语法</li>
<li>通过在交互环境中的实验去证明和验证细节，获得结论<br>可以说这本书对13年的我来说，有很大的帮助。当然这个笔记里面还有一些有意思的点，我在14年的[Python高级编程](<a href="http://dongweiming.github.io/Expert-" target="_blank" rel="noopener">http://dongweiming.github.io/Expert-</a><br>Python/#1)分享中PPT一上来就引用了这个笔记中提到的怎么让Python支持end:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">__builtins__.end = <span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"a"</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"b"</span>  </span><br><span class="line">    end  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">    test(<span class="number">1</span>)  </span><br><span class="line">    print(<span class="string">'I can use end!'</span>)  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<p>嗯，这不是ruby。其实能这么写的根本原因就是end被解释成了None，写成什么都可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">__builtins__.endif = <span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  </span><br><span class="line">    endif  </span><br><span class="line">  </span><br><span class="line">test(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<p>之后雨痕老师的<a href="http://product.dangdang.com/23997846.html" target="_blank" rel="noopener">《Go语言学习笔记》</a>出版了，但是《Python学习笔记》却没有动静，我既有失望也满怀期待，想必没有考虑出版它是由于这个笔记是针对<br>Python2.7 的。<br>但是不要紧，《Python 3学习笔记（上卷）》来了。</p>
<h3 id="荐书"><a href="#荐书" class="headerlink" title="荐书"></a>荐书</h3><p>关注我的同学应该都知道我是不愿意参与荐书的，我得对订阅者负责。我没看过的、觉得不好的书我是不可能推荐给别人的。<br>目前我正式的荐书只有<a href="http://product.dangdang.com/25071121.html" target="_blank" rel="noopener">《流畅的Python》</a>和平时在群里说到的<a href="http://product.dangdang.com/24003310.html" target="_blank" rel="noopener">《python编程<br>从入门到实践》</a>，《Python<br>3学习笔记（上卷）》是我推荐的第三本书。节前就收到了样书，刚刚读完，给大家分享一下读后感。</p>
<h4 id="本书的特点"><a href="#本书的特点" class="headerlink" title="本书的特点"></a>本书的特点</h4><ol>
<li>书中内容基于目前最新的Python 3.6版本，书中提到的一些最新的Python内容还很少有中文书或者博客来介绍。在2018年这个节点，如果一本新书还在讲Python 2，反正我是不会买了。</li>
<li>同样是从解释器和CPython源码实现的角度剖析语言语法。市面上大部分的教程都是在告诉你应该怎么用，但是背后隐藏的细节和原理却很少提及，这本书对这些并不避讳，而更像是想弄清楚解释器执行的流程和细节。尤其是在「解释器」章节里面除了从源码上分析GIL，还有内存分配、垃圾回收和Python执行过程的方面的内容。</li>
<li>配图丰富、简单易懂。同作为图书作者，我很了解做配图是一件很耗时辛苦的事情，既要对配图的内容理解非常深刻，也要让它直观好懂是很难的，这本书这点做的就不错。</li>
<li>通过在交互环境中的实验去证明和验证细节，获得结论。这是我非常喜欢的方式，作为一个读者用这样的方式学习知识是很轻松愉快的</li>
<li>概念定义深刻准确。雨痕老师的编程经验非常丰富，对Python也很熟悉，对一些知识点的定义和理解非常好。我举2个例子：<br>1.「包和模块」。有多少人不能清晰区分他俩？我看到很多同学用这2个词的时候很随意，这本书里面是这么说的：<blockquote>
<p>模块( module) 是顶层代码组织单元，其提供大粒度的封装和复用…<br>如果说模块用于组织代码，那么包就是用来组织模块的…<br>我的感觉是总结非常到位。</p>
<ol start="2">
<li>借助生成器切换执行功能，改善程序的结构设计。我举书中列出的2个例子，第一个是生产消息模型：</li>
</ol>
</blockquote>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        v = <span class="keyword">yield</span>  </span><br><span class="line">        print(<span class="string">f'consume: <span class="subst">&#123;v&#125;</span>'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(c)</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">13</span>):  </span><br><span class="line">        c.send(i)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">c = consumer()  </span><br><span class="line">c.send(<span class="literal">None</span>)  </span><br><span class="line">  </span><br><span class="line">producer(c)  </span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>



<pre><code>当然作者也提到如果有多个消费者或者数据处理时间较长，还是建议使用专业的并发方案。第二个是消除回调。我们先看看异步回调的模式：</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(request, callback)</span>:</span>  </span><br><span class="line">    s = time.time()  </span><br><span class="line">    request()  </span><br><span class="line">    time.sleep(<span class="number">2</span>)  </span><br><span class="line">    callback(<span class="string">f'done: <span class="subst">&#123;time.time() -s &#125;</span>'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">()</span>:</span>  </span><br><span class="line">    print(<span class="string">'start'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(x)</span>:</span>  </span><br><span class="line">    print(x)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service</span><span class="params">(request, callback)</span>:</span>  </span><br><span class="line">    threading.Thread(target=target, args=(request, callback)).start()</span><br></pre></td></tr></table></figure>



<pre><code>我一直不喜欢回调，这种接口设计的方式会让代码和逻辑分散开，维护性很差。如果使用生成器怎么做呢？</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">()</span>:</span>  </span><br><span class="line">    print(<span class="string">'start'</span>)  </span><br><span class="line">    x = <span class="keyword">yield</span>  </span><br><span class="line">    print(x)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(fn)</span>:</span>  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        s = time.time()  </span><br><span class="line">        g = fn()  </span><br><span class="line">        g.send(<span class="literal">None</span>)  </span><br><span class="line">  </span><br><span class="line">        time.sleep(<span class="number">2</span>)  </span><br><span class="line">        g.send(<span class="string">f'done: <span class="subst">&#123;time.time() -s &#125;</span>'</span>)  </span><br><span class="line">    <span class="keyword">except</span> StopIteration:  </span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">service</span><span class="params">(fn)</span>:</span>  </span><br><span class="line">    threading.Thread(target=target, args=(fn,)).start()  </span><br><span class="line">  </span><br><span class="line">service(request)</span><br></pre></td></tr></table></figure>



<pre><code>这样就不需要callback性质的额外参数了，通过yield让程序逻辑看起来是串行的。</code></pre><p>我要强调一下： <strong>这本书并不是适合入门，它假定读者已经有一定的编程和Python基础</strong><br>。所以更适合已经熟悉Python语言语法，使用Python写过程序的开发者，如果你正准备迁移Python 2的代码到Python<br>3.6这本书就更值得看一看了。<br>在上个月发布的<a href="https://annual2017.pycourses.com" target="_blank" rel="noopener">《爱湃森 2017年度Python榜单》</a>中，我也把这本书放到了<br><a href="https://annual2017.pycourses.com/#62" target="_blank" rel="noopener">2018年最值得期待的国内出版的Python书籍</a>的第二位（那会我还没拿到样书），现在看来这本书也物超所值，对我这种Python老手来说，看书获取新知识的几率已经不高，但是从这本书里面我还是收获了很多。我举几个印象深刻的例子：</p>
<ol>
<li>池化。之前没了解过，就是相同名字可能会重复出现在不同的名字空间里，就有必要共享实例，这样节约内存，也省去了创建新实例的开销，所以Python实现了字符串池。</li>
<li>SimpleNamespace。之前我想快速的构建一个结构化的实例会用namedtuple，但是缺点是它构建出来的是一个类型：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])  <span class="comment"># 构建出来的是一个类，而且传递参数的效果也不直观，field_names需要是一个列表或者空格分割的字符串，不方便  </span></span><br><span class="line">In [<span class="number">6</span>]: p = Point(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 我还得实例化一下Point才能用  </span></span><br><span class="line">In [<span class="number">7</span>]: p.x, p.y  </span><br><span class="line">Out[<span class="number">7</span>]: (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<p>这样不方面，SimpleNamespace就可以直接创建实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="keyword">from</span> types <span class="keyword">import</span> SimpleNamespace  </span><br><span class="line">In [<span class="number">9</span>]: p = SimpleNamespace(x=<span class="number">1</span>, y=<span class="number">2</span>)  </span><br><span class="line">In [<span class="number">10</span>]: p.x, p.y  </span><br><span class="line">Out[<span class="number">10</span>]: (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<p>这样用起来就方便多了。<br>  3. 自定义异常类的名字。我以前自定义异常的名字比较随意，XyzException或者XyzError通常有点看心情或者仿之前名字格式，这本书这样说的「内置异常多以Error结尾，但建议以Exception、Error后缀区分可修复异常和不可修复异常」，我觉得说得对…<br>上述这几点算是我的读书笔记，详细的还得看书中原文哦。<br>希望国内能出现越来越多的好书！有能力有想法的同学，可以私信我帮你联系出版社哟</p>
<h3 id="赠书"><a href="#赠书" class="headerlink" title="赠书"></a>赠书</h3><p>我向电子工业出版社谋了5本《Python-3学习笔记（上卷）》福利给大家。这次在移动端的抽奖用「抽奖助手」小程序，关注本公众号之后，长按下图，在弹出框中「选择识别图中的小程序码」进入抽奖页面即可。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python有没有站到风口上？</title>
    <url>/2016-04-16.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>熟悉我的同学都知道4-5月份在知乎上我开了三炮：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/26149723" target="_blank" rel="noopener">Python技术分享的乱象</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26204219" target="_blank" rel="noopener">《如何选择Python版本2还是3》涉嫌大量的「抄袭」</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26832983" target="_blank" rel="noopener">我不认识Pythoner这种开发者</a><br>另外也回答了对于知乎Python话题下大量的入门爬虫教程的成因，详见<br><a href="https://www.zhihu.com/question/58606373/answer/158377813" target="_blank" rel="noopener">python分享中初级爬虫教程泛滥是否有其语法特征和生态环境的锅？</a><br>知乎是一个群魔乱舞的地方。当时看起来，没人出来说话，我再不说话，知乎就要成为营销号收智商税最好的去处了。本着治病救人的原则，我隐晦的警告了那些以为关注了Python话题的知友智商都不够用的坏人。<br>PS：昨晚有个叫做 @Larry<br>的偷了我这篇文章发出来，他其实就是我文中抨击的一种人，不过抄习惯了没好好看。知乎的不作为纵容了平台上出现了这种不尊重别人知识的人，我只能说知乎💊<br>开炮之后，知乎的Python话题的风气好了很多，动机不纯的人基本都开始夹起尾巴，而那些营销号也大多被封号或者退出知乎了。自认为这是一次有意义的胜利。<br>关注我的人越多我就越觉得有责任说正确的实话。所以我的回答主要包含2种：1. 帮助新同学；2.<br>某些热门问题立意鲜明的观点，不过这种类型的回答自带杀伤力，并且经常不讨喜。<br>今天说的这篇是周二首发于我的同名微信公众号「<a href="https://mp.weixin.qq.com/s?__biz=MzA3NDk1NjI0OQ==&mid=2247484077&idx=1&sn=1f9e41fa521fc0f8ea809ed7d07c4993&chksm=9f76ae1ba801270d4913699dac264b18c3969b0ec7ccf6d95e1a84a33a2e92e9cb26708fb63e#rd" target="_blank" rel="noopener">Python之美</a>」，目前的荣誉是：<br>![](<a href="https://user-" target="_blank" rel="noopener">https://user-</a><br>images.githubusercontent.com/841395/28205566-2421bc42-68b5-11e7-92a2-3af7e01398.png)<br>14人赞赏，算是我被认可最多的一次文章了，还被这个同学暖到了：<br>![](<a href="https://user-" target="_blank" rel="noopener">https://user-</a><br>images.githubusercontent.com/841395/28206085-3c02d4de-68b7-11e7-986e-583533938c.png)<br>感谢大家的支持，因为我这一篇得罪好几大波人。<br>下文主要针对发Python话题内容的微信公众号，不过其中有些普适的观点可用于其他环境。前方高能，非战斗人员速速撤离。<h3 id="我为什么要在公众号里说这个话题？"><a href="#我为什么要在公众号里说这个话题？" class="headerlink" title="我为什么要在公众号里说这个话题？"></a>我为什么要在公众号里说这个话题？</h3>基于个人兴趣和工作需要，我关注了架构、前端、产品、运维、Linux以及Python的一些公众号，可以趁着上下班的分散时间充电。不过我最近发现了一个新现象，智商税已经开始往讲Python的公众号上来了，我每周都能看到某些公众号会发各种培训、收费课程的软广，以及一些低质量的技术大会。<br>当知乎粉丝、知乎专栏、微信公众号订阅人数到一定量的话，就会有人联系你，通过转发或者自编辑软广文章、文章尾部加二维码导流等方式变现。通过这多半年的积累，基本上市面上你们能看到的软广也会找到我，不过我都是拒绝或者置之不理的。<br>我和钱有仇么？显然不是，我还挺喜欢钱的，有了它可以过更好的生活。如果按照每周接一个软广的频率，这个月的生活费就出来了。不过，作为一个还在写代码的开发者，我还是得对自己的读者负责，所以无论是现在还是未来，你们都不会从我这里获得有被收税风险的内容。这里打个广告，外面坏人太多，欢迎关注本公众号和同名知乎专栏。<br>插个题，可能有一些内心阴暗的人会觉得我给《流畅的Python》背书这事儿背后是挣了钱的，我也先解释下，首先是英子送我一本（嗯，确实有收益），之后的推荐和赠书活动都是我主动和英子提的。一切我认为好的、对读者有益有用、但是大家不怎么知道它的好的东西我都愿意出来背书。<br>另外有些人觉得我开Live是收智商税的，呵呵 最贵29，有一天还打3.4折…<br>真的收智商税的都喜欢把人骗出去，悄悄收，在知乎明目张胆，这么多人监管着（尤其是我）他们不敢。小密圈就是一种税，我从来没看好过小密圈的模式，几个月过去了，你付费的那些圈子的作者中有几个真的像当时保证的那样持续高质量的原创输出（反正我从来不敢保证，既然没把握不好我肯定不开）？圈子已经多久没有更新了？<br>另外就是给大家普及一点常识：如果没有一个团队或者公司的支持，个人开发者是不可能做成每日都完成高质量的原创文章的。一周写2篇，坚持2个月我就认为灰常灰常厉害了，相信运营过知乎专栏或者公众号的应该都深有体会。既然持续高质量输出这么难，怎么留下并让公众号订阅者高度增长呢？这是一个挺有意思的话题，其中最常见的当然是每天花时间在网上找已经发过的文章，有点道德的人会联系原作者获得授权，有些嘛，直接拿走不谢。还有就是跟踪国外的一些相关技术网站，翻译人家的文章。总体来说，让读者觉得领域不重复，内容不腻就能保持住增长，而且还很容易出现引发热议的爆款文章，这种文章通常能带到3-4倍的阅读和关注量，成本却很低。<br>这个时候，我要说重点了。你关注的那些日更的都是编辑运营的公众号，它有几个特点：</li>
<li>盈利才是真的目的</li>
<li>运营编辑的技术水平参差不齐，选择的文章的质量嘛, 自己想</li>
<li>文章并不求精华，真正的中高级开发者一般是不看这种文章的，所以文章定位是小白和初学者，容易造成读者产生错误的世界观和价值观</li>
<li>完成每天发文章的任务，需要花费大家时间和精力，成本很高。这直接会让运营者的技术提高受限，迎合读者和技术提升是有比较大的冲突的。<br><strong>如果能做到日更的个人公众号所有者的技术水平堪忧</strong> ，真的一线开发者根本没有这个时间。<br>又想起来下面这句话：<blockquote>
<p>天下熙熙皆为利来，天下攘攘皆为利往。<br>大家辛辛苦苦提供内容，免费的话内容提供者有什么动力更新？搞技术的也得吃饭买房子，总不能靠情怀吧？技术公众号靠赞赏和让读者点下面的流量广告的收入得饿死。<br>我也很支持技术和知识的变现，那么问题来了，我喷个啥？<br><strong>我关注的领域中没有一个像Python圈子这么乱的：</strong></p>
</blockquote>
</li>
<li>公众号所有者本身是有经验的一线开发的凤毛菱角。</li>
<li>下限太低。前端现在这么火，培训机构这么多，但有那个知名前端公众号在发培训班的软广？另外的领域的公众号也能看到软广，但是都很少，而我大Python基本是隔2-3天就能看到一次</li>
<li>低质量的、无干货的当前热点、冷饭热炒的文章大受关注，点赞阅读数都很高。</li>
<li>高质量文章太少，大部分有能力有经验的开发者并不善于也不愿意营销自己，容易被现在的环境弄得放弃掉。<br>环境就是这样，针对这种情况，我谈下面3个方面。<h3 id="自学编程-vs-参加培训"><a href="#自学编程-vs-参加培训" class="headerlink" title="自学编程 vs 参加培训"></a>自学编程 vs 参加培训</h3>金旭亮老师写过一篇<a href="https://zhuanlan.zhihu.com/p/27696141" target="_blank" rel="noopener">同名专栏文章</a>，里面的观点非常中肯，有兴趣大家去看看。<br>很多人在值乎和私信里面问过我这个话题，这也是初学者尤其是非计算机专业初学者最关心的问题了。<br>先说结论。不要参加培训！Python这么容易上手你还需要培训，那么你要考虑下是不是适合编程了。<br>有些同学会说「你已经是老鸟了，你当然不能理解我这种非计算机专业学编程要面临什么啊，站着说话不腰疼」？其实我也是从一脸懵逼开始的，我大三看软考书的时候简直都是在翻「天书」，因为上面的字认识，连起来却完全不知道它在讲什么，所以备考的时候没有老师，死记硬背，熟能生巧，在学习过程中不断的去理解当时不能理解的那些内容。而现在的环境要比那个年代好的太多了，还需要老师手把手教，反正这种同学我不需要，未来也不会有什么发展。<br>上段时间知乎有个问题「学习Python很吃力，我是不是可以放弃编程了？」我的答案是「假如不是由于心不静或者学习方法、用的资料有严重问题，请放弃」。有很多行业可供选择，如果你只是为了来这个行业捞金，对它既没有兴趣也没有毅力解决那些看起来不能完成的任务，何必呢？<br>我的职业生涯里面遇到过一些通过培训出来的同事，总体的感觉是他们只是把编程当做一门养家糊口的工作，自学和理解能力都比较差，代码质量差很少反思，善于堆叠代码，bug多，习惯手把手教，缺少举一反三的思维能力和习惯。在这么快速发展的互联网行业里面显得那么格格不入，不过唯一幸运的是培训的同学没选择前端，否则有的受了…<br>（随便黑了下前端）<br>说到这里，分享一个我之前对于团队成员要求的错误理解。在我刚做技术TL负责招聘的时候，我的观点是团队的同学必须要精英，我接受如下三类做同事：</li>
<li>领悟力强，有天赋</li>
<li>已经在工作需要的领域非常深入，哪怕不再学习也能靠现有的经验解决那些未知的问题</li>
<li>主动性强，能不断自我提高，喜欢接触和挑战新事物<br>所以那段时间招聘到HR实在忍不了了，找我谈话，希望我降低标准。我也觉得挺过意不起的，就请她吃饭，吃饭过程中她说了一个观点点醒了我：团队里面要有不同层次的人。为什么呢？</li>
<li>优秀的人需要挑战，不喜欢干那些脏活累活，谁来干？</li>
<li>程序员最容易不服人，都是尖子那么矛盾就会激增，事儿会多</li>
<li>绝大多数人都是把编程作为谋生的手段，优秀的能走到金字塔尖的人非常少。人才市场就那么大，很难招聘到符合我口味的又愿意来的人<br>那么我上面说的这种能干活的、要求相对低，俗称码农的开发者还是非常有市场的。这也是培训这个行业能活到现在的根本原因之一。那么培训真的没有必要么？<blockquote>
<p>培训行业以赚钱为最高目的的、鱼龙混杂、弄虚作假成风<br>我能接受参加培训的唯一的理由是「省时间」，相信每个人都能想起来自己在第一次学习某个之前从未了解的领域知识的时候要多费劲，现在有人给你准备一个课程体系，在一个较短的时间里面教会你一些可能没有别人教你自己琢磨要花费2-3倍时间才能学会的东西，这不是典型的用金钱换时间嘛？对于一些人看来不是很值么？其实不然，因为有2个问题：</p>
</blockquote>
</li>
<li>培训班的好处大都是短期的，用不了多久就会消散。一开始会经历较慢的自学过程，但是这个过程你会掌握的自学能力和学习方法，尤其会初步形成一个适合你的找到问题、解决问题的思路和流程，对于你成长为中级和高级程序员来说，是极为重要的。而培训需要将大量的知识「灌入」学员的大脑，让学员掌握那些开发套路，学员知其然不知其所以然，问题稍微变化一下就不知道怎么解了。</li>
<li>并不能确定培训机构灌输给你的东西本身是正确的，也请谨慎面对他们传输给你的价值观和世界观。<br>那么怎么分辨好的培训机构和讲师呢？粗列几条吧：</li>
<li>培训机构的老师有确凿的证据表明其还在开发第一线, 且公司比较成熟知名，最好讲师有一定名气。据我所知，培训老师大部分是自己混不进开发第一线只能去干培训老师糊口。</li>
<li>凡是说保证就业的培训机构别去，因为清华都不敢保证，招生的不诚信，也不要指望在教学和就业推荐方面诚信</li>
<li>提供不满意全额退尾款条款<br>你需要了解业界口碑，而不是看培训网站贴出来的自己说的那些评价和薪资。讲个笑话，我之前无意在很早期进了某个很知名的Python培训QQ群，看了几次助教在吹嘘他们的学员中有去了豆瓣和知乎的，有次我实在忍不了了，就直接在群里问，你说的入职豆瓣的那个学员叫什么啊？那哥们马上不说话了，群里气氛立刻尴尬起来，不过恰好这个培训机构的负责人想拉我入伙之前加过我微信，他就和我私聊，说是那个助教记错了，没有去豆瓣的…<br>人艰不拆，我也没必要挡人家财路，最后从那个群被「劝退」了。你们想想，他们在背后骗了多少人，如果你们以后看到这种吹嘘的东西，问他们来豆瓣的是谁，然后私信或者其他方式联系我，我给你们认证。不过你们应该问不出来具体的名字，因为这都是培训机构骗人的套路罢了。<h3 id="全栈？"><a href="#全栈？" class="headerlink" title="全栈？"></a>全栈？</h3>我经常看到有人说自己是全栈，结果一问也就是会点前端会点后端。当然全栈不是要求样样精通，而是能根据需求能 <strong>快速</strong><br>掌握一门语言或者技能，以达到能够投入实际开发，独立实现各部分功能的要求。<br>全栈是目前市场希望出现的一种开发者，既懂前端也懂后端，还能写的了ios和安卓的app，能运维，可以自己设计，这样可以减少不同工种之前沟通的成本，通常一个人就搞定了，而且<br><strong>还便宜</strong> 。由于圈子有限我到现在还没见过一个真正的「全栈」，当然我相信这样的牛人是有的，不过数量…<br>事实上能熟练2个门类（注意我说的不是精通）的开发者就很少了，目前我就不满足。我只是能熟练使用Python，另外就是能当个小「前端」用用，完成工作没问题，但是我自觉自己在前端这个门类上就是个「搬砖」的。为啥这么说呢？<br>有很多后端工程师说「哎呀前端有啥难的？」，好，我们开始做一个调查：</li>
<li>只会用Bootstrap和jQuery这种框架完成前端工作？剩下了50%的人</li>
<li>能借用Google写工作需要的Javascript/ES6/Typescript程序？剩下了30%的人</li>
<li>熟练使用前端的各种工具和框架，包含但不限于React、Vue、Webpack、Sass等，剩下了10%的人</li>
<li>能手写css？只剩下了1%的人了！！<br>有些同学以为在本地能写个简单的React、Vue的项目就算前端全栈了，充其量不过是一个熟练的API使用者。一切没有在生产环境中验证的程序都不算过关。<br>如果你看到一个课程是教你成为全栈工程师请果断开骂，这TM不是智商税是什么？<h3 id="Python有没有站到风口上？"><a href="#Python有没有站到风口上？" class="headerlink" title="Python有没有站到风口上？"></a>Python有没有站到风口上？</h3>当我到一个陌生的地方去吃饭，我通常会观察整条街上那家店里面的人多，尤其排队的人数比较多的那种是我的首选，<br><strong>对于我不熟悉的领域我一向倾向于选择别人都愿意选择的那种，从概率上讲选错的概率会低很多</strong><br>。我把这种行为叫做「人云亦云」。当我不知道怎么选择的时候会跟随别人的选择，一般情况下没必要花大精力让自己做出正确的选择，要是有人举起旗帜就很容易把我拉入伙。<br>我们来看看说Python站到风口上的主要是什么人：</li>
<li>培训机构</li>
<li>自媒体</li>
<li>Python书籍出版社和作者</li>
<li>没什么输出的小号<br>那么他们有什么「Python在风口上」的证据么？好像说了很多话，但是没有一条有理有据。很多想入坑的同学并没有辨识能力，有人说好，但是没怎么看到有人说不好，那么就认为<br><strong>确实好</strong> 了。<br>那Python站不站到风口上谁说了才算？</li>
<li>使用Python的第一线开发者，在前线了解行业发展情况</li>
<li>由于Python在风口上而获利的公司或者机构的相关消息<br>目前做AI的很多，不过现在还没有什么值得兴奋的例子。而我符合第一条，反驳下被肆意夸大的最主要的2个观点（有其他观点的欢迎在评论区举出来唠唠）：</li>
<li>人工智能（AI）火爆，而相关的库都是Python写的。首先它们的执行部分都是C++/C写的，不过是提供了Python API，上当了吧… AlphaGO连柯洁都击败了也让我震撼，其中用到了AI、机器学习（ML）和深度学习（DL）技术，我也非常看好这个方向的未来。但是先冷静一下， <strong>能做好AI的工程师用Python都不是问题，但是会用Python非常不一定能做人工智能的工作</strong> 。现在出版社特别喜欢出版Tensorflow相关的书籍，因为当前热点好卖啊。不过各位先听我说几个论点：<ol>
<li>待遇和你的不可或缺性直接相关。你会用tensorflow、sklearn提供的例子调用其API有什么竞争力？给个聪明点的高中生学2天也会。你看到5-6k/month的工资不是AI工程师，是AI API工程师。</li>
<li>没有坚实的算法和数学基础，建议不要碰。哪怕我这种使用Python 6年的熟手也是知难而退的。英语不好也请谨慎，要不然看个论文都会让你怀疑人生。</li>
<li>让更专业的人去做，不要以为别人硕士阶段都在吃屎。对于大部分普通的程序员，不要什么热门就往那个方向去挤，做一个更专业的程序员更好，术业有专攻。如果你真的想往AI方向走，听听吴恩达免费课，买本周志华的《机器学习》，kaggle有比赛项目做做，再思考下能不能hold住。 </li>
</ol>
</li>
<li>在程序员圈子热议。现在看来基本是个程序员就能写的了Python。好像不会Python都不好和别人打招呼似得，我很欣慰这样的趋势，不过这个和真的靠Python就业吃饭差别是很大的。作为一个靠Python吃饭的人，我当然希望Python火的不要不要的，不过我对整个Python市场的感觉是 <strong>一直不温不火</strong> ，坑儿位就那么多，需求的涨幅平稳。好的Python工程师很稀缺，钱和环境都可以给到位，前提是能达到要求。别想着学会Python就会升职加薪, 迎娶白富美，走向人生巅峰。我们缺的是中高级开发者，初级市场早就饱和了。之前我在值乎还被问到「听说现在php前景不好，在Python和php中间如何选择」的问题。程序员有个通病就是喜欢按着自己的喜好瞎建议，一个Python 2的unicode和str还分不清楚的人会信誓旦旦的告诉你一定要学Python 3只有SB才学Python 2，你要问他Python 3好在哪里它又说不出来；一个根本没怎么写过Golang和Python的人就会出来告诉你应该选Golang, Python已经过时了，理由就是GIL，而Golang快。现在互联网这么发达非常好，什么都能搜到，虽然各类观点俯拾皆是，但是有时候却会让人迷失了方向。作为一个程序员，人生苦短，我建议你学会Python，但是如果你想靠它吃饭，尤其是希望1-2月速成的找到工作，请谨慎。<br>那么为什么现在还有这么多培训班，有软广是因为有市场。咋没见什么c++或者算法的培训班？因为他们教不了啊，Python多好教啊，拿着AI的幌子，反正这些初学者也无法分辨质量。<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3>说了这么多，就是在我自己的地盘吐个槽，但我坚信关注此专栏读者们在看到软广的时候都是淡淡一笑，如果你身边有人要跳进火坑，请把这篇文章甩给ta，你们棒棒哒🍭。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>豆瓣条目组招聘</title>
    <url>/2016-04-20.html</url>
    <content><![CDATA[<h4 id="我来做广告"><a href="#我来做广告" class="headerlink" title="我来做广告"></a>我来做广告</h4><p>豆瓣是国内python应用最广泛的公司. 没有其二. 我们条目组随着业务变更, 也需要更多地优秀工程师的加入.<br>条目是指什么? 豆瓣的电影/读书/音乐, 以及豆瓣东西都是我们在维护和迭代开发(对, 你没有听错, 你不是在一个产品线).<br>我先列一下作为一个厂公在技术层面, 我对豆瓣的感想(其他层面大家都懂):</p>
<ol>
<li>豆瓣有很多知名的工程师, 包括但是不限于前后端以及IOS/Android, 你会他们协作, 吐槽他们的代码以及被他们吐槽</li>
<li>豆瓣多年积累了很多对工作有帮助的工具. 比如CODE, dae, 还有很多的用于运维支持, 数据分析和统计, 爬虫等项目.</li>
<li>豆瓣有很多开源项目, 被其他公司使用, 比如dpark, OzJS. 你有机会参与到这样的项目中<h4 id="招聘内容"><a href="#招聘内容" class="headerlink" title="招聘内容"></a>招聘内容</h4>简单地需求都在这里: <a href="http://jobs.douban.com/#position-cpkf" target="_blank" rel="noopener">产品开发工程师</a><br>我来解读下(以下方面能帮你提高面试通过的几率):</li>
<li>豆瓣希望你是一个倾向于全栈工程师. 比如你会python, 还能写前端, 或者有移动开发经验. 你可以想到, 我们大多是同时支持多个<br>产品线, 任务重的时候如果你独当一面很好, 要是可以再别的领域帮个忙就更好了</li>
<li>假如你python初学,但是很熟悉其他语言, 我们相信你很快会上手, 不要害怕. 我组之前就有一个原来是ruby的实习生.</li>
<li>希望你能有个github/stackoverflow账号, 或者个人博客. 尤其是能看到你的作品, 了解你的代码, 希望看到你对代码的热爱. 我相信你有主动的态度会走的更远</li>
<li>如果你曾经是某个/些开源项目的贡献者甚至是多次贡献者, 或者你曾经做过分享, 也请记得一并告诉我们.<h4 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h4>想想还是先联系我吧. 我会给大家转发到组内. 或者直接<code>在线申请</code><br>我的邮箱是: ciici123#gmail.com. 请在标题中注明[豆瓣求职]</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python进行并发编程-我为什么不喜欢Gevent</title>
    <url>/2016-04-18.html</url>
    <content><![CDATA[<p>在Python的发展历史中，有过一些失败的修复CPython的缺陷和提高性能的尝试，比如消除GIL、Stackless（一个微线程扩展，避免传统线程所带来的性能与复杂度问题）、psyco<br>(被PyPy代替)、[Unladen Swallow](<a href="https://code.google.com/archive/p/unladen-" target="_blank" rel="noopener">https://code.google.com/archive/p/unladen-</a><br>swallow/)。当然也有成功的，比如PyPy。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>在开始表达我的观点之前，我们先来了解下Coroutine。<br>Coroutine 也就是 corporate routine，直译为「协同的例程」，中文一般叫做「协程」, 实际上这个概念和进程与线程有相似之处,<br>因为linux线程就是所谓的「轻量级进程」。<br>我在<a href="https://yuyang0.github.io/articles/gevent.html" target="_blank" rel="noopener">gevent源码分析</a>中找到一段表述的比较好的描述进程和协程异同的内容:</p>
<blockquote>
<ol>
<li>相同点:</li>
</ol>
<p>二者都是可以看做是一种执行流, 该执行流可以挂起,并且在将来又可以在 你挂起的地方恢复执行, 这实际上都可以看做是continuation,<br>我们来看看当我们挂 起一个执行流时我们要保存的东西：</p>
<pre><code>1. 栈, 因为如果你不保存栈,那么局部变量你就无法恢复,同时函数的调用链你也无 法恢复,
2. 寄存器的状态: 这好理解, 比如说EIP,如果你不保存,那么你恢复执行流就不知道 到底执行哪一条指令, 在比如说ESP,EBP,</code></pre><p>如果你不保存,那么你即便有完整的栈 你也不知道怎么用.<br>这二者实际就是所谓的上下文,也可以说是continuation. 在执行流切换时必须保存 这两个东西, 内核调度进程时也是一回事.</p>
<ol start="2">
<li><p>不同点:</p>
<ol>
<li>执行流的调度者不同, 进程是内核调度, 而协程是在用户态调度, 也就是说进程 的上下文是在内核态保存恢复的,而协程是在用户态保存恢复的.<br>很显然用户态的 代价更低</li>
<li>进程会被抢占,而协程不会,也就是说协程如果不主动让出CPU,那么其他的协程是不 可能得到执行机会,这实际和早期的操作系统类似,比如DOS,<br>它有一个yield原语, 一个进程调用yield,那么它就会让出CPU, 其他的进程也就有机会执行了, 如果一<br>个进程进入了死循环,那么整个系统也就挂起了,永远无法运行其他的进程了, 但 对协程而言,这不是问题</li>
<li>对内存的占用不同,实际上协程可以只需要4K的栈就够了, 而进程占用的内存要大 的多.</li>
<li>从操作系统的角度讲, 多协程的程序是单线程,单进程的</li>
</ol>
</li>
</ol>
</blockquote>
<p>那用一句话描述协程的优势就是 <strong>由开发者决定协程的切换，操作系统无法干预切换，且占用内存小的多</strong> 。<br>Gevent是一种基于协程的Python网络库，它用到Greenlet提供的，封装了libevent事件循环的高层同步API。它让开发者在不改变编程习惯的同时，用同步的方式写异步I/O的代码。<br>在12-13年的时候，我也用过gevent做过一些爬虫、网络编程的工作。在我使用场景中，使用Gevent的性能确实要比用传统的线程高，甚至高很多。<br>但是发现Gevent直到现在也仍然受到国人的喜欢（<a href="https://github.com/gevent/gevent/stargazers" target="_blank" rel="noopener">给Gevent点赞的程序员大概一半是国人</a>）。虽然我在《Python<br>Web开发实战》一书中也有专门的一节介绍Gevent，但是我却不建议大家在生产环境中用它（但是我不反对协程）。<br>现在每天在Github上都会出现有意思的新的项目，每个新的项目都号称解决了XXX问题，带来了YY的思路，令人激动和振奋…<br>但一般人都不知道它最后会不会大火，也不知道它最后会不会无疾而终。我也曾经在这些不断新的知识和项目的冲击下迷失，渐渐的总结了一些有用的判断标准：</p>
<ol>
<li>看项目社区的繁盛情况。</li>
<li>看Python社区和核心开发者对它的态度，比如在公开场合赞同/反对，给项目贡献代码等。</li>
<li>看业界有没有真的「大牛」站队，义务宣传它甚至在走否复杂和高负荷的生产环境使用。<br>如果你愿意花时间，你会知道Gvanrossum从来不喜欢Gevent，而是更愿意另辟蹊径的实现asyncio(基于生成器的协程)。我找几个链接：</li>
<li><a href="https://groups.google.com/forum/#!topic/python-tulip/swU-6lAaoEQ" target="_blank" rel="noopener">Why not coroutines?</a></li>
<li><a href="https://twitter.com/gvanrossum/status/443093650533142528" target="_blank" rel="noopener">The definitive answer (according to @glyph) on why not gevent. </a></li>
<li><a href="https://www.youtube.com/watch?v=1coLC-MUCJc" target="_blank" rel="noopener">Async I/O for Python 3</a><br>Gvanrossum提到了我大部分赞同，剩下的无感也是由于理解不够深入或者还「没踩过坑」。列举下我的观点：</li>
<li>Monkey-patching。中文「猴子补丁」，常用于对测试环境做一些hack。我个人不太喜欢这种「黑魔法」，因为如果其他人不了解细节，极为容易产生困惑。Gvanrossum说用它就是”patch-and-pray”，太形象了。由于Gevent直接修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。但是我们无法保证你在复杂的生产环境中有哪些地方使用这些标准库会由于打了补丁而出现奇怪的问题，那么你只能祈祷（pray）了。其次，在Python之禅中明确说过：「Explicit is better than implicit.」，猴子补丁明显的背离了这个原则。最后，Gvanrossum说Stackless之父Christian Tismer也赞同他。 我喜欢显式的「yield from」</li>
<li>第三方库支持。得确保项目中用到其他用到的网络库也必须使用纯Python或者明确说明支持Gevent，而且就算有这样的第三方库，我还会担心这个第三方库的代码质量和功能性。</li>
<li>Greenlet不支持Jython和IronPython，这样就无法把gevent设计成一个标准库了。<br>之前是没有选择，很多人选择了Gevent，而现在明确的有了更正统的、正确的选择：asyncio（下一篇会详细介绍）。所以建议大家放弃Gevent，拥抱asyncio。<br>BTW，《Python之禅》还有一句「practicality beats<br>purity」，如果我上面说的这些问题你都有能力解决，或者知道现在以及未来不会给你造成困扰，那么用Gevent也是可以的。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一个flask+mongoengine的site</title>
    <url>/2016-04-23.html</url>
    <content><![CDATA[<p>####前言<br>最近一直学习emacs和elisp, 也在做关于mongodb相关的研究,闲来无事就做了个网站,后端使用了flask, mongoengine,<br>前端css框架用的是<br>雅虎的<a href="https://github.com/yui/pure" target="_blank" rel="noopener">pure</a>,<br>还是用了神奇的<a href="https://github.com/gruntjs/grunt" target="_blank" rel="noopener">grunt</a>做页面修改的livereload, 然后有d3,<br>jquery,<br>amchart和一个最近发现的页面消息弹出<a href="https://github.com/CodeSeven/toastr" target="_blank" rel="noopener">toastr</a>.想学习flask和mongoengine的童鞋可直接拿去,开源地址是<br><a href="https://github.com/dongweiming/data-analysis" target="_blank" rel="noopener">data-analysis</a><br>####下载依赖和启动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd /path/to/data-analysis  </span><br><span class="line">pip install -r requirements.txt  </span><br><span class="line"><span class="comment"># 安装grunt  </span></span><br><span class="line">npm install  </span><br><span class="line"><span class="comment"># 我的后端样例数据  </span></span><br><span class="line">mongorestore -d fetch_data --directoryperdb dump/fetch_data  </span><br><span class="line">cd data_analysis  </span><br><span class="line"><span class="comment"># 启动Grunt  </span></span><br><span class="line">grunt  </span><br><span class="line"><span class="comment"># 启动  </span></span><br><span class="line">python run.py  </span><br><span class="line"><span class="comment"># 然后打开 http://Youip:5000</span></span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之模型设计和爬虫实现</title>
    <url>/2016-04-19.html</url>
    <content><![CDATA[<p>晒一下知乎Live团队送的新年礼物：<br><img src="https://cloud.githubusercontent.com/assets/841395/22178811/1824affa-e07d-11e6-8a59-ea00313d5c2b.jpg" alt><br>感谢。所以我将送上一系列知乎Live主题的文章<br>在我的<a href="https://www.zhihu.com/lives/789840559912009728" target="_blank" rel="noopener">知乎Live</a>里面，我留下了调查问卷，其中一项是可以反馈自己感兴趣的Python相关技术。意料之内，最受大家欢迎的就是爬虫。所以最近开始写了一些和爬虫有关的内容。不过虽然现在还是1月，但是我发誓这是本年最后一次写爬虫文章了（要写吐了）。</p>
<h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>做知乎Live的全文搜索，首先要抓取到全部Live信息。我尝试了下，只要是登录状态就可以使用知乎提供的API获取。<br>接口分为2种：</p>
<ol>
<li><a href="https://api.zhihu.com/lives/ongoing?purchasable=0&limit=10&offset=10" target="_blank" rel="noopener">https://api.zhihu.com/lives/ongoing?purchasable=0&amp;limit=10&amp;offset=10</a> (未结束)</li>
<li><a href="https://api.zhihu.com/lives/ended?purchasable=0&limit=10&offset=10" target="_blank" rel="noopener">https://api.zhihu.com/lives/ended?purchasable=0&amp;limit=10&amp;offset=10</a> (已结束)<br>每个Live包含非常多的字段，还包含了一些预留字段。我们简单分析下并实现对应的模型。<h4 id="主讲人模型"><a href="#主讲人模型" class="headerlink" title="主讲人模型"></a>主讲人模型</h4>主讲人字段如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">speaker: &#123;  </span><br><span class="line">    member: &#123;  </span><br><span class="line">        name: <span class="string">"Flood Sung"</span>,  </span><br><span class="line">        url: <span class="string">"https://api.zhihu.com/people/23deec836a24f295500a6d740011359c"</span>,  </span><br><span class="line">        type: <span class="string">"people"</span>,  </span><br><span class="line">        user_type: <span class="string">"people"</span>,  </span><br><span class="line">        headline: <span class="string">"Deep Learning/Reinforcement Learning/Robotics/"</span>,  </span><br><span class="line">        avatar_url: <span class="string">"https://pic3.zhimg.com/73a71f47d66e280735a6c786131bdfe2_s.jpg"</span>,  </span><br><span class="line">        gender: <span class="number">1</span>,  </span><br><span class="line">        url_token: <span class="string">"flood-sung"</span>,  </span><br><span class="line">        id: <span class="string">"23deec836a24f295500a6d740011359c"</span>  </span><br><span class="line">    &#125;,  </span><br><span class="line">    bio: <span class="string">"Deep Learning/Reinforcement Learning/Robotics/"</span>,  </span><br><span class="line">    description: <span class="string">"我是 Flood Sung ..."</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>主讲人部分我单独存储，不直接放进elasticsearch的原因有2个：</p>
<ol>
<li>全文搜索和主讲人有关的字段只有主讲人的名字和描述，其他内容没有意义</li>
<li>主讲人可能会有多个Live，重复存储浪费空间<br>所以我还是按着惯例，存在主流数据库中，由于目前Live总体才2k多，数据量太小，且更新机会不多（爬虫抓取是离线的）直接放进了SQLite就好了。<br>为了未来在数据量变大需要改变存储的数据库时可以灵活切换，我使用提供对象关系映射（ORM）的SQLAlchemy来写模型（models/speaker.py）：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, Integer, create_engine, SmallInteger  </span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker  </span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base  </span><br><span class="line">  </span><br><span class="line">DB_URI = <span class="string">'sqlite:///user.db'</span>  </span><br><span class="line">Base = declarative_base()  </span><br><span class="line">engine = create_engine(DB_URI)  </span><br><span class="line">Base.metadata.bind = engine  </span><br><span class="line">Session = sessionmaker(bind=engine)  </span><br><span class="line">session = Session()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span>  </span><br><span class="line">    __tablename__ = <span class="string">'live_user'</span>  </span><br><span class="line">  </span><br><span class="line">    id = Column(Integer, unique=<span class="literal">True</span>, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)  </span><br><span class="line">    speaker_id = Column(String(<span class="number">40</span>), index=<span class="literal">True</span>, unique=<span class="literal">True</span>)  </span><br><span class="line">    name = Column(String(<span class="number">40</span>), index=<span class="literal">True</span>, nullable=<span class="literal">False</span>)  </span><br><span class="line">    gender = Column(SmallInteger, default=<span class="number">2</span>)  </span><br><span class="line">    headline = Column(String(<span class="number">200</span>))  </span><br><span class="line">    avatar_url = Column(String(<span class="number">100</span>), nullable=<span class="literal">False</span>)  </span><br><span class="line">    bio = Column(String(<span class="number">200</span>))  </span><br><span class="line">    description = Column(String())  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(cls, **kwargs)</span>:</span>  </span><br><span class="line">        speaker_id = kwargs.get(<span class="string">'speaker_id'</span>, <span class="literal">None</span>)  </span><br><span class="line">        <span class="keyword">if</span> id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            r = session.query(cls).filter_by(speaker_id=speaker_id).first()  </span><br><span class="line">            <span class="keyword">if</span> r:  </span><br><span class="line">                <span class="keyword">return</span> r  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            r = cls(**kwargs)  </span><br><span class="line">            session.add(r)  </span><br><span class="line">            session.commit()  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            session.rollback()  </span><br><span class="line">            <span class="keyword">raise</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> r  </span><br><span class="line">  </span><br><span class="line">Base.metadata.create_all()</span><br></pre></td></tr></table></figure>


<p>speaker_id就是上面API中的speaker[‘member’][‘id’]，但是由于它是一个字符串，和常见的主键使用整数不一样（虽然也可以），所以多加一个字段存储。另外额外的写了一个add方法，相当于创建之前通过speaker_id先检查下库中是否存在对应条目。</p>
<h4 id="Live模型"><a href="#Live模型" class="headerlink" title="Live模型"></a>Live模型</h4><p>Live字段比较多，为了未来字段格式改变造成文本不可用，得列一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="string">"liked"</span>: false,  </span><br><span class="line">    <span class="string">"conv_id"</span>: <span class="string">"58747b778d6d81006c40cee7"</span>,  </span><br><span class="line">    <span class="string">"topics"</span>: [  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"https://api.zhihu.com/topics/20038840"</span>,  </span><br><span class="line">            <span class="string">"avatar_url"</span>: <span class="string">"https://pic3.zhimg.com/50/d9e63efc57a9f07378ae9d5416ecf85a_s.png"</span>,  </span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"topic"</span>,  </span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"20038840"</span>,  </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"阿尔法围棋（AlphaGo）"</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    ],  </span><br><span class="line">    <span class="string">"seats"</span>: &#123;  </span><br><span class="line">        <span class="string">"taken"</span>: <span class="number">286</span>,  </span><br><span class="line">        <span class="string">"max"</span>: <span class="number">500</span>  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="string">"duration"</span>: <span class="number">5400</span>,  </span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"802155571712253952"</span>,  </span><br><span class="line">    <span class="string">"subject"</span>: <span class="string">"从 AlphaGo 看人工智能前沿技术"</span>,  </span><br><span class="line">    <span class="string">"feedback_score"</span>: <span class="number">4.5</span>,  </span><br><span class="line">    <span class="string">"fee"</span>: &#123;  </span><br><span class="line">        <span class="string">"amount"</span>: <span class="number">1900</span>,  </span><br><span class="line">        <span class="string">"unit"</span>: <span class="string">"RMB"</span>  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="string">"purchasable"</span>: true,  </span><br><span class="line">    <span class="string">"has_feedback"</span>: false,  </span><br><span class="line">    <span class="string">"note"</span>: <span class="string">"版权声明：..."</span>,  </span><br><span class="line">    <span class="string">"source"</span>: <span class="string">"admin"</span>,  </span><br><span class="line">    <span class="string">"cospeakers"</span>: [ ],  </span><br><span class="line">    <span class="string">"speaker"</span>: &#123; &#125;,  </span><br><span class="line">    <span class="string">"income"</span>: null,  </span><br><span class="line">    <span class="string">"role"</span>: <span class="string">"visitor"</span>,  </span><br><span class="line">    <span class="string">"in_promotion"</span>: false,  </span><br><span class="line">    <span class="string">"badge"</span>: &#123;  </span><br><span class="line">        <span class="string">"avatar_url"</span>: <span class="string">"https://pic1.zhimg.com/8e3b9024d62aa293d8ba7235701a9a08_r.png"</span>,  </span><br><span class="line">        <span class="string">"id"</span>: <span class="number">0</span>,  </span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"普通票"</span>  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="string">"status"</span>: <span class="string">"ended"</span>,  </span><br><span class="line">    <span class="string">"ends_in"</span>: <span class="number">0</span>,  </span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"我是 Flood Sung ..."</span>,  </span><br><span class="line">    <span class="string">"speaker_message_count"</span>: <span class="number">127</span>,  </span><br><span class="line">    <span class="string">"tags"</span>: [  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="string">"score"</span>: <span class="number">0</span>,  </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"互联网"</span>,  </span><br><span class="line">            <span class="string">"short_name"</span>: <span class="string">"互联网"</span>,  </span><br><span class="line">            <span class="string">"available_num"</span>: <span class="number">191</span>,  </span><br><span class="line">            <span class="string">"created_at"</span>: <span class="number">1469691129</span>,  </span><br><span class="line">            <span class="string">"id"</span>: <span class="number">105</span>,  </span><br><span class="line">            <span class="string">"live_num"</span>: <span class="number">195</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    ],  </span><br><span class="line">    <span class="string">"is_muted"</span>: false,  </span><br><span class="line">    <span class="string">"liked_num"</span>: <span class="number">547</span>,  </span><br><span class="line">    <span class="string">"alert"</span>: <span class="string">"从看到听..."</span>,  </span><br><span class="line">    <span class="string">"can_speak"</span>: false,  </span><br><span class="line">    <span class="string">"artwork"</span>: <span class="string">""</span>,  </span><br><span class="line">    <span class="string">"is_public"</span>: <span class="number">1</span>,  </span><br><span class="line">    <span class="string">"ends_at"</span>: <span class="number">1484920522</span>,  </span><br><span class="line">    <span class="string">"outline"</span>: <span class="string">"＊ AlphaGo 为什么能在围棋上取得如此重大的突破？..."</span>,  </span><br><span class="line">    <span class="string">"is_anonymous"</span>: false,  </span><br><span class="line">    <span class="string">"created_at"</span>: <span class="number">1484028791</span>,  </span><br><span class="line">    <span class="string">"related_members"</span>: [ ],  </span><br><span class="line">    <span class="string">"product_list"</span>: [ ],  </span><br><span class="line">    <span class="string">"starts_at"</span>: <span class="number">1484913600</span>,  </span><br><span class="line">    <span class="string">"is_admin"</span>: false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这些字段通过名字能比较清晰的了解用途。接着我们考虑用什么elasticsearch的Python客户端。官方提供了<a href="https://github.com/elastic/elasticsearch-py" target="_blank" rel="noopener">elasticsearch-<br>py</a> 这个低级别客户端。<br>最开始我使用了elasticsearch-<br>py，所谓低级别，就是各种操作未做或者少做封装，比如搜索用到的参数就要手动拼成一个字典。相信如果你之前了解或者用过elasticsearch，就会知道它的搜索参数多的令人发指。如果业务需求比较简单，elasticsearch-<br>py还是可满足的。随着需求变多变复杂，你会发现拼这样一个多键值、多层嵌套字典的逻辑变得越来越不可维护，且写错了不容易发现，如果你对业务和elasticsearch不熟悉，非常容易掉坑儿。<br>那有没有什么更好写搜索和模型的方式嘛？<br>官方提供了基于elasticsearch-py的高级别客户端<a href="https://github.com/elastic/elasticsearch-dsl-py" target="_blank" rel="noopener">elasticsearch-dsl-<br>py</a>。DSL是领域专用语言（Domain<br>Specific Language）的简称，也就是专门针对某一特定问题的计算机语言，特点是「求专不求全」。elasticsearch-dsl-<br>py就是针对elasticsearch的特定语言。<br>它允许我们用一种非常可维护的方法来组织字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> elasticsearch_dsl.query <span class="keyword">import</span> Q  </span><br><span class="line">  </span><br><span class="line">In : Q(<span class="string">'multi_match'</span>, subject=<span class="string">'python'</span>).to_dict()  </span><br><span class="line">Out: &#123;<span class="string">'multi_match'</span>: &#123;<span class="string">'subject'</span>: <span class="string">'python'</span>&#125;&#125;</span><br></pre></td></tr></table></figure>


<p>允许用一种函数式的方法来做查询：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch  </span><br><span class="line">In : <span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> Search, Q  </span><br><span class="line">  </span><br><span class="line">In : s = Search(using=client, index=<span class="string">'live'</span>)  </span><br><span class="line">In : s = s.query(<span class="string">'match'</span>, subject=<span class="string">'python'</span>).query(~Q(<span class="string">'match'</span>, description=<span class="string">'量化'</span>))  </span><br><span class="line">In : s.execute()  </span><br><span class="line">Out: &lt;Response: [&lt;Hit(live/live/<span class="number">789840559912009728</span>): &#123;<span class="string">'subject'</span>: <span class="string">'Python 工程师的入门和进阶'</span>, <span class="string">'feedback_score'</span>: <span class="number">4.5</span>, <span class="string">'stat...&#125;&gt;]&gt;</span></span><br></pre></td></tr></table></figure>


<p>上述例子表示从live这个索引（类似数据库中的Database）中找到subject字典包含python，但是description字段不包含量化的Live。<br>当然这个DSL也支持用类代表一个doc_type（类似数据库中的Table），实现ORM的效果。我们就用它来写Live模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> DocType, Date, Integer, Text, Float, Boolean  </span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.connections <span class="keyword">import</span> connections  </span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.query <span class="keyword">import</span> SF, Q  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> SEARCH_FIELDS  </span><br><span class="line"><span class="keyword">from</span> .speaker <span class="keyword">import</span> User, session  </span><br><span class="line">  </span><br><span class="line">connections.create_connection(hosts=[<span class="string">'localhost'</span>])  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Live</span><span class="params">(DocType)</span>:</span>  </span><br><span class="line">    id = Integer()  </span><br><span class="line">    speaker_id = Integer()  </span><br><span class="line">    feedback_score = Float() <span class="comment"># 评分  </span></span><br><span class="line">    topic_names = Text(analyzer=<span class="string">'ik_max_word'</span>)  <span class="comment"># 话题标签名字  </span></span><br><span class="line">    seats_taken = Integer()  <span class="comment"># 参与人数  </span></span><br><span class="line">    subject = Text(analyzer=<span class="string">'ik_max_word'</span>)  <span class="comment"># 标题  </span></span><br><span class="line">    amount = Float()  <span class="comment"># 价格(RMB)  </span></span><br><span class="line">    description = Text(analyzer=<span class="string">'ik_max_word'</span>)  </span><br><span class="line">    status = Boolean()  <span class="comment"># public(True)/ended(False)  </span></span><br><span class="line">    starts_at = Date()  </span><br><span class="line">    outline = Text(analyzer=<span class="string">'ik_max_word'</span>)  <span class="comment"># Live内容  </span></span><br><span class="line">    speaker_message_count = Integer()  </span><br><span class="line">    tag_names = Text(analyzer=<span class="string">'ik_max_word'</span>)  </span><br><span class="line">    liked_num = Integer()  </span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>  </span><br><span class="line">        index = <span class="string">'live'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(cls, **kwargs)</span>:</span>  </span><br><span class="line">        id = kwargs.pop(<span class="string">'id'</span>, <span class="literal">None</span>)  </span><br><span class="line">        <span class="keyword">if</span> id <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">        live = cls(meta=&#123;<span class="string">'id'</span>: id&#125;, **kwargs)  </span><br><span class="line">        live.save()  </span><br><span class="line">        <span class="keyword">return</span> live</span><br></pre></td></tr></table></figure>


<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>在之前我已经分享了一个功能比较齐备的<a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-asyncio%E7%AF%87-%E4%B8%89/" target="_blank" rel="noopener">基于aiphttp的爬虫实现</a>，还分享过如何<a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8API%E7%99%BB%E5%BD%95%E7%9F%A5%E4%B9%8E%E5%B9%B6%E8%8E%B7%E5%BE%97token/" target="_blank" rel="noopener">使用API登录知乎并获得token</a>。今天用之前的积累，实现这个爬虫。由于之前已经展示用完整代码，今天只介绍如何让它们「串」起来。<br>首先是初始化部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">... </span> </span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> User, Live, session  </span><br><span class="line"><span class="keyword">from</span> client <span class="keyword">import</span> ZhihuClient  </span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> flatten_live_dict  </span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> SPEAKER_KEYS, LIVE_KEYS  </span><br><span class="line">  </span><br><span class="line">LIVE_API_URL = <span class="string">'https://api.zhihu.com/lives/&#123;type&#125;?purchasable=0&amp;limit=10&amp;offset=&#123;offset&#125;'</span>  <span class="comment"># noqa  </span></span><br><span class="line">LIVE_TYPE = frozenset([<span class="string">'ongoing'</span>, <span class="string">'ended'</span>])  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_redirect=<span class="number">10</span>, max_tries=<span class="number">4</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 max_tasks=<span class="number">10</span>, *, loop=None)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> LIVE_TYPE:  </span><br><span class="line">            <span class="keyword">for</span> offset <span class="keyword">in</span> range(self.max_tasks):  </span><br><span class="line">                self.add_url(LIVE_API_URL.format(type=t, offset=offset * <span class="number">10</span>))  </span><br><span class="line">  </span><br><span class="line">        client = ZhihuClient()  </span><br><span class="line">        self.headers = &#123;&#125;  </span><br><span class="line">        client.auth(self)</span><br></pre></td></tr></table></figure>


<p>初始化的时候通过add_url添加2种API、共2倍max_tasks个url。由于aiohttp的auth参数不支持原来requests的ZhihuOAuth，所以添加一个值为空字典的self.headers方便生成包含知乎API请求需要的headers。<br>知乎API设计的不错，返回的结果中包含了上一页和下一页的地址和是否结束：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">paging: &#123;  </span><br><span class="line">    is_end: false,  </span><br><span class="line">    next: <span class="string">"https://api.zhihu.com/lives/ended?purchasable=0&amp;limit=10&amp;offset=20"</span>,  </span><br><span class="line">    previous: <span class="string">"https://api.zhihu.com/lives/ended?purchasable=0&amp;limit=10&amp;offset=0"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以parse_link的结果也就是只是一个url了。我把存储爬取下来的Live和主讲人信息的方法也放进了这个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_link</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">    rs = <span class="keyword">await</span> response.json()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> response.status == <span class="number">200</span>:  </span><br><span class="line">        <span class="keyword">for</span> live <span class="keyword">in</span> rs[<span class="string">'data'</span>]:  </span><br><span class="line">            speaker = live.pop(<span class="string">'speaker'</span>)  </span><br><span class="line">            speaker_id = speaker[<span class="string">'member'</span>][<span class="string">'id'</span>]  </span><br><span class="line">            user = User.add(speaker_id=speaker_id,  </span><br><span class="line">                            **flatten_live_dict(speaker, SPEAKER_KEYS))  </span><br><span class="line">            live_dict = flatten_live_dict(live, LIVE_KEYS)  </span><br><span class="line">            <span class="keyword">if</span> live_dict[<span class="string">'id'</span>] == LAST_INSERT_ID:  </span><br><span class="line">                self._stopped = <span class="literal">True</span>  </span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            live_dict[<span class="string">'speaker_id'</span>] = user.id  </span><br><span class="line">            live_dict[<span class="string">'topic_names'</span>] = <span class="string">' '</span>.join(  </span><br><span class="line">                [t[<span class="string">'name'</span>] <span class="keyword">for</span> t <span class="keyword">in</span> live_dict.pop(<span class="string">'topics'</span>)])  </span><br><span class="line">            live_dict[<span class="string">'seats_taken'</span>] = live_dict.pop(<span class="string">'seats'</span>)[<span class="string">'taken'</span>]  </span><br><span class="line">            live_dict[<span class="string">'amount'</span>] = live_dict.pop(<span class="string">'fee'</span>)[<span class="string">'amount'</span>] / <span class="number">100</span>  </span><br><span class="line">            live_dict[<span class="string">'status'</span>] = live_dict[<span class="string">'status'</span>] == <span class="string">'public'</span>  </span><br><span class="line">            live_dict[<span class="string">'tag_names'</span>] = <span class="string">' '</span>.join(  </span><br><span class="line">                set(sum([(t[<span class="string">'name'</span>], t[<span class="string">'short_name'</span>])  </span><br><span class="line">                     <span class="keyword">for</span> t <span class="keyword">in</span> live_dict.pop(<span class="string">'tags'</span>)], ())))  </span><br><span class="line">            live_dict[<span class="string">'starts_at'</span>] = datetime.fromtimestamp(  </span><br><span class="line">                live_dict[<span class="string">'starts_at'</span>])  </span><br><span class="line">            Live.add(**live_dict)  </span><br><span class="line">  </span><br><span class="line">        paging = rs[<span class="string">'paging'</span>]  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> paging[<span class="string">'is_end'</span>]:  </span><br><span class="line">            next_url = paging[<span class="string">'next'</span>]  </span><br><span class="line">            <span class="keyword">return</span> paging[<span class="string">'next'</span>]  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        print(<span class="string">'HTTP status_code is &#123;&#125;'</span>.format(response.status))</span><br></pre></td></tr></table></figure>


<p>其中flatten_live_dict是从嵌套的字典里面把需要的键值抽出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten_live_dict</span><span class="params">(d, keys=[])</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">()</span>:</span>  </span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():  </span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> keys:  </span><br><span class="line">                <span class="keyword">yield</span> key, value  </span><br><span class="line">            <span class="keyword">elif</span> isinstance(value, dict):  </span><br><span class="line">                <span class="keyword">for</span> subkey, subvalue <span class="keyword">in</span> flatten_live_dict(value, keys).items():  </span><br><span class="line">                    <span class="keyword">if</span> subkey != <span class="string">'id'</span> <span class="keyword">and</span> subkey <span class="keyword">in</span> keys:  </span><br><span class="line">                        <span class="keyword">yield</span> subkey, subvalue  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dict(items())</span><br></pre></td></tr></table></figure>


<p>这个函数对id做了特殊处理，是因为在flatten过程中，有多个id会被无情替换，所以额外处理了。<br>其中参数keys分2种：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">LIVE_KEYS = [<span class="string">'id'</span>, <span class="string">'feedback_score'</span>, <span class="string">'seats'</span>, <span class="string">'subject'</span>, <span class="string">'fee'</span>,  </span><br><span class="line">             <span class="string">'description'</span>, <span class="string">'status'</span>, <span class="string">'starts_at'</span>, <span class="string">'outline'</span>,  </span><br><span class="line">             <span class="string">'speaker_message_count'</span>, <span class="string">'liked_num'</span>, <span class="string">'tags'</span>, <span class="string">'topics'</span>]  </span><br><span class="line">SEARCH_FIELDS = [<span class="string">'subject'</span>, <span class="string">'description'</span>, <span class="string">'outline'</span>, <span class="string">'tag_names'</span>,  </span><br><span class="line">                 <span class="string">'topic_names'</span>]</span><br></pre></td></tr></table></figure>


<p>这样就完成了一个爬虫。我没有添加爬虫的断点续爬（发现之前爬过停止抓取）功能。这是因为Live一般在结束后都还是可以有人参与，去评价。反正总量也就是一分钟抓取完而已。如果想要添加这种减少重复抓取的功能，最简单的方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">search = Live.search()  </span><br><span class="line"><span class="keyword">if</span> search.count():  </span><br><span class="line">    LAST_INSERT_ID = search.sort(<span class="string">'starts_at'</span>).execute()[<span class="number">0</span>]._id  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    LAST_INSERT_ID = <span class="number">0</span>  </span><br><span class="line">      </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_redirect=<span class="number">10</span>, max_tries=<span class="number">4</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 max_tasks=<span class="number">10</span>, *, loop=None)</span>:</span>   </span><br><span class="line">        ...  </span><br><span class="line">        self._stopped = <span class="literal">False</span>  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_link</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">        rs = <span class="keyword">await</span> response.json()  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> response.status == <span class="number">200</span>:  </span><br><span class="line">            <span class="keyword">if</span> live_dict[<span class="string">'id'</span>] == LAST_INSERT_ID:  </span><br><span class="line">                self._stopped = <span class="literal">True</span>  </span><br><span class="line">                <span class="keyword">return</span>   </span><br><span class="line">            ...  </span><br><span class="line">     </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">add_url</span><span class="params">(self, url, max_redirect=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> max_redirect <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            max_redirect = self.max_redirect  </span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.seen_urls <span class="keyword">and</span> <span class="keyword">not</span> self._stopped:  </span><br><span class="line">            self.seen_urls.add(url)  </span><br><span class="line">            self.q.put_nowait((url, max_redirect))</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python进行并发编程-PoolExecutor篇</title>
    <url>/2016-04-21.html</url>
    <content><![CDATA[<blockquote>
<p>我在2016年12月12日发布了一篇 使用Python进行并发编程-<br>PoolExecutor篇。其中有个例子中concurrent.futures要比multiprocessing.pool版本的快了1.7倍。看起来还是挺振奋人心的，不过这个数据是完全错误的。<br>在我的博客的文章下，NoAnyLove留言对我表示怀疑，我一翻代码，果然：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">results = pool.map(fib, NUMBERS)  </span><br><span class="line"><span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, pool.map(fib, NUMBERS)):</span><br></pre></td></tr></table></figure>


<blockquote>
<p>map了2次…<br>我一心想推concurrent.futures，当时太主观武断了，以为是Future这种架构带来的这种性能上的质变，没有去深究。在此向各位读者道歉，<br>也感谢NoAnyLove指出这个错误。这个周末我重新写了这篇文章。请大家以此为准，忽略之前那篇。原文如下：<br>—— 分割线 —–<br>之前我们使用多线程(threading)和多进程(multiprocessing)完成常规的需求，在启动的时候start、jon等步骤不能省，复杂的需要还要用1-2个队列。随着需求越来越复杂，如果没有良好的设计和抽象这部分的功能层次，代码量越多调试的难度就越大。有没有什么好的方法把这些步骤抽象一下呢，让我们不关注这些细节，轻装上阵呢？<br>答案是： <strong>有的</strong> 。<br>从Python3.2开始一个叫做concurrent.futures被纳入了标准库，而在Python2它属于第三方的futures库，需要手动安装：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pip install futures</span><br></pre></td></tr></table></figure>


<p>这个模块中有2个类：ThreadPoolExecutor和ProcessPoolExecutor，也就是对threading和multiprocessing的进行了高级别的抽象，<br>暴露出统一的接口，帮助开发者非常方便的实现异步调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, as_completed  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">25</span>, <span class="number">38</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(fib, NUMBERS)):  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'fib(&#123;&#125;) = &#123;&#125;'</span>.format(num, result)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> <span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start)</span><br></pre></td></tr></table></figure>


<p>感受下是不是很轻便呢？看一下花费的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python fib_executor.py  </span><br><span class="line">fib(<span class="number">25</span>) = <span class="number">75025</span>  </span><br><span class="line">fib(<span class="number">26</span>) = <span class="number">121393</span>  </span><br><span class="line">fib(<span class="number">27</span>) = <span class="number">196418</span>  </span><br><span class="line">fib(<span class="number">28</span>) = <span class="number">317811</span>  </span><br><span class="line">fib(<span class="number">29</span>) = <span class="number">514229</span>  </span><br><span class="line">fib(<span class="number">30</span>) = <span class="number">832040</span>  </span><br><span class="line">fib(<span class="number">31</span>) = <span class="number">1346269</span>  </span><br><span class="line">fib(<span class="number">32</span>) = <span class="number">2178309</span>  </span><br><span class="line">fib(<span class="number">33</span>) = <span class="number">3524578</span>  </span><br><span class="line">fib(<span class="number">34</span>) = <span class="number">5702887</span>  </span><br><span class="line">fib(<span class="number">35</span>) = <span class="number">9227465</span>  </span><br><span class="line">fib(<span class="number">36</span>) = <span class="number">14930352</span>  </span><br><span class="line">fib(<span class="number">37</span>) = <span class="number">24157817</span>  </span><br><span class="line">COST: <span class="number">10.8920350075</span></span><br></pre></td></tr></table></figure>


<p>除了用map，另外一个常用的方法是submit。如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">30</span>, <span class="number">35</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">34</span>:  </span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Don't do this"</span>)  </span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    future_to_num = &#123;executor.submit(fib, num): num <span class="keyword">for</span> num <span class="keyword">in</span> NUMBERS&#125;  </span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(future_to_num):  </span><br><span class="line">        num = future_to_num[future]  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            result = future.result()  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'raise an exception: &#123;&#125;'</span>.format(e)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'fib(&#123;&#125;) = &#123;&#125;'</span>.format(num, result)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(fib, NUMBERS)):  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'fib(&#123;&#125;) = &#123;&#125;'</span>.format(num, result)</span><br></pre></td></tr></table></figure>


<p>执一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python fib_executor_with_raise.py  </span><br><span class="line">fib(<span class="number">30</span>) = <span class="number">832040</span>  </span><br><span class="line">fib(<span class="number">31</span>) = <span class="number">1346269</span>  </span><br><span class="line"><span class="keyword">raise</span> an exception: Don<span class="string">'t do this  </span></span><br><span class="line"><span class="string">fib(32) = 2178309  </span></span><br><span class="line"><span class="string">fib(33) = 3524578  </span></span><br><span class="line"><span class="string">Traceback (most recent call last):  </span></span><br><span class="line"><span class="string">  File "fib_executor_with_raise.py", line 28, in &lt;module&gt;  </span></span><br><span class="line"><span class="string">    for num, result in zip(NUMBERS, executor.map(fib, NUMBERS)):  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/_base.py", line 580, in map  </span></span><br><span class="line"><span class="string">     yield future.result()  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/_base.py", line 400, in result  </span></span><br><span class="line"><span class="string">    return self.__get_result()  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/_base.py", line 359, in __get_result  </span></span><br><span class="line"><span class="string">    reraise(self._exception, self._traceback)  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/_compat.py", line 107, in reraise  </span></span><br><span class="line"><span class="string">    exec('</span><span class="keyword">raise</span> exc_type, exc_value, traceback<span class="string">', &#123;&#125;, locals_)  </span></span><br><span class="line"><span class="string">  File "/Library/Python/2.7/site-packages/concurrent/futures/thread.py", line 61, in run  </span></span><br><span class="line"><span class="string">    result = self.fn(*self.args, **self.kwargs)  </span></span><br><span class="line"><span class="string">  File "fib_executor_with_raise.py", line 9, in fib  </span></span><br><span class="line"><span class="string">    raise Exception("Don'</span>t do this<span class="string">")  </span></span><br><span class="line"><span class="string">Exception: Don't do this</span></span><br></pre></td></tr></table></figure>


<p>可以看到，第一次捕捉到了异常，但是第二次执行的时候错误直接抛出来了。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们就拿ProcessPoolExecutor介绍下它的原理，引用官方代码注释中的流程图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">|======================= In-process =====================|== Out-of-process ==|  </span><br><span class="line">  </span><br><span class="line">+----------+     +----------+       +--------+     +-----------+    +---------+  </span><br><span class="line">|          |  =&gt; | Work Ids |    =&gt; |        |  =&gt; | Call Q    | =&gt; |         |  </span><br><span class="line">|          |     +----------+       |        |     +-----------+    |         |  </span><br><span class="line">|          |     | ...      |       |        |     | ...       |    |         |  </span><br><span class="line">|          |     | <span class="number">6</span>        |       |        |     | <span class="number">5</span>, call() |    |         |  </span><br><span class="line">|          |     | <span class="number">7</span>        |       |        |     | ...       |    |         |  </span><br><span class="line">| Process  |     | ...      |       | Local  |     +-----------+    | Process |  </span><br><span class="line">|  Pool    |     +----------+       | Worker |                      |  <span class="comment">#1..n  |  </span></span><br><span class="line">| Executor |                        | Thread |                      |         |  </span><br><span class="line">|          |     +----------- +     |        |     +-----------+    |         |  </span><br><span class="line">|          | &lt;=&gt; | Work Items | &lt;=&gt; |        | &lt;=  | Result Q  | &lt;= |         |  </span><br><span class="line">|          |     +------------+     |        |     +-----------+    |         |  </span><br><span class="line">|          |     | <span class="number">6</span>: call()  |     |        |     | ...       |    |         |  </span><br><span class="line">|          |     |    future  |     |        |     | <span class="number">4</span>, result |    |         |  </span><br><span class="line">|          |     | ...        |     |        |     | <span class="number">3</span>, <span class="keyword">except</span> |    |         |  </span><br><span class="line">+----------+     +------------+     +--------+     +-----------+    +---------+</span><br></pre></td></tr></table></figure>


<p>我们结合源码和上面的数据流分析一下：</p>
<ol>
<li>executor.map会创建多个_WorkItem对象，每个对象都传入了新创建的一个Future对象。</li>
<li>把每个_WorkItem对象然后放进一个叫做「Work Items」的dict中，键是不同的「Work Ids」。</li>
<li>创建一个管理「Work Ids」队列的线程「Local worker thread」，它能做2件事：<ol>
<li>从「Work Ids」队列中获取Work Id, 通过「Work Items」找到对应的_WorkItem。如果这个Item被取消了，就从「Work Items」里面把它删掉，否则重新打包成一个_CallItem放入「Call Q」这个队列。executor的那些进程会从队列中取_CallItem执行，并把结果封装成_ResultItems放入「Result Q」队列中。</li>
<li>从「Result Q」队列中获取_ResultItems，然后从「Work Items」更新对应的Future对象并删掉入口。<br>看起来就是一个「生产者/消费者」模型，不过要注意，整个过程并不是多个进程与任务+结果-2个队列直接通信的，而是通过一个中间的「Local worker<br>thread」。<br>设想，当某一段程序提交了一个请求，期望得到一个答复。但服务程序对这个请求可能很慢，在传统的单线程环境下，调用函数是同步的，也就是说它必须等到服务程序返回结果后，才能进行其他处理。而在Future模式下，调用方式改为异步，而原先等待返回的时间段，在主调用函数中，则可用于处理其他事物。<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3>Future是常见的一种并发设计模式，在多个其他语言中都可以见到这种解决方案。<br>一个Future对象代表了一些尚未就绪（完成）的结果，在「将来」的某个时间就绪了之后就可以获取到这个结果。比如上面的例子，我们期望并发的执行一些参数不同的fib函数，获取全部的结果。传统模式就是在等待queue.get返回结果，这个是同步模式，而在Future模式下，</li>
</ol>
<strong>调用方式改为异步，而原先等待返回的时间段，由于「Local worker thread」的存在，这个时候可以完成其他工作</strong><br>在tornado中也有对应的实现。2013年的时候，我曾经写过一篇博客[使用tornado让你的请求异步非阻塞](<a href="http://www.dongwm.com/archives/shi-" target="_blank" rel="noopener">http://www.dongwm.com/archives/shi-</a><br>yong-tornadorang-ni-de-qing-qiu-yi-bu-fei-zu-<br>sai/)，最后也提到了用concurrent.futures实现异步非阻塞的完成耗时任务。<h3 id="用multiprocessing中的Pool还是concurrent-futures中的PoolExecutor？"><a href="#用multiprocessing中的Pool还是concurrent-futures中的PoolExecutor？" class="headerlink" title="用multiprocessing中的Pool还是concurrent.futures中的PoolExecutor？"></a>用multiprocessing中的Pool还是concurrent.futures中的PoolExecutor？</h3>上面说到的map，有些同学马上会说，这不是进程（线程）池的效果吗？看起来确实是的：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">25</span>, <span class="number">38</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line">pool = Pool(<span class="number">3</span>)  </span><br><span class="line"><span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, pool.map(fib, NUMBERS)):  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'fib(&#123;&#125;) = &#123;&#125;'</span>.format(num, result)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> <span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start)</span><br></pre></td></tr></table></figure>


<p>好像代码量更小。好吧，看一下花费的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python fib_pool.py  </span><br><span class="line">fib(<span class="number">25</span>) = <span class="number">75025</span>  </span><br><span class="line">fib(<span class="number">26</span>) = <span class="number">121393</span>  </span><br><span class="line">fib(<span class="number">27</span>) = <span class="number">196418</span>  </span><br><span class="line">fib(<span class="number">28</span>) = <span class="number">317811</span>  </span><br><span class="line">fib(<span class="number">29</span>) = <span class="number">514229</span>  </span><br><span class="line">fib(<span class="number">30</span>) = <span class="number">832040</span>  </span><br><span class="line">fib(<span class="number">31</span>) = <span class="number">1346269</span>  </span><br><span class="line">fib(<span class="number">32</span>) = <span class="number">2178309</span>  </span><br><span class="line">fib(<span class="number">33</span>) = <span class="number">3524578</span>  </span><br><span class="line">fib(<span class="number">34</span>) = <span class="number">5702887</span>  </span><br><span class="line">fib(<span class="number">35</span>) = <span class="number">9227465</span>  </span><br><span class="line">fib(<span class="number">36</span>) = <span class="number">14930352</span>  </span><br><span class="line">fib(<span class="number">37</span>) = <span class="number">24157817</span>  </span><br><span class="line">COST: <span class="number">11.8551170826</span></span><br></pre></td></tr></table></figure>


<p>是的，使用multiprocessing.pool中的ThreadPool/Pool其实是更快一点的。<br>既然他们都是面向线程/进程提供相同的API，甚至在一些方法上的参数和使用方式上都是一样的，为什么要保存2份用起来差不多的方案呢（甚至可以说后期实现的concurrent.futures慢一点）？<br>我翻了下源码，试着分析下：</p>
<ol>
<li>concurrent.futures的架构明显要复杂一些，不过更利于写出高效、异步、非阻塞的并行代码，而ThreadPeool/Pool更像一个黑盒，你用就好了，细节不仅屏蔽定制性也差。</li>
<li>concurrent.futures的接口更简单一些。ThreadPool/Pool的API中有processes, initializer，initargs，maxtasksperchild，context等参数，新人看起来容易不解，而concurrent.futures的参数就一个max_workers。<br>其实concurrent.futures底层还是用着threading和multiprocessing，相当于在其上又封装了一层，并且重新设计了架构，所以会慢一点。<br>然后我开始查找各种证据，找到了一个[SO的链接](<a href="https://stackoverflow.com/questions/24896193/whats-" target="_blank" rel="noopener">https://stackoverflow.com/questions/24896193/whats-</a><br>the-difference-between-pythons-multiprocessing-and-concurrent-<br>futures)，其中引用了Python核心贡献者Jesse<br>Noller说的<a href="http://bugs.python.org/issue9205#msg132661" target="_blank" rel="noopener">一段话</a>：<blockquote>
<p>Brian and I need to work on the consolidation we intend(ed) to occur<br>as people got comfortable with the APIs. My eventual goal is to remove<br>anything but the basic multiprocessing.Process/Queue stuff out of MP<br>and into concurrent.* and support threading backends for it.<br>和我的理解差不多吧。<br>不过我尝试让待处理的任务量比较大（上面的NUMBERS才包含13个），结果发现multiprocessing版本的速度差距成倍的扩大（下面会有实验代码）：concurrent.futures不可思议的要慢很多！<br>这个时候我回忆了一下标准库的实现，没找到这2种架构性能差别能这么大的原因，正在疑惑中，以为自己使用的姿势不对。不过正好在上面的链接中作者还特别说明了如下一段：<br>multiprocessing.Pool.map outperforms ProcessPoolExecutor.map. Note that the<br>performance difference is very small per work item, so you’ll probably only<br>notice a large performance difference if you’re using map on a very large<br>iterable. The reason for the performance difference is that<br>multiprocessing.Pool will batch the iterable passed to map into chunks, and<br>then pass the chunks to the worker processes, which reduces the overhead of<br>IPC between the parent and children. ProcessPoolExecutor always passes one<br>item from the iterable at a time to the children, which can lead to much<br>slower performance with large iterables, due to the increased IPC overhead.<br>The good news is this issue will be fixed in Python 3.5, as as chunksize<br>keyword argument has been added to ProcessPoolExecutor.map, which can be used<br>to specify a larger chunk size if you know you’re dealing with large<br>iterables. See this bug(<a href="http://bugs.python.org/issue11271" target="_blank" rel="noopener">http://bugs.python.org/issue11271</a>) for more info.<br>简单说明一下。multiprocessing.Pool.map要优于ProcessPoolExecutor.map，不过性能的差别是很小，如我上面说的，是由于架构和接口实现上的取舍。但是如果要处理的是一个很大的可迭代对象，就会有非常大的性能差别。这是因为multiprocessing.Pool是批量提交任务的，可以节省IPC(进程间通信)开销。而ProcessPoolExecutor每次都只提交一个任务。不过在Python3.5的时候已经通过给map方法添加chunksize参数解决了。<br>你可能比较迷惑，我们看一段代码就好了：</p>
</blockquote>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool  </span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> as_completed, ProcessPoolExecutor  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">1</span>, <span class="number">100000</span>)  </span><br><span class="line">K = <span class="number">50</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span>  </span><br><span class="line">    r = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, K+<span class="number">2</span>):  </span><br><span class="line">        r += x ** (<span class="number">1</span> / k**<span class="number">1.5</span>)  </span><br><span class="line">    <span class="keyword">return</span> r  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'multiprocessing.pool.Pool:\n'</span>)  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line">l = []  </span><br><span class="line">pool = Pool(<span class="number">3</span>)  </span><br><span class="line"><span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, pool.map(f, NUMBERS)):  </span><br><span class="line">    l.append(result)  </span><br><span class="line">print(len(l))  </span><br><span class="line">print(<span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'ProcessPoolExecutor without chunksize:\n'</span>)  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line">l = []  </span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(f, NUMBERS)):  </span><br><span class="line">        l.append(result)  </span><br><span class="line">  </span><br><span class="line">print(len(l))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'ProcessPoolExecutor with chunksize:\n'</span>)  </span><br><span class="line">start = time.time()  </span><br><span class="line">  </span><br><span class="line">l = []  </span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">    <span class="comment"># 保持和multiprocessing.pool的默认chunksize一样  </span></span><br><span class="line">    chunksize, extra = divmod(len(NUMBERS), executor._max_workers * <span class="number">4</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> num, result <span class="keyword">in</span> zip(NUMBERS, executor.map(f, NUMBERS, chunksize=chunksize)):  </span><br><span class="line">        l.append(result)  </span><br><span class="line">  </span><br><span class="line">print(len(l))  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'COST: &#123;&#125;'</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>


<p>先运行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python map_comparison.py  </span><br><span class="line">multiprocessing.pool.Pool:  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">COST: <span class="number">0.7973268032073975</span>  </span><br><span class="line">ProcessPoolExecutor without chunksize:  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">COST: <span class="number">28.467172861099243</span>  </span><br><span class="line">ProcessPoolExecutor <span class="keyword">with</span> chunksize:  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">COST: <span class="number">0.8141732215881348</span></span><br></pre></td></tr></table></figure>


<p>其中第一段使用multiprocessing.pool，最快。<br>第二段使用没有加chunksize， 这个速度不忍直视。大家不要再这样犯错了。<br>第三段加上了chunksize，分块的原则和第一段标准库实现的一样，速度又回到同一个水平了。<br>迷惑这么久的原因其实是我一直在看Python 2的对应的代码，当我看了最新版的代码就懂了。<br>最后我的建议是：虽然会慢一点点，还是推荐使用接口更简单的concurrent.futures，不过<br><strong>大家使用的时候注意要用Python3.及以后的版本啦！</strong><br>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2017-06-12" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>分享一个准备给公司讲python高级编程的slide</title>
    <url>/2016-04-22.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我以前在学习python模块的时候,曾经翻译[pymotw](<a href="http://pymotw.com/2/py-" target="_blank" rel="noopener">http://pymotw.com/2/py-</a><br>modindex.html#)的文章,其实还是有抄袭的嫌疑,从最近开始逐渐直接阅读python标准库源码, 收获颇多.<br>我现在不愿意教一些从网上或者书里提到的知识点,而更愿意根据我工作中常见的需求去挖掘对应的python的解法.也是在过程中对一些东西有了比较深的理解.<br>这个ppt是从[像黑客一样使用 Linux 命令行](<a href="https://linuxtoy.org/archives/using-cli-like-a-" target="_blank" rel="noopener">https://linuxtoy.org/archives/using-cli-like-a-</a><br>hacker.html)获得的灵感. 然后角度为&lt;python高级编程&gt;, 还用到了webfonts娃娃体^.^<br><img src="https://dl.dropboxusercontent.com/u/95512723/images/expert_python.png" alt><br>PS: 特别推荐github上看到的”雨痕”的<a href="https://github.com/qyuhen/book" target="_blank" rel="noopener">学习笔记</a>. 建议大家都好好看看.</p>
<h4 id="找到它"><a href="#找到它" class="headerlink" title="找到它"></a>找到它</h4><p><a href="http://dongweiming.github.io/Expert-Python" target="_blank" rel="noopener">Expert-Python</a><br>或者直接下载代码: <a href="https://github.com/dongweiming/Expert-Python" target="_blank" rel="noopener">github</a><br>但是注意我的字体内嵌项目里面, 请注意流量,避免移动设备直接访问或者强制刷新</p>
<h5 id="UPDATE-2015-02-02"><a href="#UPDATE-2015-02-02" class="headerlink" title="UPDATE: 2015-02-02"></a>UPDATE: 2015-02-02</h5><p>我已经把视频放到youtube上了: <a href="https://www.youtube.com/watch?v=bf5qpFFxo9g" target="_blank" rel="noopener">https://www.youtube.com/watch?v=bf5qpFFxo9g</a> 大家可以选择在线看</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ol>
<li>XX不理解python竟然没有end….</li>
<li>设置全局变量</li>
<li>字符串格式化</li>
<li>操作列表</li>
<li>操作字典</li>
<li>字典视图</li>
<li>vars</li>
<li>from <strong>future</strong> import unicode_literals</li>
<li>from <strong>future</strong> import absolute_import</li>
<li>不是支持了绝对引入,而是拒绝隐式引入</li>
<li>我靠,我的需求呢? – 在很多开源项目是拒绝你第一次的隐式用法的,</li>
<li>一个关于编码的问题</li>
<li>原因是: encoding_example里面没有对文字自动转化为unicode,默认是ascii编码</li>
<li>super 当子类调用父类属性时一般的做法是这样</li>
<li>super的一种用法</li>
<li>假如不用super会这么惨</li>
<li>手写一个迭代器</li>
<li>标准迭代器</li>
<li>生成器</li>
<li>斐波那契数列</li>
<li>其实yield和协程关系很密切</li>
<li>来个回调(阻塞的)</li>
<li>来个回调(异步的)</li>
<li>看到这里, 就得说说contextmanager</li>
<li>包导入</li>
<li>包构建<strong>all</strong></li>
<li>包构建<strong>path</strong></li>
<li>静态方法和类方法的区别</li>
<li>静态方法和类方法的区别其实是在这里</li>
<li><strong>slots</strong></li>
<li>Packaging Tools的未来</li>
<li>wheel(即将替代Eggs的二进制包格式)的优点</li>
<li>装饰器</li>
<li>给函数的类装饰器</li>
<li>给类的函数装饰器</li>
<li>带参数的装饰器</li>
<li>@property</li>
<li>@property的另外使用方法</li>
<li>元类是什么</li>
<li>模拟生成一个类</li>
<li>元类: <strong>metaclass</strong>(实现前面的Hello类)</li>
<li>一个难懂的元类</li>
<li>描述符</li>
<li>模块: itertools</li>
<li>模块: collections(一)</li>
<li>模块: collections(二)</li>
<li>模块: collections(三)</li>
<li>模块: collections(四)</li>
<li>operator模块(一)</li>
<li>operator模块(二)</li>
<li>operator模块(三)</li>
<li>functools模块之partial</li>
<li>functools模块之wraps</li>
<li>functools模块之cmp_to_key</li>
<li>functools模块之total_ordering</li>
<li>开发陷阱(一) 可变默认参数</li>
<li>开发陷阱(二) 闭包变量绑定</li>
<li>开发陷阱(二) 闭包应该的用法</li>
<li>在合适的地方用合适的技巧</li>
<li>不是它不好,而是你没有用好</li>
<li>ipython的技巧(一)</li>
<li>ipython的技巧(二)</li>
<li>联系方式<h4 id="UPDATE-2014-04-11"><a href="#UPDATE-2014-04-11" class="headerlink" title="UPDATE 2014.04.11"></a>UPDATE 2014.04.11</h4>今天下午分享了这个ppt. 并且用quicktime录像.<br>想听的可以从<a href="http://pan.baidu.com/s/1bnnaJaZ" target="_blank" rel="noopener">百度网盘</a>下载或者在线看(793.6M). 时长2小时零一分.<br>中间有个列表去重. 有同学说去重后无法保证第一次出现重复数据位置的顺序.<br>刚才想起来试了一下:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>]  </span><br><span class="line">    &gt;&gt;&gt; list(set(l))  </span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  </span><br><span class="line">    &gt;&gt;&gt; &#123;&#125;.fromkeys(l).keys()  </span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  <span class="comment"># 注意这个和上面结果是一样的,也就是内部实现的去重原理相同  </span></span><br><span class="line">    &gt;&gt;&gt; l = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]  </span><br><span class="line">    &gt;&gt;&gt; list(set(l))  </span><br><span class="line">    [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>]  </span><br><span class="line">    &gt;&gt;&gt; &#123;&#125;.fromkeys(l).keys()  </span><br><span class="line">    [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>]  </span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict  </span><br><span class="line">    &gt;&gt;&gt; OrderedDict().fromkeys(l).keys()  <span class="comment"># 只能使用这样的方法实现保证顺序的实现  </span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>]                                 <span class="comment"># 感谢@杨博的提醒</span></span><br></pre></td></tr></table></figure>


<p>新的PYPI的DEMO: <a href="http://pypi-preview.a.ssl.fastly.net" target="_blank" rel="noopener">http://pypi-preview.a.ssl.fastly.net</a></p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>分享ipython-notebook</title>
    <url>/2016-04-25.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本来准备下一次的Bpug(北京python用户组)的活动上准备做这个分享. 搁置了. 有兴趣组织纯技术活动的公司或者组织可以联系我.<br>有兴趣的同学可以前往(我也会把录像地址放到网站的).<br>提前给大家做一些预告. 其实ppt早就放到slideshare上了,<br>地址是<a href="http://www.slideshare.net/dongweiming/ipython-notebook-43211257" target="_blank" rel="noopener">http://www.slideshare.net/dongweiming/ipython-notebook-43211257</a>.<br>也可以从[github下载](<a href="https://github.com/dongweiming/divingintoipynb/blob/master/ipython-" target="_blank" rel="noopener">https://github.com/dongweiming/divingintoipynb/blob/master/ipython-</a><br>notebook.pdf)<br>对应的代码在<a href="https://github.com/dongweiming/divingintoipynb" target="_blank" rel="noopener">divingintoipynb</a>.<br>Youtube在线看: <a href="https://www.youtube.com/watch?v=qMcKp8gFAYA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=qMcKp8gFAYA</a></p>
<h4 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h4><ol>
<li>豆瓣东西双11临时后台 - 想看效果么? 看下面</li>
<li>把ipython notebook转换成html或者其他格式以及它的原理</li>
<li>我写的一个缩小版的<a href="https://github.com/jupyter/nbviewer" target="_blank" rel="noopener">nbviewer</a>: <a href="https://github.com/dongweiming/Ipynb-viewer" target="_blank" rel="noopener">Ipynb-viewer</a>, 直接在ipython目录启动web服务</li>
<li>nbconvert原理</li>
<li>用ipynb写blog(pelican/nikola) 效果可见<a href="http://dongweiming.github.io/divingintoipynb_pelican" target="_blank" rel="noopener">divingintoipynb_pelican</a>和<a href="http://dongweiming.github.io/divingintoipynb_nikola/" target="_blank" rel="noopener">divingintoipynb_nikola</a><br>还会讲到pelican转换ipynb到html插件，使用fabric: new_post, edit，import_ipynb.<br>我也给nikola贡献了import ipynb功能.</li>
<li>ipython notebook用到得第三方库和组件</li>
<li>Rich display system</li>
<li>现有的扩展, 演示. 我自己写的一个扩展. 演示, 代码分析</li>
<li>定制ipython notebook的键位. 使用emacs键位. 设计一个新的功能 - 弹出一个dialog列出所有emacs快捷键说明(想起来了么? C-h b)</li>
<li>定制一个基于<a href="https://github.com/brianreavis/selectize.js" target="_blank" rel="noopener">selectize.js</a>的widget. 前后端代码分析.</li>
<li>ipython notebook 其他方面的一些用法， 整个过程中有ipython2也有ipython3<br>模拟后台效果:<br><img src="https://github.com/dongweiming/divingintoipynb/raw/master/double11/double11.png" alt><h3 id="UPDATE-2015-02-02"><a href="#UPDATE-2015-02-02" class="headerlink" title="UPDATE: 2015-02-02"></a>UPDATE: 2015-02-02</h3>上周五在组内分享了, 下面是视频下载地址: <a href="http://pan.baidu.com/s/1o6BjBXg" target="_blank" rel="noopener">http://pan.baidu.com/s/1o6BjBXg</a></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐pre-commit/pre-push:本地在commit或者push的时候做各种检查(pep8/pylint/pyflakes8)</title>
    <url>/2016-04-24.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用git的同学想必都有这样的工作场景-保证生产环境的ci不挂.<br>也就是检查python是否符合pep8/csslint/jslint/pylint/pyflake8等.<br>我在我的emacs配置中加入了这一项[py-<br>autopep8](<a href="https://github.com/dongweiming/emacs.d/blob/master/custom/py-" target="_blank" rel="noopener">https://github.com/dongweiming/emacs.d/blob/master/custom/py-</a><br>autopep8.el),<br>就是在保存缓存区的时候把当前缓存区的文本放到一个临时文件, 然后执行autopep8, 再检查pep8/flake8<br>但是不能对css/js/html做规范检查. 而且也不通用. 周末看到了Yelp的[pre-commit](<a href="https://github.com/pre-" target="_blank" rel="noopener">https://github.com/pre-</a><br>commit/pre-commit).<br>感觉是个很有意思的东西，虽然之前也写过类似的hook. 但是没有它灵活. 看完他的源码后, 我今天给大家介绍下这个东西</p>
<h4 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h4><p>玩过svn/git的同学应该都知道他们有各种的hook. 也就是准备/完成什么事件的时候做些额外的工作. 一般是shell脚本,<br>版本控制工具会判断脚本的退出码, 如果不是0, 就不会继续完成. pre-commit顾名思义就是在commit之前做的准备, 也就是每次执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git commit -m <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure>


<p>的时候去做一些检查. 启用的插件都放到这个版本库目录的根目录下, 名字叫做.pre-commit-config.yaml -&gt; 详细文档请看:<br><a href="http://pre-commit.com/" target="_blank" rel="noopener">http://pre-commit.com/</a><br>这里有我的一个配置例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-   repo: https://github.com/pre-commit/pre-commit-hooks  </span><br><span class="line">    sha: b03733bc86d9e8b2564a5798ade40d64baae3055  </span><br><span class="line">    hooks:  </span><br><span class="line">    -   id: trailing-whitespace  </span><br><span class="line">    -   id: end-of-file-fixer  </span><br><span class="line">    -   id: autopep8-wrapper  </span><br><span class="line">    args: [<span class="string">'-i'</span>, <span class="string">'--ignore=E265,E309,E501'</span>]  </span><br><span class="line">    -   id: check-docstring-first  </span><br><span class="line">    -   id: check-json  </span><br><span class="line">    -   id: check-yaml  </span><br><span class="line">    -   id: debug-statements  </span><br><span class="line">    -   id: name-tests-test  </span><br><span class="line">    -   id: requirements-txt-fixer  </span><br><span class="line">    -   id: flake8  </span><br><span class="line">-   repo: https://github.com/pre-commit/pre-commit  </span><br><span class="line">    sha: <span class="number">86</span>c99c6b870a261d2aff0b4cdb36995764edce1b  </span><br><span class="line">    hooks:  </span><br><span class="line">    -   id: validate_config  </span><br><span class="line">    -   id: validate_manifest  </span><br><span class="line">-   repo: https://github.com/asottile/reorder_python_imports  </span><br><span class="line">    sha: ea9fa14a757bb210d849de5af8f8ba2c9744027a  </span><br><span class="line">    hooks:  </span><br><span class="line">    -   id: reorder-python-imports</span><br></pre></td></tr></table></figure>


<h4 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install pre-commit  </span><br><span class="line">pre-commit install  </span><br><span class="line"><span class="comment"># PS: 第一次执行commit会比较慢，因为他会clone对应的源, 之后就会用这个缓存的源  </span></span><br><span class="line"><span class="comment"># 其他的可选源和用法直接参照[https://github.com/pre-commit](https://github.com/pre-commit)里面的项目或者[http://pre-commit.com/hooks.html](http://pre-commit.com/hooks.html)</span></span><br></pre></td></tr></table></figure>


<h4 id="看一个失败的例子-有颜色效果-不能展示出来"><a href="#看一个失败的例子-有颜色效果-不能展示出来" class="headerlink" title="看一个失败的例子(有颜色效果, 不能展示出来)"></a>看一个失败的例子(有颜色效果, 不能展示出来)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$git commit -m <span class="string">'test'</span>  </span><br><span class="line">  </span><br><span class="line">Trim Trailing Whitespace.................................................................................................................Passed  </span><br><span class="line">Fix End of Files.........................................................................................................................Passed  </span><br><span class="line">autopep8 wrapper.........................................................................................................................Passed  </span><br><span class="line">Check docstring <span class="keyword">is</span> first.................................................................................................................Passed  </span><br><span class="line">Check JSON..........................................................................................................(no files to check) Skipped  </span><br><span class="line">Check Yaml..........................................................................................................(no files to check) Skipped  </span><br><span class="line">Debug Statements (Python)................................................................................................................Passed  </span><br><span class="line">Tests should end <span class="keyword">in</span> _test.py........................................................................................(no files to check) Skipped  </span><br><span class="line">Fix requirements.txt................................................................................................(no files to check) Skipped  </span><br><span class="line">Flake8...................................................................................................................................Failed  </span><br><span class="line">hookid: flake8  </span><br><span class="line">  </span><br><span class="line">pre_commit/__init__.py:<span class="number">2</span>:<span class="number">1</span>: F401 <span class="string">'os'</span> imported but unused  </span><br><span class="line">pre_commit/__init__.py:<span class="number">3</span>:<span class="number">1</span>: F401 <span class="string">'sys'</span> imported but unused  </span><br><span class="line">  </span><br><span class="line">Validate Pre-Commit Config..........................................................................................(no files to check) Skipped  </span><br><span class="line">Validate Pre-Commit Manifest........................................................................................(no files to check) Skipped  </span><br><span class="line">Reorder python imports...................................................................................................................Passed  </span><br><span class="line"><span class="comment"># 因为我的flake8有问题 所以commit失败了</span></span><br></pre></td></tr></table></figure>


<h4 id="pre-commit的问题"><a href="#pre-commit的问题" class="headerlink" title="pre-commit的问题"></a>pre-commit的问题</h4><p>我觉得对每次commit做一次审查, 第一是需要时间, 第二是没有必要, 因为经常一个pr有多个commit,<br>我只保证整体结果是正确的就好了 - 也就是说应该是在push的时候. 整个过程我可能对commit做多次rebase/–amend等等.<br>某一次的检查失败其实完全不<br>影响我做后的结果 - 我是手快党<br>so. 我基于它修改了一个版本<a href="https://github.com/dongweiming/pre-push/" target="_blank" rel="noopener">pre-push</a>,<br>只是我对push做了拦截. 并且我会经常和它保持同步</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pre-commit install -t pre-commit <span class="comment"># 默认安装pre-commit钩子, 每次commit触发  </span></span><br><span class="line">pre-commit install -t pre-push <span class="comment"># 默认安装pre-push钩子, 每次push触发</span></span><br></pre></td></tr></table></figure>


<p>其他用法完全一样.<br>假如push的时候想要不检查而强制push, 可以加上<code>--no-verify</code>参数</p>
<h4 id="Update-from-2015-01-15"><a href="#Update-from-2015-01-15" class="headerlink" title="Update from 2015-01-15"></a>Update from 2015-01-15</h4><p>我的这个分支已经合并到<a href="https://github.com/pre-commit/pre-commit" target="_blank" rel="noopener">pre-commit</a>.<br><a href="https://github.com/pre-commit/pre-commit/pull/189" target="_blank" rel="noopener">pull189</a><br>大家可以不要用我的分支了. PS: 这是我见到测试覆盖最高的项目.</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>线程锁的一个大坑</title>
    <url>/2016-04-28.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>原来的一位同事@炮哥, 昨天在QQ问我:<br>“想请教下一个线程获得lock之后，也可能被其他的线程释放掉？这个是因为线程之间的资源是共享的吗？这样的话普通的thread lock 都是不安全的了？”.<br>我第一反应就是怎么可能:’谁加锁谁解锁呗,别的线程怎么能解锁？’<br>炮哥发来一段python官网的文档说明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A factory function that returns a new primitive lock object. Once a thread has acquired it, subsequent attempts to acquire it block, until it <span class="keyword">is</span> released; any thread may release it.</span><br></pre></td></tr></table></figure>


<p>最有最后一句前是分号. 简单地说,一个线程获取锁, 以后的尝试获取都会被阻塞,除非它会释放. 但是 <strong>同时</strong> 其他其他线程可以释放<br>好,写个例子验证下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line">lock = threading.Lock()  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lock_holder</span><span class="params">(lock)</span>:</span>  </span><br><span class="line">    print(<span class="string">'Starting'</span>)  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        lock.acquire()  </span><br><span class="line">        print(<span class="string">'Holding'</span>)  </span><br><span class="line">        time.sleep(<span class="number">100</span>)  </span><br><span class="line">        print(<span class="string">'Sleep done'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lock_release</span><span class="params">(lock)</span>:</span>  </span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># 保证顺序  </span></span><br><span class="line">    lock.release()  </span><br><span class="line">    print(<span class="string">'Release it'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">holder = threading.Thread(target=lock_holder, args=(lock,), name=<span class="string">'LockHolder'</span>)  </span><br><span class="line">holder.setDaemon(<span class="literal">True</span>)  </span><br><span class="line">holder.start()  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#lock_release(lock)  </span></span><br><span class="line">release = threading.Thread(target=lock_release, args=(lock,), name=<span class="string">'release'</span>)  </span><br><span class="line">release.start()  </span><br><span class="line">  </span><br><span class="line">holder = threading.Thread(target=lock_holder, args=(lock,), name=<span class="string">'LockHolder'</span>)  </span><br><span class="line">holder.setDaemon(<span class="literal">True</span>)  </span><br><span class="line">holder.start()</span><br></pre></td></tr></table></figure>


<p>奇迹发生了…. 线程b果然可以释放线程a的锁,颠覆人生观啊.<br>PS: 但是Rlock不会被其他线程释放,因为它记录该线程的所有者</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python进行并发编程-asyncio篇(三)</title>
    <url>/2016-04-26.html</url>
    <content><![CDATA[<p>这是「使用Python进行并发编程」系列的最后一篇。我特意地把它安排在了16年最后一天，先祝各位元旦快乐。</p>
<h3 id="重新实验上篇的效率对比的实现"><a href="#重新实验上篇的效率对比的实现" class="headerlink" title="重新实验上篇的效率对比的实现"></a>重新实验上篇的效率对比的实现</h3><p>在第一篇我们曾经对比并发执行的效率，但是请求的是httpbin.org这个网站。很容易受到网络状态和其服务质量的影响。所以我考虑启用一个本地的eb服务。那接下来选方案吧。<br>我用sanic提供的<a href="https://github.com/channelcat/sanic/tree/master/tests/performance" target="_blank" rel="noopener">不同方案的例子</a>，对tornado、aiohttp+ujson+uvloop、sanic+uvloop三种方案，在最新的Python<br>3.6下，使用<a href="https://github.com/wg/wrk" target="_blank" rel="noopener">wrk</a>进行了性能测试。<br>先解释下上面提到的几个关键词：</p>
<ol>
<li>aiohttp。一个实现了PEP3156的HTTP的服务器，且包含客户端相关功能。最早出现，应该最知名。</li>
<li>sanic。后起之秀，基于Flask语法的异步Web框架。</li>
<li>uvloop。用Cython编写的、用来替代asyncio事件循环。作者说「它在速度上至少比Node.js、gevent以及其它任何Python异步框架快2倍」。</li>
<li>ujson。比标准库json及其社区版的simplejson都要快的JSON编解码库。<br>使用的测试命令是：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wrk -d20s -t10 -c200 http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure>


<p>表示使用10个线程、并发200、持续20秒。<br>在我个人Mac上获得的结果是：<br>方案 | tornado | aiohttp + ujson + uvloop | sanic + uvloop  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">平均延时 | 122.58ms | 35.49ms | 11.03ms  </span><br><span class="line">请求数/秒 | 162.94 | 566.87 | 2.02k  </span><br><span class="line">  </span><br><span class="line">所以简单的返回json数据，看起来sanic + uvloop是最快的。首先我对市面的各种Benchmark的对比是非常反感的，不能用hello</span><br><span class="line">world这种级别的例子的结果就片面的认为某种方案效率是最好的， **一定**</span><br><span class="line">要根据你实际的生产环境，再不行影响线上服务的前提下，对一部分有代表性的接口进程流量镜像之类的方式去进行效率的对比。而我认可上述的结果是因为正好满足我接下来测试用到的功能而已。</span><br><span class="line">写一个能GET某参数返回这个参数的sanic+uvloop的版本的例子：</span><br><span class="line"></span><br><span class="line">``` python    </span><br><span class="line">    </span><br><span class="line">    from sanic import Sanic  </span><br><span class="line">    from sanic.response import json  </span><br><span class="line">      </span><br><span class="line">    app = Sanic(__name__)  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    @app.route(&apos;/get&apos;)  </span><br><span class="line">    async def test(request):  </span><br><span class="line">        a = request.args.get(&apos;a&apos;)  </span><br><span class="line">        return json(&#123;&apos;args&apos;: &#123;&apos;a&apos;: a&#125;&#125;)  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    if __name__ == &apos;__main__&apos;:  </span><br><span class="line">        app.run(host=&apos;127.0.0.1&apos;, port=8000)</span><br></pre></td></tr></table></figure></p>
<p>然后把之前的效率对比的代码改造一下，需要变化如下几步：</p>
<ol>
<li>替换请求地址，也就是把httpbin.org改成了localhost:8000</li>
<li>增加要爬取的页面数量，由于sanic太快了（无奈脸），12个页面秒完，所以改成<code>NUMBERS = range(240)</code></li>
<li>由于页面数量大幅增加，不能在终端都打印出来。而且之前已经验证过正确性。去掉那些print<br>看下效果：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 scraper_thread.py  </span><br><span class="line">Use requests+ThreadPoolExecutor cost: <span class="number">0.9809930324554443</span>  </span><br><span class="line">Use asyncio+requests+ThreadPoolExecutor cost: <span class="number">0.9977471828460693</span>  </span><br><span class="line">Use asyncio+aiohttp cost: <span class="number">0.25928187370300293</span>  </span><br><span class="line">Use asyncio+aiohttp+ThreadPoolExecutor cost: <span class="number">0.278397798538208</span></span><br></pre></td></tr></table></figure>


<p>可以感受到asyncio+aiohttp依然是最快的。随便挺一下Sanic，准备有机会在实际工作中用一下。</p>
<h3 id="asyncio在背后怎么运行的呢？"><a href="#asyncio在背后怎么运行的呢？" class="headerlink" title="asyncio在背后怎么运行的呢？"></a>asyncio在背后怎么运行的呢？</h3><p>在<a href="http://ntoll.org/article/asyncio" target="_blank" rel="noopener">Asynchronous<br>Python</a>这篇文章里面我找到一个表达的不错的asyncio运行的序列图。例子我改编如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x, y)</span>:</span>  </span><br><span class="line">    print(<span class="string">'Compute &#123;&#125; + &#123;&#125; ...'</span>.format(x, y))  </span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)  </span><br><span class="line">    <span class="keyword">return</span> x + y  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x, y)</span>:</span>  </span><br><span class="line">    result = <span class="keyword">await</span> compute(x, y)  </span><br><span class="line">    print(<span class="string">'&#123;&#125; + &#123;&#125; = &#123;&#125;'</span>.format(x, y, result))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>


<p>运行的过程是这样的：<br><img src="https://cloud.githubusercontent.com/assets/841395/21561813/d8eb52b2-ceac-11e6-8594-7e57765172d8.png" alt></p>
<h3 id="如何把同步的代码改成异步的"><a href="#如何把同步的代码改成异步的" class="headerlink" title="如何把同步的代码改成异步的"></a>如何把同步的代码改成异步的</h3><p>之前有位订阅我的公众号的同学问过这个问题，我想了一个例子来让事情变的清楚。<br>首先看一个同步的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(id)</span>:</span>  </span><br><span class="line">    subject = get_subject_from_db(id)  </span><br><span class="line">    buyinfo = get_buyinfo(id)  </span><br><span class="line">    change = process(subject, buyinfo)  </span><br><span class="line">    notify_change(change)  </span><br><span class="line">    flush_cache(id)</span><br></pre></td></tr></table></figure>


<p>可以看到，需要获取subject和buyinfo之后才能执行process，然后才能执行notify_change和flush_cache。<br>如果使用asyncio，就是这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(id)</span>:</span>  </span><br><span class="line">    subject = asyncio.ensure_future(get_subject_from_db(id))  </span><br><span class="line">    buyinfo = asyncio.ensure_future(get_buyinfo(id))  </span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(subject, buyinfo)  </span><br><span class="line">    change = <span class="keyword">await</span> process(results)  </span><br><span class="line">    <span class="keyword">await</span> notify_change(change)   </span><br><span class="line">    loop.call_soon(flush_cache, id)</span><br></pre></td></tr></table></figure>


<p>原则上无非是让能一起协同的函数异步化（subject和buyinfo已经是Future对象了），然后通过gather获取到这些函数执行的结果；有顺序的就用call_soon来保证。<br>继续深入，现在详细了解下一步还有什么其他解决方案以及其应用场景：</p>
<ol>
<li>包装成Future对象。上面使用了ensure_future来做，上篇也说过，也可以用loop.create_task。如果你看的是老文章可能会出现asyncio.async这种用法，它现在已经被弃用了。如果你已经非常熟悉，你也可以直接使用asyncio.Task(get_subject_from_db(id))这样的方式。</li>
<li>回调。上面用到了call_soon这种回调。除此之外还有如下两种：<ol>
<li>loop.call_later(delay, func, *args)。延迟delay秒之后再执行。</li>
<li>loop.call_at(when, func, *args)。 某个时刻才执行。<br>其实套路就是这些罢了。<h3 id="爬虫分析"><a href="#爬虫分析" class="headerlink" title="爬虫分析"></a>爬虫分析</h3>可能你已经听过<a href="http://aosabook.org/en/index.html" target="_blank" rel="noopener">开源程序架构</a>系列书了。今天我们将介绍第四本<a href="https://github.com/aosabook/500lines" target="_blank" rel="noopener">500 Lines or<br>Less</a>中的<a href="https://github.com/aosabook/500lines/tree/master/crawler" target="_blank" rel="noopener">爬虫项目</a>。顺便说一下，这个项目里面每章都是由不同领域非常知名的专家而写，代码不超过500行。目前包含web服务器、决策采样器、Python解释器、爬虫、模板引擎、OCR持续集成系统、分布式系统、静态检查等内容。值得大家好好学习下。<br>我们看的这个例子，是实现一个高性能网络爬虫，它能够抓取你指定的网站的全部地址。它是由MongoDB的C和Python驱动的主要开发者<a href="https://github.com/ajdavis" target="_blank" rel="noopener">ajdavis</a>以及Python之父Guido<br>van Rossum一起完成的。BTW, 我是ajdavis粉儿！<br>如果你想看了解这篇爬虫教程可以访问： [A Web Crawler With asyncio<br>Coroutines](<a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-" target="_blank" rel="noopener">http://aosabook.org/en/500L/a-web-crawler-with-asyncio-</a><br>coroutines.html)，这篇和教程关系不大，是一篇分析文章。<br>我们首先下载并安装对应的依赖：</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ git clone https://github.com/aosabook/<span class="number">500l</span>ines  </span><br><span class="line">❯ cd <span class="number">500l</span>ines  </span><br><span class="line">❯ python3 -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure>


<p>运行一下，看看效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 crawler/code/crawl.py -q python-cn.org --exclude github  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">http://python-cn.org:<span class="number">80</span>/user/zuoshou/topics <span class="number">200</span> text/html utf<span class="number">-8</span> <span class="number">13212</span> <span class="number">0</span>/<span class="number">22</span>  </span><br><span class="line">http://python-cn.org:<span class="number">80</span>/users <span class="number">200</span> text/html utf<span class="number">-8</span> <span class="number">34156</span> <span class="number">24</span>/<span class="number">41</span>  </span><br><span class="line">http://python-cn.org:<span class="number">80</span>/users/online <span class="number">200</span> text/html utf<span class="number">-8</span> <span class="number">11614</span> <span class="number">0</span>/<span class="number">17</span>  </span><br><span class="line">http://python-cn.org:<span class="number">80</span>/users/sort-posts <span class="number">200</span> text/html utf<span class="number">-8</span> <span class="number">34642</span> <span class="number">0</span>/<span class="number">41</span>  </span><br><span class="line">http://python-cn.org:<span class="number">80</span>/users/sort-reputation <span class="number">200</span> text/html utf<span class="number">-8</span> <span class="number">34721</span> <span class="number">15</span>/<span class="number">41</span>  </span><br><span class="line">Finished <span class="number">2365</span> urls <span class="keyword">in</span> <span class="number">47.868</span> secs (max_tasks=<span class="number">100</span>) (<span class="number">0.494</span> urls/sec/task)  </span><br><span class="line">         <span class="number">4</span> error  </span><br><span class="line">        <span class="number">36</span> error_bytes  </span><br><span class="line">      <span class="number">2068</span> html  </span><br><span class="line">  <span class="number">42735445</span> html_bytes  </span><br><span class="line">        <span class="number">98</span> other  </span><br><span class="line">    <span class="number">937394</span> other_bytes  </span><br><span class="line">       <span class="number">195</span> redirect  </span><br><span class="line">         <span class="number">4</span> status_404  </span><br><span class="line">Todo: <span class="number">0</span>  </span><br><span class="line">Done: <span class="number">2365</span>  </span><br><span class="line">Date: Fri Dec <span class="number">30</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">50</span> <span class="number">2016</span> local time</span><br></pre></td></tr></table></figure>


<p>可以看到 <a href="http://python-cn.org" target="_blank" rel="noopener">http://python-cn.org</a> 有2365个页面，花费了47.868秒，并发为100。<br>这个项目有如下一些文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ tree crawler/code -L <span class="number">1</span>  </span><br><span class="line">crawler/code  </span><br><span class="line">├── Makefile  </span><br><span class="line">├── crawl.py  </span><br><span class="line">├── crawling.py  </span><br><span class="line">├── reporting.py  </span><br><span class="line">├── requirements.txt  </span><br><span class="line">├── supplemental  </span><br><span class="line">└── test.py</span><br></pre></td></tr></table></figure>


<p>其中主要有如下三个程序：</p>
<ol>
<li>crawl.py是主程序，其中包含了参数解析，以及事件循环。</li>
<li>crawling.py抓取程序，crawl.py中的异步函数就是其中的Crawler类的crawl方法。</li>
<li>reporting.py顾名思义，生成抓取结果的程序。<br>本文主要看crawling.py部分。虽然它已经很小（加上空行才275行），但是为了让爬虫的核心更直观，我把其中的兼容性、日志功能以及异常的处理去掉，并将处理成Python<br>3.5新的async/await语法。<br>首先列一下这个爬虫实现什么功能：</li>
<li>输入一个根链接，让爬虫自动帮助我们爬完所有能找到的链接</li>
<li>把全部的抓取结果存到一个列表中</li>
<li>可以排除包含某些关键词链接的抓取</li>
<li>可以控制并发数</li>
<li>可以抓取自动重定向的页面，且可以限制重定向的次数</li>
<li>抓取失败可重试<br>目前对一个复杂的结果结构常定义一个namedtuple，首先把抓取的结果定义成一个FetchStatistic：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FetchStatistic = namedtuple(<span class="string">'FetchStatistic'</span>,  </span><br><span class="line">                            [<span class="string">'url'</span>,  </span><br><span class="line">                             <span class="string">'next_url'</span>,  </span><br><span class="line">                             <span class="string">'status'</span>,  </span><br><span class="line">                             <span class="string">'exception'</span>,  </span><br><span class="line">                             <span class="string">'size'</span>,  </span><br><span class="line">                             <span class="string">'content_type'</span>,  </span><br><span class="line">                             <span class="string">'encoding'</span>,  </span><br><span class="line">                             <span class="string">'num_urls'</span>,  </span><br><span class="line">                             <span class="string">'num_new_urls'</span>])</span><br></pre></td></tr></table></figure>


<p>其中包含了url，文件类型，状态码等用得到的信息。<br>然后实现抓取类Crawler，首先是初始化方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, roots,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 exclude=None, strict=True,  <span class="comment"># What to crawl.  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 max_redirect=<span class="number">10</span>, max_tries=<span class="number">4</span>,  <span class="comment"># Per-url limits.  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                 max_tasks=<span class="number">10</span>, *, loop=None)</span>:</span>  </span><br><span class="line">        self.loop = loop <span class="keyword">or</span> asyncio.get_event_loop()  </span><br><span class="line">        self.roots = roots  </span><br><span class="line">        self.exclude = exclude  </span><br><span class="line">        self.strict = strict  </span><br><span class="line">        self.max_redirect = max_redirect  </span><br><span class="line">        self.max_tries = max_tries  </span><br><span class="line">        self.max_tasks = max_tasks  </span><br><span class="line">        self.q = Queue(loop=self.loop)  </span><br><span class="line">        self.seen_urls = set()  </span><br><span class="line">        self.done = []  </span><br><span class="line">        self.session = aiohttp.ClientSession(loop=self.loop)  </span><br><span class="line">        self.root_domains = set()  </span><br><span class="line">        <span class="keyword">for</span> root <span class="keyword">in</span> roots:  </span><br><span class="line">            parts = urllib.parse.urlparse(root)  </span><br><span class="line">            host, port = urllib.parse.splitport(parts.netloc)  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> host:  </span><br><span class="line">                <span class="keyword">continue</span>  </span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">r'\A[\d\.]*\Z'</span>, host):  </span><br><span class="line">                self.root_domains.add(host)                </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                host = host.lower()  </span><br><span class="line">                <span class="keyword">if</span> self.strict:  </span><br><span class="line">                    self.root_domains.add(host)  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    self.root_domains.add(lenient_host(host))  </span><br><span class="line">        <span class="keyword">for</span> root <span class="keyword">in</span> roots:  </span><br><span class="line">            self.add_url(root)  </span><br><span class="line">        self.t0 = time.time()  </span><br><span class="line">        self.t1 = <span class="literal">None</span></span><br></pre></td></tr></table></figure>


<p>信息量比较大，我拿出重要的解释下：</p>
<ol>
<li>第7行，self.roots就是待抓取的网站地址，是一个列表。</li>
<li>第13行，self.q这个队列就存储了待抓取的url</li>
<li>第14行，self.seen_urls会保证不重复与抓取已经抓取过的url</li>
<li>第16行，使用requests或者aiphttp，都是推荐使用一个会话完成全部工作，要不然有些需要登陆之后的操作就做不了了。</li>
<li>第18-30行，这个for循环会解析self.roots中的域名，这是为了只抓取指定的网站，其它网站的链接会基于这个集合过滤掉</li>
<li>第31-32行，触发抓取，把url放入self.q的队列，就可以被worker执行了</li>
<li>第33-34行，t0和t1是为了记录抓取的时间戳，最后可以计算抓取的总耗时<br>接着我们看add_url的实现：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url</span><span class="params">(self, url, max_redirect=None)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> max_redirect <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">        max_redirect = self.max_redirect  </span><br><span class="line">    self.seen_urls.add(url)  </span><br><span class="line">    self.q.put_nowait((url, max_redirect))</span><br></pre></td></tr></table></figure>


<p>其中q.put_nowait相当于非阻塞的q.put，还可以看到这个url被放入了self.seen_urls<br>现在我们从事件循环会用到的crawl方法开始往回溯：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    workers = [asyncio.Task(self.work(), loop=self.loop)  </span><br><span class="line">               <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.max_tasks)]  </span><br><span class="line">    self.t0 = time.time()  </span><br><span class="line">    <span class="keyword">await</span> self.q.join()  </span><br><span class="line">    self.t1 = time.time()  </span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> workers:  </span><br><span class="line">        w.cancel()</span><br></pre></td></tr></table></figure>


<p>类中的方法可以直接用async关键词的。worker就是self.work，这些worker会在后台运行，但是会阻塞在join上，直到初始化时候放入self.q的url都完成。最后需要让worker都取消掉。<br>然后看self.work：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">            url, max_redirect = <span class="keyword">await</span> self.q.get()  </span><br><span class="line">            <span class="keyword">assert</span> url <span class="keyword">in</span> self.seen_urls  </span><br><span class="line">            <span class="keyword">await</span> self.fetch(url, max_redirect)  </span><br><span class="line">            self.q.task_done()  </span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:  </span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<p>当执行worker.cancel方法就会引起asyncio.CancelledError，然后while<br>1的循环就结束了。执行完fetch方法，需要标记get的这个url执行完成，也就是要执行self.q.task_done，要不然最后join是永远结束不了的。<br>接下来就是self.fetch，这个方法比较长：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self, url, max_redirect)</span>:</span>  </span><br><span class="line">    tries = <span class="number">0</span>  </span><br><span class="line">    exception = <span class="literal">None</span>  </span><br><span class="line">    <span class="keyword">while</span> tries &lt; self.max_tries:  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            response = <span class="keyword">await</span> self.session.get(  </span><br><span class="line">                url, allow_redirects=<span class="literal">False</span>)  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">except</span> aiohttp.ClientError <span class="keyword">as</span> client_error:  </span><br><span class="line">            exception = client_error  </span><br><span class="line">  </span><br><span class="line">        tries += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        self.record_statistic(FetchStatistic(url=url,  </span><br><span class="line">                                             next_url=<span class="literal">None</span>,  </span><br><span class="line">                                             status=<span class="literal">None</span>,  </span><br><span class="line">                                             exception=exception,  </span><br><span class="line">                                             size=<span class="number">0</span>,  </span><br><span class="line">                                             content_type=<span class="literal">None</span>,  </span><br><span class="line">                                             encoding=<span class="literal">None</span>,  </span><br><span class="line">                                             num_urls=<span class="number">0</span>,  </span><br><span class="line">                                             num_new_urls=<span class="number">0</span>))  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        <span class="keyword">if</span> is_redirect(response):  </span><br><span class="line">            location = response.headers[<span class="string">'location'</span>]  </span><br><span class="line">            next_url = urllib.parse.urljoin(url, location)  </span><br><span class="line">            self.record_statistic(FetchStatistic(url=url,  </span><br><span class="line">                                                 next_url=next_url,  </span><br><span class="line">                                                 status=response.status,  </span><br><span class="line">                                                 exception=<span class="literal">None</span>,  </span><br><span class="line">                                                 size=<span class="number">0</span>,  </span><br><span class="line">                                                 content_type=<span class="literal">None</span>,  </span><br><span class="line">                                                 encoding=<span class="literal">None</span>,  </span><br><span class="line">                                                 num_urls=<span class="number">0</span>,  </span><br><span class="line">                                                 num_new_urls=<span class="number">0</span>))  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> next_url <span class="keyword">in</span> self.seen_urls:  </span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            <span class="keyword">if</span> max_redirect &gt; <span class="number">0</span>:  </span><br><span class="line">                self.add_url(next_url, max_redirect - <span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                print(<span class="string">'redirect limit reached for %r from %r'</span>,  </span><br><span class="line">                      next_url, url)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            stat, links = <span class="keyword">await</span> self.parse_links(response)  </span><br><span class="line">            self.record_statistic(stat)  </span><br><span class="line">            <span class="keyword">for</span> link <span class="keyword">in</span> links.difference(self.seen_urls):  </span><br><span class="line">                self.q.put_nowait((link, self.max_redirect))  </span><br><span class="line">            self.seen_urls.update(links)  </span><br><span class="line">    <span class="keyword">finally</span>:  </span><br><span class="line">        <span class="keyword">await</span> response.release()</span><br></pre></td></tr></table></figure>


<p>简单的说，fetch就是去请求url，获得响应。然后把结果组织成一个FetchStatistic，通过self.record_statistic放进self.done这个列表，然后对结果进行解析，通过self.parse_links(response)或者这个页面的结果包含的其他链接，和现在已经抓取的链接集合对比，把还没有抓的放入self.q。<br>如果这个url被重定向，就把重定向的链接放进self.q，待worker拿走执行。<br>然后我们看parse_links的实现，也比较长：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_links</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">    links = set()  </span><br><span class="line">    content_type = <span class="literal">None</span>  </span><br><span class="line">    encoding = <span class="literal">None</span>  </span><br><span class="line">    body = <span class="keyword">await</span> response.read()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> response.status == <span class="number">200</span>:  </span><br><span class="line">        content_type = response.headers.get(<span class="string">'content-type'</span>)  </span><br><span class="line">        pdict = &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> content_type:  </span><br><span class="line">            content_type, pdict = cgi.parse_header(content_type)  </span><br><span class="line">  </span><br><span class="line">        encoding = pdict.get(<span class="string">'charset'</span>, <span class="string">'utf-8'</span>)  </span><br><span class="line">        <span class="keyword">if</span> content_type <span class="keyword">in</span> (<span class="string">'text/html'</span>, <span class="string">'application/xml'</span>):  </span><br><span class="line">            text = <span class="keyword">await</span> response.text()  </span><br><span class="line">  </span><br><span class="line">            urls = set(re.findall(<span class="string">r'''(?i)href=["']([^\s"'&lt;&gt;]+)'''</span>,  </span><br><span class="line">                                  text))  </span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> urls:  </span><br><span class="line">                normalized = urllib.parse.urljoin(response.url, url)  </span><br><span class="line">                defragmented, frag = urllib.parse.urldefrag(normalized)  </span><br><span class="line">                <span class="keyword">if</span> self.url_allowed(defragmented):  </span><br><span class="line">                    links.add(defragmented)  </span><br><span class="line">  </span><br><span class="line">    stat = FetchStatistic(  </span><br><span class="line">        url=response.url,  </span><br><span class="line">        next_url=<span class="literal">None</span>,  </span><br><span class="line">        status=response.status,  </span><br><span class="line">        exception=<span class="literal">None</span>,  </span><br><span class="line">        size=len(body),  </span><br><span class="line">        content_type=content_type,  </span><br><span class="line">        encoding=encoding,  </span><br><span class="line">        num_urls=len(links),  </span><br><span class="line">        num_new_urls=len(links - self.seen_urls))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> stat, links  </span><br><span class="line">`</span><br></pre></td></tr></table></figure>


<p>其实就是用<code>re.findall(r&#39;&#39;&#39;(?i)href=[&quot;&#39;]([^\s&quot;&#39;&lt;&gt;]+)&#39;&#39;&#39;,
text)</code>找到链接，然后进行必要的过滤，就拿到全部链接了。<br>这就是一个爬虫，是不是很简单。但是写的算是「最佳实践」。最后，我们看一下怎么调用Crawler：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">crawler = Crawler([<span class="string">'http://python-cn.org'</span>], max_tasks=<span class="number">100</span>)  </span><br><span class="line">loop.run_until_complete(crawler.crawl())  </span><br><span class="line">print(<span class="string">'Finished &#123;0&#125; urls in &#123;1:.3f&#125; secs'</span>.format(len(crawler.done),  </span><br><span class="line">                                                 crawler.t1 - crawler.t0))  </span><br><span class="line">crawler.close()  </span><br><span class="line">  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>


<p>希望对大家的爬虫技艺有提高！<br>最后祝大家元旦快乐<br>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2016-12-29" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>最近在写一本Python_Web开发的书</title>
    <url>/2016-04-30.html</url>
    <content><![CDATA[<p>应某出版社约, 最近一直在写一本Python Web开发的书. 暂时不发大纲全部的章节，主要涵盖如下方面的内容:</p>
<ol>
<li>使用Python从零开始做一个完善的项目</li>
<li>源码级别分析产品过程中的各种知识点</li>
<li>站在运维，运维开发的角度讲解现在互联网Web应用的的方方面面</li>
<li>排错, 优化, 设计项目等<br>我清晰的知道都写些什么, 但是担心最后遗漏读者们有兴趣，关心的一些方面的内容, 特写本文. 本博客的读者如果有想法和建议, 欢迎和我交流.</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github_webhook服务实现提PR自动检查Flake8并在对应位置发评论</title>
    <url>/2016-05-01.html</url>
    <content><![CDATA[<p>最近参考<a href="https://github.com/lyft/linty_fresh" target="_blank" rel="noopener">linty_fresh</a>实现了一个webhook服务,<br>提PR自动检查Flake8, 当有代码风格问题的时候,并在对应位置发评论<br>项目地址是: <a href="https://github.com/dongweiming/gandalf" target="_blank" rel="noopener">gandalf</a><br>在公司内的Github企业版上, 已经用了一段时间, 比较稳定. 现在开源出来, 有兴趣的可以拿去^.^<br>这个项目也是我的学习asyncio的练手作品, 吐槽下<a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener">Type<br>Hints</a>让代码显的好丑哇…</p>
<h3 id="项目知识点"><a href="#项目知识点" class="headerlink" title="项目知识点"></a>项目知识点</h3><ol>
<li>Python3: 项目需要使用Python3， 建议使用Python3.5</li>
<li><a href="https://github.com/nvie/rq" target="_blank" rel="noopener">rq</a>: 工作中有一些项目的版本库很大, 实际的检查时间也会长一些, 为了保证应用解耦和更好的提供支持, 使用rq作为任务队列</li>
<li><a href="https://github.com/KeepSafe/aiohttp" target="_blank" rel="noopener">aiohttp</a>: 基于asyncio的http库, 用来调用github api, 获取对应pr信息</li>
<li><a href="https://github.com/libgit2/pygit2" target="_blank" rel="noopener">pygit2</a>: 使用官方模块实现Python版本的git版本控制功能, 它的安装比较麻烦, 但是官方文档讲的很清楚</li>
<li>Flask: 作为webhook的服务框架<br>来几张截图看个效果:<br><img src="https://cloud.githubusercontent.com/assets/841395/12537409/649e9e24-c2f9-11e5-852c-60c189cd3140.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/12537410/64e16150-c2f9-11e5-95f5-5711ddf82878.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/12537411/64fff62e-c2f9-11e5-84cc-c5c2f44482aa.png" alt><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat gandalf/config.py  </span><br><span class="line">WORK_DIR = <span class="string">'/tmp/repositories'</span>  <span class="comment"># 设定克隆的项目版本库代码存放位置  </span></span><br><span class="line">FLAKE8_EXECUTABLE = <span class="string">'/usr/local/bin/flake8'</span>  <span class="comment"># 这个项目时Python3的，但是目前大部分应用还是Python2的, 所以需要Python2版本的flake8  </span></span><br><span class="line">HOST = <span class="string">'0.0.0.0'</span>  </span><br><span class="line">PORT = <span class="number">8080</span>  </span><br><span class="line">DEBUG = <span class="literal">False</span>  </span><br><span class="line">REPORT_NO_MATCHING = <span class="literal">False</span>  <span class="comment"># 没有在diff列表的文件的错误是否也报告  </span></span><br><span class="line">GITHUB_URL = <span class="string">'http://github.com/'</span>  <span class="comment"># 行尾要加反斜杠  </span></span><br><span class="line">GITHUB_API_URL = <span class="string">'https://api.github.com'</span>  <span class="comment"># 行尾不要加反斜杠  </span></span><br><span class="line">REPORT_CLOSEST = <span class="literal">False</span> <span class="comment"># 错误出现在PR列出的文件中, 但是修改并不是此次PR中的diff里面是否报告  </span></span><br><span class="line">COMMENT_HEADER = <span class="string">''</span>  <span class="comment"># 上述截图出现的emoji头部就是指定它, 我的设置是`COMMENT_HEADER = ':sparkles:Subject Bot:sparkles:'`  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="keyword">from</span> local_settings <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">except</span> ImportError:  </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<h3 id="配置webhook"><a href="#配置webhook" class="headerlink" title="配置webhook"></a>配置webhook</h3><p>需要在github的项目/组织设置页，找到<code>Webhooks</code>, 然后<code>Add webhook</code>，</p>
<ol>
<li><code>Payload URL</code>输入 <a href="http://192.168.1.1:28030/api/hooks" target="_blank" rel="noopener">http://192.168.1.1:28030/api/hooks</a> # 或者你跑起来web服务的地址</li>
<li>选择事件 ，<code>Let me select individual events.</code> 然后勾选<code>Pull Request</code><br>如图:<br><img src="https://cloud.githubusercontent.com/assets/841395/12540180/6d6fca82-c33f-11e5-9414-19121d5469db.png" alt><br><img src="https://cloud.githubusercontent.com/assets/841395/12540179/6d6ef15c-c33f-11e5-9e90-e93c810d69b9.png" alt><br>Enjoy it</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一个使用python的web程序员的emacs.d</title>
    <url>/2016-04-27.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>越来越多的人使用emacs作为开发工具. 甚至skype,gmail,豆瓣FM都能通过emacs.<br>作为一个产品开发,肯定使用很多插件,设置一些快捷键来提高开发效率.以前一直使用<br><a href="https://github.com/bbatsov/prelude" target="_blank" rel="noopener">prelude</a>,很久之后发现有以下问题:</p>
<ol>
<li>比如开启python语言支持需要在prelude-modules.el里面把python这样的注释去掉</li>
<li>我不需要支持这么多的语言,也不需要那么多快捷键</li>
<li>aotupair实在太难用了</li>
<li>scss/css模式不好自定义缩进空格数, tab和空格混用. 不好定制</li>
<li>看过源码后发现,其实很来很简单粗暴的事情弄得有点复杂了<br>我造了个轮子<a href="https://github.com/dongweiming/emacs.d" target="_blank" rel="noopener">.emacs.d</a>,主要针对python和web开发<br>####Update<br>2014-09-28, 经过这一个月的继续研究,已经有了很大的改变<h4 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h4></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├── Cask ; 我使用[cask](https://github.com/cask/cask)做包管理工具  </span><br><span class="line">├── auto-insert ; 使用auto-insert设置新增elisp/python文件自动添加基于yasnippet的模板  </span><br><span class="line">│   ├── elisp-auto-insert  </span><br><span class="line">│   └── python-auto-insert  </span><br><span class="line">├── custom ; 自定义插件目录,你也可以把你写的程序放进来然后在init.el里面require  </span><br><span class="line">│   ├── flycheck.el ; 定制flycheck,让它在保存python程序时自动执行pep8和flake8,有问题的条目会打开新的buffer打印出来  </span><br><span class="line">│   └── py-autopep8.el ; 我自己实现了autopep8插件,保存时自动根据pep8标准处理文件  </span><br><span class="line">├── functions.el ; 用到的相关函数  </span><br><span class="line">├── helper.el ; 我自己写了个类似`C-h b`的介绍绑定的快捷键的预览表  </span><br><span class="line">├── hs-minor-mode-conf.el ; python函数/类折叠  </span><br><span class="line">├── init.el ; emacs启动的主程序  </span><br><span class="line">├── keys.el ; Key-chord配置,默认被注释了,因为它和我经常大片粘贴代码中代码重复造成很多麻烦  </span><br><span class="line">├── local-settings.el ; 本机的本地配置,比如用户名,单独的快捷键等  </span><br><span class="line">├── misc.el ; 对emacs本身的一些配置  </span><br><span class="line">├── mode-mappings.el ; 模式映射,比如Cask会自动用emacs-lisp-mode  </span><br><span class="line">├── modeline.el ; 我重新定制了modeline，使用了nyan-mode和powerline,一些加颜色的hack  </span><br><span class="line">├── osx.el ; Mac下的一些独立配置,为我的hhkb定制  </span><br><span class="line">├── smartparens-config.el ; 定制了smartparens配置  </span><br><span class="line">├── tmp  </span><br><span class="line">│   └── README.md  </span><br><span class="line">└── xiaoming-theme.el ; 我自己写了一个主题,好吧 我就是`小明`</span><br></pre></td></tr></table></figure>


<h4 id="使用的插件列表"><a href="#使用的插件列表" class="headerlink" title="使用的插件列表"></a>使用的插件列表</h4><ol>
<li>f - 处理文件相关的库</li>
<li>s - 处理字符串相关的库</li>
<li>ag - 据说比ack更快的文本搜索工具<code>the_silver_searcher</code>的emacs插件</li>
<li>ht - 处理哈希相关的库</li>
<li>anzu - 显示当前匹配文本，预览替换效果和总匹配数的插件</li>
<li>dash - 常用函数集合</li>
<li>helm - 方便查找各种文件内容,buffer切换,emacs命令执行等</li>
<li>jedi - python代码补全，快速需要函数/模块定义的插件</li>
<li>smex - M-x 的命令行补全的功能</li>
<li>direx - 展示目录树</li>
<li>magit - git插件</li>
<li>slime - commonlisp交互模式</li>
<li>ac-js2 - js2-mode支持js函数定义查找</li>
<li>rinari - 依赖,需要安装</li>
<li>diff-hl - 在行首用颜色表示git状态-只支持图形界面的emacs</li>
<li>dired-k - 用带不同颜色的高亮显示文件/目录,大小等信息</li>
<li>bind-key - 本项目绑定快捷键的用法都根据这个包,没有用global-set-key</li>
<li>css-mode - css-mode</li>
<li>js2-mode - js-mode的升级版</li>
<li>web-mode - 前端开发必备, html缩进,支持根据tag/元素/属性/block/dom跳转,语法高亮,支持mako,jinja2等模板</li>
<li>git-blame - git-blame,单独版</li>
<li>key-chord - 可以快速按键达到快捷键的作用</li>
<li>nyan-mode - 一直可爱的小猫</li>
<li>plim-mode - 我写的编辑plim的major-mode</li>
<li>powerline - 提供一个漂亮的状态栏</li>
<li>sass-mode - 编辑sass</li>
<li>scss-mode - 编辑scss</li>
<li>sublimity - 在图形界面的emacs能缩小预览代码-sublime-text有类似的插件</li>
<li>undo-tree - 让undo可视化</li>
<li>yaml-mode - 编辑yaml</li>
<li>yasnippet - 一个神奇的模板系统,定义缩写并通过tab键自动帮你展开(一些自动的”填空题”机制)</li>
<li>drag-stuff - 可以将代码块整体拖动</li>
<li>helm-swoop - 项目内关键词查找,并能自动跳到对应文件和对应行</li>
<li>ibuffer-vc - 支持版本空的ibuffer模式</li>
<li>projectile - 管理项目，可快速访问项目里任何文件，支持全项目关键词搜索 </li>
<li>coffee-mode - 编辑coffee</li>
<li>python-mode - 编辑python</li>
<li>smartparens - 自动括号匹配,可以按块删除,tag跳转</li>
<li>use-package - 本项目引用包的方式</li>
<li>crontab-mode - 高亮编辑crontab</li>
<li>golden-ratio - 黄金分割展示当前window</li>
<li>helm-ipython - helm的ipython插件</li>
<li>rainbow-mode - 在代码中通过背景色标示颜色值</li>
<li>ace-jump-mode - 快速让光标位置到你想去的地方</li>
<li>expand-region - 按层次块区域选择</li>
<li>helm-css-scss - helm的css/scss插件</li>
<li>markdown-mode - 编辑markdown</li>
<li>switch-window - 可视化切换窗口</li>
<li>visual-regexp - 可视化正则匹配</li>
<li>gitconfig-mode - 单独的gitconfig-mode</li>
<li>gitignore-mode - 单独的gitignore-mode</li>
<li>helm-descbinds - 让默认的<code>C-h b</code>高亮并且按组分开</li>
<li>imenu-anywhere - 类似于etag, 可直接跳到对应的标签</li>
<li>multiple-cursors - 一次编辑多处/行文字</li>
<li>discover-my-major - 告诉你当前mode的一些说明/快捷键设置</li>
<li>virtualenvwrapper - virtualenvwrapper</li>
<li>gitattributes-mode - 独立的gitattributes-mode</li>
<li>rainbow-delimiters - 对内嵌的括号等pair符号加不同颜色 </li>
<li>idle-highlight-mode - 在设置的一段设置时间未操作电脑会自动高亮当前关键词,并且全文高亮相同关键词</li>
<li>exec-path-from-shell - 可以使用$PATH环境变量</li>
<li>find-file-in-repository - 根据git属性在项目里查找文件</li>
<li>emmet-mode - 类似于zencoding，但是能编辑css,使用很少的代码就能构造一个复杂的div/css</li>
<li>browse-kill-ring - 查看最近操作的删除文本,以及恢复后的效果<h4 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h4></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl -fsSkL https://raw.github.com/cask/cask/master/go | python  </span><br><span class="line">git clone https://github.com/dongweiming/emacs.d .emacs.d  </span><br><span class="line">cd .emacs.d  </span><br><span class="line">cask  </span><br><span class="line">sudo pip install jedi pep8 autopep8 flake8</span><br></pre></td></tr></table></figure>


<h4 id="快捷键分布"><a href="#快捷键分布" class="headerlink" title="快捷键分布"></a>快捷键分布</h4><p>请参看项目的<a href="https://github.com/dongweiming/emacs.d/blob/master/README.md" target="_blank" rel="noopener">README.md</a></p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用celery之怎么让celery跑起来</title>
    <url>/2016-05-02.html</url>
    <content><![CDATA[<p>####前言<br>自从发了上次的文章[使用celery之深入celery配置](<a href="http://www.dongwm.com/archives/shi-yong-" target="_blank" rel="noopener">http://www.dongwm.com/archives/shi-yong-</a><br>celeryzhi-shen-ru-celerypei-zhi/),<br>有一些网友再问我怎么让celery跑起来. 其实说来也是,celery在新手眼里真的是比较重量级,不好懂,今天先让他跑起来吧<br>本文大部分代码和使用方法都可以在celery官网看到<br>####我想要的效果<br>我想实现一个定时任务, 每3个小时的12分启动,假如是定时任务大概是这样的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">12</span> */<span class="number">3</span> * * * python /where/<span class="keyword">is</span>/the/path/that.py</span><br></pre></td></tr></table></figure>


<p>####选择MQ<br>使用消息队列其实就是为了给任务一个时序,保证任务消息不丢失,想想你的一个任务是关乎公司核心业务,犹豫某种原因失败或者丢失怎么办?<br>celery就需要这个消息的存储,我这里还是选择rabbitmq mongodb,redis都无所谓 只是存储的位置的问题.<br>选择其他的工具没有远程控制和监控<br>写法就是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BROKER_URL = <span class="string">'amqp://myuser:mypassword@localhost:5672/vhost'</span></span><br></pre></td></tr></table></figure>


<p>其中可以这样解析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">amqp://user:password@hostname:port/vhost</span><br></pre></td></tr></table></figure>


<p>vhost是命名空间,就像网站的子域名,在这里由于权限控制我们需要先创建账号和密码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ rabbitmqctl add_user myuser mypassword  </span><br><span class="line">$ rabbitmqctl add_vhost myvhost  </span><br><span class="line">$ rabbitmqctl set_permissions -p myvhost myuser <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure>


<h4 id="编写tasks-py脚本"><a href="#编写tasks-py脚本" class="headerlink" title="编写tasks.py脚本"></a>编写tasks.py脚本</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery  </span><br><span class="line">  </span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=<span class="string">'amqp://myuser:mypassword@localhost:5672/vhost'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.task  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>


<h4 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$celery -A tasks worker --loglevel=debug</span><br></pre></td></tr></table></figure>


<p>-A指定的就是任务的程序 tasks.py worker表示他是一个执行任务角色. 后面的记录日志类型,默认是info<br>这个时候,你可以在当前目录下使用python交互模式生成一个任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tasks <span class="keyword">import</span> add  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.delay(<span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>


<p>这个时候可以看见上面的日志里面多了一些消息,然后里面多了这个任务的信息,比如下面这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">2013</span><span class="number">-11</span><span class="number">-24</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">59</span>,<span class="number">369</span>: INFO/MainProcess] Received task: tasks.add[f27994b0<span class="number">-3628</span><span class="number">-43</span>a1-b136<span class="number">-540</span>a360e3d64]  </span><br><span class="line">[<span class="number">2013</span><span class="number">-11</span><span class="number">-24</span> <span class="number">17</span>:<span class="number">11</span>:<span class="number">59</span>,<span class="number">371</span>: INFO/MainProcess] Task tasks.add[f27994b0<span class="number">-3628</span><span class="number">-43</span>a1-b136<span class="number">-540</span>a360e3d64] succeeded <span class="keyword">in</span> <span class="number">0.00102571400021</span>s: <span class="number">8</span></span><br></pre></td></tr></table></figure>


<p>可以看见你的任务被执行了</p>
<h4 id="假如我使用python的包-就像一个应用-让代码结构化一些"><a href="#假如我使用python的包-就像一个应用-让代码结构化一些" class="headerlink" title="假如我使用python的包, 就像一个应用,让代码结构化一些"></a>假如我使用python的包, 就像一个应用,让代码结构化一些</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$tree proj  </span><br><span class="line">proj  </span><br><span class="line">├── __init__.py  </span><br><span class="line">├── celery.py  </span><br><span class="line">└── tasks.py</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$cat proj/celery.py  </span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import  </span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery  </span><br><span class="line">app = Celery(<span class="string">'proj'</span>,  </span><br><span class="line">              broker=<span class="string">'amqp://myuser:mypassword@localhost:5672/vhost'</span>,  </span><br><span class="line">              backend=<span class="string">'amqp://'</span>,  </span><br><span class="line">              include=[<span class="string">'proj.tasks'</span>])  </span><br><span class="line">app.conf.update(CELERY_TASK_RESULT_EXPIRES=<span class="number">3600</span>,)  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    app.start()</span><br></pre></td></tr></table></figure>


<p>上面的broker就是消息存储的地址<br>backend是存储任务执行情况的,比如正在执行，执行失败, 已经执行结果.<br>include表示执行的任务的代码都放在哪个程序里面,比如这里的proj.tasks就是proj/tasks.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$cat proj/tasks.py  </span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> proj.celery <span class="keyword">import</span> app  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.task  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>


<p>其中的app.task是一个装饰器, 你可以在tasks.py里面加很多函数,但是celery只会找带这个装饰器的函数当成一种任务去执行<br>你可以有多个这样的脚本,只要在上面的celery.py的include的列表中指定<br>好吧 我们可以这样启动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$celery worker --app=proj -l info</span><br></pre></td></tr></table></figure>


<p>proj 就是我们刚才应用的项目目录</p>
<h4 id="给我们的项目任务放到特定的队列"><a href="#给我们的项目任务放到特定的队列" class="headerlink" title="给我们的项目任务放到特定的队列"></a>给我们的项目任务放到特定的队列</h4><p>可能你有很多的任务,但是你希望某些机器跑某些任务, 你可以希望有些任务优先级比较高,而不希望<br>先进先出的等待. 那么需要引入一个队列的问题. 也就是说在你的broker的消息存储里面有一些队列，他们并行运行，但是worker只从对应<br>的队列里面取任务.<br>我们要修改配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$cat proj/celery.py  </span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import  </span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery  </span><br><span class="line">app = Celery(<span class="string">'proj'</span>,  </span><br><span class="line">              broker=<span class="string">'amqp://myuser:mypassword@localhost:5672/vhost'</span>,  </span><br><span class="line">              backend=<span class="string">'amqp://'</span>,  </span><br><span class="line">              include=[<span class="string">'proj.tasks'</span>])  </span><br><span class="line">app.conf.update(  </span><br><span class="line">    CELERY_ROUTES = &#123;  </span><br><span class="line">            <span class="string">'proj.tasks.add'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'hipri'</span>&#125;,  </span><br><span class="line">                &#125;,  </span><br><span class="line">                )  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    app.start()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">celery -A proj worker -Q hipri <span class="comment">#这个worker只处理hipri这个队列的任务</span></span><br></pre></td></tr></table></figure>


<p>你会发现add这个函数任务被放在一个叫做’hipri’的队列里面，想要执行那么也需要改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> proj.tasks <span class="keyword">import</span> add  </span><br><span class="line">add.apply_async((<span class="number">2</span>, <span class="number">2</span>), queue=<span class="string">'hipri'</span>)</span><br></pre></td></tr></table></figure>


<h4 id="使用beat自动调度"><a href="#使用beat自动调度" class="headerlink" title="使用beat自动调度"></a>使用beat自动调度</h4><p>想想吧. 目前还是交互模式去手动执行, 我们要是想crontab的定时生成和执行,那么就是celery beat干的事情</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta  </span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery  </span><br><span class="line">  </span><br><span class="line">app = Celery(<span class="string">'proj'</span>,  </span><br><span class="line">             broker=<span class="string">'amqp://myuser:mypassword@localhost:5672/vhost'</span>,  </span><br><span class="line">             backend=<span class="string">'amqp://'</span>,  </span><br><span class="line">              include=[<span class="string">'proj.tasks'</span>])  </span><br><span class="line">  </span><br><span class="line">app.conf.update(  </span><br><span class="line">    CELERY_ROUTES = &#123;  </span><br><span class="line">        <span class="string">'proj.tasks.add'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'hipri'</span>&#125;,  </span><br><span class="line">    &#125;,  </span><br><span class="line">  </span><br><span class="line">    CELERYBEAT_SCHEDULE = &#123;  </span><br><span class="line">        <span class="string">"add"</span>: &#123;  </span><br><span class="line">                <span class="string">"task"</span>: <span class="string">"proj.tasks.add"</span>,  </span><br><span class="line">                <span class="string">"schedule"</span>: timedelta(seconds=<span class="number">10</span>),  </span><br><span class="line">                <span class="string">"args"</span>: (<span class="number">16</span>, <span class="number">16</span>)  </span><br><span class="line">                &#125;, &#125;,  </span><br><span class="line">                )  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    app.start()</span><br></pre></td></tr></table></figure>


<p>注意发现了一个CELERYBEAT_SCHEDULE,里面的调度其实就是表示10秒生成一次,worker启动方法一样,<br>这里启动beat,他就是按时生成任务发到MQ里面,让worker取走去执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">celery -A proj beat</span><br></pre></td></tr></table></figure>


<p>其实也可以在worker命令中加-B</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">celery -A proj worker -B -Q hipri -l debug</span><br></pre></td></tr></table></figure>


<p>刚才的CELERYBEAT_SCHEDULE也可以使用crontab的风格，比如我说的没3小时的12分就可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab  </span><br><span class="line">  </span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;  </span><br><span class="line">        <span class="string">"add"</span>: &#123;  </span><br><span class="line">                <span class="string">"task"</span>: <span class="string">"tasks.add"</span>,  </span><br><span class="line">                <span class="string">"schedule"</span>: crontab(hour=<span class="string">"*/3"</span>, minute=<span class="number">12</span>),  </span><br><span class="line">                <span class="string">"args"</span>: (<span class="number">16</span>, <span class="number">16</span>),  </span><br><span class="line">                &#125;,  </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用celery之了解celery</title>
    <url>/2016-04-29.html</url>
    <content><![CDATA[<p>####前言<br>我想很多做开发和运维的都会涉及一件事:crontab, 也就是在服务器上设定定时任务,按期执行一些任务.但是假如你有上千台的服务器，<br>你有上千种任务,那么对于这个定时任务的管理恐怕是一件很头疼的事情.哪怕你只是几十个任务分配的不同的机器上怎么样合理的管理和实现以下功能呢:</p>
<ol>
<li>查看定时任务的执行情况.比如执行是否成功，当前状态，执行花费的时间.</li>
<li>一个友好的界面或者命令行下实现添加,删除任务</li>
<li>怎么样简单实现不同的机器设定不同种任务,某些机器执行不同的队列</li>
<li>假如你需要生成一个任务怎么样不阻塞剩下来的过程(异步了呗)</li>
<li>怎么样并发的执行任务<br>####几种选择</li>
<li>有钱有人有时间自己实现一套,优点是完全符合公司业务的需要,有专门的团队维护和服务</li>
<li>使用<a href="http://gearman.org/" target="_blank" rel="noopener">Gearman</a>,听说过没用过，因为是C/java/perl,对我们这种python开发者或者运维来说,假如没有这方面经验之后没有能力了解底层实现和二次开发的能力</li>
<li>使用<a href="http://python-rq.org/" target="_blank" rel="noopener">rq</a>, rq是搞gitflow的那个作者写的，简介里面说的很清楚:Simple job queues for Python. 怕它不够复杂,但是假如业务没有那么复杂或者应用不是那么严格，完全可以尝试下</li>
<li>好吧我选择了<a href="https://github.com/celery/celery" target="_blank" rel="noopener">celery</a>, 现在用了快半年，可能是历史遗留问题,版本较低.有很多坑.但是很不错<br>####消息队列<br>RabbitMQ,ZeroMQ这样的消息队列总是出现在我们视线中, 其实意义是很简单:<br>消息就是一个要传送的数据,celery是一个分布式的任务队列.这个”任务”其实就是一种消息,<br>任务被生成到队列中，被RabbitMQ等容器接收和存储，在适当的时候又被要执行的机器把这个消息取走.<br>celery任务可以使用RabbitMQ/Redis/SQLAlchemy/Django的orm/Mongodb等等容器(这里叫做Broker).我使用的是RabbitMQ,因为作者在github主页的介绍里面很明确的写了这个<br>所谓队列,你可以设想一个问题,我有一大推的东西要执行,但是我并不是需要每个服务器都执行这个任务,因为业务不同嘛. 所以就要做个队列, 比如任务A,B,C<br>A可以在X,Y服务器执行,<br>但是不需要或者不能在Z服务器上执行.那么在X,Y你启动worker(下面会说，其实就是消费者和生产者的消费者)加上这个队列,Z服务器就不需要指定这个队列,也就不会执行这个队列的任务<br>#####celery的原理,我这里的角度是django+celery+django-celery<br>首先说一下流程:</li>
<li>使用django-celery或者直接操作数据库(settings.py里面指定)添加任务,设置的相关属性(包含定时任务的间隔)存入数据库.</li>
<li>celerybeat通过djcelery.schedulers.DatabaseScheduler获取django内你设置的任务周期性的检查(默认5s),发现需要执行某任务讲其丢入你设置的broker(我这里是rabbitmq),他会更具settings.py的设置放到对应的队列</li>
<li>在你启动了celery worker(以前是celeryd)的服务器上,根据worker也会定期(默认5s)去broker里面查找需要它执行的队列里面是否有任务</li>
<li>当发现队列有要执行的任务,worker将它取出来执行,执行完的结果通过celerycam(默认30s,所以这个进程也要启动)写入django设置的数据库,更新了这个任务的状态.比如花费的时间<br>####supervisor进程管理<br>不知道有没有人用过<a href="http://cr.yp.to/daemontools/supervise.html" target="_blank" rel="noopener">supervise</a>，我以前经常在最初的项目开发中经常使用它监视我的程序,当程序死掉自动启动,<br><a href="https://github.com/Supervisor/supervisor" target="_blank" rel="noopener">supervisor</a>确是一个<br>进程管理的工具，我在这里使用它管理celery的程序和uwsgi<br>粘贴下我的一个本地环境的配置,并直接进行一下说明:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">;程序名字  </span><br><span class="line">[program:celery-queue-fetch]  </span><br><span class="line">;程序要执行的命令, -Q 指定了生成和接受任务的队列,多个用都好分开 -c为workr的数量,原意为并发数量  </span><br><span class="line">command=python /home/dongwm/work/manage.py celery worker -E --settings=settings_local --loglevel=INFO -Q fetch_ -c <span class="number">30</span>  </span><br><span class="line">;程序执行时候所在目录  </span><br><span class="line">directory=/home/dongwm/work/  </span><br><span class="line">;执行程序使用的用户  </span><br><span class="line">user=dongwm  </span><br><span class="line">;启动的程序的实例数,默认是<span class="number">1</span>  </span><br><span class="line">numprocs=<span class="number">1</span>  </span><br><span class="line">stdout_logfile=/home/dongwm/work/celerylog/celery.log  </span><br><span class="line">stderr_logfile=/home/dongwm/work/celerylog/celery.log  </span><br><span class="line">;在启动supervisor时候自动启动  </span><br><span class="line">autostart=true  </span><br><span class="line">;当程序可能因为某些原因没有启动成功会自动重启  </span><br><span class="line">autorestart=true  </span><br><span class="line">;启动的等待时候,我想是为了重启能杀掉原来进程预留的时间  </span><br><span class="line">startsecs=<span class="number">10</span>  </span><br><span class="line">;进程发送停止信号等待os返回SIGCHILD的时间  </span><br><span class="line">stopwaitsecs=<span class="number">10</span>  </span><br><span class="line">;低优先级的会首先启动最后关闭  </span><br><span class="line">priority=<span class="number">998</span>  </span><br><span class="line">;以下<span class="number">2</span>句是为了保证杀掉进程和其子进程而不会只杀死其控制的程序主进程而留下子进程变为孤立进程的问题  </span><br><span class="line">stopsignal=KILL  </span><br><span class="line">stopasgroup=true  </span><br><span class="line">  </span><br><span class="line">[program:celery-queue-feed]  </span><br><span class="line">command=python /home/dongwm/work/manage.py celeryd -E --settings=settings_local --loglevel=INFO -Q feed  </span><br><span class="line">directory=/home/dongwm/work/  </span><br><span class="line">user=dongwm  </span><br><span class="line">numprocs=<span class="number">1</span>  </span><br><span class="line">stdout_logfile=/home/dongwm/work/celerylog/celery.log  </span><br><span class="line">stderr_logfile=/home/dongwm/work/celerylog/celery.log  </span><br><span class="line">autostart=true  </span><br><span class="line">autorestart=true  </span><br><span class="line">startsecs=<span class="number">10</span>  </span><br><span class="line">stopwaitsecs=<span class="number">10</span>  </span><br><span class="line">priority=<span class="number">998</span>  </span><br><span class="line">stopsignal=KILL  </span><br><span class="line">stopasgroup=true  </span><br><span class="line">  </span><br><span class="line">[program:celerycam]  </span><br><span class="line">;任务快照的间隔时间为<span class="number">10</span>s  </span><br><span class="line">command=python /home/dongwm/work/manage.py celerycam -F <span class="number">10</span> --settings=settings_local  </span><br><span class="line">directory=/home/dongwm/work/  </span><br><span class="line">user=dongwm  </span><br><span class="line">numprocs=<span class="number">1</span>  </span><br><span class="line">stdout_logfile=/home/dongwm/work/celerylog/celerycam.log  </span><br><span class="line">stderr_logfile=/home/dongwm/work/celerylog/celerycam.log  </span><br><span class="line">autostart=true  </span><br><span class="line">autorestart=true  </span><br><span class="line">startsecs=<span class="number">5</span>  </span><br><span class="line">stopwaitsecs=<span class="number">5</span>  </span><br><span class="line">priority=<span class="number">998</span>  </span><br><span class="line">stopsignal=KILL  </span><br><span class="line">stopasgroup=true  </span><br><span class="line">  </span><br><span class="line">[program:celerybeat]  </span><br><span class="line">command=python /home/dongwm/work/manage.py celerybeat --settings=settings_real_old --loglevel=DEBUG  </span><br><span class="line">directory=/home/dongwm/work/  </span><br><span class="line">user=dongwm  </span><br><span class="line">numprocs=<span class="number">1</span>  </span><br><span class="line">stdout_logfile=/home/dongwm/work/celerylog/celery_beat.log  </span><br><span class="line">stderr_logfile=/home/dongwm/work/celerylog/celery_beat.log  </span><br><span class="line">autostart=true  </span><br><span class="line">autorestart=true  </span><br><span class="line">startsecs=<span class="number">10</span>  </span><br><span class="line">priority=<span class="number">999</span>  </span><br><span class="line">stopsignal=KILL  </span><br><span class="line">stopasgroup=true  </span><br><span class="line">  </span><br><span class="line">;这是supervisor官方的一个监控进程状态异常退出的脚本,我对它进行了较大的修改,这样在程序奇怪退出的时候会给我发邮件  </span><br><span class="line">[eventlistener:crashmail]  </span><br><span class="line">command=python /home/dongwm/superlance/superlance/crashmail.py -a -m ciici123@<span class="number">163.</span>com  </span><br><span class="line">events=PROCESS_STATE_EXITED  </span><br><span class="line">  </span><br><span class="line">[program:uwsgi]  </span><br><span class="line">user = dongwm  </span><br><span class="line">numprocs=<span class="number">1</span>  </span><br><span class="line">command=/usr/local/bin/uwsgi -s /tmp/uwsgi-sandbox.sock --processes <span class="number">4</span>  --enable-threads \  </span><br><span class="line">     --pythonpath /home/dongwm/uwsgi --buffer-size <span class="number">32768</span> --listen <span class="number">100</span> --daemonize /home/dongwm/ulog/uwsgi_out.log  </span><br><span class="line">directory=/home/dongwm/work  </span><br><span class="line">autostart=true  </span><br><span class="line">autorestart=true  </span><br><span class="line">redirect_stderr=true  </span><br><span class="line">stopsignal=KILL  </span><br><span class="line">stopasgroup=true</span><br></pre></td></tr></table></figure>


<p>####nginx+uwsgi的实践<br>nginx进程数会直接影响性能,<br>如何使用到的模块不会出现阻塞式的调用，应该有多少cpu就配多少worker_processes,否则才需要配置更多的进程数.<br>比如你的用户大量读取你的本地静态文件，并且服务器上面内存较少，硬盘的I/O调用可能会阻塞worker少量时间,那么就要多配<br>为了更好利用多核的优势,我绑定了worker和对应的内核:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">worker_processes     <span class="number">4</span>;  </span><br><span class="line">worker_cpu_affinity <span class="number">0001</span> <span class="number">0010</span> <span class="number">0100</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python进阶必读汇总</title>
    <url>/2016-05-03.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天翻到了一本在github开源的书: <a href="http://book.pythontips.com/en/latest/index.html" target="_blank" rel="noopener">Intermediate<br>Python</a>. 就有了此文,<br>梳理了一下一些之前翻到的对python语言细节点的答案, 博文等.</p>
<h3 id="英文的"><a href="#英文的" class="headerlink" title="英文的"></a>英文的</h3><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" target="_blank" rel="noopener">Python’s super() considered<br>super!</a><br>rhettinger是python核心开发者. 这篇博文也是讲super最好最深入的博文了.</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>[Understanding Python<br>Decorators](<a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-" target="_blank" rel="noopener">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-</a><br>of-function-decorators-in-python/1594484#1594484)<br>如果你还没有经常性的用装饰器, 你就要思考你的工作需求是不是的太简单了, 或者该考虑下这种AOP模式的开发的作用了</p>
<h4 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h4><p>[What is a metaclass in<br>Python?](<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-" target="_blank" rel="noopener">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-</a><br>python/6581949#6581949)<br><a href="http://archive.is/8owmb" target="_blank" rel="noopener">Metaclasses Demystified</a><br>元类是python高阶语法. 合理的使用可以减少大量重复性的代码.</p>
<h4 id="防御性编程中的LBYL和EAFP"><a href="#防御性编程中的LBYL和EAFP" class="headerlink" title="防御性编程中的LBYL和EAFP"></a>防御性编程中的LBYL和EAFP</h4><p>[Try/catch or validation for<br>speed?](<a href="http://stackoverflow.com/questions/5589532/try-catch-or-validation-" target="_blank" rel="noopener">http://stackoverflow.com/questions/5589532/try-catch-or-validation-</a><br>for-speed/)<br>这其实就是事先检查和异常处理2个方式的讨论</p>
<h4 id="new-和-init"><a href="#new-和-init" class="headerlink" title="new 和 init"></a><strong>new</strong> 和 <strong>init</strong></h4><p>[Python (and Python C API): <strong>new</strong> versus<br><strong>init</strong>](<a href="http://stackoverflow.com/questions/4859129/python-and-python-c-api-" target="_blank" rel="noopener">http://stackoverflow.com/questions/4859129/python-and-python-c-api-</a><br>new-versus-init/)<br>这也是一个常见的面试题.</p>
<h4 id="self"><a href="#self" class="headerlink" title="self"></a>self</h4><p>[Python “self” keyword](<a href="http://stackoverflow.com/questions/6019627/python-" target="_blank" rel="noopener">http://stackoverflow.com/questions/6019627/python-</a><br>self-keyword)<br>但是注意标题. 其实self不是一个关键词. 这里知识帮助你理解self的用意</p>
<h4 id="协程和并发"><a href="#协程和并发" class="headerlink" title="协程和并发"></a>协程和并发</h4><p><a href="http://www.dabeaz.com/coroutines/" target="_blank" rel="noopener">A Curious Course on Coroutines and<br>Concurrency</a></p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p><a href="http://www.dabeaz.com/generators/" target="_blank" rel="noopener">Generator Tricks for Systems Programmers</a></p>
<h4 id="python开发必读"><a href="#python开发必读" class="headerlink" title="python开发必读"></a>python开发必读</h4><p><a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" target="_blank" rel="noopener">Code Like a Pythonista: Idiomatic<br>Python</a></p>
<h4 id="unicode必读"><a href="#unicode必读" class="headerlink" title="unicode必读"></a>unicode必读</h4><p><a href="http://farmdev.com/talks/unicode/" target="_blank" rel="noopener">Unicode In Python, Completely Demystified</a><br>之前我曾经非常困惑于各种unicode报错</p>
<h4 id="exec和eval"><a href="#exec和eval" class="headerlink" title="exec和eval"></a>exec和eval</h4><p><a href="http://lucumr.pocoo.org/2011/2/1/exec-in-python/" target="_blank" rel="noopener">Be careful with exec and eval in<br>Python</a><br>我的观点是从来都不要用exec/eval</p>
<h4 id="python性能贴士"><a href="#python性能贴士" class="headerlink" title="python性能贴士"></a>python性能贴士</h4><p><a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" target="_blank" rel="noopener">PerformanceTips</a><br><a href="http://www.monitis.com/blog/2012/02/13/python-performance-tips-part-1/" target="_blank" rel="noopener">Python Performance Tips, Part<br>1</a><br><a href="http://www.monitis.com/blog/2012/03/21/python-performance-tips-part-2/" target="_blank" rel="noopener">Python Performance Tips, Part<br>2</a></p>
<h4 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h4><p><a href="http://users.rcn.com/python/download/Descriptor.htm" target="_blank" rel="noopener">How-To Guide for<br>Descriptors</a></p>
<h4 id="python隐藏特性"><a href="#python隐藏特性" class="headerlink" title="python隐藏特性"></a>python隐藏特性</h4><p>[Hidden features of Python](<a href="http://stackoverflow.com/questions/101268/hidden-" target="_blank" rel="noopener">http://stackoverflow.com/questions/101268/hidden-</a><br>features-of-python)</p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p><a href="https://github.com/faif/python-patterns" target="_blank" rel="noopener">python-patterns</a></p>
<h4 id="初级python进阶文档"><a href="#初级python进阶文档" class="headerlink" title="初级python进阶文档"></a>初级python进阶文档</h4><p><a href="http://ivory.idyll.org/articles/advanced-swc/" target="_blank" rel="noopener">Intermediate and Advanced Software Carpentry in<br>Python</a><br>这个文档不是非常难, 甚至有点过时. 但是涵盖了python的方方面面. 非常有助于开拓视野, 更了解python</p>
<h3 id="中-译-文"><a href="#中-译-文" class="headerlink" title="中(译)文"></a>中(译)文</h3><h4 id="如何理解Python关键字yield"><a href="#如何理解Python关键字yield" class="headerlink" title="如何理解Python关键字yield"></a>如何理解Python关键字yield</h4><p>[What does the yield keyword do in<br>Python](<a href="http://stackoverflow.com/questions/231767/the-python-yield-keyword-" target="_blank" rel="noopener">http://stackoverflow.com/questions/231767/the-python-yield-keyword-</a><br>explained/231855#231855)<br>[如何理解Python关键字yield](<a href="https://github.com/lzjun567/note/blob/master/note/python/what-" target="_blank" rel="noopener">https://github.com/lzjun567/note/blob/master/note/python/what-</a><br>does-the-yield-keyword-do-in-python.md)<br>yield 是python语言里面让初学者困惑的关键词之一. 可以参考这2个理解让你对yield入门. 并且之后在正确的场景下使用</p>
<h4 id="迭代器-Iterator-与生成器-Generator-的区别"><a href="#迭代器-Iterator-与生成器-Generator-的区别" class="headerlink" title="迭代器(Iterator)与生成器(Generator)的区别"></a>迭代器(Iterator)与生成器(Generator)的区别</h4><p>[Difference between Python’s Generators and<br>Iterators](<a href="http://stackoverflow.com/questions/2776829/difference-between-" target="_blank" rel="noopener">http://stackoverflow.com/questions/2776829/difference-between-</a><br>pythons-generators-and-iterators)<br><a href="https://github.com/lzjun567/note/blob/master/note/python/iterator_generator.md" target="_blank" rel="noopener">迭代器(Iterator)与生成器(Generator)的区别</a><br>这个是很常见的面试问题.</p>
<h4 id="设计模式入门"><a href="#设计模式入门" class="headerlink" title="设计模式入门"></a>设计模式入门</h4><p><a href="http://blog.jobbole.com/62023/" target="_blank" rel="noopener">写给Python初学者的设计模式入门</a><br>所谓设计模式其实就是 <em>经过总结、优化的，对我们经常会碰到的一些编程问题的可重用解决方案</em>. 其实有时候会发现沃恩日常工作中的一些思考就是<code>设计模式</code><br><a href="http://dongweiming.github.io/category/she-ji-mo-shi.html" target="_blank" rel="noopener">python设计模式- 我写的</a>.<br>供参考.</p>
<h4 id="描述符-1"><a href="#描述符-1" class="headerlink" title="描述符"></a>描述符</h4><p><a href="https://docs.python.org/2/howto/descriptor.html" target="_blank" rel="noopener">Descriptor HowTo Guide</a><br>[Python描述器引导(翻译)](<a href="http://pyzh.readthedocs.org/en/latest/Descriptor-HOW-TO-" target="_blank" rel="noopener">http://pyzh.readthedocs.org/en/latest/Descriptor-HOW-TO-</a><br>Guide.html)<br>descriptor是python高阶的特性, 可以了解下python设计的优雅. PS: 里面也提到了类方法和静态方法的区别</p>
<h4 id="使用断言-assert-的正确场景"><a href="#使用断言-assert-的正确场景" class="headerlink" title="使用断言(assert)的正确场景"></a>使用断言(assert)的正确场景</h4><p><a href="http://www.oschina.net/translate/when-to-use-assert" target="_blank" rel="noopener">Python 使用断言的最佳时机</a><br>[Best practice for Python<br>Assert](<a href="http://stackoverflow.com/questions/944592/best-practice-for-python-" target="_blank" rel="noopener">http://stackoverflow.com/questions/944592/best-practice-for-python-</a><br>assert)<br><a href="http://courses.cms.caltech.edu/cs11/material/python/misc/python_idioms.html" target="_blank" rel="noopener">Python track: python<br>idioms</a><br><a href="http://pyzh.readthedocs.org/en/latest/python-idioms.html" target="_blank" rel="noopener">Python的惯例</a></p>
<h4 id="提高编码效率"><a href="#提高编码效率" class="headerlink" title="提高编码效率"></a>提高编码效率</h4><p>[Improving Your Python Productivity](<a href="http://ozkatz.github.io/improving-your-" target="_blank" rel="noopener">http://ozkatz.github.io/improving-your-</a><br>python-productivity.html)<br>[提高你的Python编码效率](<a href="http://pyzh.readthedocs.org/en/latest/improving-your-python-" target="_blank" rel="noopener">http://pyzh.readthedocs.org/en/latest/improving-your-python-</a><br>productivity.html)</p>
<h4 id="Stackoverflow上的Python问题精选"><a href="#Stackoverflow上的Python问题精选" class="headerlink" title="Stackoverflow上的Python问题精选"></a>Stackoverflow上的Python问题精选</h4><p>[Stackoverflow上的Python问题精选](<a href="http://pyzh.readthedocs.org/en/latest/python-" target="_blank" rel="noopener">http://pyzh.readthedocs.org/en/latest/python-</a><br>questions-on-stackoverflow.html)</p>
<h4 id="Python魔法方法指南"><a href="#Python魔法方法指南" class="headerlink" title="Python魔法方法指南"></a>Python魔法方法指南</h4><p>[Python魔法方法指南](<a href="http://pyzh.readthedocs.org/en/latest/python-magic-methods-" target="_blank" rel="noopener">http://pyzh.readthedocs.org/en/latest/python-magic-methods-</a><br>guide.html)</p>
<h4 id="Python高级编程-我写的"><a href="#Python高级编程-我写的" class="headerlink" title="Python高级编程 - 我写的"></a>Python高级编程 - 我写的</h4><p><a href="http://dongweiming.github.io/Expert-Python/" target="_blank" rel="noopener">Python高级编程</a></p>
<h4 id="洪强宁的ppt"><a href="#洪强宁的ppt" class="headerlink" title="洪强宁的ppt."></a>洪强宁的ppt.</h4><p><a href="http://www.slideshare.net/hongqn/python-9915982" target="_blank" rel="noopener">Python高级编程（二）</a><br>PS: 这个 <code>二</code> 和上一个没有任何次序关系</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-__slots__-详解</title>
    <url>/2016-05-05.html</url>
    <content><![CDATA[<p>Python老鸟都应该看过那篇非常有吸引力的<a href="http://tech.oyster.com/save-ram-with-python-slots/" target="_blank" rel="noopener">Saving 9 GB of RAM with Python’s<br><strong>slots</strong></a><br>文章，作者使用了<strong>slots</strong>让内存占用从25.5GB降到了16.2GB。在当时来说，这相当于用一个非常简单的方式就降低了30%的内存使用，着实惊人。作者并没有提到他的业务特点和代码，那我们就基于《fluent<br>python》中的例子来验证下是不是有这么厉害：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function  </span><br><span class="line"><span class="keyword">import</span> resource  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.a = <span class="string">'string'</span>  </span><br><span class="line">        self.b = <span class="number">10</span>  </span><br><span class="line">        self.c = <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    __slots__ = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.a = <span class="string">'string'</span>  </span><br><span class="line">        self.b = <span class="number">10</span>  </span><br><span class="line">        self.c = <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(cls)</span>:</span>  </span><br><span class="line">    mem_init = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss  </span><br><span class="line">    l = []  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500000</span>):  </span><br><span class="line">        l.append(cls())  </span><br><span class="line">    mem_final = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss  </span><br><span class="line">    <span class="keyword">del</span> l  </span><br><span class="line">    print(<span class="string">'Class: &#123;&#125;:\n'</span>.format(getattr(cls, <span class="string">'__name__'</span>)))  </span><br><span class="line">    print(<span class="string">'Initial RAM usage: &#123;:14,&#125;'</span>.format(mem_init))  </span><br><span class="line">    print(<span class="string">'  Final RAM usage: &#123;:14,&#125;'</span>.format(mem_final))  </span><br><span class="line">    print(<span class="string">'-'</span> * <span class="number">20</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    <span class="keyword">import</span> sys  </span><br><span class="line">    test(globals()[sys.argv[<span class="number">1</span>].upper()])</span><br></pre></td></tr></table></figure>


<p>我们分别跑一下这2个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python mem_test.py a  </span><br><span class="line">Class: A:  </span><br><span class="line">  </span><br><span class="line">Initial RAM usage:      <span class="number">4</span>,<span class="number">890</span>,<span class="number">624</span>  </span><br><span class="line">  Final RAM usage:    <span class="number">200</span>,<span class="number">454</span>,<span class="number">144</span>  </span><br><span class="line">--------------------  </span><br><span class="line">  </span><br><span class="line">❯ python mem_test.py b  </span><br><span class="line">Class: B:  </span><br><span class="line">  </span><br><span class="line">Initial RAM usage:      <span class="number">4</span>,<span class="number">919</span>,<span class="number">296</span>  </span><br><span class="line">  Final RAM usage:     <span class="number">60</span>,<span class="number">235</span>,<span class="number">776</span></span><br></pre></td></tr></table></figure>


<p>2种方法初始内存略有差别，但是由于这个差别和总内存量相比太小而忽略不计，结论就是：</p>
<blockquote>
<p>使用slots可以让内存使用减少3.5倍！！# 通过 (200 - 4) / ((60 - 4) * 1.0) 计算得来<br>那么用slot就是非非常那个有必要吗？事实上500000个实例这种机会非常少见，用不用完全根据业务来决定，并不要以偏概全。因为（敲黑板了哈）使用<strong>slots</strong>也是有副作用的：</p>
</blockquote>
<ol>
<li>每个继承的子类都要重新定义一遍<strong>slots</strong></li>
<li>实例只能包含哪些在<strong>slots</strong>定义的属性，这对写程序的灵活性有影响，比如你由于某个原因新网给instance设置一个新的属性，比如instance.a = 1, 但是由于a不在<strong>slots</strong>里面就直接报错了，你得不断地去修改<strong>slots</strong>或者用其他方法迂回的解决</li>
<li>实例不能有弱引用(weakref)目标，否则要记得把<strong>weakref</strong>放进<strong>slots</strong><br>第三点有点难理解，我写个例子看看吧：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: %pycat ref_example.py  </span><br><span class="line"><span class="keyword">from</span> weakref <span class="keyword">import</span> ref  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    __slots__ = [<span class="string">'b'</span>]  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.b = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    __slots__ = [<span class="string">'b'</span>, <span class="string">'__weakref__'</span>]  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.b = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">from</span> ref_example <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: a = A()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: r = ref(a)  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-6</span><span class="number">-75</span>a6d689c8b3&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 r = ref(a)  </span><br><span class="line">  </span><br><span class="line">TypeError: cannot create weak reference to <span class="string">'A'</span> object  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">6</span>]: b = B()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: r = ref(b)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">8</span>]: r  </span><br><span class="line">Out[<span class="number">8</span>]: &lt;weakref at <span class="number">0x109199578</span>; to <span class="string">'B'</span> at <span class="number">0x10919f890</span>&gt;</span><br></pre></td></tr></table></figure>


<p>所以实例不超过万级别的类，<strong>slots</strong>是不太值得使用的。<br>PS:《fluent python》比我狠，说的是小于百万级别实例不值得使用。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>荐书：《Fluent Python》</title>
    <url>/2016-05-04.html</url>
    <content><![CDATA[<p>最早应该是2015年4月份在「Python-ideas」邮件组知道的《Fluent Python》，当时作者发帖推荐这本书，其中提到了核心开发Victor<br>Stinner做了asyncio部分的评审。那个时候我对asyncio还不太习惯，asyncio的文档也比较匮乏，看到这个消息感觉又多了一个好的帮助我了解Python的途径。<br>去年双十一的时候从淘宝淘了一本《流畅的Python》，它是台译版的《Fluent<br>Python》。买它的原因是为因为之前看原版过程中有多处理解不清晰，希望通过看台版的书来对比帮助理解。<br>另外，在豆瓣上《Fluent Python》的评分高达9.6分！那么为什么大家觉得这本书好呢？我今天试着写一篇书评，分如下4部分来介绍这本书：</p>
<h3 id="作者靠谱"><a href="#作者靠谱" class="headerlink" title="作者靠谱"></a>作者靠谱</h3><p>看一本书是不是靠谱，首先就是看作者。我认为一本好的技术书籍，首先作者就要是还在第一线，是不是在这个圈子里面。Luciano<br>Ramalho是一个非常知名的Pycon演讲者，同时还是PSF(Python Software<br>Foundation)的研究员。由于他是Django和Zope系的，他有什么贡献我所知甚少。不过我经常能在邮件组看到他参与PEP草案制定和讨论。<br>另外本书基本每个章节都有对应领域致命的Python核心开发来评审，质量非常有保证。</p>
<h3 id="关键特性剖析到位"><a href="#关键特性剖析到位" class="headerlink" title="关键特性剖析到位"></a>关键特性剖析到位</h3><p>目前大量的Python相关的书都倾向基础只是和入门，内容重复，对于中高级开发者意义不大。虽然一般有Python的新书我都会买来翻翻然后咸鱼卖掉，但是越来越容易失望了。<br>而《Fluent<br>Python》是Python语言图书中的一朵「奇葩」。其他大部分书都是在告诉你「应该这么写，这样用就对了，这样代码性能更高…」，但是没人告诉你为什么？也就是没有从语言设计实现层面给你一些解释，这本书会对这些细节剖析的很到位，还会告诉你一些不踩不能理解的坑儿的成因和解决办法。比如之前我写过一篇<br>Python元组的赋值谜题 ，就是因为看《Fluent Python》的时候，才从作者哪里获得了肯定的答案。再比如说道 <strong>slots</strong><br>的时候，不仅通过2个例子对比内存使用量究竟有多大差距，还告诉你使用 <strong>slots</strong> 的弊端，需要你注意到的。 <strong>slots</strong><br>之后我会专门写一篇专栏来介绍的。</p>
<h3 id="技术前瞻和全面"><a href="#技术前瞻和全面" class="headerlink" title="技术前瞻和全面"></a>技术前瞻和全面</h3><p>要注意，这是一本在2015年出版的书。那么开始写应该还是在2014年。看看目录，你能发现它是兼顾Python3(主要基于3.4，那会还没有3.5，但是书中却提到了未发布的3.5的一些内容)和Python2(2.7)的。书中大篇幅讲到的concurrent.futures、asyncio到现在看来也是非常前沿的技术。另外对描述符、元类、设计模式、abc、编码问题（貌似很多人对这点都很崩溃，其实是真的没学好-.<br>-）、上下文管理器等高阶内容也都有非常详实的介绍。</p>
<h3 id="包含参考文献和视频链接"><a href="#包含参考文献和视频链接" class="headerlink" title="包含参考文献和视频链接"></a>包含参考文献和视频链接</h3><p>可以感受到作者对这些内容非常了解，旁征博引，每章后面都包含了非常多的相关的质量很高的参考文献和视频链接链接，方便读者进一步深入。凡是在网络上找寻各种资源的同学都知道，这是一件费时费力的事情，还得自己去不断地甄别去掉那些质量差的内容，另外有些资源可能真的不好找，也可能是好的内容由于作者并不会去营销变的没有入口，而作者直接把他们列出来了让大家省心省事。<br>这本书的受众<br>如果你是一个Python语言的初学者，暂时不要动这本书。如果你之前已经看过几本Python语言相关的书籍，用Python完成过一些项目尤其是能用它来完成日常80%以上的工作时，你就可以看这本书了。<br>如果你是一个高级的Python开发，还是要做好略微失望的准备。因为他一半以上的内容可能你已经熟悉和了解了。不会有一本书能让初中高三种级别的读者满意，但是这本书还是非常一读的，因为其中有非常多的细节你可能并不了解和熟悉。<br>举个例子，我之前一直以为类中的属性、特性、方法是不同的3种东西，直到看了本书，我按照自己的理解翻译了下：</p>
<blockquote>
<p>属性和方法在Python中被统称为属性（attributes）,<br>方法是一种可被调用的属性。除了属性和方法，也可以建立特性properties，他可以和存取方法（即getter、setter)一起使用来取代属性，这不会改变类的接口，这符合统一存取原则（uniform<br>access principle):<br>一个模块所提供的所有服务应该是通过一个统一的符号被使用, 其不会泄漏出它们是通过存储还是经过计算而实现的。<br>PS：其中「uniform access principle」的概念是在《面向对象软件构造》中被提到的。<br>看完这段是不是有种豁然开朗的感觉呢?<br>英语好的请直接看原版，如果有同学希望一睹为快，可以抢一下我的这本《流畅的Python》，9成新，100不包邮（原价到手230左右）,<br><a href="https://weidian.com/i/2063232715?wfr=c&ifr=itemdetail" target="_blank" rel="noopener">微店地址</a><br>书买的时候带的封皮，台湾同胞非常贴心. 9成新 。本着对大家负责的态度，有2点我还是先说清楚：</p>
</blockquote>
<ol>
<li>台湾在表达一些技术名词的时候确实看着不适用，比如「介面」应该是「接口」的意思，所以最好是和英语的一起看，要不然不太好理解。看台版图书和汉语图书还是有区别的，如果你是一个初学者更不要买了，要不然有些地方看台版的也真的不好懂。</li>
<li>据说图灵有出版这本书的计划，但是目前还完全没有中文译作要出版的消息，遥遥无期，其实我从去年就一直等，后来实在看不到希望才淘宝的，不过希望翻译的比台湾的好点，大家如果不着急可以等出版中文的一部到位。</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>django和flask分页</title>
    <url>/2016-05-08.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h4><p>最近搞了一些关于flask和django的东西，尤其是django的模板和admin功能以及这些框架使用bootstrap的东西，没时间更新博客，先说一下flask和django分页吧<br>#####flask的bootstrap分页插件[flask-paginate](<a href="http://packages.python.org/Flask-" target="_blank" rel="noopener">http://packages.python.org/Flask-</a><br>paginate)<br>其实安装很常规，他的思路就是根据你的数据量给每个页面加一个li前缀到最后返回的div里面。因为官网提供的说明很简单，我在这里仔细说说：</p>
<ol>
<li>官网说给你的网站页面添加css：</li>
</ol>
<pre><code>.pagination-page-info {  
    padding: .6em;  
    padding-left: 0;  
    width: 40em;  
    margin: .5em;  
    margin-left: 0;  
    font-size: 12px;  
}  
.pagination-page-info b {  
    color: black;  
    background: #6aa6ed;  
    padding-left: 2px;  
    padding: .1em .25em;  
    font-size: 150%;  
}  </code></pre><p>其实这个是给你页面显示统计数据的方法pagination.info提供的样式，默认的class=’pagination’是bootstrap自带的，不需要你添加  </p>
<p>2. 官网的例子使用的是：Blueprint：  </p>
<p>我们一般都是： ‘from flask import<br>Flask’，其实Blueprint就是一个可定制的容器，一个应用可以有多个容器，他们都继承于flask.helpers._PackageBoundObject<br>可以看我的一个例子：  </p>
<pre><code>@app.route(‘/‘)  
def index():  

    pagesize = 100 #设定每页显示条目数  
    page = int(request.args.get(‘page’,0)) #获取当前页面页数  
    data = get_MongoData(page, pagesize) #get_MongoData是我自己的函数，根据页数过滤要显示的数据（因为实在太大了）  
    pagination = Pagination(total=data[1], per_page=pagesize, page=page) #total的值是总数据条目，per_page表示每页显示数目，page就是当前页数。还可以设置向前/后页面标签（默认是&lt;&lt;/&gt;&gt;）等  
    return render_template(“index.html”, pagination=pagination)  </code></pre><ol start="3">
<li>我对他的一点修改：<ol>
<li>我发现在我的程序里面，这个分页栏在后部会放不下而换行显示，我就直接把link_css制定的div改成了行内元素span</li>
<li>当我默认使用link_size,代码是这样：</li>
</ol>
</li>
</ol>
<p>link_css = ‘‘<br>其实最后页面出来的效果是’‘<br>这样就没有符合的bootstrap类，所以我修改了links方法:</p>
<pre><code>@property  
def links(self):  
    ‘’’get all the pagination links’’’  
    if self.total_pages &lt;= 1:  
        return ‘’  
    if not self.link_size:  
        self.link_size = ‘’  
    s = [link_css.format(self.link_size)]  
    s.append(self.prev_page)  
    for page in self.pages:  
        s.append(self.single_page(page) if page else gap_marker)  

    s.append(self.next_page)  
    s.append(‘‘)  
    return ‘’.join(s)  </code></pre><p>#####flask的bootstrap分页插件<a href="http://tgdn.github.com/django-bootstrap-pagination/" target="_blank" rel="noopener">django-bootstrap-<br>pagination</a><br>django的插件比较复杂，它自己定义了中间件和标签，这样你需要在模板中load它提供的函数，并且很nb的使用了RequestContext去处理变量,可以看张沈鹏以前写的一个小文章：<a href="http://zsp.iteye.com/blog/115254" target="_blank" rel="noopener">django<br>简化 view 函数的编写</a></p>
<ol>
<li>先看我的后台方法：</li>
</ol>
<pre><code>def showlist(req):  

    t = req.GET.get(‘type’, None)  
    l = req.GET.get(‘app’, None)  
    if t and l:  
        db = getMongo(‘XXX.XXX.XXX.XXX:XX’, ‘dc2’)  
        if t == ‘v’:  
            q = re.compile(r’.*%s$’ % l)  
            data = db.site.find({‘modules.site.level’:’v4’, ‘site’:{ ‘$regex’ : q }},  
                {‘site’:1, ‘_id’:0, ‘modules.site.links’:1, ‘modules.site.keywords’:1}).sort(  
                ‘modules.site.site.check_time’)  

    return render_to_response(“list.html”, {‘data’:data}, context_instance=RequestContext(req))  </code></pre><p>但是运行时候会报错：</p>
<pre><code>Traceback:  
File “/usr/local/lib/python2.6/dist-packages/django/core/handlers/base.py” in get_response  
  111.                         response = callback(request, _callback_args, **callback_kwargs)  
 File “/home/dongwm/centerCon/views.py” in showlist  
  68.     return render_to_response(“list.html”, {‘data’:data}, context_instance=RequestContext(req))  
File “/usr/local/lib/python2.6/dist-packages/django/shortcuts/ **init**.py” in render_to_response  
  20.     return HttpResponse(loader.render_to_string(_ args, **kwargs),** httpresponse_kwargs)  
File “/usr/local/lib/python2.6/dist-packages/django/template/loader.py” in render_to_string  
  176.         return t.render(context_instance)  
File “/usr/local/lib/python2.6/dist-packages/django/template/base.py” in render  
  140.             return self._render(context)  
File “/usr/local/lib/python2.6/dist-packages/django/template/base.py” in _render  
  134.         return self.nodelist.render(context)  
File “/usr/local/lib/python2.6/dist-packages/django/template/base.py” in render  
  823.                 bit = self.render_node(node, context)  
File “/usr/local/lib/python2.6/dist-packages/django/template/debug.py” in render_node  
  74.             return node.render(context)  
File “/home/dongwm/centerCon/templatetags/pagination_tags.py” in render  
  91.             page_obj = paginator.page(context[‘request’].page)  
File “/usr/local/lib/python2.6/dist-packages/django/template/context.py” in **getitem**  
  54.         raise KeyError(key)  

 Exception Type: KeyError at /showlist/  
Exception Value: ‘request’  </code></pre><p>不管你用那个插件都会有这个报错。。。<br><em>后来发现原因是：</em><br><em>settings文件没有设置TEMPLATE_CONTEXT_PROCESSORS</em><br>理由：模板上下文处理器会指定了哪些contextprocessors总是默认被使用。这样就省去了每次使用RequestContext都指定processors的麻烦<br>在settings加入：<br>TEMPLATE_CONTEXT_PROCESSORS = (<br>“django.core.context_processors.media”,<br>“django.core.context_processors.request”<br>)</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>attrs和Python3.7的dataclasses</title>
    <url>/2016-05-09.html</url>
    <content><![CDATA[<p>一直想写一篇介绍 <a href="http://www.attrs.org" target="_blank" rel="noopener">attrs</a><br>的文章，但是最近几个月忙于做<a href="https://zhuanlan.zhihu.com/p/33611869" target="_blank" rel="noopener">爱湃森课程</a>实在抽不出空来做，最近感觉找到节奏了，还是稳步向前走了，这个周末就硬挤了一下午写写，要不感觉对不起订阅专栏的同学们。<br>在国内我没见过有同学说这2个东西，它们是什么，又有什么关联呢？别着急，先铺垫一下他俩出现的背景。</p>
<h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>写多了Python，尤其是开发和微信的项目比较大的时候，你可能和我一样感觉写Python的类很累。怎么累呢？举个例子，现在有个商品类，<strong>init</strong>是这么写的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, author_id, category_id, brand_id, spu_id,   </span></span></span><br><span class="line"><span class="function"><span class="params">                 title, item_id, n_comments, creation_time, update_time,   </span></span></span><br><span class="line"><span class="function"><span class="params">                 source=<span class="string">''</span>, parent_id=<span class="number">0</span>, ancestor_id=<span class="number">0</span>)</span>:</span>   </span><br><span class="line">        self.id = id  </span><br><span class="line">        self.author_id = author_id  </span><br><span class="line">        self.category_id = category_id  </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>


<p>问题1：特点是初始化参数很多，每一个都需要self.xx = xx 这样往实例上赋值。我印象见过一个类有30多个参数，这个 <strong>init</strong><br>方法下光是赋值就占了一屏多…<br>再说问题2，如果不定义<strong>repr</strong>方法，打印类对象的方式很不友好，大概是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : p  </span><br><span class="line">Out: &lt;test.Product at <span class="number">0x10ba6a320</span>&gt;</span><br></pre></td></tr></table></figure>


<p>定义时参数太多，一般按需要挑几个露出来:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125;(id=&#123;&#125;, author_id=&#123;&#125;, category_id=&#123;&#125;, brand_id=&#123;&#125;)'</span>.format(  </span><br><span class="line">        self.__class__.__name__, self.id, self.author_id, self.category_id,   </span><br><span class="line">        self.brand_id)</span><br></pre></td></tr></table></figure>


<p>这样再看类对象就友好了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : p  </span><br><span class="line">Out: Product(id=<span class="number">1</span>, author_id=<span class="number">100001</span>, category_id=<span class="number">2003</span>, brand_id=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>


<p><strong>但是每个类都需要手动的去写<strong>repr</strong>！</strong><br>接着说问题3，对象比较，有时候需要判断2个对象是否相等甚至大小（例如用于展示顺序）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, self.__class__):  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  </span><br><span class="line">    <span class="keyword">return</span> (self.id, self.author_id, self.category_id, self.brand_id) == (  </span><br><span class="line">        other.id, other.author_id, other.category_id, other.brand_id)  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, self.__class__):  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  </span><br><span class="line">    <span class="keyword">return</span> (self.id, self.author_id, self.category_id, self.brand_id) &lt; (  </span><br><span class="line">        other.id, other.author_id, other.category_id, other.brand_id)</span><br></pre></td></tr></table></figure>


<p>如果对比的更全面不用所有gt、gte、lte都写出来，用functools.total_ordering这样就够了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@total_ordering  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>


<p>然后是问题4。有些场景下希望对对象去重，可以添加<strong>hash</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> hash((self.id, self.author_id, self.category_id, self.brand_id))</span><br></pre></td></tr></table></figure>


<p>这样就不需要对一大堆的对象挨个比较去重了，直接用集合就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : p1 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品1'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">In : p2 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品2'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">In : &#123;p1, p2&#125;  </span><br><span class="line">Out: &#123;Product(id=<span class="number">1</span>, author_id=<span class="number">100001</span>, category_id=<span class="number">2003</span>, brand_id=<span class="number">20</span>)&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到集合只返回了一个对象，另外一个被去掉了。<br>最后是问题5。我很喜欢给类写一个to_dict、to_json或者as_dict这样的方法，把类里面的属性打包成一个字典返回。基本都是每个类都要写一遍它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">        <span class="string">'id'</span>: self.id,  </span><br><span class="line">        <span class="string">'author_id'</span>: self.author_id,  </span><br><span class="line">        <span class="string">'category_id'</span>: self.category_id,  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>当然没有特殊的理由，可以直接使用vars(self)获得， 上面这种键值对指定的方式会更精准，只导出想导出的部分，举个特殊的理由吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    self._a = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> vars(self)</span><br></pre></td></tr></table></figure>


<p>会把_a也包含在返回的结果中，然而它并不应该被导出，所以不适合vars函数。<br>到这里，我们停下来想想，self.id、self.author_id、self.category_id 这些分别写了几次？<br>那有没有一种方法，可以在创建类的时候自动给类加上这些东西，把开发者解脱出来呢？这就是我们今天介绍的attrs和Python<br>3.7标准库里面将要加的dataclasses模块做的事情，而且它们能做的会更多。</p>
<h3 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h3><p><a href="https://github.com/python-attrs/attrs" target="_blank" rel="noopener">attrs</a>是Python核心开发Hynek<br>Schlawack设计并实现的一个项目，它就是解决上述痛点而生的，上述类，使用attrs这样写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> attr  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@attr.s(hash=True)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    id = attr.ib()  </span><br><span class="line">    author_id = attr.ib()  </span><br><span class="line">    brand_id = attr.ib()  </span><br><span class="line">    spu_id = attr.ib()  </span><br><span class="line">    title = attr.ib(repr=<span class="literal">False</span>, cmp=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    item_id = attr.ib(repr=<span class="literal">False</span>, cmp=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    n_comments = attr.ib(repr=<span class="literal">False</span>, cmp=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    creation_time = attr.ib(repr=<span class="literal">False</span>, cmp=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    update_time = attr.ib(repr=<span class="literal">False</span>, cmp=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    source = attr.ib(default=<span class="string">''</span>, repr=<span class="literal">False</span>, cmp=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    parent_id = attr.ib(default=<span class="number">0</span>, repr=<span class="literal">False</span>, cmp=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    ancestor_id = attr.ib(default=<span class="number">0</span>, repr=<span class="literal">False</span>, cmp=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>


<p>这就可以了，上面说的那些dunder方法(双下划线开头和结尾的方法)都不用写了:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : p1 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品1'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">In : p2 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品2'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">In : p3 = Product(<span class="number">3</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品3'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line">In : p1  </span><br><span class="line">Out: Product(id=<span class="number">1</span>, author_id=<span class="number">100001</span>, brand_id=<span class="number">2003</span>, spu_id=<span class="number">20</span>)  </span><br><span class="line">  </span><br><span class="line">In : p1 == p2  </span><br><span class="line">Out: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In : p1 &gt; p3  </span><br><span class="line">Out: <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">In : &#123;p1, p2, p3&#125;  </span><br><span class="line">Out:  </span><br><span class="line">&#123;Product(id=<span class="number">1</span>, author_id=<span class="number">100001</span>, brand_id=<span class="number">2003</span>, spu_id=<span class="number">20</span>),  </span><br><span class="line"> Product(id=<span class="number">3</span>, author_id=<span class="number">100001</span>, brand_id=<span class="number">2003</span>, spu_id=<span class="number">20</span>)&#125;  </span><br><span class="line">  </span><br><span class="line">In : attr.asdict(p1)  </span><br><span class="line">Out:  </span><br><span class="line">&#123;<span class="string">'ancestor_id'</span>: <span class="number">0</span>,  </span><br><span class="line"> <span class="string">'author_id'</span>: <span class="number">100001</span>,  </span><br><span class="line"> <span class="string">'brand_id'</span>: <span class="number">2003</span>,  </span><br><span class="line"> <span class="string">'creation_time'</span>: <span class="number">100</span>,  </span><br><span class="line"> <span class="string">'id'</span>: <span class="number">1</span>,  </span><br><span class="line"> <span class="string">'item_id'</span>: <span class="string">'这是一个测试商品1'</span>,  </span><br><span class="line"> <span class="string">'n_comments'</span>: <span class="number">2000001</span>,  </span><br><span class="line"> <span class="string">'parent_id'</span>: <span class="number">0</span>,  </span><br><span class="line"> <span class="string">'source'</span>: <span class="number">1</span>,  </span><br><span class="line"> <span class="string">'spu_id'</span>: <span class="number">20</span>,  </span><br><span class="line"> <span class="string">'title'</span>: <span class="number">1002393002</span>,  </span><br><span class="line"> <span class="string">'update_time'</span>: <span class="literal">None</span>&#125;  </span><br><span class="line">   </span><br><span class="line">In : attr.asdict(p1, filter=<span class="keyword">lambda</span> a, v: a.name <span class="keyword">in</span> (<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'author_id'</span>))  </span><br><span class="line">Out: &#123;<span class="string">'author_id'</span>: <span class="number">100001</span>, <span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'title'</span>: <span class="number">1002393002</span>&#125;</span><br></pre></td></tr></table></figure>


<p>是不是清爽直观？<br>当然， 我这个例子中对属性的要求比较多，所以不同属性的参数比较长。看这个类的定义的方式是不是有点像ORM？对象和属性的关系直观，不参与类中代码逻辑。<br>有兴趣的可以看[Kenneth Reitz、Łukasz Langa、Glyph Lefkowitz等人对项目的评价]<br>(<a href="http://www.attrs.org/en/stable/index.html#testimonials)。" target="_blank" rel="noopener">http://www.attrs.org/en/stable/index.html#testimonials)。</a><br>除此之外，attrs 还支持多种高级用法，如字段类型验证、自动类型转化、属性值不可变（Immutability）、类型注解等等 ，我列3个我觉得非常有用的吧</p>
<h4 id="字段类型验证"><a href="#字段类型验证" class="headerlink" title="字段类型验证"></a>字段类型验证</h4><p>业务代码中经验会对对象属性的类型和内容验证，attrs也提供了验证支持。验证有2种方案：</p>
<ol>
<li>装饰器</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@attr.s  </span><br><span class="line"><span class="meta">... </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>    x = attr.ib()  </span><br><span class="line"><span class="meta">... </span>    @x.validator  </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, attribute, value)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> value &gt; <span class="number">42</span>:  </span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">"x must be smaller or equal to 42"</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C(<span class="number">42</span>)  </span><br><span class="line">C(x=<span class="number">42</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C(<span class="number">43</span>)  </span><br><span class="line">Traceback (most recent call last):  </span><br><span class="line">   ...  </span><br><span class="line">ValueError: x must be smaller <span class="keyword">or</span> equal to <span class="number">42</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>属性参数：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">x_smaller_than_y</span><span class="params">(instance, attribute, value)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> value &gt;= instance.y:  </span><br><span class="line"><span class="meta">... </span>        <span class="keyword">raise</span> ValueError(<span class="string">"'x' has to be smaller than 'y'!"</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@attr.s  </span><br><span class="line"><span class="meta">... </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>    x = attr.ib(validator=[attr.validators.instance_of(int),  </span><br><span class="line"><span class="meta">... </span>                           x_smaller_than_y])  </span><br><span class="line"><span class="meta">... </span>    y = attr.ib()  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C(x=<span class="number">3</span>, y=<span class="number">4</span>)  </span><br><span class="line">C(x=<span class="number">3</span>, y=<span class="number">4</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C(x=<span class="number">4</span>, y=<span class="number">3</span>)  </span><br><span class="line">Traceback (most recent call last):  </span><br><span class="line">   ...  </span><br><span class="line">ValueError: <span class="string">'x'</span> has to be smaller than <span class="string">'y'</span>!</span><br></pre></td></tr></table></figure>


<h4 id="属性类型转化"><a href="#属性类型转化" class="headerlink" title="属性类型转化"></a>属性类型转化</h4><p>Python不会检查传入的值的类型，类型错误很容易发生，attrs支持自动的类型转化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@attr.s  </span><br><span class="line"><span class="meta">... </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>    x = attr.ib(converter=int)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = C(<span class="string">"1"</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o.x</span><br></pre></td></tr></table></figure>


<h4 id="包含元数据"><a href="#包含元数据" class="headerlink" title="包含元数据"></a>包含元数据</h4><p>属性还可以包含元数据！这个真的非常有用，这个属性的值就不仅仅是一个值了，带上元数据的值非常灵活也更有意义，这样就不需要额外的把属性需要的元数据独立存储起来了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@attr.s  </span><br><span class="line"><span class="meta">... </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span>  </span><br><span class="line"><span class="meta">... </span>   x = attr.ib(metadata=&#123;<span class="string">'my_metadata'</span>: <span class="number">1</span>&#125;)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>attr.fields(C).x.metadata  </span><br><span class="line">mappingproxy(&#123;<span class="string">'my_metadata'</span>: <span class="number">1</span>&#125;)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>attr.fields(C).x.metadata[<span class="string">'my_metadata'</span>]</span><br></pre></td></tr></table></figure>


<p>通过上面支持的几个功能可以看出作者做项目就是基于实际工作痛点出发的。</p>
<h3 id="dataclasses模块"><a href="#dataclasses模块" class="headerlink" title="dataclasses模块"></a>dataclasses模块</h3><p>在Python 3.7里面会添加一个新的模块<br><a href="https://github.com/python/cpython/blob/3.7/Lib/dataclasses.py" target="_blank" rel="noopener">dataclasses</a><br>，它基于<a href="https://www.python.org/dev/peps/pep-0557/" target="_blank" rel="noopener">PEP 557</a>，Python<br>3.6可以通过pip下载安装使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install dataclasses</span><br></pre></td></tr></table></figure>


<p>解决如上痛点，把Product类改成这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime  </span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@dataclass(hash=True, order=True)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    id: int  </span><br><span class="line">    author_id: int  </span><br><span class="line">    brand_id: int  </span><br><span class="line">    spu_id: int  </span><br><span class="line">    title: str = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)  </span><br><span class="line">    item_id = int = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)  </span><br><span class="line">    n_comments = int = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)  </span><br><span class="line">    creation_time: datetime = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>,hash=<span class="literal">False</span>)  </span><br><span class="line">    update_time: datetime = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    source: str = field(default=<span class="string">''</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    parent_id: int = field(default=<span class="number">0</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)  </span><br><span class="line">    ancestor_id: int = field(default=<span class="number">0</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>


<p>先验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : p1 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品1'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">In : p2 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品2'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">In : p3 = Product(<span class="number">3</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品3'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line">In : p1  </span><br><span class="line">Out: Product(id=<span class="number">1</span>, author_id=<span class="number">100001</span>, brand_id=<span class="number">2003</span>, spu_id=<span class="number">20</span>)  </span><br><span class="line">  </span><br><span class="line">In : p1 == p2  </span><br><span class="line">Out: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In : p1 &gt; p3  </span><br><span class="line">Out: <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">In : &#123;p1, p2, p3&#125;  </span><br><span class="line">Out:  </span><br><span class="line">&#123;Product(id=<span class="number">1</span>, author_id=<span class="number">100001</span>, brand_id=<span class="number">2003</span>, spu_id=<span class="number">20</span>),  </span><br><span class="line"> Product(id=<span class="number">3</span>, author_id=<span class="number">100001</span>, brand_id=<span class="number">2003</span>, spu_id=<span class="number">20</span>)&#125;  </span><br><span class="line">  </span><br><span class="line">In : <span class="keyword">from</span> dataclasses <span class="keyword">import</span> asdict  </span><br><span class="line">  </span><br><span class="line">In : asdict(p1)  </span><br><span class="line">Out:  </span><br><span class="line">&#123;<span class="string">'ancestor_id'</span>: <span class="number">1</span>,  </span><br><span class="line"> <span class="string">'author_id'</span>: <span class="number">100001</span>,  </span><br><span class="line"> <span class="string">'brand_id'</span>: <span class="number">2003</span>,  </span><br><span class="line"> <span class="string">'creation_time'</span>: <span class="string">'这是一个测试商品1'</span>,  </span><br><span class="line"> <span class="string">'id'</span>: <span class="number">1</span>,  </span><br><span class="line"> <span class="string">'parent_id'</span>: <span class="literal">None</span>,  </span><br><span class="line"> <span class="string">'source'</span>: <span class="number">100</span>,  </span><br><span class="line"> <span class="string">'spu_id'</span>: <span class="number">20</span>,  </span><br><span class="line"> <span class="string">'title'</span>: <span class="number">1002393002</span>,  </span><br><span class="line"> <span class="string">'update_time'</span>: <span class="number">2000001</span>&#125;</span><br></pre></td></tr></table></figure>


<p>dataclasses.asdict不能过滤返回属性。但是总体满足需求。但是，你有没有发现什么不对？</p>
<h3 id="attrs-和-dataclasses"><a href="#attrs-和-dataclasses" class="headerlink" title="attrs 和 dataclasses"></a>attrs 和 dataclasses</h3><p>虽然2种方案写的代码确实有些差别，但有木有觉得它俩很像？其实attrs 的诞生远早于 dataclasses，<br>dataclasses更像是在借鉴。dataclasses可以看做是一个 <strong>强制类型注解，功能是attrs的子集</strong> 。那么为什么不把 attrs<br>放入标准库，而是Python 3.7加入一个阉割版的 attrs 呢？<br>Glyph Lefkowitz犀利的写了标题为<a href="https://github.com/ericvsmith/dataclasses/issues/19" target="_blank" rel="noopener">why not just<br>attrs?</a>的issue，我打开这个issue没往下看的时候，猜测是「由于attrs兼容Python3.6，包含Python2.7的版本，进入标准库必然是一次卸掉包袱的重构，attrs作者不同意往这个方向发展？」，翻了下讨论发现不是这样的。<br>这个issue很有意思，多个Python开发都参与进来了，最后Gvanrossum结束了讨论，明确表达不同意 attrs 进入标准库，Donald<br>Stufft也直接问了为啥？Gvanrossum虽然解释了下，但是我还是觉得这算是「仁慈的独裁者」中的「独裁」部分的体现吧，Python社区的态度一直是不太开放。包含在<br><a href="https://www.python.org/dev/peps/pep-0557/" target="_blank" rel="noopener">PEP 557</a> 下[解释为什么不用<br>attrs](<a href="https://www.python.org/dev/peps/pep-0557/#why-not-just-use-" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0557/#why-not-just-use-</a><br>attrs)，也完全说服不了我。<br>我站 attrs，向大家推荐！ 不仅是由于attrs兼容之前的Python版本，而是attrs是真的站在开发者的角度上添加功能支持，最后相信 attrs<br>会走的更远。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="http://www.attrs.org/en/stable/index.html" target="_blank" rel="noopener">http://www.attrs.org/en/stable/index.html</a></li>
<li><a href="https://glyph.twistedmatrix.com/2016/08/attrs.html" target="_blank" rel="noopener">https://glyph.twistedmatrix.com/2016/08/attrs.html</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0557/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0557/</a></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pipenv管理你的项目</title>
    <url>/2016-05-06.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚才使用pipenv发现了一个bug,<br>顺手提了个的PR。无聊之下翻了下贡献者列表，貌似没有一个我国的开发者！我的普及工作任重而道远啊，我写篇文章给大家介绍下这个终极大杀器。<br>Python开发者应该听过pip、easy_install和virtualenv，如果看过我的书应该还知道<br>virtualenvwrapper、virtualenv-burrito和autoenv，再加上pyvenv、venv（Python<br>3标准库）、pyenv…<br>额，是不是有种发懵的感觉？<br>那么现在有个好消息，你可以只使用终极方案: pipenv + autoenv（可选）。<br>「终极方案」，听起来好噱头呀。给出我的理由之前我们先了解一下Python虚拟环境和包管理的历史吧。</p>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>在Python发展史上出现了很多创建和发布包的工具。<br>当你想要把你的项目分享出去，放到PYPI或者其他托管服务上的时候，就需要借助这样的工具来构建和分发项目。早在1998年Python标准库内置了模块distutils，但是只提供了有限的支持，之后社区选择通过setuptools这个包实现构建和发布，它自带easy_install，能帮助你找到、下载、安装以及更新需要使用的包。不过依然功能很有限，比如不能删除包。<br>当你做一个专职的Python开发，独立的虚拟环境也是一个开发中迫切需要的功能，在这里请大家记住一个 Ian Bicking（下称ianb）<br>的开发者，08年，他开发了virtualenv。<br>社区一些Python核心开发者和知名项目（如Django）核心开发者也在支持和推动这件事，后来成立了pypa(Python Packaging<br>Authority)，pypa早期做的就是pip - 现在最主流的安装包的工具。再提一下，ianb也是pip的早期核心开发者。<br>不过非常遗憾，由于和社区产生了一些矛盾，ianb很早之前就不再写Python项目（可见这矛盾多大呀<br>😮），virtualenv也转给了其他开发者，这是Python社区一个极大的损失。<br>现在pip和virtualenv已经被大家所熟知，甚至可以说是Python官方的包管理和虚拟环境选择。不过其实还是有问题，我举几个例子：</p>
<ol>
<li>必须手动安装或删除某些特定版本的包，并记得定期更新requirements.txt文件，以保持项目环境的一致</li>
<li>有时项目中需要有多个requirements.txt文件，比如开发时应该用dev-requirements.txt，现有的模式不能满足这些复杂的需要</li>
<li>卸载包的时候只是卸载包自己，不能处理相关依赖，时间久了项目环境就混乱了<h3 id="pipenv-是什么？"><a href="#pipenv-是什么？" class="headerlink" title="pipenv 是什么？"></a>pipenv 是什么？</h3>Pipenv 是 Python 项目的依赖管理器。其实它不是什么先进的理念和技术，如果你熟悉 Node.js 的 npm/yarn 或 Ruby 的<br>bundler，那么就非常好理解了，它在思路上与这些工具类似。尽管pip可以安装Python包，但仍推荐使用Pipenv，因为它是一种更高级的工具，可简化依赖关系管理的常见使用情况。<br>主要特性包含：</li>
<li>根据 Pipfile 自动寻找项目根目录。</li>
<li>如果不存在，可以自动生成 Pipfile 和 Pipfile.lock。</li>
<li>自动在项目目录的 .venv 目录创建虚拟环境。（当然这个目录地址通过设置WORKON_HOME改变）</li>
<li>自动管理 Pipfile 新安装和删除的包。</li>
<li>自动更新 pip。<br><strong>对于新手和老手来说都是更好的选择。</strong><h3 id="pipenv-都包含什么？"><a href="#pipenv-都包含什么？" class="headerlink" title="pipenv 都包含什么？"></a>pipenv 都包含什么？</h3>pipenv 是 Pipfile 主要倡导者、requests 作者 Kenneth Reitz<br>写的一个命令行工具，主要包含了Pipfile、pip、click、requests和virtualenv。Pipfile和pipenv本来都是Kenneth<br>Reitz的个人项目，后来贡献给了pypa组织。Pipfile是社区拟定的依赖管理文件，用于替代过于简陋的 requirements.txt 文件。<br>Pipfile的基本理念是：</li>
<li>Pipfile 文件是 TOML 格式而不是 requirements.txt 这样的纯文本。</li>
<li>一个项目对应一个 Pipfile，支持开发环境与正式环境区分。默认提供 default 和 development 区分。</li>
<li>提供版本锁支持，存为 Pipfile.lock。<br>click是Flask作者 Armin Ronacher 写的命令行库，现在Flask已经集成了它。<br>接下来，我们看看怎么使用它吧<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3>pipenv兼容Python 2/3，我们这里以Mac下Python 3为例：<h4 id="安装pipenv"><a href="#安装pipenv" class="headerlink" title="安装pipenv"></a>安装pipenv</h4></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ brew install python3  <span class="comment"># 如果已经安装了可以忽略  </span></span><br><span class="line">❯ python3 -m pip install --upgrade --force-reinstall pip  </span><br><span class="line">❯ pip3 install pipenv --user  <span class="comment"># 推荐安装在个人目录下  </span></span><br><span class="line">❯ export PATH=<span class="string">"/Users/dongweiming/Library/Python/3.6/bin:$PATH"</span>  <span class="comment"># 把用户目录下bin放在最前面，这样可以直接使用pipenv了</span></span><br></pre></td></tr></table></figure>


<h4 id="使用pipenv"><a href="#使用pipenv" class="headerlink" title="使用pipenv"></a>使用pipenv</h4><p>用一个空目录体验一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ mkdir test_pipenv  </span><br><span class="line">❯ cd test_pipenv  </span><br><span class="line">❯ pipenv install  <span class="comment"># 创建一个虚拟环境  </span></span><br><span class="line">Creating a virtualenv <span class="keyword">for</span> this project…  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">Installing setuptools, pip, wheel...done.  </span><br><span class="line">  </span><br><span class="line">Virtualenv location: /Users/dongweiming/.virtualenvs/test_pipenv-GP_s2TW5  </span><br><span class="line">Creating a Pipfile <span class="keyword">for</span> this project…  </span><br><span class="line">Pipfile.lock <span class="keyword">not</span> found, creating…  </span><br><span class="line">Locking [dev-packages] dependencies…  </span><br><span class="line">Locking [packages] dependencies…  </span><br><span class="line">Updated Pipfile.lock (c23e27)!  </span><br><span class="line">Installing dependencies <span class="keyword">from</span> Pipfile.lock (c23e27)…  </span><br><span class="line">  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ <span class="number">0</span>/<span class="number">0</span> — <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  </span><br><span class="line">To activate this project<span class="string">'s virtualenv, run the following:  </span></span><br><span class="line"><span class="string"> $ pipenv shell  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">❯ which python3  </span></span><br><span class="line"><span class="string">/usr/local/Cellar/python3/3.6.1/bin/python3  # 还是mac自带的Python  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">❯ pipenv shell  # 激活虚拟环境  </span></span><br><span class="line"><span class="string">Spawning environment shell (/bin/zsh). Use '</span>exit<span class="string">' to leave.  </span></span><br><span class="line"><span class="string">source /Users/dongweiming/.virtualenvs/test_pipenv-GP_s2TW5/bin/activate  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">❯ which python3  # 已经在虚拟环境里了  </span></span><br><span class="line"><span class="string">/Users/dongweiming/.virtualenvs/test_pipenv-GP_s2TW5/bin/python3  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">❯ exit  # 退出虚拟环境  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">❯ which python3  </span></span><br><span class="line"><span class="string">/usr/local/Cellar/python3/3.6.1/bin/python3</span></span><br></pre></td></tr></table></figure>


<p>以上就是原来virtualenv的基本用法了。我们看一下当前目录现在是什么样子的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ ls  </span><br><span class="line">Pipfile  Pipfile.lock</span><br></pre></td></tr></table></figure>


<p>这个环境下目前什么都没有。我们安装2个包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pipenv install elasticsearch-dsl requests  </span><br><span class="line">Installing elasticsearch-dsl…  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">Adding elasticsearch-dsl to Pipfile<span class="string">'s [packages]…  </span></span><br><span class="line"><span class="string">Installing requests…  </span></span><br><span class="line"><span class="string">...  </span></span><br><span class="line"><span class="string">Adding requests to Pipfile'</span>s [packages]…  </span><br><span class="line">  PS: You have excellent taste! ✨ 🍰 ✨  </span><br><span class="line">Locking [dev-packages] dependencies…  </span><br><span class="line">Locking [packages] dependencies…  </span><br><span class="line">Updated Pipfile.lock (<span class="number">8</span>d307d)!</span><br></pre></td></tr></table></figure>


<p>现在Pipfile.lock已经更新了，包含了 elasticsearch-dsl、requests 和相关依赖的包信息。<br>另外如果你添加–two或–three标志到上面的最后一个命令，它分别使用Python 2或3来初始化你的项目。 否则将使用默认版本的Python。<br>可以看一下依赖关系：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pipenv graph  </span><br><span class="line">elasticsearch-dsl==<span class="number">6.1</span><span class="number">.0</span>  </span><br><span class="line">  - elasticsearch [required: &lt;<span class="number">7.0</span><span class="number">.0</span>,&gt;=<span class="number">6.0</span><span class="number">.0</span>, installed: <span class="number">6.1</span><span class="number">.1</span>]  </span><br><span class="line">    - urllib3 [required: &lt;<span class="number">1.23</span>,&gt;=<span class="number">1.21</span><span class="number">.1</span>, installed: <span class="number">1.22</span>]  </span><br><span class="line">  - ipaddress [required: Any, installed: <span class="number">1.0</span><span class="number">.19</span>]  </span><br><span class="line">  - python-dateutil [required: Any, installed: <span class="number">2.6</span><span class="number">.1</span>]  </span><br><span class="line">    - six [required: &gt;=<span class="number">1.5</span>, installed: <span class="number">1.10</span><span class="number">.0</span>]  </span><br><span class="line">  - six [required: Any, installed: <span class="number">1.10</span><span class="number">.0</span>]  </span><br><span class="line">requests==<span class="number">2.18</span><span class="number">.4</span>  </span><br><span class="line">  - certifi [required: &gt;=<span class="number">2017.4</span><span class="number">.17</span>, installed: <span class="number">2017.11</span><span class="number">.5</span>]  </span><br><span class="line">  - chardet [required: &lt;<span class="number">3.1</span><span class="number">.0</span>,&gt;=<span class="number">3.0</span><span class="number">.2</span>, installed: <span class="number">3.0</span><span class="number">.4</span>]  </span><br><span class="line">  - idna [required: &lt;<span class="number">2.7</span>,&gt;=<span class="number">2.5</span>, installed: <span class="number">2.6</span>]  </span><br><span class="line">  - urllib3 [required: &lt;<span class="number">1.23</span>,&gt;=<span class="number">1.21</span><span class="number">.1</span>, installed: <span class="number">1.22</span>]</span><br></pre></td></tr></table></figure>


<p>可以看到，他俩都依赖了urllib3。虽然现在pipenv不能直接卸载包及其依赖，但是由于它提供了良好的接口，我们还是可以实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pipenv uninstall `pipenv graph --json |python3 depends.py requests`  </span><br><span class="line">Un-installing certifi…  </span><br><span class="line">Uninstalling certifi<span class="number">-2017.11</span><span class="number">.5</span>:  </span><br><span class="line">  Successfully uninstalled certifi<span class="number">-2017.11</span><span class="number">.5</span>  </span><br><span class="line">  </span><br><span class="line">No package certifi to remove <span class="keyword">from</span> Pipfile.  </span><br><span class="line">Un-installing requests…  </span><br><span class="line">Uninstalling requests<span class="number">-2.18</span><span class="number">.4</span>:  </span><br><span class="line">  Successfully uninstalled requests<span class="number">-2.18</span><span class="number">.4</span>  </span><br><span class="line">  </span><br><span class="line">Removing requests <span class="keyword">from</span> Pipfile…  </span><br><span class="line">Un-installing idna…  </span><br><span class="line">Uninstalling idna<span class="number">-2.6</span>:  </span><br><span class="line">  Successfully uninstalled idna<span class="number">-2.6</span>  </span><br><span class="line">  </span><br><span class="line">No package idna to remove <span class="keyword">from</span> Pipfile.  </span><br><span class="line">Un-installing chardet…  </span><br><span class="line">Uninstalling chardet<span class="number">-3.0</span><span class="number">.4</span>:  </span><br><span class="line">  Successfully uninstalled chardet<span class="number">-3.0</span><span class="number">.4</span>  </span><br><span class="line">  </span><br><span class="line">No package chardet to remove <span class="keyword">from</span> Pipfile.  </span><br><span class="line">Locking [dev-packages] dependencies…  </span><br><span class="line">Locking [packages] dependencies…  </span><br><span class="line">Updated Pipfile.lock (c05ac4)!</span><br></pre></td></tr></table></figure>


<p>其中depends.py脚本会解析依赖关系，排除其他包依赖的项目然后删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat depends.py  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">import</span> json  </span><br><span class="line">  </span><br><span class="line">package = sys.argv[<span class="number">1</span>]  </span><br><span class="line">other_dependencies = set()  </span><br><span class="line">removing_dependencies = set([package])  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> json.load(sys.stdin):  </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> i[<span class="string">'dependencies'</span>]:  </span><br><span class="line">        key = p[<span class="string">'key'</span>]  </span><br><span class="line">        <span class="keyword">if</span> i[<span class="string">'package'</span>][<span class="string">'key'</span>] == package:  </span><br><span class="line">            removing_dependencies.add(key)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            other_dependencies.add(key)  </span><br><span class="line">  </span><br><span class="line">print(<span class="string">' '</span>.join(removing_dependencies - other_dependencies))</span><br></pre></td></tr></table></figure>


<p>再看一下现在环境中的包依赖关系：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pipenv graph  </span><br><span class="line">elasticsearch-dsl==<span class="number">6.1</span><span class="number">.0</span>  </span><br><span class="line">  - elasticsearch [required: &gt;=<span class="number">6.0</span><span class="number">.0</span>,&lt;<span class="number">7.0</span><span class="number">.0</span>, installed: <span class="number">6.1</span><span class="number">.1</span>]  </span><br><span class="line">    - urllib3 [required: &gt;=<span class="number">1.21</span><span class="number">.1</span>,&lt;<span class="number">1.23</span>, installed: <span class="number">1.22</span>]  </span><br><span class="line">  - ipaddress [required: Any, installed: <span class="number">1.0</span><span class="number">.19</span>]  </span><br><span class="line">  - python-dateutil [required: Any, installed: <span class="number">2.6</span><span class="number">.1</span>]  </span><br><span class="line">    - six [required: &gt;=<span class="number">1.5</span>, installed: <span class="number">1.10</span><span class="number">.0</span>]  </span><br><span class="line">  - six [required: Any, installed: <span class="number">1.10</span><span class="number">.0</span>]</span><br></pre></td></tr></table></figure>


<p>是不是很干净呢？</p>
<h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><p>除了上述基本功能以外，pipenv还有很多附加的功能，我举几个日常比较常用的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pipenv run which python <span class="comment"># 「pipenv run」可以激活虚拟环境，并使用shell命令  </span></span><br><span class="line">/Users/dongweiming/.virtualenvs/test_pipenv-GP_s2TW5/bin/python  </span><br><span class="line">❯ pipenv check  <span class="comment"># 检查装的包的安全性  </span></span><br><span class="line">Checking PEP <span class="number">508</span> requirements…  </span><br><span class="line">Passed!  </span><br><span class="line">Checking installed package safety…  </span><br><span class="line">All good!  </span><br><span class="line">❯ pipenv --man  <span class="comment"># 传统的看文档的方法  </span></span><br><span class="line">❯ pipenv check --style depends.py  <span class="comment"># 代码Flake8检查，在这里我修改了depends.py让它故意有问题  </span></span><br><span class="line">/Users/dongweiming/test_pipenv/depends.py:<span class="number">1</span>:<span class="number">1</span>: F401 <span class="string">'os'</span> imported but unused</span><br></pre></td></tr></table></figure>


<p>另外由于autoenv也是Kenneth Reitz写的，所以pipenv默认也包含了对.env文件的支持。<br>是不是方便很多呢？</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>slack-alert把定时任务的结果发送slack消息的微框架</title>
    <url>/2016-05-11.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>为什么要做<a href="https://github.com/dongweiming/slack-alert" target="_blank" rel="noopener">slack-alert</a>呢?<br>成因其实是我一直想做的AST相关的一个项目.<br>正好是一个机会. 其次也是业务需要:<br>工程师都比较懒, 在每天的各种问题邮件几百几千封的时候会经常遗漏重要的邮件. 会经常被用户以及公司其他同事发现问题时@到时候才发现.<br>现在大家也接受了slack这个工具. 那么我就在想何不把更重要的消息发送到slack里呢.<br>原来也做过, 就是写一些脚本,<br>会把运行的结果通过<a href="https://github.com/os/slacker" target="_blank" rel="noopener">slacker</a>里面封装的<a href="https://api.slack.com/methods/chat.postMessage" target="_blank" rel="noopener">postMessage</a>发消息进来.<br>先说一下为什么我不用<a href="https://api.slack.com/incoming-webhooks" target="_blank" rel="noopener">Incoming-webhooks</a>. 最主要的,<br>因为通常slack都是用的免费版, 我担心对webhooks会有限制或者未来会有限制.<br>但是为什么做这个<code>微框架</code>呢? 一则这样的脚本和任务会越来越多, 脚本需要设置的定时任务的间隔也会各不相同. 用系统自带的crontab,<br>每次新增修改删除都要去做调整.<br>代码还需要做抽象; 用celery, rq这些其实一是很浪费, 二也不怎么应景. 所以我写了这个工具.</p>
<h4 id="优点和特点"><a href="#优点和特点" class="headerlink" title="优点和特点"></a>优点和特点</h4><ol>
<li>只支持python3</li>
<li>支持多种调度模式: AsyncIOScheduler, BackgroundScheduler, GeventScheduler, TornadoScheduler. 默认是AsyncIO</li>
<li>使用<a href="https://docs.python.org/3/library/ast.html" target="_blank" rel="noopener">AST</a>, 而没有直接import代码.</li>
<li>代码和项目无关, 没有register. 只需要按格式编写plugin脚本即可, 要被执行的任务加一个装饰器(只需要他是一个装饰器, 不需要存在). 指定运行的间隔就好</li>
<li>附带常用的配置<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install slack-alert</span><br></pre></td></tr></table></figure>


<p>slack-alert有个默认的配置[slack_alert.conf](<a href="https://github.com/dongweiming/slack-" target="_blank" rel="noopener">https://github.com/dongweiming/slack-</a><br>alert/blob/master/slack_alert.conf).<br>使用<code>OS X</code>或者<code>linux</code>可以拷贝到 <code>~/.config/slack_alert.conf</code></p>
<h4 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h4><p>PS: 插件目录默认是当前目录的<code>plugins</code>子目录下.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tree plugins  </span><br><span class="line">plugins  </span><br><span class="line">├── examples.py  </span><br><span class="line">  </span><br><span class="line"><span class="number">0</span> directories, <span class="number">1</span> files</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@deco(seconds=2)  # 这个一个正确格式的任务, 因为装饰器里面包含`hours|seconds|minutes|days`这样的键.  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span>  </span><br><span class="line">    print(<span class="number">1</span>)  <span class="comment"># 插件也需要python3的语法  </span></span><br><span class="line">    print(os)  <span class="comment"># 可以使用外部的变量  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 这个返回值最后会被发送到slack的channel里面  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span>  <span class="comment"># 这个函数因为没有对应的格式的装饰器 他不会被当做一个任务  </span></span><br><span class="line">    print(<span class="number">3</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@deco2(xx=1)  </span></span><br><span class="line"><span class="meta">@deco(minutes=2, seconds=30)  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">()</span>:</span>  <span class="comment"># 这个函数也不是一个正确格式的装饰器. 我需要把`deco`放在最外面  </span></span><br><span class="line">    print(<span class="number">4</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>


<p>PS: 大家不要迷惑为什么<code>deco</code>这个函数没有介绍. 因为我只需要这个代码文本. 我其实不直接运行这个脚本. 所以不需要装饰器存在.</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">slack-alert</span><br></pre></td></tr></table></figure>


<p>这样就启动了.<br><code>a</code>这个函数就会每隔2秒运行一次， 运行三次后, 停顿60分钟… 这样循环(高级用法看下面的参数). 并且把结果发送到slack里面</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol>
<li>启动<code>slack-alert</code> 我首先加载配置.</li>
<li>我会根据配置<code>--path</code>去找我应该去哪个文件目录下(默认是当前目录)的<code>plugins</code>子目录下去找符合的任务程序.</li>
<li>加载符合的目录下的每个python文件. 生成一个AST(抽象语法树).</li>
<li>遍历这棵树. 找到符合我需要的语法的函数. 去掉这个实际不存在的装饰器. 编译源码并且执行. 生成一个命名空间</li>
<li>获取这个命名空间的参数, 通过<a href="http://apscheduler.readthedocs.org/en/latest/" target="_blank" rel="noopener">apscheduler</a>. 添加一个任务</li>
<li>添加全部任务. 再添加一个监控这些任务的任务(主要是用来在某些时机停掉/启动其他某些任务)</li>
<li>启动任务调度. 直到<code>Ctrl+C</code><h4 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项</h4>可以参照源码的选项:</li>
<li><a href="https://github.com/dongweiming/slack-alert#config-files-options" target="_blank" rel="noopener">Config file”s Options</a></li>
<li><a href="https://github.com/dongweiming/slack-alert#command-options" target="_blank" rel="noopener">Command Options</a></li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会python嘛?</title>
    <url>/2016-05-07.html</url>
    <content><![CDATA[<p>####前言<br>我这个博客一直都是一些技术分享,show code的地方，我从来没有写过个人生活或者情感杂谈,当然我也从来没有谈论过我对什么东西的喜恶.<br>很多人喜欢喷XX语言，喜欢谈论XX和YY的优缺,甚至凑了一本不知所云的书…好吧,我觉得没有使用一门语言超过10年，没有对一个技术研究个5,6年，<br>不好意思说自己懂(天才除外).我也觉得我没有资格讨论什么，也许我有我的观点看法，但是我怀着怀疑的心态看自己，生怕自己理解错了.<br>下文纯属个人吐槽,也许没有指定路怎么走，只是希望提个醒…<br>使用python2年，可喜的是python被越来越多的人接受，甚至前端工程师…但是却有点烂大街的感觉:感觉出门不聊几句python都不好意思和人打招呼.但是你真的懂python嘛?<br>####你会python真的不重要<br>python实在太好学习了,假如你会其它的语言，可能搞本书翻一翻，一周后就能写很高端的python程序，由于web框架的普及，你甚至可以让一个网站应用跑起来.<br>你会我也会，你有什么竞争力?<br>####你知道python怎么用嘛?</p>
<ol>
<li>在什么时候需要使用OOP？</li>
<li>在什么时候使用类装饰器?</li>
<li>你用过元类嘛?</li>
<li>在什么时候用静态方法什么时候使用类方法?</li>
<li>你了解那些管理属性? <code>__call__</code> , <code>__init__</code> , <code>__new__</code>都是在什么时候被触发?<code>__getattr__</code>和<code>__getattribute__</code>应用有什么不同?</li>
<li>你知道标准库里面的多少个模块?你能在需要的时候知道这个功能其实标准库里面已经实现了?</li>
<li>什么时候用回调？</li>
<li>什么时候用signal？假如你会django你知道django的signal是什么?你了解orm嘛?</li>
<li>asyncore，contextlib， functools， collections， heapq，itertools， SocketServer， weakref，operator(知道3个就算)这些你会几个？</li>
<li>python的多态是什么?</li>
<li>在什么场景可以尝试python的设计模式中的XX(能想到2个场景就算)?</li>
<li>在什么时候可以使用Mixin？</li>
<li>在什么时候可以使用python的闭包？</li>
<li>你曾经用过yield嘛？生成器和迭代器的区别和应用场景是什么?</li>
<li>在什么可以使用python的函数式编程?</li>
<li><strong>future</strong> 模块里面都有什么定义的用法?<br>提笔想了这上面16点我认为体现python的东西，假如你不能有效的回答上面1/4,<br>好吧不要和我说你原来是会python的，踏实下来..你的路还很长.假如你回答不超过一半,我提醒你-你只是刚入行而已(这是我的角度)<h4 id="假如我是一个入职后的带新人的引导者"><a href="#假如我是一个入职后的带新人的引导者" class="headerlink" title="假如我是一个入职后的带新人的引导者"></a>假如我是一个入职后的带新人的引导者</h4></li>
<li>学好git… 呵呵</li>
<li>假如新人还不熟悉python,python_koans是个不错的入门选择</li>
<li>首先就是严格的代码规范，加上团队的文化以及风格.</li>
<li>我会给一个任务，比如一周内写个多线程的socket命令行聊天程序,支持群组，加好友，群聊，发送文件等功能，看新人能力而定</li>
<li>而后把项目一部分略棘手的工作教给他，注意这里是生产环境，在他完成任务的过程中会熟悉我们的上线/code review/代码风格等东西</li>
<li>我希望整个团队一起贡献一个基础的公共库，包含一些常用的功能，然后新人首先学习这些东西，以后就不需要浪费时间造轮子，但是可以修改完善公共库，<br>这个公共库可以在新服务器部署时候直接使用pypi或者ubuntuPPA安装进来<h4 id="什么算是好的python代码"><a href="#什么算是好的python代码" class="headerlink" title="什么算是好的python代码?"></a>什么算是好的python代码?</h4>假如你的代码没使用pep8检验过，你….<br>最差你也要使用<a href="https://github.com/hhatto/autopep8" target="_blank" rel="noopener">autopep8</a>格式化差劲的代码吧?如果你想对自己的代码质量有要求，我强烈建议你了解什么是pythonic:</li>
<li>doughellmann(&lt;python标准库&gt;的作者)的<a href="http://www.slideshare.net/doughellmann/an-introduction-to-the-zen-of-python" target="_blank" rel="noopener">an-introduction-to-the-zen-of-python</a></li>
<li><a href="http://sssslide.com/www.slideshare.net/hychen/be-pythonic-14859746" target="_blank" rel="noopener">be-pythonic</a><h4 id="代码易懂但是堆了很多-代码难懂但是精炼之间的取舍"><a href="#代码易懂但是堆了很多-代码难懂但是精炼之间的取舍" class="headerlink" title="代码易懂但是堆了很多/代码难懂但是精炼之间的取舍"></a>代码易懂但是堆了很多/代码难懂但是精炼之间的取舍</h4>我想很多对代码有追求的人, 会看见项目中存在大量，没有被重用的函数，似曾相似的方法甚至方法的名字…<br>我是极为见不得ugly或者华而不实的代码的人, 但是有个问题.<br>我封装的代码很不直观，难懂..原来的代码貌似极为好懂.每个人都有自己的理解吧.就象我的团队里面有人说django代码太难懂，因为它们有django项目组的文化…<br>celery代码写的不好这样的安慰似的评论…但是我不这样认为,我还在读celery代码，我也承认里面是有作者风格的取名或者实现的方式，但是我学到了很多.<br>通过看开源代码，比如django，requests，flask.<br>我会发现和总结很多别人的用法，思考别人为啥这样用.比如项目代码目录结构，解决一些问题使用的方式. 还有一些pep8中没有提到的规范.<br>比如一些代码实用的风格，举个例子：<br>我们的代码引用其它模块是这样的:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> long_long_long_test1  </span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> long_long_long_test2  </span><br><span class="line">form test <span class="keyword">import</span> long_long_long_test3</span><br></pre></td></tr></table></figure>


<p>省略20多行，很脑残吧? 有一种风格是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> long_long_long_test1, \  </span><br><span class="line">                 long_long_long_test2, \  </span><br><span class="line">                 long_long_long_test3</span><br></pre></td></tr></table></figure>


<p>说一个技巧:当我不知道该用什么，去看很NB项目怎么用<br>结果django和requests是这样的风格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> (long_long_long_test1,  </span><br><span class="line">                  long_long_long_test2,  </span><br><span class="line">                  long_long_long_test3)</span><br></pre></td></tr></table></figure>


<p>怎么样进步?不是闭门造车..先去看看别人是怎么用的..<br>比如我以前拼接一个文件路径都是这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'&#123;0&#125;/&#123;1&#125;'</span>.fotmat(dir, filename)</span><br></pre></td></tr></table></figure>


<p>其实人家本来有:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">os.path.join(dir, filename)</span><br></pre></td></tr></table></figure>


<p>很惭愧.然后花了半个小时，把以前我这样用的地方全改了<br>这是我说的重要的一点: 知道了什么是对的 就要改….<br>对于这个主题, 我的答案是: 我喜欢难懂但是精炼的代码. 境界就是你看的懂就能写的出来.<br>假如你连这点代码都看不懂.你看不了开源项目的做法.你会一直是个堆代码的码农..你会一直在堆着垃圾的代码.你会增加未来接手人的维护成本</p>
<h4 id="怎么样提高python可读性和质量"><a href="#怎么样提高python可读性和质量" class="headerlink" title="怎么样提高python可读性和质量"></a>怎么样提高python可读性和质量</h4><p>以下是我的想法</p>
<ol>
<li>首先给函数/类/方法取个好懂的名字(我这点很失败，英语太烂…是不是应该加一个学好英语)</li>
<li>当一个差不多的操作出现了三次，不要继续堆代码，要抽象出来</li>
<li>我倾向于写FIXME，TODO, 写文件/函数的用途的注释，在不是很好理解的代码上面注释作用，标明输入和输出都是什么(如果不是要修改维护你的代码，没人在乎你的算法多NB)</li>
<li>上面说的，请不要让别人需要仔细研究你的代码才明白是什么意思.. 我写代码很有压力，因为我不想以后维护我代码的人骂我.</li>
<li>不要炫技，请不要乱用函数式编程/闭包.我在乎的是性能和简单粗暴的实现功能</li>
<li>多用标准库的实现，如果不知道有这个功能实现前先google.</li>
<li>多读有名的项目，github上面有很多.思考别人为什么这样用<br>….<h4 id="我们是封装开源项目还是直接修改开源代码给自己用"><a href="#我们是封装开源项目还是直接修改开源代码给自己用" class="headerlink" title="我们是封装开源项目还是直接修改开源代码给自己用"></a>我们是封装开源项目还是直接修改开源代码给自己用</h4>其实我这样描述,比如有个项目因为历史原因是一个很早的版本.但是和其它新的版本组件有兼容问题以及我们业务的特殊需要.我看了源码发现需要改动几个地方.<br>问题改动后就需要自己维护这个项目，对于新部署的环境甚至其它版本我还继续需要这个变动. 还有一种声音是”你不能修改XX源码”,你要在上面封装出一个新的东西，<br>也就是不直接调用XX，而是在我的自己的项目对XX有了个封装YY，然后我们的调用YY.<br>我觉得这个东西自己部署是一个可行的方案，首先这个修改不是一个patch，不是主流的修改.只能算是我们业务的二次开发而已，封装只是在掩耳盗铃.<br>着让我想起一个问题:为什么中国鲜有好的开源项目:中国人不缺好的idea?是因为中国人觉得这件事情做不了，是因为它们觉得别人实现的就是很牛比的，<br>自己改了就会有问题…其实这是自卑..首先是代码就会有bug，tornado/flask/requests不还是在开发和解决问题嘛？bug一直在只是你没有发现和注意.<br>我觉得开源项目的代码看懂了，了解了就可以修改..没什么可担心的…我指的是角度.我觉得每个人学了一门语言看了某个项目的源码只要你有胆量，<br>你有一个怀疑的善于发现和思考的心，那么你都能贡献你的代码，做你的二次开发.<br>和本文相关: 如果你没有做过这件事，你怎么可以说你会python?<h4 id="我的感想"><a href="#我的感想" class="headerlink" title="我的感想"></a>我的感想</h4>我不赞同”做好工作就好了”的调调.对你个人来说你明年今天做的事情和现在是一样的，不同的是你老了一岁.<br>如果是为了完成工作而完成工作. 其实你这个代码就是线上运行的代码，并且是以后很长时间再用的版本，你随意的一些代码会在很久之后很难的变动..<br>我也不同意一上来就把你的程序写的能承受千万级PV的架构.我认为对于现在项目状态，我要思考大约未来一年可能的发展，它如何简单的扩展就好了..</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ipython的一些高级用法(一)</title>
    <url>/2016-05-10.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>以前在我的PPT[python高级编程](<a href="http://dongweiming.github.io/Expert-" target="_blank" rel="noopener">http://dongweiming.github.io/Expert-</a><br>Python/)也提到了一些关于ipython的用法. 今天继续由浅入深的看看ipython,<br>本文作为读者的你已经知道ipython并且用了一段时间了.</p>
<h5 id="run"><a href="#run" class="headerlink" title="%run"></a>%run</h5><p>这是一个magic命令, 能把你的脚本里面的代码运行, 并且把对应的运行结果存入ipython的环境变量中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$cat t.py  </span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line">l = range(<span class="number">5</span>)  </span><br><span class="line">  </span><br><span class="line">$ipython  </span><br><span class="line">In [<span class="number">1</span>]: %run t.py <span class="comment"># `%`可加可不加  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: l <span class="comment"># 这个l本来是t.py里面的变量, 这里直接可以使用了  </span></span><br><span class="line">Out[<span class="number">2</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>


<h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: %alias largest ls <span class="number">-1</span>sSh | grep %s  </span><br><span class="line">In [<span class="number">4</span>]: largest to  </span><br><span class="line">total <span class="number">42</span>M  </span><br><span class="line"> <span class="number">20</span>K tokenize.py  </span><br><span class="line"> <span class="number">16</span>K tokenize.pyc  </span><br><span class="line"><span class="number">8.0</span>K story.html  </span><br><span class="line"><span class="number">4.0</span>K autopep8  </span><br><span class="line"><span class="number">4.0</span>K autopep8.bak  </span><br><span class="line"><span class="number">4.0</span>K story_layout.html</span><br></pre></td></tr></table></figure>


<p>PS 别名需要存储的, 否则重启ipython就不存在了:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: %store largest  </span><br><span class="line">Alias stored: largest (ls <span class="number">-1</span>sSh | grep %s)</span><br></pre></td></tr></table></figure>


<p>下次进入的时候<code>%store -r</code></p>
<h5 id="bookmark-对目录做别名"><a href="#bookmark-对目录做别名" class="headerlink" title="bookmark - 对目录做别名"></a>bookmark - 对目录做别名</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: %pwd  </span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">u'/home/vagrant'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: %bookmark dongxi ~/shire/dongxi  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: %cd dongxi  </span><br><span class="line">/home/vagrant/shire/dongxi_code  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: %pwd  </span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">u'/home/vagrant/shire/dongxi_code'</span></span><br></pre></td></tr></table></figure>


<h5 id="ipcluster-并行计算"><a href="#ipcluster-并行计算" class="headerlink" title="ipcluster - 并行计算"></a>ipcluster - 并行计算</h5><p>其实ipython提供的方便的并行计算的功能. 先回答ipython做并行计算的特点:<br>1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$wget http://www.gutenberg.org/files/<span class="number">27287</span>/<span class="number">27287</span><span class="number">-0.</span>txt</span><br></pre></td></tr></table></figure>


<p>第一个版本是直接的, 大家习惯的用法.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> re  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> io  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: non_word = re.compile(<span class="string">r'[\W\d]+'</span>, re.UNICODE)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: common_words = &#123;  </span><br><span class="line">   ...: <span class="string">'the'</span>,<span class="string">'of'</span>,<span class="string">'and'</span>,<span class="string">'in'</span>,<span class="string">'to'</span>,<span class="string">'a'</span>,<span class="string">'is'</span>,<span class="string">'it'</span>,<span class="string">'that'</span>,<span class="string">'which'</span>,<span class="string">'as'</span>,<span class="string">'on'</span>,<span class="string">'by'</span>,  </span><br><span class="line">   ...: <span class="string">'be'</span>,<span class="string">'this'</span>,<span class="string">'with'</span>,<span class="string">'are'</span>,<span class="string">'from'</span>,<span class="string">'will'</span>,<span class="string">'at'</span>,<span class="string">'you'</span>,<span class="string">'not'</span>,<span class="string">'for'</span>,<span class="string">'no'</span>,<span class="string">'have'</span>,  </span><br><span class="line">   ...: <span class="string">'i'</span>,<span class="string">'or'</span>,<span class="string">'if'</span>,<span class="string">'his'</span>,<span class="string">'its'</span>,<span class="string">'they'</span>,<span class="string">'but'</span>,<span class="string">'their'</span>,<span class="string">'one'</span>,<span class="string">'all'</span>,<span class="string">'he'</span>,<span class="string">'when'</span>,  </span><br><span class="line">   ...: <span class="string">'than'</span>,<span class="string">'so'</span>,<span class="string">'these'</span>,<span class="string">'them'</span>,<span class="string">'may'</span>,<span class="string">'see'</span>,<span class="string">'other'</span>,<span class="string">'was'</span>,<span class="string">'has'</span>,<span class="string">'an'</span>,<span class="string">'there'</span>,  </span><br><span class="line">   ...: <span class="string">'more'</span>,<span class="string">'we'</span>,<span class="string">'footnote'</span>, <span class="string">'who'</span>, <span class="string">'had'</span>, <span class="string">'been'</span>,  <span class="string">'she'</span>, <span class="string">'do'</span>, <span class="string">'what'</span>,  </span><br><span class="line">   ...: <span class="string">'her'</span>, <span class="string">'him'</span>, <span class="string">'my'</span>, <span class="string">'me'</span>, <span class="string">'would'</span>, <span class="string">'could'</span>, <span class="string">'said'</span>, <span class="string">'am'</span>, <span class="string">'were'</span>, <span class="string">'very'</span>,  </span><br><span class="line">   ...: <span class="string">'your'</span>, <span class="string">'did'</span>, <span class="string">'not'</span>,  </span><br><span class="line">   ...: &#125;  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: <span class="function"><span class="keyword">def</span> <span class="title">yield_words</span><span class="params">(filename)</span>:</span>  </span><br><span class="line">   ...:     <span class="keyword">import</span> io  </span><br><span class="line">   ...:     <span class="keyword">with</span> io.open(filename, encoding=<span class="string">'latin-1'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">   ...:         <span class="keyword">for</span> line <span class="keyword">in</span> f:  </span><br><span class="line">   ...:             <span class="keyword">for</span> word <span class="keyword">in</span> line.split():  </span><br><span class="line">   ...:                 word = non_word.sub(<span class="string">''</span>, word.lower())  </span><br><span class="line">   ...:                 <span class="keyword">if</span> word <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> common_words:  </span><br><span class="line">   ...:                     <span class="keyword">yield</span> word  </span><br><span class="line">   ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">6</span>]: <span class="function"><span class="keyword">def</span> <span class="title">word_count</span><span class="params">(filename)</span>:</span>  </span><br><span class="line">   ...:     word_iterator = yield_words(filename)  </span><br><span class="line">   ...:     counts = &#123;&#125;  </span><br><span class="line">   ...:     counts = defaultdict(int)  </span><br><span class="line">   ...:     <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">   ...:         <span class="keyword">try</span>:  </span><br><span class="line">   ...:             word = next(word_iterator)  </span><br><span class="line">   ...:         <span class="keyword">except</span> StopIteration:  </span><br><span class="line">   ...:             <span class="keyword">break</span>  </span><br><span class="line">   ...:         <span class="keyword">else</span>:  </span><br><span class="line">   ...:             counts[word] += <span class="number">1</span>  </span><br><span class="line">   ...:     <span class="keyword">return</span> counts  </span><br><span class="line">   ...:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict <span class="comment"># 脑残了 忘记放进去了..  </span></span><br><span class="line">In [<span class="number">7</span>]: %time counts = word_count(filename)  </span><br><span class="line">CPU times: user <span class="number">88.5</span> ms, sys: <span class="number">2.48</span> ms, total: <span class="number">91</span> ms  </span><br><span class="line">Wall time: <span class="number">89.3</span> ms</span><br></pre></td></tr></table></figure>


<p>现在用ipython来跑一下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ipcluster start -n <span class="number">2</span> <span class="comment"># 好吧, 我的Mac是双核的</span></span><br></pre></td></tr></table></figure>


<p>先讲下ipython 并行计算的用法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> IPython.parallel <span class="keyword">import</span> Client <span class="comment"># import之后才能用%px*的magic  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: rc = Client()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: rc.ids <span class="comment"># 因为我启动了2个进程  </span></span><br><span class="line">Out[<span class="number">3</span>]: [<span class="number">0</span>, <span class="number">1</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: %autopx <span class="comment"># 如果不自动 每句都需要: `%px xxx`  </span></span><br><span class="line">%autopx enabled  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">5</span>]: <span class="keyword">import</span> os <span class="comment"># 这里没autopx的话 需要: `%px import os`  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">print</span> os.getpid() <span class="comment"># 2个进程的pid  </span></span><br><span class="line">[stdout:<span class="number">0</span>] <span class="number">62638</span>  </span><br><span class="line">[stdout:<span class="number">1</span>] <span class="number">62636</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: %pxconfig --targets <span class="number">1</span> <span class="comment"># 在autopx下 这个magic不可用  </span></span><br><span class="line">[stderr:<span class="number">0</span>] ERROR: Line magic function `%pxconfig` <span class="keyword">not</span> found.  </span><br><span class="line">[stderr:<span class="number">1</span>] ERROR: Line magic function `%pxconfig` <span class="keyword">not</span> found.  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">8</span>]: %autopx <span class="comment"># 再执行一次就会关闭autopx  </span></span><br><span class="line">%autopx disabled  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">10</span>]: %pxconfig --targets <span class="number">1</span> <span class="comment"># 指定目标对象, 这样下面执行的代码就会只在第2个进程下运行  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">11</span>]: %%px --noblock <span class="comment"># 其实就是执行一段非阻塞的代码  </span></span><br><span class="line">   ....: <span class="keyword">import</span> time  </span><br><span class="line">   ....: time.sleep(<span class="number">1</span>)  </span><br><span class="line">   ....: os.getpid()  </span><br><span class="line">   ....:  </span><br><span class="line">Out[<span class="number">11</span>]: &lt;AsyncResult: execute&gt;  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">12</span>]: %pxresult <span class="comment"># 看 只返回了第二个进程的pid  </span></span><br><span class="line">Out[<span class="number">1</span>:<span class="number">21</span>]: <span class="number">62636</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">13</span>]: v = rc[:] <span class="comment"># 使用全部的进程, ipython可以细粒度的控制那个engine执行的内容  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">14</span>]: <span class="keyword">with</span> v.sync_imports(): <span class="comment"># 每个进程都导入time模块  </span></span><br><span class="line">   ....:     <span class="keyword">import</span> time  </span><br><span class="line">   ....:  </span><br><span class="line">importing time on engine(s)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">15</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span>  </span><br><span class="line">   ....:     time.sleep(<span class="number">1</span>)  </span><br><span class="line">   ....:     <span class="keyword">return</span> x * x  </span><br><span class="line">   ....:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">16</span>]: v.map_sync(f, range(<span class="number">10</span>)) <span class="comment"># 同步的执行  </span></span><br><span class="line">  </span><br><span class="line">Out[<span class="number">16</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">17</span>]: r = v.map(f, range(<span class="number">10</span>)) <span class="comment"># 异步的执行  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">18</span>]: r.ready(), r.elapsed <span class="comment"># celery的用法  </span></span><br><span class="line">Out[<span class="number">18</span>]: (<span class="literal">True</span>, <span class="number">5.87735</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">19</span>]: r.get() <span class="comment"># 获得执行的结果  </span></span><br><span class="line">Out[<span class="number">19</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>


<p>入正题:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: <span class="function"><span class="keyword">def</span> <span class="title">split_text</span><span class="params">(filename)</span>:</span>  </span><br><span class="line">....:    text = open(filename).read()  </span><br><span class="line">....:    lines = text.splitlines()  </span><br><span class="line">....:    nlines = len(lines)  </span><br><span class="line">....:    n = <span class="number">10</span>  </span><br><span class="line">....:    block = nlines//n  </span><br><span class="line">....:    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  </span><br><span class="line">....:        chunk = lines[i*block:(i+<span class="number">1</span>)*(block)]  </span><br><span class="line">....:        <span class="keyword">with</span> open(<span class="string">'count_file%i.txt'</span> % i, <span class="string">'w'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">....:            f.write(<span class="string">'\n'</span>.join(chunk))  </span><br><span class="line">....:    cwd = os.path.abspath(os.getcwd())  </span><br><span class="line">....:    fnames = [ os.path.join(cwd, <span class="string">'count_file%i.txt'</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="comment"># 不用glob是为了精准  </span></span><br><span class="line">....:    <span class="keyword">return</span> fnames  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">21</span>]: <span class="keyword">from</span> IPython <span class="keyword">import</span> parallel  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">22</span>]: rc = parallel.Client()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">23</span>]: view = rc.load_balanced_view()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">24</span>]: v = rc[:]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">25</span>]: v.push(dict(  </span><br><span class="line">   ....:     non_word=non_word,  </span><br><span class="line">   ....:     yield_words=yield_words,  </span><br><span class="line">   ....:     common_words=common_words  </span><br><span class="line">   ....: ))  </span><br><span class="line">Out[<span class="number">25</span>]: &lt;AsyncResult: _push&gt;  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">26</span>]: fnames = split_text(filename)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">27</span>]: <span class="function"><span class="keyword">def</span> <span class="title">count_parallel</span><span class="params">()</span>:</span>  </span><br><span class="line">   .....:     pcounts = view.map(word_count, fnames)  </span><br><span class="line">   .....:     counts = defaultdict(int)  </span><br><span class="line">   .....:     <span class="keyword">for</span> pcount <span class="keyword">in</span> pcounts.get():  </span><br><span class="line">   .....:         <span class="keyword">for</span> k, v <span class="keyword">in</span> pcount.iteritems():  </span><br><span class="line">   .....:             counts[k] += v  </span><br><span class="line">   .....:     <span class="keyword">return</span> counts, pcounts  </span><br><span class="line">   .....:  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">28</span>]: %time counts, pcounts = count_parallel() <span class="comment"># 这个时间包含了我再聚合的时间  </span></span><br><span class="line">CPU times: user <span class="number">47.6</span> ms, sys: <span class="number">6.67</span> ms, total: <span class="number">54.3</span> ms <span class="comment"># 是不是比直接运行少了很多时间?  </span></span><br><span class="line">Wall time: <span class="number">106</span> ms <span class="comment"># 这个时间是  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">29</span>]: pcounts.elapsed, pcounts.serial_time, pcounts.wall_time  </span><br><span class="line">Out[<span class="number">29</span>]: (<span class="number">0.104384</span>, <span class="number">0.13980499999999998</span>, <span class="number">0.104384</span>)</span><br></pre></td></tr></table></figure>


<p>更多地关于并行计算请看这里: <a href="http://nbviewer.ipython.org/url/www.astro.washington.edu/users/vanderplas/Astr599/notebooks/21_IPythonParallel.ipynb" target="_blank" rel="noopener">Parallel Computing with<br>IPython</a></p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>gentoo浣跨敤wpa_supplicant閰嶇疆鏃犵嚎缃戝崱</title>
    <url>/2016-05-12.html</url>
    <content><![CDATA[<h4 id="鍓嶈█"><a href="#鍓嶈█" class="headerlink" title="鍓嶈█"></a><em>鍓嶈█</em></h4><p>鍏徃鍏ㄩ儴浣跨敤浜嗘棤绾跨綉缁滐紝鎴戜篃琚€橀€尖€欑殑寮€濮嬬爺绌秅entoo鐨勬棤绾夸笂缃戯紝鐪嬩簡缃戜笂寰堝鏂囩珷锛屼互鍙奼entoo鏂囨。锛屼絾鏄劅瑙夐兘璁╂垜寰堣糠绯婏紝浠ヤ笅鏄垜浣跨敤wpa_supplicant鏄竴浜涙€荤粨<br>####鎬荤粨</p>
<ul>
<li>鏌ョ湅鏈満鐨勬棤绾跨綉鍗�</li>
</ul>
<pre><code>emerge pciutils #杩欐牱灏辨湁浜唋spci杩欎釜鍛戒护  
localhost ~ # lspci |grep -i wire  
02:00.0 Network controller: Atheros Communications Inc. AR9285 Wireless Network Adapter (PCI-Express) (rev 01)  </code></pre><p>鍙互鍙戠幇锛岀綉鍗℃槸Atheros鐨凙R9285</p>
<ul>
<li>瀹夎wpa_supplicant</li>
</ul>
<pre><code>emerge -s wpa_supplicant  </code></pre><ul>
<li>鐢熸垚涓€涓厤缃厤缃枃浠�</li>
</ul>
<pre><code>zcat /usr/share/doc/wpa_supplicant-2.0/wpa_supplicant.conf.bz2 &gt; /etc/wpa_supplicant/wpa_supplicant.conf  </code></pre><ul>
<li>閰嶇疆锛屼互涓嬫槸鎴戝幓鎺夋敞閲婅锛岀┖鐧借绛夊墿涓嬬殑閰嶇疆锛屽叾涓殑psk鐨勫瓧绗︿覆杩欐牱鐢熸垚锛�</li>
</ul>
<pre><code>localhost ~ # wpa_passphrase 鎴戠殑ssid 鎴戠殑key  
network={  
    ssid=鈥濇垜鐨剆sid鈥�  
    #psk=鈥濇垜鐨刱ey鈥�  
    psk=e596aa911775ed47e04f5b9a9540978203210874eb258208b87cf82b5cf72588  
}  </code></pre><p>鎶婅繖娈靛姞鍦ㄩ厤缃枃浠朵腑</p>
<pre><code>localhost ~ # cat /etc/wpa_supplicant.conf  

ctrl_interface=/var/run/wpa_supplicant  
eapol_version=1  
ap_scan=1  
fast_reauth=1  
network={  
    ssid=鈥濇垜鐨剆sid鈥�  
    psk=e596aa911775ed47e04f5b9a9540978203210874eb258208b87cf82b5cf72588  
    priority=2  
}  </code></pre><ul>
<li>鍛戒护琛屽惎鍔╳pa(濡傛灉鎯崇湅璇︾粏鐨勪俊鎭敤浜庤皟璇曪紝鍔�-d閫夐」)</li>
</ul>
<pre><code>localhost ~ # wpa_supplicant -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf  
Successfully initialized wpa_supplicant  
wlan0: Trying to associate with 20:dc:c6:61:ab:34 (SSID=鈥欐垜鐨剆sid鈥� freq=2437 MHz)  
ioctl[SIOCSIWFREQ]: Device or resource busy  
wlan0: Association request to the driver failed  
wlan0: Associated with 20:dc:c6:61:ab:34  
wlan0: WPA: Key negotiation completed with 20:dc:c6:61:ab:34 [PTK=CCMP GTK=CCMP]  
wlan0: CTRL-EVENT-CONNECTED - Connection to 20:dc:c6:61:ab:34 completed [id=0 id_str=]  </code></pre><p>鍏朵腑wlan0: Association request to the driver failed 娌″叧绯�</p>
<ul>
<li>瀹夎udhcpc</li>
</ul>
<pre><code>emerge udhcpc  </code></pre><ul>
<li>閫氳繃dhcp鑷姩鑾峰緱</li>
</ul>
<pre><code>localhost ~ # dhcpcd wlan0  
dhcpcd[12395]: version 5.6.4 starting  
dhcpcd[12395]: wlan0: waiting for carrier  
dhcpcd[12395]: wlan0: carrier acquired  
dhcpcd[12395]: wlan0: carrier lost  
dhcpcd[12395]: wlan0: waiting for carrier  
dhcpcd[12395]: wlan0: carrier acquired  
dhcpcd[12395]: wlan0: sending IPv6 Router Solicitation  
dhcpcd[12395]: wlan0: sendmsg: Cannot assign requested address  
dhcpcd[12395]: wlan0: rebinding lease of 192.168.0.106  
dhcpcd[12395]: wlan0: acknowledged 192.168.0.106 from 192.168.0.1 `锟解€�  
dhcpcd[12395]: wlan0: checking for 192.168.0.106  
dhcpcd[12395]: wlan0: sending IPv6 Router Solicitation  
dhcpcd[12395]: wlan0: leased 192.168.0.106 for 7200 seconds  
dhcpcd[12462]: wlan0: wlan0: MTU set to 576  
dhcpcd[12395]: forked to background, child pid 12479  </code></pre><p>鐪嬪埌浜嗗惂 鑾峰緱浜�192.168.0.106杩欎釜鍦板潃</p>
<p>鐗堟潈澹版槑锛氭湰鏂囩敱 钁ｄ紵鏄� 鍘熷垱锛屾湭缁忎綔鑰呮巿鏉冪姝换浣曞井淇″叕浼楀彿鍜屽悜鎺橀噾(juejin.im)杞浇锛孾鎶€鏈崥瀹㈣浆杞介噰鐢� 淇濈暀缃插悕-闈炲晢涓氭€т娇鐢�-绂佹婕旂粠 4.0-鍥介檯璁稿彲鍗忚](<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh</a>)<br>杞浇璇蜂繚鐣欎互涓婂０鏄庝俊鎭紒</p>
]]></content>
      <categories>
        <category>杞浇</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-cn社区欢迎大家来贡献代码</title>
    <url>/2016-05-13.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>一次QQ群随意一说,得到大家的认同. 所有我想把这件事坚持下去, 做完.<br>具体的可以看 <a href="http://python-cn.org" target="_blank" rel="noopener">http://python-cn.org</a>. 在社区没有上线前, 保持低调，欢迎你来参观.</p>
<h4 id="社区项目"><a href="#社区项目" class="headerlink" title="社区项目"></a>社区项目</h4><p><a href="https://github.com/python-cn/firefly" target="_blank" rel="noopener">firefly</a>. 欢迎star, 欢迎PR - 其实我要star没用,<br>但是我希望你能来给我提个Pull request.</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用flit替代setup.py打包上传Python模块</title>
    <url>/2016-05-14.html</url>
    <content><![CDATA[<p>首先说明，这种方式目前是一种「非主流」的方式，是在安装IPython最新版本时无意发现的。<br>我们先看一个真实的项目<a href="https://github.com/takluyver/entrypoints/" target="_blank" rel="noopener">entrypoints</a>，我们先安装它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ virtualenv venv -p /usr/local/bin/python3  <span class="comment"># flit依赖Python 3，但是可以分发Python 2的包  </span></span><br><span class="line">❯ source venv/bin/activate  </span><br><span class="line">❯ pip install entrypoints</span><br></pre></td></tr></table></figure>


<p>这看起来一直很正常。我们再看看项目文件结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ tree -L <span class="number">2</span>  </span><br><span class="line">.  </span><br><span class="line">├── LICENSE  </span><br><span class="line">├── doc  </span><br><span class="line">│   ├── Makefile  </span><br><span class="line">│   ├── api.rst  </span><br><span class="line">│   ├── conf.py  </span><br><span class="line">│   └── index.rst  </span><br><span class="line">├── entrypoints.py  </span><br><span class="line">├── flit.ini  </span><br><span class="line">└── tests  </span><br><span class="line">    ├── __init__.py  </span><br><span class="line">    ├── samples  </span><br><span class="line">    └── test_entrypoints.py</span><br></pre></td></tr></table></figure>


<p>有没有发现，没有setup.py文件! 这和我们平时对打包上传的理解有冲突呀。<br>这是怎么实现的呢？首先我们先了解下下面2个PEP：</p>
<ol>
<li><a href="https://www.python.org/dev/peps/pep-0516/" target="_blank" rel="noopener">PEP 516 – Build system abstraction for pip/conda etc</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0517/" target="_blank" rel="noopener">PEP 517 – A build-system independent format for source trees</a><br>对， 就是让flit.ini替代(部分)了setup.py的作用：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat flit.ini  </span><br><span class="line">[metadata]  </span><br><span class="line">module = entrypoints  </span><br><span class="line">author = Thomas Kluyver  </span><br><span class="line">author-email = thomas@kluyver.me.uk  </span><br><span class="line">home-page = https://github.com/takluyver/entrypoints  </span><br><span class="line">classifiers = License :: OSI Approved :: MIT License  </span><br><span class="line">requires-python = &gt;=<span class="number">2.7</span>  </span><br><span class="line">requires = configparser (&gt;=<span class="number">3.5</span>); python_version == <span class="string">'2.7'</span></span><br></pre></td></tr></table></figure>


<p>我们来体会下使用<a href="https://github.com/takluyver/flit" target="_blank" rel="noopener">flit</a>的用法，首先安装它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pip install flit</span><br></pre></td></tr></table></figure>


<p>现在我们创建一个简单的项目，就叫「flit_test」吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ mkdir flit_test  </span><br><span class="line">❯ cd flit_test  </span><br><span class="line">❯ flit init  <span class="comment"># 初始化  </span></span><br><span class="line">Module name: flit_test  </span><br><span class="line">Author: Dongweiming  </span><br><span class="line">Author email: ciici123@gmail.com  </span><br><span class="line">Home page: http://www.dongwm.com  </span><br><span class="line">Choose a license (see http://choosealicense.com/ <span class="keyword">for</span> more info)  </span><br><span class="line"><span class="number">1.</span> MIT - simple <span class="keyword">and</span> permissive  </span><br><span class="line"><span class="number">2.</span> Apache - explicitly grants patent rights  </span><br><span class="line"><span class="number">3.</span> GPL - ensures that code based on this <span class="keyword">is</span> shared <span class="keyword">with</span> the same terms  </span><br><span class="line"><span class="number">4.</span> Skip - choose a license later  </span><br><span class="line">Enter <span class="number">1</span><span class="number">-4</span>: <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">Written flit.ini; edit that file to add optional extra info.</span><br></pre></td></tr></table></figure>


<p>接着我们创建初始化填写的模块文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat flit_test.py  </span><br><span class="line"><span class="string">'''Some docstring'''</span>  </span><br><span class="line">__version__ = <span class="string">'0.1'</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">    print(<span class="string">'Hello World'</span>)</span><br></pre></td></tr></table></figure>


<p>我们现在给flit.ini文件添加一个入口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[scripts]  </span><br><span class="line">hello=flit_test:main</span><br></pre></td></tr></table></figure>


<p>这样在安装之后就可以在命令行直接使用hello命令，会执行打印’Hello World’。<br>最后一步就是上传到PYPI了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ flit wheel --upload  </span><br><span class="line"><span class="meta">... </span> </span><br><span class="line">Registered flit_test <span class="keyword">with</span> PyPI                                               I-flit.upload  </span><br><span class="line">Uploading dist/flit_test<span class="number">-0.1</span>-py2.py3-none-any.whl...                         I-flit.upload  </span><br><span class="line">Package <span class="keyword">is</span> at https://pypi.python.org/pypi/flit_test                         I-flit.upload</span><br></pre></td></tr></table></figure>


<p>我们现在验证下flit_test这个包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ pip install flit_test  </span><br><span class="line">❯ hello  </span><br><span class="line">Hello World  </span><br><span class="line">❯ which hello  </span><br><span class="line">/Users/dongweiming/entrypoints/venv/bin/hello</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Python并发编程一篇就够了--线程篇</title>
    <url>/2016-05-16.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对我来说，编程的乐趣之一是想办法让程序执行的越来越快，代码越写越优雅。在刚开始学习并发编程时，相信你它会有一些困惑，本文将解释多个并发开发的问题并帮助你快速了解并发编程的不同场景和应该使用的解决方案。</p>
<h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>Python（特指CPython）的多线程的代码并不能利用多核的优势，而是通过著名的全局解释锁（GIL）来进行处理的。如果是一个计算型的任务，使用多线程GIL就会让多线程变慢。我们举个计算斐波那契数列的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">(func)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  </span><br><span class="line">        <span class="keyword">import</span> time  </span><br><span class="line">        start = time.time()  </span><br><span class="line">        func(*args, **kwargs)  </span><br><span class="line">        end   = time.time()  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'COST: &#123;&#125;'</span>.format(end - start)  </span><br><span class="line">    <span class="keyword">return</span> wrapper  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> n&lt;= <span class="number">2</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@profile  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothread</span><span class="params">()</span>:</span>  </span><br><span class="line">    fib(<span class="number">35</span>)  </span><br><span class="line">    fib(<span class="number">35</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@profile  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasthread</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </span><br><span class="line">        t = threading.Thread(target=fib, args=(<span class="number">35</span>,))  </span><br><span class="line">        t.start()  </span><br><span class="line">    main_thread = threading.currentThread()  </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threading.enumerate():  </span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">is</span> main_thread:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        t.join()  </span><br><span class="line">  </span><br><span class="line">nothread()  </span><br><span class="line">hasthread()</span><br></pre></td></tr></table></figure>


<p>运行的结果你猜猜会怎么样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python profile_thread.py  </span><br><span class="line">COST: <span class="number">5.05716490746</span>  </span><br><span class="line">COST: <span class="number">6.75599503517</span></span><br></pre></td></tr></table></figure>


<p>这种情况还不如不用多线程！<br>GIL是必须的，这是Python设计的问题：Python解释器是非线程安全的。这意味着当从线程内尝试安全的访问Python对象的时候将有一个全局的强制锁。<br>在任何时候，仅仅一个单一的线程能够获取Python对象或者C<br>API。每100个字节的Python指令解释器将重新获取锁，这（潜在的）阻塞了I/O操作。因为锁，CPU密集型的代码使用线程库时，不会获得性能的提高（但是当它使用之后介绍的多进程库时，性能可以获得提高）。<br>那是不是由于GIL的存在，多线程库就是个「鸡肋」呢？当然不是。事实上我们平时会接触非常多的和网络通信或者数据输入/输出相关的程序，比如网络爬虫、文本处理等等。这时候由于网络情况和I/O的性能的限制，Python解释器会等待读写数据的函数调用返回，这个时候就可以利用多线程库提高并发效率了。</p>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>Python线程包含多种同步机制:</p>
<h4 id="1-Semaphore（信号量）"><a href="#1-Semaphore（信号量）" class="headerlink" title="1. Semaphore（信号量）"></a>1. Semaphore（信号量）</h4><p>在多线程编程中，为了防止不同的线程同时对一个公用的资源（比如全部变量）进行修改，需要进行同时访问的数量（通常是1）。信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.当计数器为0时，acquire()调用被阻塞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore  </span><br><span class="line">  </span><br><span class="line">sema = Semaphore(<span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(tid)</span>:</span>  </span><br><span class="line">    <span class="keyword">with</span> sema:  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'&#123;&#125; acquire sema'</span>.format(tid)  </span><br><span class="line">        wt = random() * <span class="number">2</span>  </span><br><span class="line">        time.sleep(wt)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'&#123;&#125; release sema'</span>.format(tid)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">threads = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):  </span><br><span class="line">    t = Thread(target=foo, args=(i,))  </span><br><span class="line">    threads.append(t)  </span><br><span class="line">    t.start()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:  </span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>


<p>这个例子中，我们限制了同时能访问资源的数量为3。看一下执行的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python semaphore.py  </span><br><span class="line"><span class="number">0</span> acquire sema  </span><br><span class="line"><span class="number">1</span> acquire sema  </span><br><span class="line"> <span class="number">2</span> acquire sema  </span><br><span class="line"><span class="number">2</span> release sema  </span><br><span class="line"> <span class="number">3</span> acquire sema  </span><br><span class="line"><span class="number">1</span> release sema  </span><br><span class="line"> <span class="number">4</span> acquire sema  </span><br><span class="line"><span class="number">0</span> release sema  </span><br><span class="line"><span class="number">3</span> release sema  </span><br><span class="line"><span class="number">4</span> release sema</span><br></pre></td></tr></table></figure>


<h4 id="2-Lock（锁）"><a href="#2-Lock（锁）" class="headerlink" title="2. Lock（锁）"></a>2. Lock（锁）</h4><p>Lock也可以叫做互斥锁，其实相当于信号量为1。我们先看一个不加锁的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread  </span><br><span class="line">  </span><br><span class="line">value = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlock</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">global</span> value  </span><br><span class="line">    new = value + <span class="number">1</span>  </span><br><span class="line">    time.sleep(<span class="number">0.001</span>)  <span class="comment"># 使用sleep让线程有机会切换  </span></span><br><span class="line">    value = new  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">threads = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):  </span><br><span class="line">    t = Thread(target=getlock)  </span><br><span class="line">    t.start()  </span><br><span class="line">    threads.append(t)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:  </span><br><span class="line">    t.join()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> value</span><br></pre></td></tr></table></figure>


<p>执行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python nolock.py</span><br></pre></td></tr></table></figure>


<p>大写的黑人问号。不加锁的情况下，结果会远远的小于100。那我们加上互斥锁看看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock  </span><br><span class="line">  </span><br><span class="line">value = <span class="number">0</span>  </span><br><span class="line">lock = Lock()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlock</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">global</span> value  </span><br><span class="line">    <span class="keyword">with</span> lock:  </span><br><span class="line">        new = value + <span class="number">1</span>  </span><br><span class="line">        time.sleep(<span class="number">0.001</span>)  </span><br><span class="line">        value = new  </span><br><span class="line">  </span><br><span class="line">threads = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):  </span><br><span class="line">    t = Thread(target=getlock)  </span><br><span class="line">    t.start()  </span><br><span class="line">    threads.append(t)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:  </span><br><span class="line">    t.join()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> value</span><br></pre></td></tr></table></figure>


<p>我们对value的自增加了锁，就可以保证了结果了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python lock.py</span><br></pre></td></tr></table></figure>


<h4 id="3-RLock（可重入锁）"><a href="#3-RLock（可重入锁）" class="headerlink" title="3. RLock（可重入锁）"></a>3. RLock（可重入锁）</h4><p>acquire() 能够不被阻塞的被同一个线程调用多次。但是要注意的是release()需要调用与acquire()相同的次数才能释放锁。</p>
<h4 id="4-Condition（条件）"><a href="#4-Condition（条件）" class="headerlink" title="4. Condition（条件）"></a>4. Condition（条件）</h4><p>一个线程等待特定条件，而另一个线程发出特定条件满足的信号。最好说明的例子就是「生产者/消费者」模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(cond)</span>:</span>  </span><br><span class="line">    t = threading.currentThread()  </span><br><span class="line">    <span class="keyword">with</span> cond:  </span><br><span class="line">        cond.wait()  <span class="comment"># wait()方法创建了一个名为waiter的锁，并且设置锁的状态为locked。这个waiter锁用于线程间的通讯  </span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'&#123;&#125;: Resource is available to consumer'</span>.format(t.name)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(cond)</span>:</span>  </span><br><span class="line">    t = threading.currentThread()  </span><br><span class="line">    <span class="keyword">with</span> cond:  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'&#123;&#125;: Making resource available'</span>.format(t.name)  </span><br><span class="line">        cond.notifyAll()  <span class="comment"># 释放waiter锁，唤醒消费者  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">condition = threading.Condition()  </span><br><span class="line">  </span><br><span class="line">c1 = threading.Thread(name=<span class="string">'c1'</span>, target=consumer, args=(condition,))  </span><br><span class="line">c2 = threading.Thread(name=<span class="string">'c2'</span>, target=consumer, args=(condition,))  </span><br><span class="line">p = threading.Thread(name=<span class="string">'p'</span>, target=producer, args=(condition,))  </span><br><span class="line">  </span><br><span class="line">c1.start()  </span><br><span class="line">time.sleep(<span class="number">1</span>)  </span><br><span class="line">c2.start()  </span><br><span class="line">time.sleep(<span class="number">1</span>)  </span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>


<p>执行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python condition.py  </span><br><span class="line">p: Making resource available  </span><br><span class="line">c2: Resource <span class="keyword">is</span> available to consumer  </span><br><span class="line">c1: Resource <span class="keyword">is</span> available to consumer</span><br></pre></td></tr></table></figure>


<p>可以看到生产者发送通知之后，消费者都收到了。</p>
<h4 id="5-Event"><a href="#5-Event" class="headerlink" title="5. Event"></a>5. Event</h4><p>一个线程发送/传递事件，另外的线程等待事件的触发。我们同样的用「生产者/消费者」模型的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">TIMEOUT = <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(event, l)</span>:</span>  </span><br><span class="line">    t = threading.currentThread()  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        event_is_set = event.wait(TIMEOUT)  </span><br><span class="line">        <span class="keyword">if</span> event_is_set:  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                integer = l.pop()  </span><br><span class="line">                <span class="keyword">print</span> <span class="string">'&#123;&#125; popped from list by &#123;&#125;'</span>.format(integer, t.name)  </span><br><span class="line">                event.clear()  <span class="comment"># 重置事件状态  </span></span><br><span class="line">            <span class="keyword">except</span> IndexError:  <span class="comment"># 为了让刚启动时容错  </span></span><br><span class="line">                <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(event, l)</span>:</span>  </span><br><span class="line">    t = threading.currentThread()  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        integer = randint(<span class="number">10</span>, <span class="number">100</span>)  </span><br><span class="line">        l.append(integer)  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'&#123;&#125; appended to list by &#123;&#125;'</span>.format(integer, t.name)  </span><br><span class="line">        event.set()	 <span class="comment"># 设置事件  </span></span><br><span class="line">        time.sleep(<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">event = threading.Event()  </span><br><span class="line">l = []  </span><br><span class="line">  </span><br><span class="line">threads = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> (<span class="string">'consumer1'</span>, <span class="string">'consumer2'</span>):  </span><br><span class="line">    t = threading.Thread(name=name, target=consumer, args=(event, l))  </span><br><span class="line">    t.start()  </span><br><span class="line">    threads.append(t)  </span><br><span class="line">  </span><br><span class="line">p = threading.Thread(name=<span class="string">'producer1'</span>, target=producer, args=(event, l))  </span><br><span class="line">p.start()  </span><br><span class="line">threads.append(p)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:  </span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>


<p>执行的效果是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">77</span> appended to list by producer1  </span><br><span class="line"><span class="number">77</span> popped <span class="keyword">from</span> list by consumer1  </span><br><span class="line"><span class="number">46</span> appended to list by producer1  </span><br><span class="line"><span class="number">46</span> popped <span class="keyword">from</span> list by consumer2  </span><br><span class="line"><span class="number">43</span> appended to list by producer1  </span><br><span class="line"><span class="number">43</span> popped <span class="keyword">from</span> list by consumer2  </span><br><span class="line"><span class="number">37</span> appended to list by producer1  </span><br><span class="line"><span class="number">37</span> popped <span class="keyword">from</span> list by consumer2  </span><br><span class="line"><span class="number">33</span> appended to list by producer1  </span><br><span class="line"><span class="number">33</span> popped <span class="keyword">from</span> list by consumer2  </span><br><span class="line"><span class="number">57</span> appended to list by producer1  </span><br><span class="line"><span class="number">57</span> popped <span class="keyword">from</span> list by consumer1</span><br></pre></td></tr></table></figure>


<p>可以看到事件被2个消费者比较平均的接收并处理了。如果使用了wait方法，线程就会等待我们设置事件，这也有助于保证任务的完成。</p>
<h4 id="6-Queue"><a href="#6-Queue" class="headerlink" title="6. Queue"></a>6. Queue</h4><p>队列在并发开发中最常用的。我们借助「生产者/消费者」模式来理解：生产者把生产的「消息」放入队列，消费者从这个队列中对去对应的消息执行。<br>大家主要关心如下4个方法就好了：</p>
<ol>
<li>put: 向队列中添加一个项。</li>
<li>get: 从队列中删除并返回一个项。</li>
<li>task_done: 当某一项任务完成时调用。</li>
<li>join: 阻塞直到所有的项目都被处理完。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue  </span><br><span class="line">  </span><br><span class="line">q = Queue()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        wt = random()  </span><br><span class="line">        time.sleep(wt)  </span><br><span class="line">        q.put((double, wt))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        task, arg = q.get()  </span><br><span class="line">        <span class="keyword">print</span> arg, task(arg)  </span><br><span class="line">        q.task_done()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> target <span class="keyword">in</span>(producer, consumer):  </span><br><span class="line">    t = threading.Thread(target=target)  </span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>


<p>这就是最简化的队列架构。<br>Queue模块还自带了PriorityQueue（带有优先级）和LifoQueue（后进先出）2种特殊队列。我们这里展示下线程安全的优先级队列的用法，<br>PriorityQueue要求我们put的数据的格式是<code>(priority_number, data)</code>，我们看看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint  </span><br><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> PriorityQueue  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">q = PriorityQueue()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span>  </span><br><span class="line">    count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">5</span>:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        pri = randint(<span class="number">0</span>, <span class="number">100</span>)  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'put :&#123;&#125;'</span>.format(pri)  </span><br><span class="line">        q.put((pri, double, pri))  <span class="comment"># (priority, func, args)  </span></span><br><span class="line">        count += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        <span class="keyword">if</span> q.empty():  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        pri, task, arg = q.get()  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[PRI:&#123;&#125;] &#123;&#125; * 2 = &#123;&#125;'</span>.format(pri, arg, task(arg))  </span><br><span class="line">        q.task_done()  </span><br><span class="line">        time.sleep(<span class="number">0.1</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">t = threading.Thread(target=producer)  </span><br><span class="line">t.start()  </span><br><span class="line">time.sleep(<span class="number">1</span>)  </span><br><span class="line">t = threading.Thread(target=consumer)  </span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>


<p>其中消费者是故意让它执行的比生产者慢很多，为了节省篇幅，只随机产生5次随机结果。我们看下执行的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python priority_queue.py  </span><br><span class="line">put :<span class="number">84</span>  </span><br><span class="line">put :<span class="number">86</span>  </span><br><span class="line">put :<span class="number">16</span>  </span><br><span class="line">put :<span class="number">93</span>  </span><br><span class="line">put :<span class="number">14</span>  </span><br><span class="line">put :<span class="number">93</span>  </span><br><span class="line">[PRI:<span class="number">14</span>] <span class="number">14</span> * <span class="number">2</span> = <span class="number">28</span>  </span><br><span class="line">  </span><br><span class="line">[PRI:<span class="number">16</span>] <span class="number">16</span> * <span class="number">2</span> = <span class="number">32</span>  </span><br><span class="line">[PRI:<span class="number">84</span>] <span class="number">84</span> * <span class="number">2</span> = <span class="number">168</span>  </span><br><span class="line">[PRI:<span class="number">86</span>] <span class="number">86</span> * <span class="number">2</span> = <span class="number">172</span>  </span><br><span class="line">[PRI:<span class="number">93</span>] <span class="number">93</span> * <span class="number">2</span> = <span class="number">186</span>  </span><br><span class="line">[PRI:<span class="number">93</span>] <span class="number">93</span> * <span class="number">2</span> = <span class="number">186</span></span><br></pre></td></tr></table></figure>


<p>可以看到put时的数字是随机的，但是get的时候先从优先级更高（数字小表示优先级高）开始获取的。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>面向对象开发中，大家知道创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。无节制的创建和销毁线程是一种极大的浪费。那我们可不可以把执行完任务的线程不销毁而重复利用呢？仿佛就是把这些线程放进一个池子，一方面我们可以控制同时工作的线程数量，一方面也避免了创建和销毁产生的开销。<br>线程池在标准库中其实是有体现的，只是在官方文章中基本没有被提及：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : <span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool  </span><br><span class="line">In : pool = ThreadPool(<span class="number">5</span>)  </span><br><span class="line">In : pool.map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, range(<span class="number">5</span>))  </span><br><span class="line">Out: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure>


<p>当然我们也可以自己实现一个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8  </span></span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(n)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(threading.Thread)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span>  </span><br><span class="line">        super(Worker, self).__init__()  </span><br><span class="line">        self._q = queue  </span><br><span class="line">        self.daemon = <span class="literal">True</span>  </span><br><span class="line">        self.start()  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">            f, args, kwargs = self._q.get()  </span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                <span class="keyword">print</span> <span class="string">'USE: &#123;&#125;'</span>.format(self.name)  <span class="comment"># 线程名字  </span></span><br><span class="line">                <span class="keyword">print</span> f(*args, **kwargs)  </span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">                <span class="keyword">print</span> e  </span><br><span class="line">            self._q.task_done()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_t=<span class="number">5</span>)</span>:</span>  </span><br><span class="line">        self._q = Queue(num_t)  </span><br><span class="line">        <span class="comment"># Create Worker Thread  </span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_t):  </span><br><span class="line">            Worker(self._q)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_task</span><span class="params">(self, f, *args, **kwargs)</span>:</span>  </span><br><span class="line">        self._q.put((f, args, kwargs))  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_complete</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self._q.join()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">pool = ThreadPool()  </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>):  </span><br><span class="line">    wt = random()  </span><br><span class="line">    pool.add_task(double, wt)  </span><br><span class="line">    time.sleep(wt)  </span><br><span class="line">pool.wait_complete()</span><br></pre></td></tr></table></figure>


<p>执行一下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">USE: Thread<span class="number">-1</span>  </span><br><span class="line"><span class="number">1.58762376489</span>  </span><br><span class="line">USE: Thread<span class="number">-2</span>  </span><br><span class="line"><span class="number">0.0652918738849</span>  </span><br><span class="line">USE: Thread<span class="number">-3</span>  </span><br><span class="line"><span class="number">0.997407997138</span>  </span><br><span class="line">USE: Thread<span class="number">-4</span>  </span><br><span class="line"><span class="number">1.69333900685</span>  </span><br><span class="line">USE: Thread<span class="number">-5</span>  </span><br><span class="line"><span class="number">0.726900613676</span>  </span><br><span class="line">USE: Thread<span class="number">-1</span>  </span><br><span class="line"><span class="number">1.69110052253</span>  </span><br><span class="line">USE: Thread<span class="number">-2</span>  </span><br><span class="line"><span class="number">1.89039743989</span>  </span><br><span class="line">USE: Thread<span class="number">-3</span>  </span><br><span class="line"><span class="number">0.96281118122</span></span><br></pre></td></tr></table></figure>


<p>线程池会保证同时提供5个线程工作，但是我们有8个待完成的任务，可以看到线程按顺序被循环利用了。<br>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2016-12-01" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>idiomatic-python</title>
    <url>/2016-05-19.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>算来学会python已经4年有余, 使用它作为我的工作语言也3年了. 这个过程中我读过一些书, 看了很多人的博客.<br>也读了一些开源项目的代码, 但是尤其重要的是和同事在一起得到的进步. 一直到现在我都有习惯了解python, 提高自己的python能力<br>说到idiomatic. python有自己独特的语法和习惯. 而实现同样功能的代码不用的人呢也会使用不同的方式.<br>写出来的代码内容也有非常大的区别, 但是总是会有一个是更好的, idiomatic的写法. 今天突然翻到了一个我之前一直维护的keynote.<br>这里面记录了我总结和从其他的ppt或者代码里看到更优美的写法.<br>其中有些已经放在python3中, 说明这样的功能确实是程序员蛮有用的. 我整理了一下. 来给大家分享下.<br>PS: 这些是编程的思维, 举一反三, 再适合的时候利用上.</p>
<h4 id="循环列表-直到找到符合的结果-没有结果返回一个默认值"><a href="#循环列表-直到找到符合的结果-没有结果返回一个默认值" class="headerlink" title="循环列表, 直到找到符合的结果, 没有结果返回一个默认值"></a>循环列表, 直到找到符合的结果, 没有结果返回一个默认值</h4><p>通常这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="number">-1</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">4</span>:  </span><br><span class="line">        a = i  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line"><span class="comment"># a = 4</span></span><br></pre></td></tr></table></figure>


<p>更好的写法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="string">''</span>  </span><br><span class="line">a = next((i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">4</span>), <span class="number">-1</span>)  </span><br><span class="line"><span class="comment"># a = 4</span></span><br></pre></td></tr></table></figure>


<h4 id="执行调用直到某种情况"><a href="#执行调用直到某种情况" class="headerlink" title="执行调用直到某种情况"></a>执行调用直到某种情况</h4><p>通常这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">blocks = []  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">    block = f.read(<span class="number">32</span>)  </span><br><span class="line">    <span class="keyword">if</span> block == <span class="string">''</span>:  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    blocks.append(block)</span><br></pre></td></tr></table></figure>


<p>更好的写法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial  </span><br><span class="line">blocks = []  </span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> iter(partial(f.read, <span class="number">32</span>), <span class="string">''</span>):  </span><br><span class="line">    blocks.append(block)</span><br></pre></td></tr></table></figure>


<h4 id="标记区分"><a href="#标记区分" class="headerlink" title="标记区分"></a>标记区分</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(seq, target)</span>:</span>  </span><br><span class="line">    found = <span class="literal">False</span>  </span><br><span class="line">    <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(seq):  </span><br><span class="line">        <span class="keyword">if</span> value == target:  </span><br><span class="line">            found = <span class="literal">True</span>  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> found:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  </span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>


<p>更好的写法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(seq, target)</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(seq):  </span><br><span class="line">        <span class="keyword">if</span> value == target:  </span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  </span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>


<h4 id="threading-Lock"><a href="#threading-Lock" class="headerlink" title="threading.Lock"></a>threading.Lock</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lock = threading.Lock()  </span><br><span class="line">lock.acquire()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Critical section 1'</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Critical section 2'</span>  </span><br><span class="line"><span class="keyword">finally</span>:  </span><br><span class="line">    lock.release()</span><br></pre></td></tr></table></figure>


<p>其实是这样的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lock = threading.Lock()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> lock:  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Critical section 1'</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Critical section 2'</span></span><br></pre></td></tr></table></figure>


<h4 id="忽略抛出的异常"><a href="#忽略抛出的异常" class="headerlink" title="忽略抛出的异常"></a>忽略抛出的异常</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)  </span><br><span class="line"><span class="keyword">except</span> OSError:  </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> ignored(OSError):  </span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br></pre></td></tr></table></figure>


<p>就算用python2, 我也强烈建议把这样的函数放在项目里</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@contextmanager  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ignored</span><span class="params">(*exceptions)</span>:</span>  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        <span class="keyword">yield</span>  </span><br><span class="line">    <span class="keyword">except</span> exceptions:  </span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<p>如果你使用python3.4或以上可以使用标准库的 <code>contextlib.suppress</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">suppress</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *exceptions)</span>:</span>  </span><br><span class="line">        self._exceptions = exceptions  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exctype, excinst, exctb)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> exctype <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> issubclass(exctype, self._exceptions)</span><br></pre></td></tr></table></figure>


<h4 id="直接把输出存进文件中"><a href="#直接把输出存进文件中" class="headerlink" title="直接把输出存进文件中"></a>直接把输出存进文件中</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'help.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    oldstdout = sys.stdout  </span><br><span class="line">    sys.stdout = f  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        help(pow)  </span><br><span class="line">    <span class="keyword">finally</span>:  </span><br><span class="line">        sys.stdout = oldstdout</span><br></pre></td></tr></table></figure>


<p>同样使用python3.4以上可以使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'help.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    <span class="keyword">with</span> redirect_stdout(f):  </span><br><span class="line">        help(pow)</span><br></pre></td></tr></table></figure>


<p>redirect_stdout是这样的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@contextmanager  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redirect_stdout</span><span class="params">(fileobj)</span>:</span>  </span><br><span class="line">    oldstdout = sys.stdout  </span><br><span class="line">    sys.stdout = fileobj  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        <span class="keyword">yield</span> fieldobj  </span><br><span class="line">    <span class="keyword">finally</span>:  </span><br><span class="line">        sys.stdout = oldstdout</span><br></pre></td></tr></table></figure>


<h4 id="最简单的缓存"><a href="#最简单的缓存" class="headerlink" title="最简单的缓存"></a>最简单的缓存</h4><p>通常这样实现缓存:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">web_lookup</span><span class="params">(url, saved=&#123;&#125;)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">in</span> saved:  </span><br><span class="line">        <span class="keyword">return</span> saved[url]  </span><br><span class="line">    page = urllib.urlopen(url).read()  </span><br><span class="line">    saved[url] = page  </span><br><span class="line">    <span class="keyword">return</span> page</span><br></pre></td></tr></table></figure>


<p>可以这样写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@cache  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">web_lookup</span><span class="params">(url)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> urllib.urlopen(url).read()  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache</span><span class="params">(func)</span>:</span>  </span><br><span class="line">    saved = &#123;&#125;  </span><br><span class="line"><span class="meta">    @wraps(func)  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*args)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> saved:  </span><br><span class="line">            <span class="keyword">return</span> saved[args]  </span><br><span class="line">        result = func(*args)  </span><br><span class="line">        saved[args] = result  </span><br><span class="line">        <span class="keyword">return</span> result  </span><br><span class="line">    <span class="keyword">return</span> newfunc</span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python进行并发编程-asyncio篇(二)</title>
    <url>/2016-05-18.html</url>
    <content><![CDATA[<p>我们今天继续深入学习asyncio。</p>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>asyncio模块包含多种同步机制，每个原语的解释可以看<a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AF%87/" target="_blank" rel="noopener">线程篇</a>，这些原语的用法上和线程/进程有一些区别。</p>
<h4 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a>Semaphore（信号量）</h4><p>并发的去爬取显然可以让爬虫工作显得更有效率，但是我们应该把抓取做的无害，这样既可以保证我们不容易发现，也不会对被爬的网站造成一些额外的压力。<br>在这里吐槽下，豆瓣现在几乎成了爬虫练手专用网站，我个人也不知道为啥？欢迎留言告诉我。难道是豆瓣一直秉承尊重用户的原则不轻易对用户才去封禁策略，造成大家觉得豆瓣最适合入门么？BTW，我每天在后台都能看到几十万次无效的抓取，也就是抓取程序写的有问题，但还在不停地请求着…<br>好吧回到正题，比如我现在要抓取<a href="http://httpbin.org/get?a=X这样的页面，X为1-10000的数字，一次性的产生1w次请求显然很快就会被封掉。那么我们可以用Semaphore控制同时的并发量(例子中为了演示，X为0-11)：" target="_blank" rel="noopener">http://httpbin.org/get?a=X这样的页面，X为1-10000的数字，一次性的产生1w次请求显然很快就会被封掉。那么我们可以用Semaphore控制同时的并发量(例子中为了演示，X为0-11)：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp  </span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line">  </span><br><span class="line">NUMBERS = range(<span class="number">12</span>)  </span><br><span class="line">URL = <span class="string">'http://httpbin.org/get?a=&#123;&#125;'</span>  </span><br><span class="line">sema = asyncio.Semaphore(<span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_async</span><span class="params">(a)</span>:</span>  </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.request(<span class="string">'GET'</span>, URL.format(a)) <span class="keyword">as</span> r:  </span><br><span class="line">        data = <span class="keyword">await</span> r.json()  </span><br><span class="line">    <span class="keyword">return</span> data[<span class="string">'args'</span>][<span class="string">'a'</span>]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_result</span><span class="params">(a)</span>:</span>  </span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">await</span> sema):  </span><br><span class="line">        r = <span class="keyword">await</span> fetch_async(a)  </span><br><span class="line">        print(<span class="string">'fetch(&#123;&#125;) = &#123;&#125;'</span>.format(a, r))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">f = asyncio.wait([print_result(num) <span class="keyword">for</span> num <span class="keyword">in</span> NUMBERS])  </span><br><span class="line">loop.run_until_complete(f)</span><br></pre></td></tr></table></figure>


<p>在运行的时候可以感受到并发受到了信号量的限制，基本保持在同时处理三个请求的标准。</p>
<h4 id="Lock（锁）"><a href="#Lock（锁）" class="headerlink" title="Lock（锁）"></a>Lock（锁）</h4><p>看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ cat lock.py  </span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line"><span class="keyword">import</span> functools  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unlock</span><span class="params">(lock)</span>:</span>  </span><br><span class="line">    print(<span class="string">'callback releasing lock'</span>)  </span><br><span class="line">    lock.release()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(locker, lock)</span>:</span>  </span><br><span class="line">    print(<span class="string">'&#123;&#125; waiting for the lock'</span>.format(locker))  </span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">await</span> lock:  </span><br><span class="line">        print(<span class="string">'&#123;&#125; acquired lock'</span>.format(locker))  </span><br><span class="line">    print(<span class="string">'&#123;&#125; released lock'</span>.format(locker))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(loop)</span>:</span>  </span><br><span class="line">    lock = asyncio.Lock()  </span><br><span class="line">    <span class="keyword">await</span> lock.acquire()  </span><br><span class="line">    loop.call_later(<span class="number">0.1</span>, functools.partial(unlock, lock))  </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait([test(<span class="string">'l1'</span>, lock), test(<span class="string">'l2'</span>, lock)])  </span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">loop.run_until_complete(main(loop))  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>


<p>这个例子中我们首先使用acquire加锁，通过call_later方法添加一个0.1秒后释放锁的函数。看一下调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 lock.py  </span><br><span class="line">l1 waiting <span class="keyword">for</span> the lock  </span><br><span class="line">l2 waiting <span class="keyword">for</span> the lock  </span><br><span class="line">callback releasing lock  </span><br><span class="line">l1 acquired lock  </span><br><span class="line">l1 released lock  </span><br><span class="line">l2 acquired lock  </span><br><span class="line">l2 released lock</span><br></pre></td></tr></table></figure>


<h4 id="Condition（条件）"><a href="#Condition（条件）" class="headerlink" title="Condition（条件）"></a>Condition（条件）</h4><p>我们根据线程篇Condition的例子，改成一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line"><span class="keyword">import</span> functools  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(cond, name, second)</span>:</span>  </span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(second)  </span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">await</span> cond:  </span><br><span class="line">        <span class="keyword">await</span> cond.wait()  </span><br><span class="line">        print(<span class="string">'&#123;&#125;: Resource is available to consumer'</span>.format(name))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(cond)</span>:</span>  </span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):  </span><br><span class="line">        <span class="keyword">with</span> <span class="keyword">await</span> cond:  </span><br><span class="line">            print(<span class="string">'notifying consumer &#123;&#125;'</span>.format(n))  </span><br><span class="line">            cond.notify(n=n)  </span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">producer2</span><span class="params">(cond)</span>:</span>  </span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">await</span> cond:  </span><br><span class="line">        print(<span class="string">'Making resource available'</span>)  </span><br><span class="line">        cond.notify_all()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(loop)</span>:</span>  </span><br><span class="line">    condition = asyncio.Condition()  </span><br><span class="line">  </span><br><span class="line">    task = loop.create_task(producer(condition))  </span><br><span class="line">    consumers = [consumer(condition, name, index)  </span><br><span class="line">                 <span class="keyword">for</span> index, name <span class="keyword">in</span> enumerate((<span class="string">'c1'</span>, <span class="string">'c2'</span>))]  </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(consumers)  </span><br><span class="line">    task.cancel()  </span><br><span class="line">  </span><br><span class="line">    task = loop.create_task(producer2(condition))  </span><br><span class="line">    consumers = [consumer(condition, name, index)  </span><br><span class="line">                 <span class="keyword">for</span> index, name <span class="keyword">in</span> enumerate((<span class="string">'c1'</span>, <span class="string">'c2'</span>))]  </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(consumers)  </span><br><span class="line">    task.cancel()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">loop.run_until_complete(main(loop))  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>


<p>这次演示了2种通知的方式：</p>
<ol>
<li>使用notify方法挨个通知单个消费者</li>
<li>使用notify_all方法一次性的通知全部消费者<br>由于producer和producer2是异步的函数，所以不能使用之前call_later方法，需要用create_task把它创建成一个任务（Task）。但是最后记得要把任务取消掉。<br>执行以下看看效果：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 condition.py  </span><br><span class="line">notifying consumer <span class="number">1</span>  </span><br><span class="line">c1: Resource <span class="keyword">is</span> available to consumer  </span><br><span class="line">notifying consumer <span class="number">2</span>  </span><br><span class="line">c2: Resource <span class="keyword">is</span> available to consumer  </span><br><span class="line">Making resource available  </span><br><span class="line">c1: Resource <span class="keyword">is</span> available to consumer  </span><br><span class="line">c2: Resource <span class="keyword">is</span> available to consumer</span><br></pre></td></tr></table></figure>


<h4 id="Event（事件）"><a href="#Event（事件）" class="headerlink" title="Event（事件）"></a>Event（事件）</h4><p>模仿锁的例子实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line"><span class="keyword">import</span> functools  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_event</span><span class="params">(event)</span>:</span>  </span><br><span class="line">    print(<span class="string">'setting event in callback'</span>)  </span><br><span class="line">    event.set()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(name, event)</span>:</span>  </span><br><span class="line">    print(<span class="string">'&#123;&#125; waiting for event'</span>.format(name))  </span><br><span class="line">    <span class="keyword">await</span> event.wait()  </span><br><span class="line">    print(<span class="string">'&#123;&#125; triggered'</span>.format(name))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(loop)</span>:</span>  </span><br><span class="line">    event = asyncio.Event()  </span><br><span class="line">    print(<span class="string">'event start state: &#123;&#125;'</span>.format(event.is_set()))  </span><br><span class="line">    loop.call_later(  </span><br><span class="line">        <span class="number">0.1</span>, functools.partial(set_event, event)  </span><br><span class="line">    )  </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait([test(<span class="string">'e1'</span>, event), test(<span class="string">'e2'</span>, event)])  </span><br><span class="line">    print(<span class="string">'event end state: &#123;&#125;'</span>.format(event.is_set()))  </span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">loop.run_until_complete(main(loop))  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>


<p>看起来也确实和锁的意思很像，不同的是，事件被触发时，2个消费者不用获取锁就要尽快的执行下去了。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>在asyncio官网上已经举例了2个很好的<a href="http://asyncio.readthedocs.io/en/latest/producer_consumer.html" target="_blank" rel="noopener">队列例子</a>了，这文就不重复了。asyncio同样支持LifoQueue和PriorityQueue，我们体验下aiohttp+优先级队列的用法吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">import</span> aiohttp  </span><br><span class="line">  </span><br><span class="line">NUMBERS = random.sample(range(<span class="number">100</span>), <span class="number">7</span>)  </span><br><span class="line">URL = <span class="string">'http://httpbin.org/get?a=&#123;&#125;'</span>  </span><br><span class="line">sema = asyncio.Semaphore(<span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_async</span><span class="params">(a)</span>:</span>  </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.request(<span class="string">'GET'</span>, URL.format(a)) <span class="keyword">as</span> r:  </span><br><span class="line">        data = <span class="keyword">await</span> r.json()  </span><br><span class="line">    <span class="keyword">return</span> data[<span class="string">'args'</span>][<span class="string">'a'</span>]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">collect_result</span><span class="params">(a)</span>:</span>  </span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">await</span> sema):  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> fetch_async(a)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(queue)</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> NUMBERS:  </span><br><span class="line">        print(<span class="string">'producing &#123;&#125;'</span>.format(num))  </span><br><span class="line">        item = (num, num)  </span><br><span class="line">        <span class="keyword">await</span> queue.put(item)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(queue)</span>:</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">        item = <span class="keyword">await</span> queue.get()  </span><br><span class="line">        num = item[<span class="number">0</span>]  </span><br><span class="line">        rs = <span class="keyword">await</span> collect_result(num)  </span><br><span class="line">        print(<span class="string">'consuming &#123;&#125;...'</span>.format(rs))  </span><br><span class="line">        queue.task_done()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span>  </span><br><span class="line">    queue = asyncio.PriorityQueue()  </span><br><span class="line">    consumer = asyncio.ensure_future(consume(queue))  </span><br><span class="line">    <span class="keyword">await</span> produce(queue)  </span><br><span class="line">    <span class="keyword">await</span> queue.join()  </span><br><span class="line">    consumer.cancel()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">loop.run_until_complete(run())  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>


<p>看到使用了新的ensure_future方法，其实它和之前说的create_task意思差不多，都是为了把一个异步的函数变成一个协程的Task。它们的区别是：</p>
<ol>
<li>create_task是AbstractEventLoop的抽象方法，不同的loop可以实现不同的创建Task方法，这里用的是BaseEventLoop的实现。</li>
<li>ensure_future是asyncio封装好的创建Task的函数，它还支持一些参数，甚至指定loop。一般应该使用它，除非用到后面提到的uvloop这个第三方库。<br>这个例子中，首先我们从0-99中随机取出7个数字，放入优先级队列，看看消费者是不是按照从小到大的顺序执行的呢？</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 prioqueue.py  </span><br><span class="line">producing <span class="number">6</span>  </span><br><span class="line">producing <span class="number">4</span>  </span><br><span class="line">producing <span class="number">22</span>  </span><br><span class="line">producing <span class="number">48</span>  </span><br><span class="line">producing <span class="number">9</span>  </span><br><span class="line">producing <span class="number">90</span>  </span><br><span class="line">producing <span class="number">40</span>  </span><br><span class="line">consuming <span class="number">4.</span>..  </span><br><span class="line">consuming <span class="number">6.</span>..  </span><br><span class="line">consuming <span class="number">9.</span>..  </span><br><span class="line">consuming <span class="number">22.</span>..  </span><br><span class="line">consuming <span class="number">40.</span>..  </span><br><span class="line">consuming <span class="number">48.</span>..  </span><br><span class="line">consuming <span class="number">90.</span>..</span><br></pre></td></tr></table></figure>


<p>确实是这样的。<br>说到这里，我们稍微偏个题，看看Task是什么？</p>
<h3 id="深入Task"><a href="#深入Task" class="headerlink" title="深入Task"></a>深入Task</h3><p>Task类用来管理协同程序运行的状态。根据源码，我保留核心，实现一个简单的Task类帮助大家理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(asyncio.futures.Future)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen, *,loop)</span>:</span>  </span><br><span class="line">        super().__init__(loop=loop)  </span><br><span class="line">        self._gen = gen  </span><br><span class="line">        self._loop.call_soon(self._step)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_step</span><span class="params">(self, val=None, exc=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">if</span> exc:  </span><br><span class="line">                f = self._gen.throw(exc)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                f = self._gen.send(val)  </span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:  </span><br><span class="line">            self.set_result(e.value)  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">            self.set_exception(e)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            f.add_done_callback(  </span><br><span class="line">                 self._wakeup)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_wakeup</span><span class="params">(self, fut)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            res = fut.result()  </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">            self._step(<span class="literal">None</span>, e)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            self._step(res, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>


<p>如果_step方法没有让协程执行完成，就会添加回调，_wakeup又会继续执行_step… 直到协程程序完成，并set_result。<br>写个使用它的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  </span><br><span class="line">    print(<span class="string">'Hello Foo'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  </span><br><span class="line">    print(<span class="string">'Hello Bar'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">tasks = [Task(foo(), loop=loop),  </span><br><span class="line">         loop.create_task(bar())]  </span><br><span class="line">loop.run_until_complete(  </span><br><span class="line">        asyncio.wait(tasks))  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>


<p>第一个任务是用我们自己的Task创建的，第二个是用BaseEventLoop自带的create_task。<br>运行一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 task.py  </span><br><span class="line">Hello Bar  </span><br><span class="line">Hello Foo</span><br></pre></td></tr></table></figure>


<p>自定义的Task类和asyncio自带的是可以好好协作的。</p>
<h3 id="深入事件循环"><a href="#深入事件循环" class="headerlink" title="深入事件循环"></a>深入事件循环</h3><p>asyncio根据你的操作系统信息会帮你选择默认的事件循环类，在*nix下使用的类继承于BaseEventLoop，在上面已经提到了。和Task一样，我们剥离出一份最核心的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback</span><span class="params">(fut)</span>:</span>  </span><br><span class="line">    fut._loop.stop()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loop</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self._ready = deque()  </span><br><span class="line">        self._stopping = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">(self, coro)</span>:</span>  </span><br><span class="line">        Task = asyncio.tasks.Task  </span><br><span class="line">        task = Task(coro, loop=self)  </span><br><span class="line">        <span class="keyword">return</span> task  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(self, fut)</span>:</span>  </span><br><span class="line">        tasks = asyncio.tasks  </span><br><span class="line">        <span class="comment"># 获取任务  </span></span><br><span class="line">        fut = tasks.ensure_future(  </span><br><span class="line">                    fut, loop=self)  </span><br><span class="line">        <span class="comment"># 增加任务到self._ready  </span></span><br><span class="line">        fut.add_done_callback(done_callback)  </span><br><span class="line">        <span class="comment"># 跑全部任务  </span></span><br><span class="line">        self.run_forever()  </span><br><span class="line">        <span class="comment"># 从self._ready中移除  </span></span><br><span class="line">        fut.remove_done_callback(done_callback)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">                self._run_once()  </span><br><span class="line">                <span class="keyword">if</span> self._stopping:  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">finally</span>:  </span><br><span class="line">            self._stopping = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_soon</span><span class="params">(self, cb, *args)</span>:</span>  </span><br><span class="line">        self._ready.append((cb, args))  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_once</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        ntodo = len(self._ready)  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(ntodo):  </span><br><span class="line">            t, a = self._ready.popleft()  </span><br><span class="line">            t(*a)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self._stopping = <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self._ready.clear()  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_exception_handler</span><span class="params">(self, c)</span>:</span>  </span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_debug</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<p>其中call_exception_handler和get_debug是必须存在的。<br>写个例子用一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span>  </span><br><span class="line">    print(<span class="string">'Hello Foo'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span>  </span><br><span class="line">    print(<span class="string">'Hello Bar'</span>)  </span><br><span class="line">  </span><br><span class="line">loop = Loop()  </span><br><span class="line">tasks = [loop.create_task(foo()),  </span><br><span class="line">         loop.create_task(bar())]  </span><br><span class="line">loop.run_until_complete(  </span><br><span class="line">        asyncio.wait(tasks))  </span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>


<p>执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ python3 loop.py  </span><br><span class="line">Hello Foo  </span><br><span class="line">Hello Bar</span><br></pre></td></tr></table></figure>


<p>也可以和asyncio.wait正常协作了。<br>PS：本文全部代码可以在<a href="https://github.com/dongweiming/mp/tree/master/2016-12-20" target="_blank" rel="noopener">微信公众号文章代码库项目</a>中找到。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎Live全文搜索之完成爬虫</title>
    <url>/2016-05-15.html</url>
    <content><![CDATA[<p>看这篇文章前推荐阅读相关的如下文章：</p>
<ol>
<li><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8API%E7%99%BB%E5%BD%95%E7%9F%A5%E4%B9%8E%E5%B9%B6%E8%8E%B7%E5%BE%97token/" target="_blank" rel="noopener">使用API登录知乎并获得token</a></li>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">知乎Live全文搜索之模型设计和爬虫实现</a></li>
<li><a href="http://www.dongwm.com/archives/%E7%9F%A5%E4%B9%8ELive%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%8F%A3/" target="_blank" rel="noopener">知乎Live全文搜索之模型接口</a><br>在[知乎Live全文搜索之模型设计和爬虫实现」里面我已经说过这是本年度最后一次说爬虫，今天就啪啪的打脸了。主要现在的爬虫有比较大的改变，由于微信公众号文章长度限制一篇放不上，只能专门写一篇啦。<h4 id="抓取话题信息"><a href="#抓取话题信息" class="headerlink" title="抓取话题信息"></a>抓取话题信息</h4>给新增的Topic提供数据。在parse_live_link中，解析到Live数据中包含了topic的id,<br>基于这个id拼链接，然后在fetch方法中添加对topic页面的处理，新增parse_topic_link方法：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TOPIC_API_URL = <span class="string">'https://api.zhihu.com/topics/&#123;&#125;'</span>   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_redirect=<span class="number">10</span>, max_tries=<span class="number">4</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 max_tasks=<span class="number">10</span>, *, loop=None)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        self.seen_topics = set()  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_topic_link</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">        rs = <span class="keyword">await</span> response.json()  </span><br><span class="line">        <span class="keyword">if</span> response.status == <span class="number">200</span>:  </span><br><span class="line">            rs[<span class="string">'avatar_url'</span>] = <span class="keyword">await</span> self.convert_local_image(  </span><br><span class="line">                rs[<span class="string">'avatar_url'</span>].replace(<span class="string">'_s'</span>, <span class="string">'_r'</span>))  </span><br><span class="line">            Topic.add_or_update(**flatten_live_dict(rs, TOPIC_KEYS))  </span><br><span class="line">              </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_live_link</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">          </span><br><span class="line">        topics = live_dict.pop(<span class="string">'topics'</span>)  </span><br><span class="line">        <span class="keyword">for</span> topic <span class="keyword">in</span> topics:  </span><br><span class="line">            topic_id = topic[<span class="string">'id'</span>]  </span><br><span class="line">            <span class="keyword">if</span> topic_id <span class="keyword">not</span> <span class="keyword">in</span> self.seen_topics:  </span><br><span class="line">                self.seen_topics.add(topic_id)  </span><br><span class="line">                self.add_url(TOPIC_API_URL.format(topic_id),  </span><br><span class="line">                             self.max_redirect)  </span><br><span class="line">        ...  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self, url, max_redirect)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">'api.zhihu.com'</span> <span class="keyword">in</span> url:  </span><br><span class="line">                parse_func = (self.parse_topic_link <span class="keyword">if</span> <span class="string">'topics'</span> <span class="keyword">in</span> url  </span><br><span class="line">                              <span class="keyword">else</span> self.parse_live_link)  </span><br><span class="line">                next_url = <span class="keyword">await</span> parse_func(response)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                next_url = <span class="keyword">await</span> self.parse_zhuanlan_link(response)  </span><br><span class="line">         ...</span><br></pre></td></tr></table></figure>


<p>思考下，这是不是一种套路(模式)：</p>
<ol>
<li>初始化一个已完成的url的集合</li>
<li>启动一定量的worker，每个worker都在等待从队列获取要抓取的url</li>
<li>一次性添加足量要抓取的链接到队列中，让每个worker都忙起来(执行前要确认之前没有抓取过)</li>
<li>worker在parse处理中又会解析到新的要抓取的链接，放入队列</li>
<li>worker消费任务，过程中也可能生产任务给自己或者其他worker来消费</li>
<li>全部任务都完成了，通过<code>self.q.join()</code>结束</li>
<li>停止这些worker，任务完成<h4 id="修改live灌suggest数据的方式"><a href="#修改live灌suggest数据的方式" class="headerlink" title="修改live灌suggest数据的方式"></a>修改live灌suggest数据的方式</h4>在上上篇我把相关字段的文本用analyze接口拆分成不同的token成为一个列表赋值给live_suggest，其实完全不需要这样，因为<code>Completion(analyzer=ik_analyzer)</code>就是做这个的。gen_suggests用最简单的input+weight就可以：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_suggests</span><span class="params">(topics, tags, outline, username, subject)</span>:</span>  </span><br><span class="line">    suggests = [&#123;<span class="string">'input'</span>: item, <span class="string">'weight'</span>: weight&#125;  </span><br><span class="line">                <span class="keyword">for</span> item, weight <span class="keyword">in</span> ((topics, <span class="number">10</span>), (subject, <span class="number">5</span>), (outline, <span class="number">3</span>),  </span><br><span class="line">                                     (tags, <span class="number">3</span>), (username, <span class="number">2</span>)) <span class="keyword">if</span> item]  </span><br><span class="line">    <span class="keyword">return</span> suggests</span><br></pre></td></tr></table></figure>


<h4 id="下载主讲人头像"><a href="#下载主讲人头像" class="headerlink" title="下载主讲人头像"></a>下载主讲人头像</h4><p>小程序开发工具中不能直接使用知乎的图片资源，所以我只能下载下来并生成一个本地的图片地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line">  </span><br><span class="line">IMAGE_FOLDER = <span class="string">'static/images/zhihu'</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(IMAGE_FOLDER):  </span><br><span class="line">    os.mkdir(IMAGE_FOLDER)   </span><br><span class="line">      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">convert_local_image</span><span class="params">(self, pic)</span>:</span>  </span><br><span class="line">        pic_name = pic.split(<span class="string">'/'</span>)[<span class="number">-1</span>]  </span><br><span class="line">        path = os.path.join(IMAGE_FOLDER, pic_name)  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):  </span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> self.session.get(pic) <span class="keyword">as</span> resp:  </span><br><span class="line">                content = <span class="keyword">await</span> resp.read()  </span><br><span class="line">                <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                    f.write(content)  </span><br><span class="line">        <span class="keyword">return</span> path  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_live_link</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        <span class="keyword">for</span> live <span class="keyword">in</span> rs[<span class="string">'data'</span>]:  </span><br><span class="line">            ...  </span><br><span class="line">            speaker = live.pop(<span class="string">'speaker'</span>)  </span><br><span class="line">            speaker_id = speaker[<span class="string">'member'</span>][<span class="string">'id'</span>]  </span><br><span class="line">            speaker[<span class="string">'member'</span>][<span class="string">'avatar_url'</span>] = <span class="keyword">await</span> self.convert_local_image(  <span class="comment"># noqa  </span></span><br><span class="line">                    speaker[<span class="string">'member'</span>][<span class="string">'avatar_url'</span>])  </span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>


<p>这样User类中的avatar_url最后会变成<code>static/images/zhihu/v2-4db301967fffa08dfa727ff467170e_s.jpg</code>这样的地址了。未来我们将让sanic来提供静态资源服务。当然，也可以只存文件名，在接口返回前再去拼图片地址。</p>
<h4 id="抓取专栏信息"><a href="#抓取专栏信息" class="headerlink" title="抓取专栏信息"></a>抓取专栏信息</h4><p>知乎Live申请通过之后，主讲人可以写一篇专栏介绍Live，文章中带上Live的链接来导流，知乎Live官方也会收录这个Live的专栏文章。为了让微信小程序的效果更好，我想要抓专栏头图，并且保存专栏链接，希望在小城中能给跳转进去（以证明不可行）。下面我将遍历<a href="https://zhuanlan.zhihu.com/zhihulive" target="_blank" rel="noopener">知乎Live官方专栏</a>收录的专栏，解析每个专栏的标题，去ES里面匹配是不是有对应的subject匹配，如果匹配还会验证用户的hash值确保正确，如果没找到还会从Live正文中搜索live的链接的方式来匹配。<br>看起来很绕，但是没办法啦，因为专栏和live没有明确的匹配关系，目测是知乎2个部门写的不同的系统。<br>最后要提的是专栏的抓取和live的api不同，它不提供paging键，也就是返回内容中并不告诉你下一页的地址，所以需要我们人工的修改链接，这需要一个转化的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse, parse_qsl, urlunparse, urlencode  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_url</span><span class="params">(url)</span>:</span>  </span><br><span class="line">    url_parts = list(urlparse(url))  </span><br><span class="line">    query = dict(parse_qsl(url_parts[<span class="number">4</span>]))  </span><br><span class="line">    query[<span class="string">'offset'</span>] = int(query[<span class="string">'offset'</span>]) + int(query[<span class="string">'limit'</span>])  </span><br><span class="line">    url_parts[<span class="number">4</span>] = urlencode(query)  </span><br><span class="line">    <span class="keyword">return</span> urlunparse(url_parts)</span><br></pre></td></tr></table></figure>


<p>这个方法在我实际工作中很常用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In : get_next_url(<span class="string">'http://dongwm.com?offset=10&amp;limit=20'</span>)  </span><br><span class="line">Out: <span class="string">'http://dongwm.com?offset=30&amp;limit=20'</span>  </span><br><span class="line">  </span><br><span class="line">In : get_next_url(<span class="string">'http://dongwm.com?offset=20&amp;limit=30'</span>)  </span><br><span class="line">Out: <span class="string">'http://dongwm.com?offset=50&amp;limit=30'</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ZHUANLAN_API_URL = <span class="string">'https://zhuanlan.zhihu.com/api/columns/zhihulive/posts?limit=20&amp;offset=&#123;offset&#125;'</span>  </span><br><span class="line">LIVE_REGEX = re.compile(<span class="string">r'&lt;a href="https://(www.)?zhihu.com/lives/(\d+)(.*)?"'</span>)  <span class="comment"># noqa  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_redirect=<span class="number">10</span>, max_tries=<span class="number">4</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 max_tasks=<span class="number">10</span>, *, loop=None)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        self.seen_zhuanlan = set()  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_zhuanlan_link</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">        posts = <span class="keyword">await</span> response.json()  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> response.status == <span class="number">200</span> <span class="keyword">and</span> posts:  </span><br><span class="line">            <span class="keyword">for</span> post <span class="keyword">in</span> posts:  </span><br><span class="line">                cover = post[<span class="string">'titleImage'</span>]  </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cover:  </span><br><span class="line">                    <span class="keyword">continue</span>  </span><br><span class="line">                s = Live.search()  </span><br><span class="line">                title = post[<span class="string">'title'</span>]  </span><br><span class="line">                <span class="keyword">for</span> sep <span class="keyword">in</span> (<span class="string">'－'</span>, <span class="string">'—'</span>):  </span><br><span class="line">                    <span class="keyword">if</span> sep <span class="keyword">in</span> title:  </span><br><span class="line">                        title = title.split(sep)[<span class="number">-1</span>].strip()  </span><br><span class="line">                speaker_id = post[<span class="string">'author'</span>][<span class="string">'hash'</span>]  </span><br><span class="line">                zid = post[<span class="string">'url'</span>].split(<span class="string">'/'</span>)[<span class="number">-1</span>]  </span><br><span class="line">                s = s.query(Q(<span class="string">'match_phrase'</span>, subject=title))  </span><br><span class="line">                lives = <span class="keyword">await</span> s.execute()  </span><br><span class="line">                <span class="keyword">for</span> live <span class="keyword">in</span> lives:  </span><br><span class="line">                    <span class="keyword">if</span> live.speaker <span class="keyword">and</span> live.speaker.speaker_id == speaker_id:  </span><br><span class="line">                        <span class="keyword">await</span> self.update_live(zid, cover, live)  </span><br><span class="line">                        <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    match = LIVE_REGEX.search(post[<span class="string">'content'</span>])  </span><br><span class="line">                    <span class="keyword">if</span> match:  </span><br><span class="line">                        live_id = match.group(<span class="number">2</span>)  </span><br><span class="line">                        <span class="keyword">try</span>:  </span><br><span class="line">                            live = <span class="keyword">await</span> Live.get(live_id)  </span><br><span class="line">                        <span class="keyword">except</span> NotFoundError:  </span><br><span class="line">                            <span class="keyword">pass</span>  </span><br><span class="line">                        <span class="keyword">else</span>:  </span><br><span class="line">                            <span class="keyword">await</span> self.update_live(zid, cover, live)  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> get_next_url(response.url)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_live</span><span class="params">(self, zid, cover, live)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> live.id <span class="keyword">in</span> self.seen_zhuanlan:  </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        self.seen_zhuanlan.add(live.id)  </span><br><span class="line">        zhuanlan_url = ZHUANLAN_URL.format(zid)  </span><br><span class="line">        cover = <span class="keyword">await</span> self.convert_local_image(cover)  </span><br><span class="line">        <span class="keyword">await</span> live.update(cover=cover, zhuanlan_url=zhuanlan_url)  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_zhuanlan_urls</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> range(self.max_tasks):  </span><br><span class="line">            self.add_url(ZHUANLAN_API_URL.format(offset=offset * <span class="number">20</span>))   </span><br><span class="line">              </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.__workers = [asyncio.Task(self.work(), loop=self.loop)  </span><br><span class="line">                          <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.max_tasks)]  </span><br><span class="line">        self.t0 = time.time()  </span><br><span class="line">        <span class="keyword">await</span> self.q.join()  </span><br><span class="line">        self.add_zhuanlan_urls()  </span><br><span class="line">        <span class="keyword">await</span> self.q.join()  </span><br><span class="line">        self.t1 = time.time()  </span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> self.__workers:  </span><br><span class="line">            w.cancel()</span><br></pre></td></tr></table></figure>


<p>其中crawl方法中用2次join用来确保 <strong>先抓取全部live信息之后再去抓专栏信息</strong><br>，因为得先确保live内容足够完整才能搜索匹配，其次由于parse_live_link和parse_zhuanlan_link都涉及到Live的更新，在并发中容易造成同时更新某些live而触发版本冲突的ConflictError。<br>我使用<code>s = s.query(Q(&#39;match_phrase&#39;,
subject=title))</code>进行标题匹配，首先我们先聊聊在ES中match和term的区别, 简单的说：</p>
<blockquote>
<p>term用于精确查询，match用于全文检索<br>我们要把标题和Live的subject字段去匹配，但是由于subject设置了analyzer，所以无法使用term。除非新加一个字段，修改成类似cover的那种<code>Text(index=&#39;not_analyzed&#39;)</code>。但是这样新增字段实在有点浪费，用math会把要匹配的标题分词之后挨个去匹配，匹配其中一个或多个的文档就会被搜索出来,<br>显然不满足「精确」，所以我想到了「短语匹配」(Phrase Matching)。<br>短语匹配和match查询类似，match_phrase查询首先解析查询字符串产生一个词条列表。但只保留含有了所有搜索词条的文档，并且还要求这些词条的顺序也一致。就是相当于虽然分词了但是词的顺序是有要求的，效果类似于精确匹配。</p>
</blockquote>
<h4 id="支持自动刷新知乎的token"><a href="#支持自动刷新知乎的token" class="headerlink" title="支持自动刷新知乎的token"></a>支持自动刷新知乎的token</h4><p>在调用知乎API的时候，会经常告诉我token过期了。我得删掉原来的token.json然后重新生成，这样很不爽。所以抓包分析后，通过已有的refresh_token自动刷新token:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhihuClient</span>:</span>   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">refresh_token</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        data = LOGIN_DATA.copy()  </span><br><span class="line">        data[<span class="string">'grant_type'</span>] = <span class="string">'refresh_token'</span>  </span><br><span class="line">        data[<span class="string">'refresh_token'</span>] = self._token.refresh_token  </span><br><span class="line">        gen_signature(data)  </span><br><span class="line">        auth = ZhihuOAuth(self._token)  </span><br><span class="line">        self.save_token(auth, data)  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_token</span><span class="params">(self, auth, data)</span>:</span>  </span><br><span class="line">        res = self._session.post(LOGIN_URL, auth=auth, data=data)  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            json_dict = res.json()  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">'error'</span> <span class="keyword">in</span> json_dict:  </span><br><span class="line">                <span class="keyword">raise</span> LoginException(json_dict[<span class="string">'error'</span>][<span class="string">'message'</span>])  </span><br><span class="line">            self._token = ZhihuToken.from_dict(json_dict)  </span><br><span class="line">        <span class="keyword">except</span> (ValueError, KeyError) <span class="keyword">as</span> e:  </span><br><span class="line">            <span class="keyword">raise</span> LoginException(str(e))  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            ZhihuToken.save_file(self.token_file, json_dict)</span><br></pre></td></tr></table></figure>


<p>启动爬虫首先会去get一个url，看看返回的状态码是不是401，如果是就执行refresh_token方法获得新的token：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">check_token</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> self.session.get(  </span><br><span class="line">                LIVE_API_URL.format(type=<span class="string">'ended'</span>, offset=<span class="number">0</span>)) <span class="keyword">as</span> resp:  </span><br><span class="line">            <span class="keyword">if</span> resp.status == <span class="number">401</span>:  </span><br><span class="line">                self.client.refresh_token()  </span><br><span class="line">                  </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">await</span> self.check_token()  </span><br><span class="line">        ...  </span><br><span class="line">          </span><br><span class="line">PS: 今天试用好像不对</span><br></pre></td></tr></table></figure>


<h4 id="更新用户举办的Live数量"><a href="#更新用户举办的Live数量" class="headerlink" title="更新用户举办的Live数量"></a>更新用户举办的Live数量</h4><p>之前我们给User添加了incr_live_count这个方法，调用一次live_count就+1，由于这个爬虫每次都是重新过一遍，所以需要仅在创建live的时候才更新：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_live_link</span><span class="params">(self, response)</span>:</span>  </span><br><span class="line">    ...  </span><br><span class="line">    result = <span class="keyword">await</span> Live.add(**live_dict)                                                                                     </span><br><span class="line">    <span class="keyword">if</span> result.meta[<span class="string">'version'</span>] == <span class="number">1</span>:                                                                                          </span><br><span class="line">        user.incr_live_count()</span><br></pre></td></tr></table></figure>


<p>ES每次每次都会返回添加/更新的结果，其中的version字段正好被我们利用。</p>
<h4 id="优化抓取"><a href="#优化抓取" class="headerlink" title="优化抓取"></a>优化抓取</h4><p>终于到最后一个小节了。再次道歉，之前分享的爬虫其中有一句检查要抓取的url是不是在self.seen_uls里面的判断，如果已经抓取过就assert抛了异常，这其实造成最后就剩下一个协程在执行任务了。<br>现在我重构了这部分的内容，大家看代码体会吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_redirect=<span class="number">10</span>, max_tries=<span class="number">4</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 max_tasks=<span class="number">10</span>, *, loop=None)</span>:</span>  </span><br><span class="line">        self.__stopped = &#123;&#125;.fromkeys([<span class="string">'ended'</span>, <span class="string">'ongoing'</span>, <span class="string">'posts'</span>], <span class="literal">False</span>)   </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self, url, max_redirect)</span>:</span>  </span><br><span class="line">        ...  </span><br><span class="line">        <span class="keyword">if</span> next_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            self.add_url(next_url, max_redirect)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="comment"># 如果live或者知乎官方专栏接口不再返回下一页，这个类型的任务就停止  </span></span><br><span class="line">            <span class="keyword">for</span> type <span class="keyword">in</span> self.__stopped:  </span><br><span class="line">                <span class="keyword">if</span> type <span class="keyword">in</span> url:  </span><br><span class="line">                    self.__stopped[type] = <span class="literal">True</span>  </span><br><span class="line">                      </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">                url, max_redirect = <span class="keyword">await</span> self.q.get()  </span><br><span class="line">                <span class="keyword">if</span> url <span class="keyword">in</span> self.seen_urls:  </span><br><span class="line">                    type = url.split(<span class="string">'/'</span>)[<span class="number">-1</span>].split(<span class="string">'?'</span>)[<span class="number">0</span>]  </span><br><span class="line">                    <span class="comment"># 如果一个接口返回的next_url已经抓去过，自动添加next_url的下一页  </span></span><br><span class="line">                    <span class="comment"># 除非这个类型的任务停止状态为True  </span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> type.isdigit() <span class="keyword">and</span> <span class="keyword">not</span> self.__stopped[type]:  </span><br><span class="line">                        self.add_url(get_next_url(url), max_redirect)  </span><br><span class="line">                <span class="keyword">await</span> self.fetch(url, max_redirect)  </span><br><span class="line">                self.q.task_done()  </span><br><span class="line">                asyncio.sleep(<span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:  </span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<p>这样就既不会重复抓取，也能保证worker都能正常工作。<br>截止发稿，抓取到的Live 1967个， 话题 656 个<br>完整抓取一次大概调用约950次API（1967 / 10 + 1967 / 20 + 656）, 在我MacBook上耗时 70 - 90 s。</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python的魔法(一):基本知识</title>
    <url>/2016-05-17.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近读了一篇<a href="http://nbviewer.ipython.org/github/rasbt/python_reference/blob/master/not_so_obvious_python_stuff.ipynb" target="_blank" rel="noopener">A collection of not-so-obvious Python stuff you should<br>know!</a>,感觉受益颇多.<br>翻译过来(非直接翻译),再加上一些我的理解和注释. 让大家注意python鲜为人知的”魔法”. 我会分2篇</p>
<h5 id="python多继承-C3"><a href="#python多继承-C3" class="headerlink" title="python多继承(C3)"></a>python多继承(C3)</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...:         <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>  </span><br><span class="line">   ...:                 print(<span class="string">"class A"</span>)  </span><br><span class="line">   ...:           </span><br><span class="line">  </span><br><span class="line">In [<span class="number">2</span>]: <span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...:         <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>  </span><br><span class="line">   ...:                 print(<span class="string">"class B"</span>)  </span><br><span class="line">   ...:           </span><br><span class="line">  </span><br><span class="line">In [<span class="number">3</span>]: <span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span>  </span><br><span class="line">   ...:         <span class="keyword">pass</span>  </span><br><span class="line">   ...:   </span><br><span class="line">  </span><br><span class="line">In [<span class="number">4</span>]: C().foo()  </span><br><span class="line">class A # 例子很好懂, C继承了A和B，从左到右,发现A有foo方法,返回了</span><br></pre></td></tr></table></figure>


<p>看起来都是很简单, 有次序的从底向上,从前向后找,找到就返回. 再看例子:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>  </span><br><span class="line">   ...:        <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>  </span><br><span class="line">   ...:               print(<span class="string">"class A"</span>)  </span><br><span class="line">   ...:           </span><br><span class="line">  </span><br><span class="line">In [<span class="number">6</span>]: <span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span>  </span><br><span class="line">   ...:        <span class="keyword">pass</span>  </span><br><span class="line">   ...:   </span><br><span class="line">  </span><br><span class="line">In [<span class="number">7</span>]: <span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span>  </span><br><span class="line">   ...:        <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span>  </span><br><span class="line">   ...:               print(<span class="string">"class C"</span>)  </span><br><span class="line">   ...:           </span><br><span class="line">  </span><br><span class="line">In [<span class="number">8</span>]: <span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span>  </span><br><span class="line">   ...:        <span class="keyword">pass</span>  </span><br><span class="line">   ...:   </span><br><span class="line">  </span><br><span class="line">In [<span class="number">9</span>]: D().foo()  </span><br><span class="line">class C # ? 按道理, 顺序是 D-&gt;B-&gt;A,为什么找到了C哪去了</span><br></pre></td></tr></table></figure>


<p>这也就涉及了MRO([Method Resolution Order](<a href="http://python-" target="_blank" rel="noopener">http://python-</a><br>history.blogspot.ru/2010/06/method-resolution-order.html)):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: D.__mro__  </span><br><span class="line">Out[<span class="number">10</span>]: (__main__.D, __main__.B, __main__.C, __main__.A, object)</span><br></pre></td></tr></table></figure>


<p>简单的理解其实就是新式类是广度优先了， D-&gt;B, 但是发现C也是继承A，就先找C，最后再去找A</p>
<h4 id="列表的-和-append和extend"><a href="#列表的-和-append和extend" class="headerlink" title="列表的+和+=, append和extend"></a>列表的+和+=, append和extend</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: print(<span class="string">'ID:'</span>, id(a_list))  </span><br><span class="line">(<span class="string">'ID:'</span>, <span class="number">4481323592</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">18</span>]: a_list += [<span class="number">1</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'ID (+=):'</span>, id(a_list))  </span><br><span class="line">(<span class="string">'ID (+=):'</span>, <span class="number">4481323592</span>) <span class="comment"># 使用+= 还是在原来的列表上操作  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">20</span>]: a_list = a_list + [<span class="number">2</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">21</span>]: print(<span class="string">'ID (list = list + ...):'</span>, id(a_list))  </span><br><span class="line">(<span class="string">'ID (list = list + ...):'</span>, <span class="number">4481293056</span>) <span class="comment"># 简单的+其实已经改变了原有列表  </span></span><br><span class="line">In [<span class="number">28</span>]: a_list = []  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">29</span>]: id(a_list)  </span><br><span class="line">Out[<span class="number">29</span>]: <span class="number">4481326976</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">30</span>]: a_list.append(<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">31</span>]: id(a_list)  </span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">4481326976</span> <span class="comment"># append 是在原有列表添加  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">32</span>]: a_list.extend([<span class="number">2</span>])  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">33</span>]: id(a_list)  </span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">4481326976</span> <span class="comment"># extend 也是在原有列表上添加</span></span><br></pre></td></tr></table></figure>


<h4 id="datetime也有布尔值"><a href="#datetime也有布尔值" class="headerlink" title="datetime也有布尔值"></a>datetime也有布尔值</h4><p>这是一个<a href="http://lwn.net/SubscriberLink/590299/bf73fe823974acea/" target="_blank" rel="noopener">坑</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: <span class="keyword">import</span> datetime  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">35</span>]: print(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, bool(datetime.time(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)))  </span><br><span class="line">(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, <span class="literal">False</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">36</span>]: print(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, bool(datetime.time(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))  </span><br><span class="line">(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<h4 id="‘-’-和-is-的区别"><a href="#‘-’-和-is-的区别" class="headerlink" title="‘==’ 和 is 的区别"></a>‘==’ 和 is 的区别</h4><p>我的理解是”is”是判断2个对象的身份, ==是判断2个对象的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: a = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">38</span>]: b = <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">39</span>]: print(<span class="string">'a is b'</span>, bool(a <span class="keyword">is</span> b))  </span><br><span class="line">(<span class="string">'a is b'</span>, <span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">40</span>]: c = <span class="number">999</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">41</span>]: d = <span class="number">999</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">42</span>]: print(<span class="string">'c is d'</span>, bool(c <span class="keyword">is</span> d))  </span><br><span class="line">(<span class="string">'c is d'</span>, <span class="literal">False</span>) <span class="comment"># 原因是python的内存管理,缓存了-5 - 256的对象  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">43</span>]: print(<span class="string">'256 is 257-1'</span>, <span class="number">256</span> <span class="keyword">is</span> <span class="number">257</span><span class="number">-1</span>)  </span><br><span class="line">(<span class="string">'256 is 257-1'</span>, <span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">44</span>]: print(<span class="string">'257 is 258-1'</span>, <span class="number">257</span> <span class="keyword">is</span> <span class="number">258</span> - <span class="number">1</span>)  </span><br><span class="line">(<span class="string">'257 is 258-1'</span>, <span class="literal">False</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">45</span>]: print(<span class="string">'-5 is -6+1'</span>, <span class="number">-5</span> <span class="keyword">is</span> <span class="number">-6</span>+<span class="number">1</span>)  </span><br><span class="line">(<span class="string">'-5 is -6+1'</span>, <span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">46</span>]: print(<span class="string">'-7 is -6-1'</span>, <span class="number">-7</span> <span class="keyword">is</span> <span class="number">-6</span><span class="number">-1</span>)  </span><br><span class="line">(<span class="string">'-7 is -6-1'</span>, <span class="literal">False</span>)  </span><br><span class="line">In [<span class="number">47</span>]: a = <span class="string">'hello world!'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">48</span>]: b = <span class="string">'hello world!'</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">49</span>]: print(<span class="string">'a is b,'</span>, a <span class="keyword">is</span> b)  </span><br><span class="line">(<span class="string">'a is b,'</span>, <span class="literal">False</span>) <span class="comment"># 很明显 他们没有被缓存,这是2个字段串的对象  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">50</span>]: print(<span class="string">'a == b,'</span>, a == b)  </span><br><span class="line">(<span class="string">'a == b,'</span>, <span class="literal">True</span>) <span class="comment"># 但他们的值相同  </span></span><br><span class="line"><span class="comment"># But, 有个特例  </span></span><br><span class="line">In [<span class="number">51</span>]: a = float(<span class="string">'nan'</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">52</span>]: print(<span class="string">'a is a,'</span>, a <span class="keyword">is</span> a)  </span><br><span class="line">(<span class="string">'a is a,'</span>, <span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">53</span>]: print(<span class="string">'a == a,'</span>, a == a)  </span><br><span class="line">(<span class="string">'a == a,'</span>, <span class="literal">False</span>) <span class="comment"># 亮瞎我眼睛了~</span></span><br></pre></td></tr></table></figure>


<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>我们在实际开发中都可以向对某列表的对象做修改,但是可能不希望改动原来的列表. <strong>浅拷贝只拷贝父对象，深拷贝还会拷贝对象的内部的子对象</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: list1 = [<span class="number">1</span>, <span class="number">2</span>]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">66</span>]: list2 = list1 <span class="comment"># 就是个引用, 你操作list2,其实list1的结果也会变  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">67</span>]: list3 = list1[:]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">69</span>]: <span class="keyword">import</span> copy  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">70</span>]: list4 = copy.copy(list1) <span class="comment"># 他和list3一样 都是浅拷贝  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">71</span>]: id(list1), id(list2), id(list3), id(list4)  </span><br><span class="line">Out[<span class="number">71</span>]: (<span class="number">4480620232</span>, <span class="number">4480620232</span>, <span class="number">4479667880</span>, <span class="number">4494894720</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">72</span>]: list2[<span class="number">0</span>] = <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">73</span>]: print(<span class="string">'list1:'</span>, list1)  </span><br><span class="line">(<span class="string">'list1:'</span>, [<span class="number">3</span>, <span class="number">2</span>])  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">74</span>]: list3[<span class="number">0</span>] = <span class="number">4</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">75</span>]: list4[<span class="number">1</span>] = <span class="number">4</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">76</span>]: print(<span class="string">'list1:'</span>, list1)  </span><br><span class="line">(<span class="string">'list1:'</span>, [<span class="number">3</span>, <span class="number">2</span>]) <span class="comment"># 对list3和list4操作都没有对list1有影响  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 再看看深拷贝和浅拷贝的区别  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">88</span>]: <span class="keyword">from</span> copy <span class="keyword">import</span> copy, deepcopy  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">89</span>]: list1 = [[<span class="number">1</span>], [<span class="number">2</span>]]  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">90</span>]: list2 = copy(list1) <span class="comment"># 还是浅拷贝  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">91</span>]: list3 = deepcopy(list1) <span class="comment"># 深拷贝  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">92</span>]: id(list1), id(list2), id(list3)  </span><br><span class="line">Out[<span class="number">92</span>]: (<span class="number">4494896592</span>, <span class="number">4495349160</span>, <span class="number">4494896088</span>)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">93</span>]: list2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">94</span>]: print(<span class="string">'list1:'</span>, list1)  </span><br><span class="line">(<span class="string">'list1:'</span>, [[<span class="number">3</span>], [<span class="number">2</span>]]) <span class="comment"># 看到了吧 假如你操作其子对象 还是和引用一样 影响了源  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">95</span>]: list3[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">96</span>]: print(<span class="string">'list1:'</span>, list1)  </span><br><span class="line">(<span class="string">'list1:'</span>, [[<span class="number">3</span>], [<span class="number">2</span>]]) <span class="comment"># 深拷贝就不会影响</span></span><br></pre></td></tr></table></figure>


<h4 id="bool其实是int的子类"><a href="#bool其实是int的子类" class="headerlink" title="bool其实是int的子类"></a>bool其实是int的子类</h4><p>这篇<a href="http://www.peterbe.com/plog/bool-is-int" target="_blank" rel="noopener">bool-is-int</a>很有趣:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: isinstance(<span class="literal">True</span>, int)  </span><br><span class="line">Out[<span class="number">97</span>]: <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">98</span>]: <span class="literal">True</span> + <span class="literal">True</span>  </span><br><span class="line">Out[<span class="number">98</span>]: <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">99</span>]: <span class="number">3</span> * <span class="literal">True</span> + <span class="literal">True</span>  </span><br><span class="line">Out[<span class="number">99</span>]: <span class="number">4</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">100</span>]: <span class="number">3</span> * <span class="literal">True</span> - <span class="literal">False</span>  </span><br><span class="line">Out[<span class="number">100</span>]: <span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">104</span>]: <span class="literal">True</span> &lt;&lt; <span class="number">10</span>  </span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">1024</span></span><br></pre></td></tr></table></figure>


<h4 id="元组是不是真的不可变"><a href="#元组是不是真的不可变" class="headerlink" title="元组是不是真的不可变?"></a>元组是不是真的不可变?</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: tup = ([],)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">112</span>]: tup[<span class="number">0</span>] += [<span class="number">1</span>]  </span><br><span class="line">---------------------------------------------------------------------------  </span><br><span class="line">TypeError                                 Traceback (most recent call last)  </span><br><span class="line">&lt;ipython-input<span class="number">-112</span>-d4f292cf35de&gt; <span class="keyword">in</span> &lt;module&gt;()  </span><br><span class="line">----&gt; 1 tup[0] += [1]  </span><br><span class="line">  </span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">113</span>]: tup  </span><br><span class="line">Out[<span class="number">113</span>]: ([<span class="number">1</span>],) <span class="comment"># 我靠 又是亮瞎我眼睛,明明抛了异常 还能修改?  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">114</span>]: tup = ([],)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">115</span>]: tup[<span class="number">0</span>].extend([<span class="number">1</span>])  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">116</span>]: tup[<span class="number">0</span>]  </span><br><span class="line">Out[<span class="number">116</span>]: [<span class="number">1</span>] <span class="comment"># 好吧,我有点看明白了, 虽然我不能直接操作元组，但是不能阻止我操作元组中可变的子对象(list)</span></span><br></pre></td></tr></table></figure>


<p>这里有个不错的解释[Python’s += Is Weird, Part II ](<a href="http://emptysqua.re/blog/python-" target="_blank" rel="noopener">http://emptysqua.re/blog/python-</a><br>increment-is-weird-part-ii/):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: my_tup = (<span class="number">1</span>,)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">118</span>]: my_tup += (<span class="number">4</span>,)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">119</span>]: my_tup = my_tup + (<span class="number">5</span>,)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">120</span>]: my_tup  </span><br><span class="line">Out[<span class="number">120</span>]: (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment"># ? 嗯 不是不能操作元组嘛?  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">121</span>]: my_tup = (<span class="number">1</span>,)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">122</span>]: print(id(my_tup))  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">In [<span class="number">123</span>]: my_tup += (<span class="number">4</span>,)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">124</span>]: print(id(my_tup))  </span><br><span class="line"><span class="number">4480606864</span> <span class="comment"># 操作的不是原来的元组 所以可以  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">125</span>]: my_tup = my_tup + (<span class="number">5</span>,)  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">126</span>]: print(id(my_tup))</span><br></pre></td></tr></table></figure>


<h4 id="python没有私有方法-变量-但是可以有”伪”的"><a href="#python没有私有方法-变量-但是可以有”伪”的" class="headerlink" title="python没有私有方法/变量? 但是可以有”伪”的"></a>python没有私有方法/变量? 但是可以有”伪”的</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: <span class="class"><span class="keyword">class</span> <span class="title">my_class</span><span class="params">(object^E)</span>:</span>  </span><br><span class="line">   .....:     <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span>  </span><br><span class="line">   .....:         print(<span class="string">'Hello public world!'</span>)  </span><br><span class="line">   .....:     <span class="function"><span class="keyword">def</span> <span class="title">__private_method</span><span class="params">(self)</span>:</span> <span class="comment"># 私有以双下划线开头  </span></span><br><span class="line">   .....:         print(<span class="string">'Hello private world!'</span>)  </span><br><span class="line">   .....:     <span class="function"><span class="keyword">def</span> <span class="title">call_private_method_in_class</span><span class="params">(self)</span>:</span>  </span><br><span class="line">   .....:         self.__private_method()  </span><br><span class="line">     </span><br><span class="line">In [<span class="number">132</span>]: my_instance = my_class()  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">133</span>]: my_instance.public_method()  </span><br><span class="line">Hello public world! <span class="comment"># 普通方法  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">134</span>]: my_instance._my_class__private_method()  </span><br><span class="line">Hello private world! <span class="comment"># 私有的可以加"_ + 类名字 + 私有方法名字”  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">135</span>]: my_instance.call_private_method_in_class()  </span><br><span class="line">Hello private world! <span class="comment"># 还可以通过类提供的公有接口内部访问  </span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">136</span>]: my_instance._my_class__private_variable  </span><br><span class="line">Out[<span class="number">136</span>]: <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h4 id="异常处理加else"><a href="#异常处理加else" class="headerlink" title="异常处理加else"></a>异常处理加else</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: <span class="keyword">try</span>:  </span><br><span class="line">   .....:     print(<span class="string">'third element:'</span>, a_list[<span class="number">2</span>])  </span><br><span class="line">   .....: <span class="keyword">except</span> IndexError:  </span><br><span class="line">   .....:     print(<span class="string">'raised IndexError'</span>)  </span><br><span class="line">   .....: <span class="keyword">else</span>:  </span><br><span class="line">   .....:     print(<span class="string">'no error in try-block'</span>) <span class="comment"># 只有在try里面没有异常的时候才会执行else里面的表达式  </span></span><br><span class="line">   .....:       </span><br><span class="line">raised IndexError <span class="comment"># 抛异常了 没完全完成  </span></span><br><span class="line">In [<span class="number">153</span>]: i = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">154</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:  </span><br><span class="line">   .....:     print(i)  </span><br><span class="line">   .....:     i += <span class="number">1</span>  </span><br><span class="line">   .....: <span class="keyword">else</span>:  </span><br><span class="line">   .....:     print(<span class="string">'in else'</span>)  </span><br><span class="line">   .....:       </span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="keyword">else</span> <span class="comment"># while也支持哦~  </span></span><br><span class="line">In [<span class="number">155</span>]: i = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">156</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:  </span><br><span class="line">   .....:         print(i)  </span><br><span class="line">   .....:         i += <span class="number">1</span>  </span><br><span class="line">   .....:         <span class="keyword">break</span>  </span><br><span class="line">   .....: <span class="keyword">else</span>:  </span><br><span class="line">   .....:         print(<span class="string">'completed while-loop'</span>)  </span><br><span class="line">   .....:       </span><br><span class="line"><span class="number">0</span> <span class="comment"># 被break了 没有完全执行完 就不执行else里面的了  </span></span><br><span class="line">In [<span class="number">158</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </span><br><span class="line">   .....:         print(i)  </span><br><span class="line">   .....: <span class="keyword">else</span>:  </span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)  </span><br><span class="line">   .....:       </span><br><span class="line"></span><br><span class="line">completed <span class="keyword">for</span>-loop  </span><br><span class="line">  </span><br><span class="line">In [<span class="number">159</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  </span><br><span class="line">   .....:         print(i)  </span><br><span class="line">   .....:         <span class="keyword">break</span>  </span><br><span class="line">   .....: <span class="keyword">else</span>:  </span><br><span class="line">   .....:         print(<span class="string">'completed for-loop'</span>)  </span><br><span class="line">   .....:       </span><br><span class="line"><span class="number">0</span> <span class="comment"># 也是因为break了</span></span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用http和websocket连接服务器</title>
    <url>/2016-05-21.html</url>
    <content><![CDATA[<p>####前言<br>想想吧，通过网页ssh登录服务器是一件多么酷的事情?今天看了[使用浏览器访问 Linux<br>终端](<a href="http://www.vpsee.com/2013/06/invoke-a-linux-shell-with-ssh-account-from-" target="_blank" rel="noopener">http://www.vpsee.com/2013/06/invoke-a-linux-shell-with-ssh-account-from-</a><br>browser),<br>也就是这个<a href="https://github.com/dongweiming/wssh" target="_blank" rel="noopener">wssh</a>,你也可以理解为websocket-ssh,<br>觉得有点意思就拿出来<br>####原路<br>它是一个库，很简单，作者写了2个flask+gevent+websocket+paramiko的例子，其中网页版的使用了bootstrap.<br>简单的理解就是不通过ssh连接服务器，而是通过网页或者一个client请求url+相应参数调用<br>shell到服务器的方式，但是遗憾的是作者一年没有再维护，bootstrap的网页竟然没有指定ssh端口的选项，但是很多时候为了安全<br>都会把ssh端口换成其它端口，这样就不能用了,好吧 我动手给它加了这个功能，也提了pull<br>request.目前大家可以用我的这版:<a href="https://github.com/dongweiming/wssh" target="_blank" rel="noopener">wssh</a></p>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a><strong>update</strong></h4><p>wssh作者已经合并了我的修改<br>####使用说明<br>当你使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>


<p>安装后，就能直接使用wssh和wsshd,wsshd是一个flask作为httpserver和gevent作为wsgi的服务端，默认启动在你本机的5000端口.<br>网页登录就能看见简单大气的选项页面，可以指定用户，服务器ip，端口，以及使用密钥或者密码登录.输入点击连接就会登录到那台服务器,数据通过websocket实时显示到页面上<br>而wssh是一个命令行登录的带选项的命令，其实就是页面输入的参数通过命令行的方式输入然后直接登录服务器，比如我下面的用法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wssh dongwm@dongwm.com -p XXX -s <span class="number">58404</span></span><br></pre></td></tr></table></figure>


<p>####我觉得有空可以基于这个做点好玩的东西</p>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一起学习common-lisp吧</title>
    <url>/2016-05-23.html</url>
    <content><![CDATA[<p>####前言<br>我记得在什么地方说过一个程序员要学什么语言:汇编,C,lisp,还有一门脚本语言(python或者ruby).遗憾的是我只会一点python和一点点ruby.<br>最近关注到google出品了[lisp_koans](<a href="https://github.com/google/lisp-" target="_blank" rel="noopener">https://github.com/google/lisp-</a><br>koans)-一个给初学者学习commonlisp的好东西,也许你也没有听过ruby_koans<br>和python_koans,假如你已经回了这2门语言可以忽略假如你想学习这2门语言,从koans入手是一个很好地途径.<br>最近几天花了些时间完成了lisp_koans,把答案分享出来<a href="https://github.com/dongweiming/lisp-koans-answer" target="_blank" rel="noopener">lisp-koans-<br>answer</a><br>我也给python_koans贡献了几行代码,在入职培训要求通过几种koans,xx_koans其实是一些测试用例,就像过关题目,他涉及这个语言的方方面面.只能你提供了正确的答案<br>才能继续下一个题目<br>####为啥分享答案</p>
<ol>
<li>做过python_koans的都记得，当某一题目你的答案不是期望的值的时候，这个测试没有通过，但是会提示你正确的结果,但是lisp_koans不会，你可以在不明所以的情况下需要研究很久</li>
<li>lisp_koans还很新(2013.05), 而且本来lisp语言就很小众. 不像ruby和python那样广泛.你不能从stackoverflow或者stackexchange找到答案<br>####让我们一起学习common lisp吧</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>octopress自定义markdown的code语法</title>
    <url>/2016-05-24.html</url>
    <content><![CDATA[<p>####前言<br>octopress自带的markdown语法高亮代码，最后展示在页面上的效果比较不友好-不能复制粘贴代码，不高亮，还有很丑的行数提示。<br>我一直使<a href="shjs.sourceforge.net">SHJS</a>,还算比较喜欢，但是以前每次都是编辑markdown文章，在使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```XX</span><br></pre></td></tr></table></figure>


<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line">的时候，使用  </span><br><span class="line">  </span><br><span class="line">```python  </span><br><span class="line">&lt;div class="bogus-wrapper"&gt;&lt;notextile&gt;&lt;figure class="code"&gt;&lt;pre class="sh_python"&gt;  </span><br><span class="line">XXX  </span><br><span class="line">&lt;/pre&gt;&lt;/figure&gt;&lt;/notextile&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p>这样的苦逼方式，最近实在是不了了，自定义octopress的解析过程<br>其实就是修改plugins/pygments_code.rb</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">require <span class="string">'pygments'</span>  </span><br><span class="line">require <span class="string">'fileutils'</span>  </span><br><span class="line">require <span class="string">'digest/md5'</span>  </span><br><span class="line">  </span><br><span class="line">PYGMENTS_CACHE_DIR = File.expand_path(<span class="string">'../../.pygments-cache'</span>, __FILE__)  </span><br><span class="line">FileUtils.mkdir_p(PYGMENTS_CACHE_DIR)  </span><br><span class="line">  </span><br><span class="line">module HighlightCode  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">highlight</span><span class="params">(str, lang)</span>  </span></span><br><span class="line">    lang = 'ruby' if lang == 'ru'  </span><br><span class="line">    lang = <span class="string">'objc'</span> <span class="keyword">if</span> lang == <span class="string">'m'</span>  </span><br><span class="line">    lang = <span class="string">'perl'</span> <span class="keyword">if</span> lang == <span class="string">'pl'</span>  </span><br><span class="line">    lang = <span class="string">'yaml'</span> <span class="keyword">if</span> lang == <span class="string">'yml'</span>  </span><br><span class="line">    str = pygments(str, lang).match(/&lt;pre&gt;(.+)&lt;\/pre&gt;/m)[<span class="number">1</span>].to_s.gsub(/ *$/, <span class="string">''</span>) <span class="comment">#strip out divs &lt;div class="highlight"&gt;  </span></span><br><span class="line">    tableize_code(str, lang)  </span><br><span class="line">  end  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pygments</span><span class="params">(code, lang)</span>  </span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">defined</span>?<span class="params">(PYGMENTS_CACHE_DIR)</span>  </span></span><br><span class="line">      path = File.join(PYGMENTS_CACHE_DIR, "#&#123;lang&#125;-#&#123;Digest::MD5.hexdigest(code)&#125;.html")  </span><br><span class="line">      if File.exist?(path)  </span><br><span class="line">        highlighted_code = File.read(path)  </span><br><span class="line">      <span class="keyword">else</span>  </span><br><span class="line">        highlighted_code = Pygments.highlight(code, :lexer =&gt; lang, :formatter =&gt; 'html', :options =&gt; &#123;:encoding =&gt; 'utf-8'&#125;)  </span><br><span class="line">        File.open(path, <span class="string">'w'</span>) &#123;|f| f.print(highlighted_code) &#125;  </span><br><span class="line">      end  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">      highlighted_code = Pygments.highlight(code, :lexer =&gt; lang, :formatter =&gt; 'html', :options =&gt; &#123;:encoding =&gt; 'utf-8'&#125;)  </span><br><span class="line">    end  </span><br><span class="line">    highlighted_code  </span><br><span class="line">  end  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tableize_code</span> <span class="params">(str, lang = <span class="string">'python'</span>)</span> #主要是修改这个方法  </span></span><br><span class="line">    table = "&lt;pre class='sh_#&#123;lang&#125;'&gt;"  </span><br><span class="line">    str.lines.each_with_index do |line,index|  </span><br><span class="line">      table += <span class="string">"&lt;span class='line'&gt;#&#123;line&#125;&lt;/span&gt;"</span>  </span><br><span class="line">    end  </span><br><span class="line">    table += <span class="string">"&lt;/pre&gt;"</span>  </span><br><span class="line">  end  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<p>####使用方法<br>和过去一样，在md的文章中使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```XX</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line">要是想指定某语言，需要先引用这个css，然后在md中  </span><br><span class="line">比如这里用bash语法（也是我的默认）</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">XX  </span><br><span class="line">\``` <span class="comment"># 这里不能正常显示，加个反斜杠</span></span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.6安装配置wordpress</title>
    <url>/2016-05-25-centos6-install-wordpress.html</url>
    <content><![CDATA[<ol>
<li>安装配置php环境：<br>yum install mysql-server php php-mysql httpd -y<br>a. 启动mysql，创建数据库和用户：<br>mysql<br>create database db_name;<br>grant all on db_name.* to username@localhost identified by ‘passwd’;</li>
<li>下载安装wordpress：<br>a. 访问本机ip地址，显示apache界面表示正常，不正常可以查看一下防火墙配置；<br>b. 官网下载wordpress安装包，解压以后放到站点目录；<br>c. 修改/etc/httpd/conf/httpd.conf 中<br>DocumentRoot “/var/html/wordpress”<br>DirectoryIndex ?index.html index.html.var index.php<br>d. 进入wordpress目录修改php配置：<br>cp wp-config-sample.php wp-config.php<br>vim wp-config.php 配置mysql数据库；<br>修改wordpress目录权限：chown apache. * -R<br>配置以后重启apache：/etc/init.d/httpd restart<br>c. 访问本机站点，按照提示安装wordpress ;</li>
</ol>
]]></content>
      <categories>
        <category>wordpress</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.5下添加epel源</title>
    <url>/2016-05-26-centos6-add-epel-resources.html</url>
    <content><![CDATA[<ol start="0">
<li>安装yum优先级插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install yum-priorities</span><br></pre></td></tr></table></figure>

<ol>
<li>epel简介: <a href="https://fedoraproject.org/wiki/EPEL/zh-cn" target="_blank" rel="noopener">https://fedoraproject.org/wiki/EPEL/zh-cn</a></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://mirrors.ustc.edu.cn/fedora/epel/6/x86_64/epel-release-6-8.noarch.rpm rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm</span><br></pre></td></tr></table></figure>

<p>以上URL请按实际情况修改<br>2. 查看是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -q epel-release</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>导入key：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改/etc/yum.repos.d/epel.repo文件<br>在[epel]最后添加一条属性 priority=11</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/yum.repos.d/epel.repo</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>意思是yum先去官方源查，官方没有再去epel的源找</p>
<ol start="5">
<li>重建缓存<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>epel</tag>
        <tag>redhat</tag>
      </tags>
  </entry>
  <entry>
    <title>slack上的小黄鸡--SlackBot</title>
    <url>/2016-05-20.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="http://www.slack.com/" target="_blank" rel="noopener">Slack</a>是一个最近一年兴起的团队沟通协作平台.<br>程序员对工具其实是最有品位和要求的，相信国内很多公司和团队都在使用，豆瓣也算比较早在用.<br>相信用过的人会理解本文. 如果你还没有接触它, 尤其是对现有的团队沟通协作工具有些不满, 可以试一下.<br>本文就是介绍我们在最近做出来的一个bot - <a href="https://github.com/python-cn/slack_bot" target="_blank" rel="noopener">slack_bot</a>.<br>它的口号是: 立志成为一个可被调戏且有用的Bot</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>无论是运维还是开发, 某些时间都会收到一些邮件/提醒, 可能是固定的时间的定时任务跑出来的结果,<br>也可能是某个故障引起的问题邮件. 我们都很烦手头有好几个东西来接收这些消息， 而slack可以使用某些方法让这些问题集中起来.<br>比如很常用的, 使用<a href="https://api.slack.com/methods/chat.postMessage" target="_blank" rel="noopener">chat</a>或者<a href="https://api.slack.com/incoming-webhooks" target="_blank" rel="noopener">incoming-<br>webhooks</a>接收消息. 做什么呢?<br>我可以把一些昨天的数据汇总或者汇总的地址在今天早上发到某个channel下, 这样想要看这个数据的人直接点进去就好了.<br>当然啦, 也可以直接发消息到某个人. 一个具体的例子: 豆瓣的同事都知道, 我们的测试环境时间过期就会被删除,<br>在某段时间里面每天都有很多人在关注我们要新上的一个测试的地址,<br>但是经常被同事@, 说地址怎么找不到了, 那么我就要抽出精力再去创建一个. 后来一想, 索性跑个定时任务, 拉最新的代码, 走逻辑, 生成一个测试环境.<br>每天都会在channel里面发消息给对应关心这个消息的人.<br>一段时间以后, 我们的工作完成了, 同事都有点不适用, 哎， 怎么早上看不到那个消息了…<br>但是今天说的是什么呢? 我们的slack_bot主要借用<a href="https://api.slack.com/outgoing-webhooks" target="_blank" rel="noopener">outgoing-<br>webhooks</a>. incoming表示把消息推到slack里面,<br>outgoing其实就是当有人在某些符合的channel里面说了什么, 会跳到我们提供的回调地址, 根据内容返回对应符合的回复. 大家是不是有点懂了,<br>这就是小黄鸡的原理.<br>说到这里大家应该明白了. 其实slack给我们提供了很大的想象和实现的空间. 我立刻想起来做运维时候做的一些事情:<br>比如当时有时候要去机房, 路上没有网(2g上网太慢), 有时候想看个监控状态, 切个负载均衡, 重启个服务什么的, 后来做了一个东西,<br>就是给某些号码发某些特殊的短信内容就可以获得想要的结果, 执行想做的事情.<br>其实slack_bot只是一些爬虫的集合, 一些功能实现的例子. 在实际开发和工作中可以做很多更有意思的, 公司内部的插件. 和公司的业务相关,<br>和自己做的事情相关. 这样在路上就能用.<br>比如我的地图功能, 我可以在网络不好的时候找到行程的最好路线; 我用公交插件可以实时的看我要等的公交需要多久到达, 我可以踩着点去站牌….</p>
<h3 id="小黄鸡原理"><a href="#小黄鸡原理" class="headerlink" title="小黄鸡原理"></a>小黄鸡原理</h3><p>小黄鸡很火的时候, 我还是一个perl运维…<br>小黄鸡其实调用的是<a href="http://developer.simsimi.com/" target="_blank" rel="noopener">simsim</a>的接口.<br>大家都可以去注册一个key来玩,也可以用项目自带的.<br>其实就是post一个数据到simsim的api上, 他会返回你对应的小黄鸡的回复.</p>
<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>很多人听过甚至曾经用过<a href="https://github.com/wong2/xiaohuangji-new" target="_blank" rel="noopener">小黄鸡</a>. 你可以把本bot理解为<code>增加了很多
功能</code>, <code>只保留小黄鸡交流的基本逻辑</code>, <code>用于slackchannel里面</code>的<code>小黄鸡</code><br>项目使用flask, 目前本项目是一个heroku应用. 地址是 &lt;<a href="https://slack-" target="_blank" rel="noopener">https://slack-</a><br>bot2.herokuapp.com/slack_callback&gt; 但是你<br>也可以直接裸跑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gunicorn wsgi:app localhost:<span class="number">5000</span> --timeout <span class="number">240</span> --log-file -</span><br></pre></td></tr></table></figure>


<p>你也可以使用heroku创建一个新的应用, 直接用我们的项目代码就可以.</p>
<h3 id="我们使用slack的特性"><a href="#我们使用slack的特性" class="headerlink" title="我们使用slack的特性"></a>我们使用slack的特性</h3><ol>
<li>可以把消息私聊发给自己</li>
<li>可以使用带图的方式接收结果(支持canvas, 以下会看到例图)<h3 id="继承自小黄鸡的模块们-但是都做了对应的修改"><a href="#继承自小黄鸡的模块们-但是都做了对应的修改" class="headerlink" title="继承自小黄鸡的模块们, 但是都做了对应的修改:"></a>继承自小黄鸡的模块们, 但是都做了对应的修改:</h3></li>
<li>空气插件</li>
<li>wikipedia</li>
<li>地震了</li>
<li>糗百</li>
<li>orz # orz需要自定义emoji<h3 id="新加的模块们"><a href="#新加的模块们" class="headerlink" title="新加的模块们:"></a>新加的模块们:</h3><h4 id="地图插件-你可以输入我想从哪去哪-会给你个路线-步行-开车-公交"><a href="#地图插件-你可以输入我想从哪去哪-会给你个路线-步行-开车-公交" class="headerlink" title="地图插件 - 你可以输入我想从哪去哪, 会给你个路线(步行/开车/公交)"></a>地图插件 - 你可以输入我想从哪去哪, 会给你个路线(步行/开车/公交)</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/map.png)<br>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/map2.png)<h4 id="天气插件-使用了百度api-获得城市的天气情况"><a href="#天气插件-使用了百度api-获得城市的天气情况" class="headerlink" title="天气插件 - 使用了百度api, 获得城市的天气情况"></a>天气插件 - 使用了百度api, 获得城市的天气情况</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/weather.png)<h4 id="北京公交插件-可以查询北京公交线路-获取实时的到某站的信息-有些线路站点不准"><a href="#北京公交插件-可以查询北京公交线路-获取实时的到某站的信息-有些线路站点不准" class="headerlink" title="北京公交插件 - 可以查询北京公交线路, 获取实时的到某站的信息(有些线路站点不准)"></a>北京公交插件 - 可以查询北京公交线路, 获取实时的到某站的信息(有些线路站点不准)</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/bus.png)<br>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/bus2.png)<h4 id="美食插件-使用大众点评网api-获取附近餐饮信息-评分-电话地址-距离等等"><a href="#美食插件-使用大众点评网api-获取附近餐饮信息-评分-电话地址-距离等等" class="headerlink" title="美食插件 - 使用大众点评网api, 获取附近餐饮信息, 评分, 电话地址,距离等等"></a>美食插件 - 使用大众点评网api, 获取附近餐饮信息, 评分, 电话地址,距离等等</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/dianping.png)<h4 id="技术活动插件-从segmentfault-csdn-车库咖啡-活动行获得最近的活动列表"><a href="#技术活动插件-从segmentfault-csdn-车库咖啡-活动行获得最近的活动列表" class="headerlink" title="技术活动插件 - 从segmentfault/csdn/车库咖啡/活动行获得最近的活动列表"></a>技术活动插件 - 从segmentfault/csdn/车库咖啡/活动行获得最近的活动列表</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/events.png)<h4 id="Github-issue插件-获得你个人或者组织下未处理的Pull-requests列表"><a href="#Github-issue插件-获得你个人或者组织下未处理的Pull-requests列表" class="headerlink" title="Github_issue插件 - 获得你个人或者组织下未处理的Pull requests列表"></a>Github_issue插件 - 获得你个人或者组织下未处理的Pull requests列表</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/issue.png)<h4 id="电影信息插件-列出最近上映和即将上映的电影信息"><a href="#电影信息插件-列出最近上映和即将上映的电影信息" class="headerlink" title="电影信息插件 - 列出最近上映和即将上映的电影信息"></a>电影信息插件 - 列出最近上映和即将上映的电影信息</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/movie.png)<h4 id="pycoders插件-获得订阅数据"><a href="#pycoders插件-获得订阅数据" class="headerlink" title="pycoders插件 - 获得订阅数据"></a>pycoders插件 - 获得订阅数据</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/pycoders.png)<h4 id="pythonweekly插件-获得订阅数据"><a href="#pythonweekly插件-获得订阅数据" class="headerlink" title="pythonweekly插件 - 获得订阅数据"></a>pythonweekly插件 - 获得订阅数据</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/pythonweekly.png)<h4 id="头条插件-获得今日头条新闻"><a href="#头条插件-获得今日头条新闻" class="headerlink" title="头条插件 - 获得今日头条新闻"></a>头条插件 - 获得今日头条新闻</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/toutiao.png)<h4 id="travel插件-旅游推荐-景点介绍"><a href="#travel插件-旅游推荐-景点介绍" class="headerlink" title="travel插件 - 旅游推荐/景点介绍"></a>travel插件 - 旅游推荐/景点介绍</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/travel.png)<br>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/travel2.png)<h4 id="v2ex-feed插件-获得一些节点的最新feed"><a href="#v2ex-feed插件-获得一些节点的最新feed" class="headerlink" title="v2ex feed插件 - 获得一些节点的最新feed"></a>v2ex feed插件 - 获得一些节点的最新feed</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/v2ex.png)<h4 id="help插件-列出所有插件的帮助信息"><a href="#help插件-列出所有插件的帮助信息" class="headerlink" title="help插件 - 列出所有插件的帮助信息"></a>help插件 - 列出所有插件的帮助信息</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/help.png)<h4 id="最主要的是小黄鸡-simsim"><a href="#最主要的是小黄鸡-simsim" class="headerlink" title="最主要的是小黄鸡(simsim)"></a>最主要的是小黄鸡(simsim)</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/simsim.png)<h4 id="也可以直接发到个人的slackbot-channel里"><a href="#也可以直接发到个人的slackbot-channel里" class="headerlink" title="也可以直接发到个人的slackbot channel里:"></a>也可以直接发到个人的slackbot channel里:</h4>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/direct.png)<br>![](<a href="https://raw.githubusercontent.com/python-" target="_blank" rel="noopener">https://raw.githubusercontent.com/python-</a><br>cn/slack_bot/master/screenshots/direct2.png)<h3 id="配置slack"><a href="#配置slack" class="headerlink" title="配置slack"></a>配置slack</h3>去你的slack组织的services页面. 比如我们是 <a href="https://pythoncn.slack.com/services/new" target="_blank" rel="noopener">https://pythoncn.slack.com/services/new</a>.<br>找到<code>Outgoing WebHooks</code>:<br><img src="https://cloud.githubusercontent.com/assets/841395/8311561/9ef87dc2-1a09-11e5-9d87-132d8d534042.png" alt><br>点击<code>Add+</code>并确认到新建页面:<br><img src="https://cloud.githubusercontent.com/assets/841395/8311562/9efaffa2-1a09-11e5-8584-58894ae6e254.png" alt><br><code>channel</code> 可以选择any,也可以指定单独一个. <code>Trigger Word(s)</code> 可以不填, 那就是所有的记录都会走.<br>也可以找关键词/字, 用逗号隔开. <code>url</code>就是你控制的回调的地址. 本图中的是我们用的herokuapp地址: &lt;<a href="https://slack-" target="_blank" rel="noopener">https://slack-</a><br>bot2.herokuapp.com/slack_callback&gt;<br>你还可以自定义icon的图标和名字:<br><img src="https://cloud.githubusercontent.com/assets/841395/8311563/9efe2ff6-1a09-11e5-8492-1dd39c4ae1d6.png" alt><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3>我还是抄袭了<a href="https://github.com/wong2/xiaohuangji-new" target="_blank" rel="noopener">小黄鸡</a>的插件思想. 但是完全脱离和小黄鸡的代码关系.<br>只留下了几个原有的插件并更新.<br>[plugins](<a href="https://github.com/python-" target="_blank" rel="noopener">https://github.com/python-</a><br>cn/slack_bot/tree/master/slack_bot/plugins)目录下有一些插件.<br>系统会按照plugins/<strong>init</strong>.py里面的 <strong>all</strong> 的列表顺序, 挨个插件对比是否符合. 符合即停止.<br>都不符合最后会使用simsim模块<br>具体的插件编写可以参看项目的[插件编写](<a href="https://github.com/python-" target="_blank" rel="noopener">https://github.com/python-</a><br>cn/slack_bot/blob/master/README.md#插件编写)<h3 id="一些trick"><a href="#一些trick" class="headerlink" title="一些trick"></a>一些trick</h3></li>
<li>假如你没有设置<code>Trigger Word</code>. 你要保证你的回复可以被停止, 否者你的回复会被当成下一次的输入. 这样就死循环了. 比如我们使用一个函数,<br>只要文本用<code>!</code>开头就不会回调. 表示这个是一个正常的,不想被out-going的记录.</li>
<li>这里的天气图片是一个html5的data image. 还有豆瓣电影的海报图片做了防盗链， 不能被slack识别和正常显示.<br>我的用法是upload到slack. 获得返回的url.然后在生成附件.</li>
<li>direct message其实是被限定了post的长度. 太长的话会报414. 需要对长数据切分. slack_bot已经实现了</li>
<li>现在simsim的借口被玩坏了, 有些低级，无聊，带有攻击性的回复. 酌情使用</li>
</ol>
<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>OSX下使用vagrant和docker管理创建虚拟环境</title>
    <url>/2016-05-22.html</url>
    <content><![CDATA[<p>####前言<br>乍一看题目出现了好多名词，根据我的理解一一说来<br>虚拟化: 其实就是因为云计算的催生的技术，目的是让运行在上面的应用程序觉得自己独占所有的资源。说白了就是资源管理/隔离和namspace的隔离.<br>Hypervisor:<br>这是虚拟化的一种,也就是操作系统上面在运行一个或者多个操作系统，这个底层的操作系统系统就是hypervisor.它来管理和分配那些创建的操作系统<br>所需要的资源.这种虚拟化也可以分成2种:原生(直接将虚拟的操作系统运行在裸机上，比如kvm和xen,确定是需要特定的硬件支持)和宿生(软件层面的，比如我这里<br>会用到的Virtualbox). 但是有个问题：运行了多个操作系统实例，开销很大，而且启动一个系统就要拿走一部分资源<br>LXC(LinuX Containers):是一种操作系统层面的虚拟化技术.它只运行 <strong>一个内核</strong><br>，一个虚拟的执行环境就是一个容器。可以为容器绑定特定的cpu和memory节点，<br>分配特定比例的cpu时间、IO时间，限制可以使用的内存大小等.遗憾的是LXC只支持linux，不支持BSD，OSX，WINDOWS，所以我下面在我的Mac里面是通过<br>Virtualbox生成容器的. 至于为什么选择LXC，我想除了开销小之外，就是方便快速的部署<br><a href="http://www.docker.io" target="_blank" rel="noopener">Docker</a>: 是一种增加了高级API的LinuX<br>Container（LXC）技术，来至<a href="https://www.dotcloud.com" target="_blank" rel="noopener">dotcloud</a>,<br>官网这样描述:提供了能够独立运行Unix进程的<br>轻量级虚拟化解决方案。它提供了一种在安全、可重复的环境中自动部署软件的方式.在<a href="http://www.infoq.com/cn/news/2013/04/Docker" target="_blank" rel="noopener">Infoq</a>你能找到主要特性，当然，3个月过去了，它肯定成长了很多<br><a href="https://github.com/mitchellh/vagrant" target="_blank" rel="noopener">Vagrant</a>: 是一个ruby语言的工具. 用于创建和部署虚拟化开发环境.<br>我们使用Vagrant在VirtualBox的虚拟机里安装docker<br>####什么系统来使用docker的一些想法<br>用OSX本来就有点…额，太绕. 其实docker已经被ubuntu官方支持，添加docker的PPA然后安装.<br>还可以把安装流程封装成Dockfile，用git做版本控制<br>####谁需要学习本文<br>我想运维同学会更需要一些.或者硬件资源缺乏的程序员们<br>程序员倒是可以学习把开发的应用放在虚拟机里面做成模板，可以使用vagrant管理<br>为什么这么说？要是为了不污染开发环境，我们python已经有个virtualenv+virtualenvwrapper.<br>对我这种程序员来说，我不需要那么多虚拟机,其次是我还有物理机的测试环境，并且我们线上的操作系统相当一致. 这篇文章就是为了了解docker<br>####安装Vagrant和Virtualbox<br>vagrant就是基于<a href="https://www.virtualbox.org" target="_blank" rel="noopener">Virtualbox</a>的，你可以使用gem安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gem install vagrant</span><br></pre></td></tr></table></figure>


<p>我喜欢最新版，手动安装的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget https://github.com/mitchellh/vagrant/archive/v1<span class="number">.2</span><span class="number">.2</span>.tar.gz  </span><br><span class="line">tar zxvf v1<span class="number">.2</span><span class="number">.2</span>.tar.gz  </span><br><span class="line">cd vagrant<span class="number">-1.2</span><span class="number">.2</span>  </span><br><span class="line">sudo gem install bundler  </span><br><span class="line">bundle install  </span><br><span class="line">rake install</span><br></pre></td></tr></table></figure>


<p>####从github克隆docker</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/dotcloud/docker.git  </span><br><span class="line">cd docker  </span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure>


<p>‘vagrant up’其实就是调用了virtualbox的终端接口打开你的虚拟机，类似下面的命令， 而不是你在界面点击’开始’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/Applications/VirtualBox.app/Contents/MacOS/VBoxHeadless --comment docker_1373340358 --startvm <span class="number">6e4</span>ea638<span class="number">-77</span>b2<span class="number">-400</span>d<span class="number">-9</span>fbe<span class="number">-3</span>b4e8d4fba21 --vrde config</span><br></pre></td></tr></table></figure>


<p>这时候你在virtualbox的界面可以看见启动的虚拟机,名字就是上面的docker_1373340358<br>在docker目录下已经有个一个Vagrantfile文件，你想想Makefile，意思很类似，其实为什么要这个docker源，<br>很大原因就是要用这个文件，因为它已经配置好了默认你要是用的box文件,类似执行了下面的命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vagrant init ubuntu http://files.vagrantup.com/http://files.vagrantup.com/precise64.box  </span><br><span class="line">.... <span class="comment">#一些配置  </span></span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure>


<p>首先说这里可能会报错,类似这个网页粘贴的<a href="http://wklej.org/id/836076/txt" target="_blank" rel="noopener">内容</a>， 内容有类似提示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">INFO interface: error: There was an error executing the following command <span class="keyword">with</span>  </span><br><span class="line">VBoxManage:  </span><br><span class="line">  </span><br><span class="line">[<span class="string">"import"</span>, <span class="string">"C:/Users/kwladyka/Desktop/My Dropbox/Vagrant/vagrant.d/boxes/base/bo  </span></span><br><span class="line"><span class="string">x.ovf"</span>]  </span><br><span class="line">  </span><br><span class="line">For more information on the failure, enable detailed logging <span class="keyword">with</span>  </span><br><span class="line">VAGRANT_LOG.</span><br></pre></td></tr></table></figure>


<p>解决办法是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd /Users/dongwm/.vagrant.d/boxes/ubuntu/virtualbox/  </span><br><span class="line">openssl sha1 *.vmdk *.ovf &gt; box.mf  </span><br><span class="line">cd -</span><br></pre></td></tr></table></figure>


<p>但是官网说这样会自动帮我们增加docker的PPA，更新源再安装lxc-docker，可是没有出现，我后来都是自己去执行的,如下<br>为什么用这个box？当然了其它系统都可以，你可以下载其它的虚拟机镜像，再安装其系统下的lxc-docker(我会准备一篇gentoo版本的文章)<br>####登录虚拟机</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>


<p>其实通过2222的端口转发登录了虚拟机的22端口，实际命令类似这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ssh vagrant@<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">2222</span> -o LogLevel=FATAL -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o   </span><br><span class="line">IdentitiesOnly=yes -i /Users/dongwm/.vagrant.d/insecure_private_key</span><br></pre></td></tr></table></figure>


<p>####我自己安装lxc-docker的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install python-software-properties  </span><br><span class="line">sudo add-apt-repository ppa:dotcloud/lxc-docker  </span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install lxc-docker</span><br></pre></td></tr></table></figure>


<p>####生成容器(虚拟机)并且创建一个sshd进程，以便使用者链接这个虚拟机<br>官网说的下载dhrp/sshd这个容器，但是我费了半天劲下载后报神奇的404…后来我在换了另外一个,这个pull其实就是去下载一个已经<br>被别人做好的实现某种功能的虚拟机，然后你使用这个实现基本功能的虚拟机，提交你的修改就变成你定制的版本了,当然你可以自己做一个容器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker pull base  <span class="comment">#pull基本的ubuntu镜像   </span></span><br><span class="line">docker run -i -t base /bin/bash <span class="comment">#-i表示进入交互模式，-t为启动一个终端，其实就是根据base镜像进入一个容器  </span></span><br><span class="line">root@<span class="number">4</span>a61c288be0f:/<span class="comment"># apt-get update &amp;&amp; apt-get install openssh-server #注意前面的PS，root权限，进入了这个容器，需要先安装sshd  </span></span><br><span class="line">root@<span class="number">4</span>a61c288be0f:/<span class="comment"># mkdir /var/run/sshd #要不然启动不了sshd  </span></span><br><span class="line">root@<span class="number">4</span>a61c288be0f:/<span class="comment"># /usr/sbin/sshd #启动sshd进程，不同的系统可能位置不同  </span></span><br><span class="line">root@<span class="number">4</span>a61c288be0f:/<span class="comment"># passwd #设置root密码,以后要ssh登录滴  </span></span><br><span class="line">root@<span class="number">4</span>a61c288be0f:/<span class="comment"># exit #退出容器 但是记住前面PS的一排随机号码 这里是4a61c288be0f  </span></span><br><span class="line">docker ps -a |less <span class="comment">#查看都有那些容器,也能看见上面的  </span></span><br><span class="line">docker commit <span class="number">4</span>a61c288be0f dongweiming/sshd <span class="comment">#这里的commit号码就是刚才记住的. 这样状态保存到dongwm/sshd,以后就不用下载openssh-server,设置root密码了</span></span><br></pre></td></tr></table></figure>


<p>想要简单的话直接这样嘛….</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker pull johnfuller/sshd  </span><br><span class="line">docker run -i -t johnfuller/sshd /bin/bash  </span><br><span class="line">root@<span class="number">2</span>fd1aabac314:/<span class="comment"># /usr/sbin/sshd  </span></span><br><span class="line">root@<span class="number">2</span>fd1aabac314:/<span class="comment"># passwd  </span></span><br><span class="line">root@<span class="number">2</span>fd1aabac314:/<span class="comment"># exit  </span></span><br><span class="line">docker commit <span class="number">2</span>fd1aabac314 dongweiming/sshd</span><br></pre></td></tr></table></figure>


<p>这里有个STATUS列，退出码有0，1，2，127等,验证你的容器正常运行,后面还有PORTS列，要是sshd启动了就会显示的<br>####启动容器,用我自己的sshd容器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rst=$(docker run -d dongwm/sshd -p <span class="number">22</span> /usr/sbin/sshd -D) <span class="comment">#执行这个会返回类似的字符数字串  </span></span><br><span class="line">docker ps <span class="comment">#你会发现它启动了  </span></span><br><span class="line">port=$(docker port $rst <span class="number">22</span>) <span class="comment">#这会显示在实际的虚拟机的这个容器专用的端口</span></span><br></pre></td></tr></table></figure>


<p>####ssh链接这个容器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ifconfig <span class="comment">#找你本机的ip  </span></span><br><span class="line">ssh root@<span class="number">192.168</span><span class="number">.33</span><span class="number">.10</span> -p $port <span class="comment">#port 好像默认从49153开始 这样输入root密码就登录进去了</span></span><br></pre></td></tr></table></figure>


<p>OK了<br>就是这样，然后当然你可以为这个虚拟机和你本机(注意三个关键词:本机(我的Mac),虚拟机(vagrant创建的vbox),容器(在vbox中创建的虚拟机，虚拟机中的虚拟机))<br>####把你的源push到docker,需要你注册. 可以被别人用，当然了 目前来说没啥用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker login  </span><br><span class="line">docker push dongweiming/sshd  <span class="comment">#要确保这个源没有被用,我这里是dongweiming和 dongweiming/sshd</span></span><br></pre></td></tr></table></figure>


<p>这样你以后想找个sshd的源,就可以这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker pull dongweiming/sshd</span><br></pre></td></tr></table></figure>


<p>但是这里面还是有很多其他的东西,往下看<br>####端口转发<br>你想，你这是在虚拟机里面创建了一堆容器，他可以连接本机，甚至上网，但是你不能直连到它，那么这时候就需要神奇的端口转发,<br>将你本机的端口的数据转发到这个vbox的端口，然后就可以看起来直连了,其实人家已经实现了<br>回到最上面的Vagrantfile，就是docker的根目录下.最后面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if !FORWARD_DOCKER_PORTS.nil?                                                    </span><br><span class="line">    Vagrant::VERSION &lt; <span class="string">"1.1.0"</span> <span class="keyword">and</span> Vagrant::Config.run do |config|               </span><br><span class="line">        (<span class="number">49000.</span><span class="number">.49900</span>).each do |port|                                            </span><br><span class="line">            config.vm.forward_port port, port                                    </span><br><span class="line">        end                                                                      </span><br><span class="line">    end                                                                          </span><br><span class="line">                                                                                 </span><br><span class="line">    Vagrant::VERSION &gt;= <span class="string">"1.1.0"</span> <span class="keyword">and</span> Vagrant.configure(<span class="string">"2"</span>) do |config|           </span><br><span class="line">        (<span class="number">49000.</span><span class="number">.49900</span>).each do |port|                                            </span><br><span class="line">            config.vm.network :forwarded_port, :host =&gt; port, :guest =&gt; port     </span><br><span class="line">        end                                                                      </span><br><span class="line">    end</span><br></pre></td></tr></table></figure>


<p>什么意思呢?其实你在本机的环境变量设置了FORWARD_DOCKER_PORTS，默认就会把49000..49900端口转发开启</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export FORWARD_DOCKER_PORTS=<span class="literal">True</span>，然后再vagrant up</span><br></pre></td></tr></table></figure>


<p>####其他系统镜像<br>不知道你有没有注意,我们在OSX上面安装的虚拟机是ubuntu的，在里面使用docker管理的容器也是ubuntu的，假如想用其他的操作系统容器呢?<br>比如找debian的,你可以使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker search debian</span><br></pre></td></tr></table></figure>


<p>或者在docker的索引网站搜索</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">https://index.docker.io</span><br></pre></td></tr></table></figure>


<p>我选择了 tianon/debian</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker pull tianon/debian</span><br></pre></td></tr></table></figure>


<p>比如还是刚才的ssh, -t 就不指base 而是tianon/debian</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run -i -t tianon/debian  /bin/bash</span><br></pre></td></tr></table></figure>


<p>####使用docker创建一个python的web环境，这里用我写的<a href="https://github.com/dongweiming/flask_reveal" target="_blank" rel="noopener">flask_reveal</a><br>上面说的是一个容器,当你有了root权限想要安装什么都可以，对我来说还可以设置一个专为某应用设置的环境,根据官网的说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker pull dongweiming/sshd <span class="comment">#一个构建python的web环境的镜像,根据上面的sshd我加的一些脚本在里面,然后下载了curl,python-pip等构建了一个环境  </span></span><br><span class="line">URL=https://github.com/dongweiming/flask_reveal/archive/v1<span class="number">.0</span>.tar.gz <span class="comment">#这是我提供的release版本  </span></span><br><span class="line">BUILD_JOB=$(docker run -d -t dongweiming/sshd:latest /usr/local/bin/buildapp $URL) <span class="comment">#其实就是创建一个容器,下载这个tar.gz安装包  </span></span><br><span class="line"><span class="comment"># 解压，进入目录下 格局需要安装依赖pip install -r requirements.txt  </span></span><br><span class="line">docker attach $BUILD_JOB <span class="comment">#因为刚才的任务就是下载解压你可以这样去查看这个任务的执行过程  </span></span><br><span class="line">BUILD_IMG=$(docker commit $BUILD_JOB reveal) <span class="comment">#把刚才的下载提交后commit到新的镜像 取名reveal.这里请注意[commit](http://docs.docker.io/en/latest/commandline/command/commit)的用法,  </span></span><br><span class="line"><span class="comment"># 加'-run'可以运行你想的某种/些服务,设置内存，主机名，端口转发，dns，环境变量等  </span></span><br><span class="line">WEB_WORKER=$(docker run -d -p <span class="number">5000</span> $BUILD_IMG /usr/local/bin/runapp) <span class="comment">#应用跑起来,这个runapp是我自己写的,启动mongodb, 根据我的reveal启动的流程  </span></span><br><span class="line">docker logs $WEB_WORKER <span class="comment">#可以查看manage.py已经启动了  </span></span><br><span class="line">WEB_PORT=$(docker port $WEB_WORKER <span class="number">5000</span>) <span class="comment">#使用虚拟机的一个端口映射到这个容器的5000端口  </span></span><br><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:$WEB_PORT <span class="comment">#好吧 你可以通过本机访问了</span></span><br></pre></td></tr></table></figure>

<p>版权声明：本文由 董伟明 原创，未经作者授权禁止任何微信公众号和向掘金(juejin.im)转载，<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="noopener">技术博客转载采用 保留署名-非商业性使用-禁止演绎 4.0-国际许可协议</a><br>python</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>制作linux还原镜像</title>
    <url>/2016-05-26-make-linux-iso.html</url>
    <content><![CDATA[<h1 id="ghost和g4l"><a href="#ghost和g4l" class="headerlink" title="ghost和g4l"></a>ghost和g4l</h1><p>安装操作系统，速度太慢，整个过程太冗长乏味了。<br>安装过程中，需要回答若干问题，系统需要安装无数个软件，创建和写入无数的文件。因为涉及到大量的文件定位和读写，速度一定是快不起来的。<br>Windows下我们常常使用ghost系统来备份和刻录操作系统。ghost可以clone整个系统的镜像，然后在新的电脑上恢复，相当简单。用ghost系统安装操作系统比使用安装光盘安装系统要快捷多了，也不需要回答任何问题了。<br>那么，我们能不能用ghost来备份和恢复Linux系统呢。<br>答案是不行。因为ghost只能识别很少的老旧Linux文件系统，也无法识别grub和LILO等引导加载程序。<br>其实，Linux下也有ghost工具，最著名的有g4l—ghostForLinux。<br>用了一下ghostForLinux。如果是整个磁盘的复制和恢复，还算简单。但是，我试了半天，也没办法实现对一个或者几个分区的恢复。<br>g4l，还是太弱了，无法满足我的要求！</p>
<h1 id="神奇的fdisk和dd命令"><a href="#神奇的fdisk和dd命令" class="headerlink" title="神奇的fdisk和dd命令"></a>神奇的fdisk和dd命令</h1><p>深深的苦恼中，灵光乍现：神奇的ghost的原理是什么呢？不就是数据复制吗？Linux下的dd命令不就是最强大的数据复制工具！<br>既然如此，我为什么要使用g4l这样复杂的工具呢？一条dd命令不就可以帮我实现任意复杂的镜像复制和恢复的需求了吗？管他是grub，还是ext4，btrfs，FAT32，NTFS…dd面前众生平等。<br>进入Linux操作系统，打开命令行，执行如下命令：<br>** sudo  fdisk -u -l**</p>
<p>可以查看所有磁盘上的所有分区的尺寸和布局情况。</p>
<p>-u，让start和end中数字的单位是512字节，也就是一个sector扇区的大小。</p>
<p>假设我有一个/dev/sda磁盘，有100GB大小。我安装了一个Ubuntu操作系统。使用了如下分区：<br>/dev/sda1 5GB<br>/dev/sda2 1GB 扩展分区<br>/dev/sda5 1GB 扩展分区</p>
<p>/dev/sda2是所有扩展分区，它的大小和/dev/sda5重合。<br>/dev/sda1是ext4格式的文件系统。用于安装ubuntu操作系统。</p>
<p>/dev/sda5是swap格式的文件系统，作为交换分区。</p>
<p>如果我用弱智的g4l工具制作系统的镜像，就需要备份整个磁盘100GB，而不是我需要的6GB。</p>
<p>g4l也可以单独备份分区，但是在恢复时，就需要在目标计算机上安装好grub，并进行了适当的分区。很麻烦！</p>
<p>我这里，可以使用一条dd命令就生成6GB的镜像。然后可以在任意硬盘大于6GB的计算机上恢复出完整的系统，包括MBR和3个分区sda1,sda2,sda5。</p>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>找一个U盘，安装UbuntuLive Cd系统。【具体如何制作U盘启动的UbuntuLive CD，可以参考Ubuntu官方网站的帮助。】<br>UbuntuLive Cd和WindowsPE系统类似，是光盘/U盘引导的Ubuntu操作系统，不需要安装就可以直接使用。</p>
<p>U盘启动，进入盘上的Ubuntu系统，打开命令行，执行：<br>** sudo  fdisk -u -l /dev/sda**<br>查看硬件的分区情况。</p>
<p>然后执行：<br><strong>dd   bs=512 count=[fdisk**</strong>命令中最大的end数+1] if=/dev/sda of=/ghost.img**<br>这样，就可以把我需要的分区数据全部copy到ghost.img文件中。镜像制作完成了！</p>
<p>然后，我们就可以把U盘插到其他系统上，用U盘启动，进入UbuntuLiveCD，打开命令行，执行如下命令：<br><strong>dd if=/ghost.img of=/dev/sda</strong></p>
<p>完成后，拔掉U盘，启动计算机，就可以看到我们的Linux系统已经安装完毕了！</p>
<p><strong>注意：</strong><br>**       不要直接在计算机上用本地磁盘启动系统后执行dd命令生成本地磁盘的镜像。而应该使用livecd启动计算机。**<br>**        因此计算机运行时会对系统盘产生大量写操作。 直接对运行中的系统盘生成的镜像，在恢复到其他硬盘上时，很可能会无法启动！**</p>
<h1 id="一样适用于非Linux操作系统"><a href="#一样适用于非Linux操作系统" class="headerlink" title="一样适用于非Linux操作系统"></a>一样适用于非Linux操作系统</h1><p>在linux上用dd命令实现系统镜像备份和恢复，是不是很简单呢？<br>对于Windows系统，甚至Mac等等任意系统，其实都可以用dd命令实现系统镜像的备份和恢复。<br>因为，Linux的fdisk命令能够识别任意系统下的分区格式。fdisk并不关系分区上的文件系统，甚至有无文件系统都不关心。fdisk总是可以报告分区占用了哪些扇区。<br>dd命令也不关心磁盘的文件系统格式，它只是简单地按照要求从指定的位置，复制多少字节数据而已。<br>dd命令实现镜像备份和恢复，比Ghost软件简单和强大多了。使用ghost软件，依然需要用户进行复杂而危险的磁盘分区操作。<br>而使用fdisk和dd这两条命令，一切都免了！</p>
<h1 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h1><p>   可能我们需要备份的分区很大，使用dd命令生成的镜像文件也就很大。存储和传输这些镜像不太方便。  我们也可以使用压缩程序压缩生成的镜像文件。 这里，我选择使用gzip程序，配合dd命令一起使用。</p>
<p>gzip参数：<br>-c 表示输出到stdout<br>-d  表示解压缩<br>-1 表示最快压缩<br>-9 表示最好压缩<br>默认使用的是-6压缩级别。<br>要使用 dd 和 gzip 生成压缩的镜像文件，可以执行命令： `#  ** dd   bs=512<br>count=[fdisk命令中最大的end数+1] if=/dev/sda | gzip -6 &gt; /ghost.img.gz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">还原时，可以执行下列命令： $: gzip -dc /ghost.img.gz.gz | dd of=/dev/sda</span><br></pre></td></tr></table></figure>

<p><strong>提醒：</strong><br>     如果你把镜像恢复到另一台计算机上，你可能会发现你的网卡是eth1，而不是eth0。这是因为</p>
<p>/etc/udev/rules.d/70-persistent-net.rules   文件把你做镜像的计算机的网卡作为eth0登记了。</p>
<pre><code> 如果你的网络脚本对eth0进行了处理，而没有对eth1进行处理，那么不修改网络脚本，你可能就无法上网了。

也许你会希望在做镜像之前，先删除 /etc/udev/rules.d/70-persistent-net.rules 文件。这样你恢复镜像时，网卡的名字就是eth0。   就不会造成你在恢复后的计算机上无法上网的问题了。</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ghost</tag>
        <tag>ubuntu</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>redhat7下rdo方式安装openstack笔记</title>
    <url>/2016-06-19-redhat-rdo-install-openstack.html</url>
    <content><![CDATA[<p>学习openstack在安装过程中也遇到了很多的问题，，在此记录一下：</p>
<ol>
<li>首先查看硬件是否支持虚拟化：<br>linux下：<br>grep -E ‘svm|vmx’ /proc/cpuinfo</li>
</ol>
<p>有输出信息说明支持，然后在bios中开启虚拟化<br>如果不支持虚拟化，openstack会默认使用软件虚拟化技术qemu来创建虚拟机，性能上和kvm差距很大，并且个人赶脚比较占内存；<br>2. 先用 YUM 安裝 RDO 及 openstack-packstack</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> yum update -y</span><br><span class="line"><span class="meta">$</span> yum install -y http://rdo.fedorapeople.org/rdo-release.rpm</span><br><span class="line"><span class="meta">$</span> yum install -y openstack-packstack</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>本机设置成静态ip：<br>$ vim /etc/sysconfig/network-scripts/ifcfg-eno16777736</li>
</ol>
<p>修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HWADDR=00:0C:29:99:3C:45</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=eno16777736</span><br><span class="line">UUID=88d86789-394c-4647-b8e6-88f14a652c84</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.1.50</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line">DNS1=114.114.114.114</span><br></pre></td></tr></table></figure>

<p>重启网卡：</p>
<p>$ systemctl restart network</p>
<p>4.生成安装配置文件：</p>
<p>$ packstack –gen-answer-file=allinone.txt<br>$ vim allinone.txt</p>
<p>配置需要安装的服务和设置密码，根据个人需要设置，然后执行费时较长的最终安装：</p>
<p>$ packstack –answer-file=allinone.txt</p>
<p>国内安装过程中极有可能会中断，重新执行即可，直到安装成功。</p>
<p>5.allinone方式安装成功以后需要配置网卡：</p>
<p>$ vim /etc/sysconfig/network-scripts/ifcfg-eno16777736 配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HWADDR=00:0C:29:99:3C:45</span><br><span class="line">#TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=eno16777736</span><br><span class="line">UUID=88d86789-394c-4647-b8e6-88f14a652c84</span><br><span class="line">#ONBOOT=yes</span><br><span class="line">#IPADDR=192.168.1.50</span><br><span class="line">#PREFIX=24</span><br><span class="line">#GATEWAY=192.168.1.1</span><br><span class="line">#DNS1=114.114.114.114</span><br><span class="line">TYPE=OVSPort</span><br><span class="line">DEVICETYPE=ovs</span><br><span class="line">OVS_BRIDGE=br-ex</span><br></pre></td></tr></table></figure>

<p>vim /etc/sysconfig/network-scripts/ifcfg-br-ex 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEVICE=br-ex</span><br><span class="line">DEVICETYPE=ovs</span><br><span class="line">TYPE=OVSBridge</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.1.50</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>

<p>重启网卡：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> systemctl restart network</span><br></pre></td></tr></table></figure>

<p>记录的一些问题：<br>a. packstack –answer-file=xxx.txt安装过程，有可能因为源的原因中断，你可以修改一下netns.pp文件中延时。</p>
<p>b.创建云主机参照：<a href="http://www.chenshake.com/centos6-4-single-card-all-in-one-install-havana/" target="_blank" rel="noopener">http://www.chenshake.com/centos6-4-single-card-all-in-one-install-havana/</a> 照着步骤用SecureCRT登录不上云主机，提示：需要一个.pub的公钥文件，所以照着第四步用用户名和密码登录的</p>
<p>c.登录云主机参照：<a href="http://www.chenshake.com/openstack-mirror-and-password/" target="_blank" rel="noopener">http://www.chenshake.com/openstack-mirror-and-password/</a></p>
<p>d. DNS的错误，今天搭了CentOS6.5上RDO（Vlan）双节点安装Icehouse版本：总是报DNS的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR : Failed to run remote script, stdout: Loaded plugins: fastestmirror, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">* epel: mirrors.neusoft.edu.cn</span><br><span class="line"></span><br><span class="line">stderr: Warning: Permanently added '192.168.115.115' (RSA) to the list of known hosts.</span><br><span class="line">+ trap t ERR</span><br><span class="line">+ yum install -y puppet openssh-clients tar nc rubygem-json</span><br><span class="line">http://yum.theforeman.org/releases/1.3/el6/x86_64/repodata/repomd.xml: [Errno 14] PYCURL ERROR 6 - "Couldn't resolve host 'yum.theforeman.org'"</span><br><span class="line">Trying other mirror.</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: foreman. Please verify its path and try again</span><br><span class="line">++ t</span><br><span class="line">++ exit 1</span><br><span class="line">Please check log file /var/tmp/packstack/20141102-222130-D8Ve6D/openstack-setup.log for more information</span><br></pre></td></tr></table></figure>

<p>最后yum update以后还是报DNS的错误：于是把8.8.8.8 改成了114.114.114.114，关了计算节点的iptables和Selinux以后就好了，记录一下</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>epel</tag>
        <tag>centos7</tag>
        <tag>openstack</tag>
        <tag>rdo</tag>
        <tag>redhat7</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu修改/etc/fstab文件无法进入系统</title>
    <url>/2016-05-26-ubuntu-modify-fstab-not-enter-system.html</url>
    <content><![CDATA[<p>ubuntu修改/etc/fstab文件无法进入系统：</p>
<p>重启进入第二个选项：</p>
<p>进入drop to root shell prompt</p>
<p>$ mount -o remount,rw /</p>
<p>然后vim /etc/fstab修改配置文件保存退出，重启即可。</p>
<p>redhat：</p>
<p>在虚拟机刚开启时按e键，进入到界面，有如下条目</p>
<p>Enterprise linux (2.6.18-128.el5)</p>
<p>然后按e键，进入一个界面，如下条目</p>
<p>kernel /vmlinuz-2.6.18-128.el5 ro root=LABEL=/ rhgb quite<br>把光标移动这行后，再按一下e键，进入编辑这行；在行尾条一个空格 ，然后输入 <a href="http://linux.chinaitlab.com/" target="_blank" rel="noopener">linux</a> single</p>
<p>也就是类似如下的：</p>
<p>kernel /vmlinuz-2.6.18-128.el5 ro root=LABEL=/ rhgb quite linux quite<br>结束编辑，按回车返回；</p>
<p>接着我们要启动系统，按一下b键启动；</p>
<p>在启动过程中，因为/etc/fstab修改错误，导致磁盘检查报错。此时，输入root密码后，进入字符界面，</p>
<p>系统是只读的（执行vi /etc/fstab后，无法保存，报错说read only），要运行下面的命令；</p>
<p>$ mount -o remount,rw /</p>
<p>然后，执行如下操作，改正/etc/fstab，保存退出，重启</p>
<p>$ vi /etc/fstab<br>$ reboot</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ubuntu</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python来写5种排序方法冒泡，选择，插入，归并，快排</title>
    <url>/2016-06-20-five-methods-sort-in-python.html</url>
    <content><![CDATA[<h2 id="Python写五种排序"><a href="#Python写五种排序" class="headerlink" title="Python写五种排序"></a>Python写五种排序</h2><h4 id="1-冒泡排序："><a href="#1-冒泡排序：" class="headerlink" title="1.冒泡排序："></a>1.冒泡排序：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble</span><span class="params">(ori_list, n)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	冒泡排序	</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):	</span><br><span class="line">			<span class="keyword">if</span> ori_list[j] &gt; ori_list[j+<span class="number">1</span>]:</span><br><span class="line">				ori_list[j], ori_list[j+<span class="number">1</span>] = ori_list[j+<span class="number">1</span>], ori_list[j]</span><br></pre></td></tr></table></figure>

<h4 id="2-选择排序："><a href="#2-选择排序：" class="headerlink" title="2.选择排序："></a>2.选择排序：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(ori_list, n)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	选择排序</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">		min_num = i<span class="number">-1</span></span><br><span class="line">		j = i</span><br><span class="line">		<span class="keyword">while</span> j &lt; n:</span><br><span class="line">			<span class="keyword">if</span> ori_list[j] &lt; ori_list[min_num]:</span><br><span class="line">				min_num = j</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		ori_list[i<span class="number">-1</span>], ori_list[min_num] = ori_list[min_num], ori_list[i<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="3-插入排序："><a href="#3-插入排序：" class="headerlink" title="3.插入排序："></a>3.插入排序：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(ori_list, n)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	插入排序</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">		tmp = ori_list[i]</span><br><span class="line">		j = i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> j &gt; <span class="number">-1</span>:</span><br><span class="line">			<span class="keyword">if</span> ori_list[j] &gt; tmp:</span><br><span class="line">				ori_list[j+<span class="number">1</span>] = ori_list[j]</span><br><span class="line">				ori_list[j] = tmp</span><br><span class="line">			j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-归并排序："><a href="#4-归并排序：" class="headerlink" title="4.归并排序："></a>4.归并排序：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	归并排序</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	result = []	</span><br><span class="line">	<span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">		<span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">			result.append(left[i])</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			result.append(right[j])</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">	result += left[i:]</span><br><span class="line">	result += right[j:]</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(ori_list)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(ori_list) &lt;= <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> ori_list	</span><br><span class="line">	mid = len(ori_list)/<span class="number">2</span></span><br><span class="line">	left = merge_sort(ori_list[:mid])</span><br><span class="line">	right = merge_sort(ori_list[mid:])</span><br><span class="line">	<span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure>

<h4 id="5-快速排序："><a href="#5-快速排序：" class="headerlink" title="5.快速排序："></a>5.快速排序：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(lists, left, right)</span>:</span></span><br><span class="line">    <span class="comment"># 快速排序</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span> lists</span><br><span class="line">    key = lists[left]</span><br><span class="line">    low = left</span><br><span class="line">    high = right</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[right] &gt;= key:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        lists[left] = lists[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[left] &lt;= key:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        lists[right] = lists[left]</span><br><span class="line">    lists[right] = key</span><br><span class="line">    quick_sort(lists, low, left - <span class="number">1</span>)</span><br><span class="line">    quick_sort(lists, left + <span class="number">1</span>, high)</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line">res_list = quick_sort(ori_list, <span class="number">0</span>, len(ori_list)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'quick_sort:'</span>, res_list</span><br></pre></td></tr></table></figure>

<ul>
<li>简易写法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(q) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = q[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> qsort([x <span class="keyword">for</span> x <span class="keyword">in</span> q[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; p]) + [p] + qsort([x <span class="keyword">for</span> x <span class="keyword">in</span> q[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= p])</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>linux</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Django添加富文本编辑器DjangoUeditor</title>
    <url>/2016-06-20-django-add-DjangoUeditor.html</url>
    <content><![CDATA[<p>1.上DjangoUeditor的github官网下载安装Ueditor，网址如下：<a href="https://github.com/zhangfisher/DjangoUeditor.git" target="_blank" rel="noopener">https://github.com/zhangfisher/DjangoUeditor.git</a> 按照readme.md安装即可<br>推荐下载DjangoUeditor源码到项目根目录下</p>
<p>2.django admin中配置富文本编辑器：<br>a. settings.py中添加apps：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (             </span><br><span class="line">    &apos;django.contrib.admin&apos;,    </span><br><span class="line">    &apos;django.contrib.auth&apos;,     </span><br><span class="line">    &apos;django.contrib.contenttypes&apos;,</span><br><span class="line">    &apos;django.contrib.sessions&apos;, </span><br><span class="line">    &apos;django.contrib.messages&apos;,</span><br><span class="line">    &apos;django.contrib.staticfiles&apos;,</span><br><span class="line">    &apos;bootstrap_toolkit&apos;,</span><br><span class="line">    &apos;DjangoUeditor&apos;,  </span><br><span class="line">    &apos;news&apos;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>b. urls.py中配置ueditor的路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url(r&apos;^ueditor/&apos;, include(&apos;DjangoUeditor.urls&apos;)),</span><br></pre></td></tr></table></figure>

<p>c. models.py中添加ueditor字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> DjangoUeditor.models <span class="keyword">import</span> UEditorWidget</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span><span class="params">(BaseModel)</span>:</span>         </span><br><span class="line">    title = models.CharField(verbose_name=<span class="string">u"新闻标题"</span>, max_length=<span class="number">127</span>)</span><br><span class="line">    content = UEditorField(<span class="string">u"文章正文"</span>, width=<span class="number">600</span>, height=<span class="number">300</span>, default=<span class="string">u''</span>, blank=<span class="literal">True</span>, imagePath=<span class="string">"uploads/images/"</span>,</span><br><span class="line">             toolbars=<span class="string">'besttome'</span>, filePath=<span class="string">'uploads/files/'</span>)</span><br></pre></td></tr></table></figure>

<p>d. 在admin.py中添加ueditor</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> News</span><br><span class="line"><span class="keyword">from</span> django.utils.html <span class="keyword">import</span> strip_tags</span><br><span class="line"><span class="keyword">from</span> DjangoUeditor.models <span class="keyword">import</span> UEditorWidget</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    content=forms.CharField(widget=UEditorWidget(attrs=&#123;<span class="string">'width'</span>: <span class="number">1000</span>, <span class="string">'height'</span>: <span class="number">500</span>,</span><br><span class="line">                            <span class="string">'imagePath'</span>: <span class="string">'uploads/images/'</span>, <span class="string">'filePath'</span>: <span class="string">'uploads/files/'</span>&#125;))</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = News</span><br><span class="line">        exclude = []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    form = NewsForm</span><br><span class="line">    <span class="comment"># 只读字段</span></span><br><span class="line">    readonly_fields = [<span class="string">'_get_thumbnail'</span>, <span class="string">'create_time'</span>]</span><br><span class="line">    <span class="comment"># 可编辑的字段</span></span><br><span class="line">    fields = [<span class="string">'title'</span>, <span class="string">'publish_time'</span>,<span class="string">'is_active'</span>, <span class="string">'news_type'</span>, <span class="string">'index_flag'</span>, <span class="string">'cover_image'</span>, <span class="string">'slide_show'</span>,</span><br><span class="line">              <span class="string">'_get_thumbnail'</span>, <span class="string">'introduce'</span>, <span class="string">'content'</span>]</span><br><span class="line">    <span class="comment"># 列表页展示字段</span></span><br><span class="line">    list_display = (<span class="string">'title'</span>, <span class="string">'introduce'</span>,)</span><br><span class="line">    <span class="comment"># 筛选字段</span></span><br><span class="line">    list_filter = [<span class="string">'publish_time'</span>]</span><br><span class="line">    <span class="comment"># 搜索字段</span></span><br><span class="line">    search_fields = [<span class="string">'title'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_content</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> strip_tags(obj.content)[:<span class="number">20</span>]</span><br><span class="line">    _get_content.short_description = <span class="string">'内容'</span></span><br><span class="line">    _get_content.allow_tags = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">admin.site.register(News, NewsAdmin)</span><br></pre></td></tr></table></figure>

<p>e. 参数说明：<br>文件图片和视频都是保存在MEDIA_ROOT目录下，所以需要在settings.py文件中指定MEDIA_ROOT = os.path.join(BASE_DIR, ‘media’)<br>imagePath 保存图片的目录<br>filePath 保存文件的目录</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>linux</tag>
        <tag>DjangoUeditor</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的中英文混搭字符串中文的提取</title>
    <url>/2016-06-21-python-search-ch-in-string.html</url>
    <content><![CDATA[<h3 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h3><p>re.compile(pattern, flags=0)<br>编译正则表达式，返回RegexObject对象，然后可以通过RegexObject对象调用match()和search()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'hi新手oh'</span>.decode(<span class="string">'utf-8'</span>) <span class="comment">#举个栗子是字符串s，为了匹配下文的unicode形式，所以需要解码</span></span><br><span class="line">p = re.compile(<span class="string">ur'[\u4e00-\u9fa5]'</span>) <span class="comment">#这里是精髓，[\u4e00-\u9fa5]是匹配所有中文的正则，因为是unicode形式，所以也要转为ur</span></span><br></pre></td></tr></table></figure>

<p>print p.split(s) #使用re库的split切割</p>
<p>中英文混搭字符串中文的提取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">mys = <span class="string">u'hi新手oh上o路hea多ooo多oo指教98'</span> <span class="comment">#提取其中的中文字符串</span></span><br><span class="line">p = re.compile(<span class="string">ur'[\u4e00-\u9fa5]'</span>)</span><br><span class="line">res = re.findall(p, mys)</span><br><span class="line">result = <span class="string">''</span>.join(res)</span><br><span class="line"><span class="keyword">print</span> result</span><br></pre></td></tr></table></figure>

<p>新手上路多多指教</p>
<p>###<img src="%3C!--%EF%BF%BC2--%3E2016/06/%E6%AD%A3%E5%88%99%E5%9B%BE-1.png" alt="正则图"><br><img src="%3C!--%EF%BF%BC3--%3Ehome-bg.jpg" alt="正则图"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim实用技巧</title>
    <url>/2016-06-23-vim-methods.html</url>
    <content><![CDATA[<h4 id="指定开始行到结尾行缩进："><a href="#指定开始行到结尾行缩进：" class="headerlink" title="指定开始行到结尾行缩进："></a>指定开始行到结尾行缩进：</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">：<span class="number">2</span>,<span class="number">7</span>&gt;    指定第<span class="number">2</span>到第<span class="number">7</span>行右缩进一个单位</span><br></pre></td></tr></table></figure>

<p>vim拷贝指定行到目的行：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">：30,50 co 20     #copy 30行到50行内容到20行;</span><br></pre></td></tr></table></figure>

<p>注释多行:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Ctl +v 方向键向下指定行 shift + i  注释符  esc</span><br></pre></td></tr></table></figure>

<p>uwsgi依赖与lxml ,  必须先装lxml再装uwsgi</p>
<p>否则会报错</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title>python对时间日期做格式化</title>
    <url>/2016-07-06-python-datetime-format.html</url>
    <content><![CDATA[<ol>
<li>Python格式化日期时间的函数为datetime.datetime.strftime()；由字符串转为日期型的函数为：datetime.datetime.strptime()，两个函数都涉及日期时间的格式化字符串，列举如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span>a Abbreviated weekday name</span><br><span class="line"><span class="meta">%</span>A Full weekday name</span><br><span class="line"><span class="meta">%</span>b Abbreviated month name</span><br><span class="line"><span class="meta">%</span>B Full month name</span><br><span class="line"><span class="meta">%</span>c Date and time representation appropriate for locale</span><br><span class="line"><span class="meta">%</span>d Day of month as decimal number (01 - 31)</span><br><span class="line"><span class="meta">%</span>H Hour in 24-hour format (00 - 23)</span><br><span class="line"><span class="meta">%</span>I Hour in 12-hour format (01 - 12)</span><br><span class="line"><span class="meta">%</span>j Day of year as decimal number (001 - 366)</span><br><span class="line"><span class="meta">%</span>m Month as decimal number (01 - 12)</span><br><span class="line"><span class="meta">%</span>M Minute as decimal number (00 - 59)</span><br><span class="line"><span class="meta">%</span>p Current locale's A.M./P.M. indicator for 12-hour clock</span><br><span class="line"><span class="meta">%</span>S Second as decimal number (00 - 59)</span><br><span class="line"><span class="meta">%</span>U Week of year as decimal number, with Sunday as first day of week (00 - 51)</span><br><span class="line"><span class="meta">%</span>w Weekday as decimal number (0 - 6; Sunday is 0)</span><br><span class="line"><span class="meta">%</span>W Week of year as decimal number, with Monday as first day of week (00 - 51)</span><br><span class="line"><span class="meta">%</span>x Date representation for current locale</span><br><span class="line"><span class="meta">%</span>X Time representation for current locale</span><br><span class="line"><span class="meta">%</span>y Year without century, as decimal number (00 - 99)</span><br><span class="line"><span class="meta">%</span>Y Year with century, as decimal number</span><br><span class="line"><span class="meta">%</span>z, %Z Time-zone name or abbreviation; no characters if time zone is unknown</span><br><span class="line"><span class="meta">%</span>% Percent sign</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>举一个例子：</p>
<p>ebay中时间格式为‘Sep-21-09 16:34’</p>
<p>则通过下面代码将这个字符串转换成datetime</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = datetime.datetime.strptime(‘Sep-21-09 16:34’,’%b-%d-%y %H:%M’);<br>c<br>datetime.datetime(2009, 9, 21, 16, 34)</p>
</blockquote>
</blockquote>
</blockquote>
<p>又如：datetime转换成字符串</p>
<blockquote>>> datetime.datetime.now().strftime('%b-%d-%y %H:%M:%S');
'Sep-22-09 16:48:08'</blockquote>

<ol start="2">
<li>获取指定日期的n个月之后（或之前）的日期</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">months</span><span class="params">(dt, months)</span>:</span>  <span class="comment"># 这里的months 参数传入的是正数表示往后 ，负数表示往前</span></span><br><span class="line">    month = dt.month - <span class="number">1</span> + months</span><br><span class="line">    year = dt.year + month / <span class="number">12</span></span><br><span class="line">    month = month % <span class="number">12</span> + <span class="number">1</span></span><br><span class="line">    day = min(dt.day, calendar.monthrange(year, month)[<span class="number">1</span>])</span><br><span class="line">    dt = dt.replace(year=year, month=month, day=day)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dt</span><br><span class="line">求两天以前的日期：</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">today = datetime.datetime.now()</span><br><span class="line">morning_day = datetime.datetime(today.year, today.month, today.day, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">before_two_day = today - datetime.timedelta(days=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>django utc时间格式不兼容的问题：RuntimeWarning: DateTimeField MonthlyStatistics.start_time received a naive datetime (2016-06-30 00:00:00) while time zone support is active.<br>RuntimeWarning)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line">utc = pytz.timezone(<span class="string">'UTC'</span>)</span><br><span class="line">today = datetime.date.today()</span><br><span class="line">today_start = datetime.datetime(today.year, today.month, today.day).replace(tzinfo=utc)</span><br><span class="line">end_day = today_start - datetime.timedelta(days=today_start.day)</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>查找附近的人功能实现</title>
    <url>/2016-08-09-find-somebody-in-map.html</url>
    <content><![CDATA[<ul>
<li>查找附近的人是移动开发非常流行的功能，最近在给移动端写后台接口，上午查了很多资料发现用geohash算法的人居多，本来想自己设计数据库来实现以下geohash的，但是项目赶得紧，正好发现新版的redis支持geo的地理位置的操作：</li>
</ul>
<ol>
<li>安装最新版的redis3.2.3+</li>
<li>redis的geo模块支持的操作有：</li>
</ol>
<p>添加位置和获取位置<br>为了进行地理位置相关操作， 我们首先需要将具体的地理位置记录起来， 这一点可以通过执行 GEOADD 命令来完成， 该命令的基本格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOADD location-set longitude latitude name [longitude latitude name ...]</span><br></pre></td></tr></table></figure>

<p>GEOADD 命令每次可以添加一个或多个经纬度地理位置。 其中 location-set 为储存地理位置的集合， 而 longitude 、 latitude 和 name 则分别为地理位置的经度、纬度、名字。</p>
<p>举个例子， 以下代码展示了如何通过 GEOADD 命令， 将清远、广州、佛山、东莞、深圳等数个广东省的市添加到位置集合 Guangdong-cities 里面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> GEOADD Guangdong-cities 113.2099647 23.593675 Qingyuan</span><br></pre></td></tr></table></figure>

<ol>
<li>– 成功添加一个位置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> GEOADD Guangdong-cities 113.2278442 23.1255978 Guangzhou 113.106308 23.0088312 Foshan 113.7943267 22.9761989 Dongguan 114.0538788 22.5551603 Shenzhen</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>– 成功添加四个位置<br>在将位置记录到位置集合之后， 我们可以使用 GEOPOS 命令， 输入位置的名字并取得位置的具体经纬度：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOPOS location-set name [name ...]</span><br></pre></td></tr></table></figure>

<p>比如说， 如果我们想要获取清远、广州和佛山的经纬度， 那么可以执行以下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> GEOPOS Guangdong-cities Qingyuan Guangzhou Foshan</span><br><span class="line">1) 1) "113.20996731519699" -- 清远的经度</span><br><span class="line">2) "23.593675019671288" -- 清远的纬度</span><br><span class="line">2) 1) "113.22784155607224" -- 广州的经度</span><br><span class="line">2) "23.125598202060807" -- 广州的纬度</span><br><span class="line">3) 1) "113.10631066560745" -- 佛山的经度</span><br><span class="line">2) "23.008831202413539" -- 佛山的纬度</span><br></pre></td></tr></table></figure>

<ul>
<li><p>计算两个位置之间的距离</p>
</li>
<li><p>在拥有了地理数据之后， 我们就可以基于这些数据进行各种各样的操作。 针对地理位置信息的其中一个最简单的操作， 就是计算两个位置之间的距离。</p>
</li>
<li><p>在 Redis 里面， 计算两个位置之间的距离可以通过 GEODIST 命令来实现：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEODIST location-set location-x location-y [unit]</span><br></pre></td></tr></table></figure>

<p>在调用这个命令时， 用户需要给定想要计算差距的地点 location-x 和 location-y ， 以及储存这两个地点的地理位置集合。</p>
<p>可选参数 unit 用于指定计算距离时的单位， 它的值可以是以下单位的其中一个：</p>
<p>m 表示单位为米。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。<br>如果用户没有指定 unit 参数， 那么 GEODIST 默认使用米为单位。</p>
<p>作为例子， 以下代码展示了如何计算清远和广州之间的距离：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> GEODIST Guangdong-cities Qingyuan Guangzhou</span><br></pre></td></tr></table></figure>

<p>“52094.433840356309” – 两地相距 52094 米<br>上面的计算结果使用了米来表示清远和广州两地的距离， 不过在表示比较长的距离时， 我们更习惯采用公里（km）作为单位。 通过显式地给定 km （千米）作为单位， 我们可以让 GEODIST 显示两个地点之间相距的公里数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> GEODIST Guangdong-cities Qingyuan Guangzhou km</span><br></pre></td></tr></table></figure>

<p>“52.094433840356309” – 两地相距 52 公里</p>
<p>获取指定范围内的元素<br>除了计算两地的距离之外， 另一个常见的地理位置操作就是找出特定范围之内的其他存在的地点。 比如找出地点 x 范围 100 米之内的所有地点， 找出地点 y 范围 50 公里之内的所有地点等等。</p>
<p>Redis 提供了 GEORADIUS 和 GEORADIUSBYMEMBER 两个命令来实现查找特定范围内地点的功能， 它们的作用一样， 只是指定中心点的方式不同： GEORADIUS 使用用户给定的经纬度作为计算范围时的中心点， 而 GEORADIUSBYMEMBER 则使用储存在位置集合里面的某个地点作为中心点。 以下是这两个命令的基本格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEORADIUS location-set longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count]</span><br><span class="line">GEORADIUSBYMEMBER location-set location radius m|km|ft|mi [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count]</span><br></pre></td></tr></table></figure>

<ul>
<li>这两个命令的各个参数的意义如下：<br>m|km|ft|mi 指定的是计算范围时的单位；<br>如果给定了可选的 WITHCOORD ， 那么命令在返回匹配的位置时会将位置的经纬度一并返回；<br>如果给定了可选的 WITHDIST ， 那么命令在返回匹配的位置时会将位置与中心点之间的距离一并返回；<br>在默认情况下， GEORADIUS 和 GEORADIUSBYMEMBER 的结果是未排序的， ASC 可以让查找结果根据距离从近到远排序， 而 DESC 则可以让查找结果根据从远到近排序；<br>COUNT 参数指定要返回的结果数量。<br>作为示例， 我们可以使用 GEORADIUSBYMEMBER 去找出位于广州 50 公里、 100 公里以及 150 公里以内的城市：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> GEORADIUSBYMEMBER Guangdong-cities Guangzhou 50 km</span><br><span class="line">1) "Foshan"</span><br><span class="line">2) "Guangzhou"</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span> GEORADIUSBYMEMBER Guangdong-cities Guangzhou 100 km</span><br><span class="line">1) "Foshan"</span><br><span class="line">2) "Guangzhou"</span><br><span class="line">3) "Dongguan"</span><br><span class="line">4) "Qingyuan"</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span> GEORADIUSBYMEMBER Guangdong-cities Guangzhou 150 km</span><br><span class="line">1) "Foshan"</span><br><span class="line">2) "Guangzhou"</span><br><span class="line">3) "Dongguan"</span><br><span class="line">4) "Qingyuan"</span><br><span class="line">5) "Shenzhen"</span><br></pre></td></tr></table></figure>

<ul>
<li>geohash查找精度：<br><img src="%3C!--%EF%BF%BC12--%3E2016/08/geo%E7%B2%BE%E5%BA%A6.png" alt="geo精度"><br>示例：查找附近的人<br>好的， 在了解了 Redis GEO 特性的基本信息之后， 接下来我们该思考如何使用这些特性去解决实际的问题了。</li>
</ul>
<p>为了让用户可以方便地找到自己附近的其他用户， 每个社交网站基本上都内置了“查找附近的人”这一功能， 通过 Redis ， 我们也可以实现同样的功能， 以下是实现该功能的伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pin</span><span class="params">(user, longitude, latitude)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">记录用户的地理位置。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">GEOADD(<span class="string">'user-location-set'</span>, longitude, latitude, user)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_nearby</span><span class="params">(user, n)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">返回指定用户附近 n 公里的所有其他用户。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> GEORADIUSBYMEMBER(<span class="string">'user-location-set'</span>, user, n, unit=<span class="string">'km'</span>)</span><br></pre></td></tr></table></figure>

<p>示例：摇一摇<br>为了增加乐趣性， 我们可以对“查找附近的人”这一功能进行修改 —— 程序不是返回指定范围内的所有人， 而是随机地返回指定范围内的某个人， 这也就是非常著名的“摇一摇”功能。 以下是实现该功能的伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RANDOM_RADIUS = <span class="number">1</span> <span class="comment"># 随机查找的范围为 1 公里</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_random</span><span class="params">(user)</span>:</span></span><br><span class="line"><span class="comment"># 获取范围内的所有其他用户</span></span><br><span class="line">get_all_near_users = find_nearby(user, RANDOM_RADIUS)</span><br><span class="line"><span class="comment"># 将查找的结果从 Python 列表转换为 Python 集合</span></span><br><span class="line">user_set = set(get_all_near_users)</span><br><span class="line"><span class="comment"># 然后调用 pop() 方法，从集合里面随机地移除并返回一个元素</span></span><br><span class="line"><span class="keyword">return</span> user_set.pop()</span><br><span class="line"></span><br><span class="line">``` python</span><br><span class="line">    <span class="comment"># python目前的连接redis的第三方模块暂时没发现支持geo模块的，但是redis模块有一个execute_command()的函数支持传入redis命令：</span></span><br><span class="line">    db = redis.Redis(host=self.ip, port=self.port, db=<span class="number">0</span>, password=self.password)</span><br><span class="line">    db.execute_command(<span class="string">'geoadd'</span>, collect, lng, lat, user_id)</span><br><span class="line">    db.execute_command(<span class="string">'georadiusbymember'</span>, collect, user_id, distance, <span class="string">'m'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>简单的测了一下：百万条地理位置信息，查询附近的人只需要0.002秒左右，redis还是很给力的，以后要多多研究</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>系统</tag>
        <tag>数据库</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache配置优化</title>
    <url>/2016-07-20-apache-config.html</url>
    <content><![CDATA[<ul>
<li><p>过滤配置文件中的注释信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v ‘^#\|^$\|#’ /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>CentOS6.5下配置apache启动方式为worker：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /usr/sbin/httpd /usr/sbin/httpd.prefork</span><br><span class="line">mv /usr/sbin/httpd.worker /usr/sbin/httpd</span><br></pre></td></tr></table></figure>

<ul>
<li>配置参数解读：</li>
</ul>
<p>ServerTokens OS   当服务器响应主机头（header）信息时显示Apache的版本和</p>
<p>操作系统名称<br>ServerRoot “/etc/httpd”   设置服务器的根目录<br>PidFile run/httpd.pid     PID存放位置<br>Timeout 60                若60秒后没有收到或送出任何数据就切断该连接<br>KeepAlive Off             是否开启保持链接状态<br>MaxKeepAliveRequests 100  在使用保持连接功能时，设置客户一次请求连接能</p>
<p>响应文件的最大上限<br>KeepAliveTimeout 15       在使用保持连接功能时，两个相邻的连接的时间间</p>
<p>隔超过15秒，就切断连接<br><ifmodule prefork.c>      设置使用Prefork MPM运行方式的参数，此运行方式</ifmodule></p>
<p>是Red hat默认的方式<br>StartServers       8      设置服务器启动时运行的进程数<br>MinSpareServers    5      最小空闲进程数<br>MaxSpareServers   20      最大空闲进程数<br>ServerLimit      256      最大的进程数<br>MaxClients       256      最大的请求并发MaxClients=ServerLimit*进程的线</p>
<p>程数<br>MaxRequestsPerChild  4000 限制每个子进程在结束处理请求之前能处理的连接请求为1000</p>
<ifmodule worker.c>
ServerLimit 64
ThreadLimit 200
StartServers 5
MaxClients 2500
MinSpareThreads 50
maxSpareThreads 200
ThreadsPerChild 100
MaxRequestsPerChild 1000
</ifmodule>

<p>ServerLimit 16<br>//服务器允许配置的进程数上限。这个指令和ThreadLimit结合使用设置了MaxClients最大允许配置的数值。任何在重启期间对这个指令的改变都将被忽略，但对MaxClients的修改却会生效。<br>ThreadLimit 64<br>//每个子进程可配置的线程数上限。这个指令设置了每个子进程可配置的线程数ThreadsPerChild上限。任何在重启期间对这个指令的改变都将被忽略，但对ThreadsPerChild的修改却会生效。默认值是”64″.<br>StartServers 3<br>//服务器启动时建立的子进程数，默认值是”3″。<br>MinSpareThreads 75<br>//最小空闲线程数,默认值是”75″。这个MPM将基于整个服务器监视空闲线程数。如果服务器中总的空闲线程数太少，子进程将产生新的空闲线程。<br>MaxSpareThreads 250<br>//设置最大空闲线程数。默认值是”250″。这个MPM将基于整个服务器监视空闲线程数。如果服务器中总的空闲线程数太多，子进程将杀死多余的空闲线 程。MaxSpareThreads的取值范围是有限制的。Apache将按照如下限制自动修正你设置的值：worker要求其大于等于 MinSpareThreads加上ThreadsPerChild的和<br>MaxClients 400<br>//允许同时伺服的最大接入请求数量(最大线程数量)。任何超过MaxClients限制的请求都将进入等候队列。默认值是”400″ ,16(ServerLimit)乘以25(ThreadsPerChild)的结果。因此要增加MaxClients的时候，你必须同时增加 ServerLimit的值。<br>ThreadsPerChild 25<br>//每个子进程建立的常驻的执行线程数。默认值是25。子进程在启动时建立这些线程后就不再建立新的线程了。<br>MaxRequestsPerChild 0<br>//设置每个子进程在其生存期内允许伺服的最大请求数量。到达MaxRequestsPerChild的限制后，子进程将会结束。如果MaxRequestsPerChild为”0″，子进程将永远不会结束。<br>将MaxRequestsPerChild设置成非零值有两个好处：<br>1.可以防止(偶然的)内存泄漏无限进行，从而耗尽内存。<br>2.给进程一个有限寿命，从而有助于当服务器负载减轻的时候减少活动进程的数量。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redhat</tag>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字符串的问题</title>
    <url>/2016-07-22-python-string.html</url>
    <content><![CDATA[<ul>
<li>普通字符串可以用多种方式编码成Unicode字符串，具体要看你究竟选择了哪种编码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unicodestring = <span class="string">u"Hello world"</span> </span><br><span class="line"><span class="comment">#### 将Unicode转化为普通Python字符串："encode" </span></span><br><span class="line">utf8string = unicodestring.encode(<span class="string">"utf-8"</span>) </span><br><span class="line">asciistring = unicodestring.encode(<span class="string">"ascii"</span>) </span><br><span class="line">isostring = unicodestring.encode(<span class="string">"ISO-8859-1"</span>) </span><br><span class="line">utf16string = unicodestring.encode(<span class="string">"utf-16"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="将普通Python字符串转化为Unicode：”decode”"><a href="#将普通Python字符串转化为Unicode：”decode”" class="headerlink" title="将普通Python字符串转化为Unicode：”decode”"></a>将普通Python字符串转化为Unicode：”decode”</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plainstring1 = unicode(utf8string, <span class="string">"utf-8"</span>) </span><br><span class="line">plainstring2 = unicode(asciistring, <span class="string">"ascii"</span>) </span><br><span class="line">plainstring3 = unicode(isostring, <span class="string">"ISO-8859-1"</span>) </span><br><span class="line">plainstring4 = unicode(utf16string, <span class="string">"utf-16"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中密码的保存和token的生成验证itsdangerous模块</title>
    <url>/2016-08-09-itsdangerous.html</url>
    <content><![CDATA[<p>密码的保存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">hashlib.sha1(config.SECRET_KEY+password).hexdigest()</span><br></pre></td></tr></table></figure>

<p>token的生成和保存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> TimedJSONWebSignatureSerializer <span class="keyword">as</span> Serializer, BadSignature, SignatureExpired</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QXToken</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">生成/验证　用户token</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_auth_token</span><span class="params">(self, expiration=<span class="number">3600</span>)</span>:</span></span><br><span class="line">        s = Serializer(config.SECRET_KEY, expires_in=expiration)</span><br><span class="line">        <span class="keyword">return</span> s.dumps(&#123;<span class="string">'name'</span>: self.name&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_auth_token</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        s = Serializer(config.SECRET_KEY)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = s.loads(token)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'data:'</span>, data</span><br><span class="line">        <span class="keyword">except</span> SignatureExpired:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># valid token, but expired</span></span><br><span class="line">        <span class="keyword">except</span> BadSignature:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> <span class="comment"># invalid token</span></span><br><span class="line">        <span class="keyword">return</span> data[<span class="string">'name'</span>] == self.name</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成token</span></span><br><span class="line">qxtoken = QXToken(<span class="string">'name'</span>)</span><br><span class="line">token = qxtoken.generate_auth_token()</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证token</span></span><br><span class="line">q = QXToken(<span class="string">'name'</span>)</span><br><span class="line">res = q.verify_auth_token()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>token</tag>
        <tag>python</tag>
        <tag>itsdangerous</tag>
        <tag>数字</tag>
        <tag>签名</tag>
        <tag>过期</tag>
      </tags>
  </entry>
  <entry>
    <title>用DFA算法来实现敏感词汇的过滤</title>
    <url>/2016-08-18-DFA-filter-words.html</url>
    <content><![CDATA[<p>工作中遇到一个过滤敏感词汇的问题，网上找了一下主要解决方法有3种思路：<br>【可行思路】<br>1、暴力匹配–这个就算了，只是说说而已，实际应用中很少的。<br>2、正则表达式，暂时没有用过<br>3、利用DFA实现文字过滤，<br>本文主要研究的就是DFA算法，在计算理论中，确定有限状态自动机或确定有限自动机（英语：deterministic finite automation, DFA）是一个能实现状态转移的自动机。对于一个给定的属于该自动机的状态和一个属于该自动机字母表的字符，它都能根据事先给定的转移函数转移到下一个状态（这个状态可以是先前那个状态）。以上是wiki上的介绍，通俗点来讲就是实现了一个链表，每个元素是一个字典，字典中存储的是敏感词的单位子串，子串也是一个链表元素内容也是一个字典，描述起来有点绕，还是图来的实在：</p>
<p><img src="%3C!--%EF%BF%BC2--%3E2016/08/dfa.png" alt="dfa"></p>
<p>python代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">FILENAME = <span class="string">'dict.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DFA</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化装载敏感词</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            lines = fp.readlines()</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                l_d = line.strip().split()[<span class="number">-1</span>]</span><br><span class="line">                t = self.data</span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> l_d:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> t.get(w):</span><br><span class="line">                        <span class="comment"># print(self.data)</span></span><br><span class="line">                        t[w] = &#123;<span class="string">'is_end'</span>: <span class="literal">False</span>&#125;</span><br><span class="line">                        <span class="comment"># print(self.data)</span></span><br><span class="line">                    t = t[w]</span><br><span class="line">                <span class="comment"># print(t)</span></span><br><span class="line">                t[<span class="string">'is_end'</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_sensitive</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        <span class="string">"""是否包含某个敏感词"""</span></span><br><span class="line">        t = self.data</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> t.get(w):</span><br><span class="line">                t = t[w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> t[<span class="string">'is_end'</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sensitive_replace</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""句子中敏感词替换"""</span></span><br><span class="line">        new_words = copy.deepcopy(words)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            t = self.data</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> range(s, len(words)<span class="number">-1</span>):</span><br><span class="line">                <span class="comment"># print(s, e, words[e], t.get(words[e]))</span></span><br><span class="line">                <span class="keyword">if</span> t.get(words[e]):</span><br><span class="line">                    t = t[words[e]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> t.get(<span class="string">'is_end'</span>):</span><br><span class="line">                word = new_words[s:e]</span><br><span class="line">                <span class="comment"># print('enter is_end', word)</span></span><br><span class="line">                new_words = new_words.replace(word, len(word)*<span class="string">'*'</span>)</span><br><span class="line">        <span class="keyword">return</span> new_words</span><br><span class="line"></span><br><span class="line">message = <span class="string">'四处乱咬乱吠，办理证件吓得家中11岁的女儿躲在屋里不敢出来，直到辖区派出所民警赶到后，才将孩子从屋中救出。最后在征得主人同意后，民警和村民合力将这只发疯的狗打死'</span></span><br><span class="line"></span><br><span class="line">dfa = DFA(FILENAME)</span><br><span class="line">print(dfa.has_sensitive(<span class="string">'办理证件'</span>))</span><br><span class="line">print(dfa.sensitive_replace(message))</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    s = i % len(message)</span><br><span class="line">    res = dfa.sensitive_replace(message[s:])</span><br><span class="line">    print(res)</span><br><span class="line">end_time = time.time()</span><br><span class="line">print(end_time - start_time)</span><br></pre></td></tr></table></figure>

<p>14600个敏感词汇查询10000次，普通暴力和dfa对比测试结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">----------------dfa-----------</span><br><span class="line">***message*** 224</span><br><span class="line">0.976715803146</span><br><span class="line">------------normal--------------</span><br><span class="line">***message*** 224</span><br><span class="line">The count of word: 14600</span><br><span class="line">30.5309519768</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>DFA</tag>
        <tag>过滤敏感词</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的collections模块学习</title>
    <url>/2016-08-17-python-collections.html</url>
    <content><![CDATA[<ul>
<li>Python在一些内置的数据类型，比如str, int, list, tuple, dict等，之后又提供了比较高级的额外的<strong>数据类型</strong>， 共有以下几种：Counter, deque, defaultdict, namedtuple, OrderedDict</li>
</ul>
<p>那么接下来一个个的攻克它们。</p>
<h1 id="一-namedtuple"><a href="#一-namedtuple" class="headerlink" title="一.namedtuple"></a>一.namedtuple</h1><p>namedtuple的函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">namedtuple</span><span class="params">(typename, field_names, verbose=False, rename=False)</span>:</span></span><br><span class="line">    <span class="string">"""Returns a new subclass of tuple with named fields.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>作用就是通过将可迭代对象设置字段名，可使用名称来访问元素的数据对象。<br>比较重要参数释义：<ul>
<li>typename: 自定义名，字符串类型</li>
<li>field_names： 字段名，list类型</li>
</ul>
</li>
</ul>
<p>如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`&gt;&gt;&gt; Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point.__doc__                   <span class="comment"># 新类的文档字符串</span></span><br><span class="line"><span class="string">'Point(x, y)'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">11</span>, y=<span class="number">22</span>)             <span class="comment"># 通过位置参数或关键字参数实例化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p[<span class="number">0</span>] + p[<span class="number">1</span>]                     <span class="comment"># 像普通元组一样使用索引</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = p                        <span class="comment"># 像普通元组一样解包</span></span><br><span class="line">(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x + p.y                       <span class="comment"># 通过字段名访问</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = p._asdict()                 <span class="comment"># 转换为字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'x'</span>]</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point(**d)                      <span class="comment"># 从字典转换过来</span></span><br><span class="line">Point(x=<span class="number">11</span>, y=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p._replace(x=<span class="number">100</span>)               <span class="comment"># _replace() is like str.replace() but targets named fields</span></span><br><span class="line">Point(x=<span class="number">100</span>, y=<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>再举一个<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f330.png" alt=":chestnut:">：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">tuples = [</span><br><span class="line">    (<span class="string">'Bman'</span>, <span class="number">22</span>, <span class="string">'Python'</span>),</span><br><span class="line">    (<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'C'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">p = namedtuple(<span class="string">"Code"</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'language'</span>])</span><br><span class="line"><span class="keyword">print</span> p             <span class="comment"># &lt;class '__main__.Code'&gt;</span></span><br><span class="line"><span class="keyword">print</span> p._fields     <span class="comment"># ('name', 'age', 'language')</span></span><br><span class="line"><span class="keyword">print</span> p.__doc__     <span class="comment"># Code(name, age, language)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tuples:</span><br><span class="line">    _i = p._make(i)</span><br><span class="line">    <span class="keyword">print</span> i, _i, _i.name, _i.age, _i.language</span><br><span class="line"><span class="comment"># ('Bman', 22, 'Python') Code(name='Bman', age=22, language='Python') Bman 22 Python</span></span><br><span class="line"><span class="comment"># ('Jack', 24, 'C') Code(name='Jack', age=24, language='C') Jack 24 C</span></span><br></pre></td></tr></table></figure>

<h1 id="二-deque"><a href="#二-deque" class="headerlink" title="二.deque"></a>二.deque</h1><p>deque其实是 double-ended queue 的缩写，翻译过来就是双端队列，它最大的好处就是实现了从队列 头部快速增加和取出对象: popleft(),appendleft()</p>
<ul>
<li><p>该类的原型如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">deque([iterable[, maxlen]]) --&gt; deque object</span><br></pre></td></tr></table></figure>
</li>
<li><p>该类有以下方法：<br>append: 添加元素到右侧的双端队列<br>appendleft: 添加元素到左侧的双端队列<br>clear: 移除所有元素<br>count: D.count(value) -&gt; integer, 返回出现的值数<br>extend: 通过可迭代元素扩展右侧的双端队列<br>extendleft: 与上相反<br>pop: 删除并返回最右边的元素</p>
</li>
<li><p>虽然原生的list也可以从头部添加和取出对象等方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis.insert(<span class="number">0</span>, v)</span><br><span class="line">lis.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是与list不同的是<strong>list对象的这两种用法的时间复杂度是 O(n) ，也就是说随着元素数量的增加耗时呈线性上升。而使用deque对象则是 O(1) 的复杂度，所以当你的代码有这样的需求的时候， 一定要记得使用deque。</strong></p>
</li>
<li><p>我们可以创建一个空的deque对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = deque()</span><br><span class="line"><span class="comment"># deque([])</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>然后进行操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">d.append(<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">print</span> d, len(d)     <span class="comment"># deque([1, '2']) 2</span></span><br><span class="line"><span class="keyword">print</span> d[<span class="number">0</span>]          <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">d.appendleft(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">print</span> d             <span class="comment"># deque(['a', 1, '2'])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> d.count(<span class="string">'a'</span>)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">d.extend([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">print</span> d             <span class="comment"># deque(['a', 1, '2', 'a', 'b', 'c'])</span></span><br><span class="line"></span><br><span class="line">d.extendleft([<span class="string">'m'</span>, <span class="string">'n'</span>])</span><br><span class="line"><span class="keyword">print</span> d             <span class="comment"># deque(['n', 'm', 'a', 1, '2', 'a', 'b', 'c'])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> d.pop()       <span class="comment"># c</span></span><br><span class="line"><span class="keyword">print</span> d.popleft()   <span class="comment"># n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> d             <span class="comment"># deque(['m', 'a', 1, '2', 'a', 'b'])</span></span><br><span class="line">d.remove(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">print</span> d             <span class="comment"># deque(['m', 1, '2', 'a', 'b'])</span></span><br><span class="line"></span><br><span class="line">d = deque(<span class="string">'abcde'</span>)</span><br><span class="line"><span class="keyword">print</span> d</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(d)):</span><br><span class="line">    d.rotate()</span><br><span class="line">    <span class="keyword">print</span> i, d</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line"><span class="number">0</span> deque([<span class="string">'e'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="number">1</span> deque([<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="number">2</span> deque([<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="number">3</span> deque([<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>])</span><br><span class="line"><span class="number">4</span> deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br></pre></td></tr></table></figure>

<p>下面例子实现一个跑马灯效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">loading = deque(<span class="string">'&gt;--------------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\r%s'</span> % <span class="string">''</span>.join(loading),        <span class="comment"># 注意："\r"表示回车（将光标移至本行开头）这里不能省略后面的逗号</span></span><br><span class="line">    loading.rotate()        <span class="comment"># 默认1</span></span><br><span class="line">    sys.stdout.flush()     </span><br><span class="line">    time.sleep(<span class="number">0.08</span>)</span><br></pre></td></tr></table></figure>

<h1 id="三-Counter"><a href="#三-Counter" class="headerlink" title="三.Counter"></a>三.Counter</h1><p>实现计数功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`&gt;&gt;&gt; c = Counter(<span class="string">'abcdeabcdabcaba'</span>)  <span class="comment"># count elements from a string</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.most_common(<span class="number">3</span>)                <span class="comment"># 出现最多的三个元素</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">5</span>), (<span class="string">'b'</span>, <span class="number">4</span>), (<span class="string">'c'</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(c)                       <span class="comment"># 列出所有唯一元素</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.elements()                    <span class="comment"># 迭代器</span></span><br><span class="line">&lt;itertools.chain at <span class="number">0x1094c0e50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(c.elements())            <span class="comment"># 列出所有元素</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(sorted(c.elements()))   </span><br><span class="line"><span class="string">'aaaaabbbbcccdde'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(c.values())                 <span class="comment"># total of all counts</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'a'</span>]                          <span class="comment"># 元素a出现次数</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> elem <span class="keyword">in</span> <span class="string">'shazam'</span>:           <span class="comment"># 通过可迭代对象更新counts</span></span><br><span class="line"><span class="meta">... </span>    c[elem] += <span class="number">1</span>                <span class="comment"># by adding 1 to each element's count</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'a'</span>]                          <span class="comment"># now there are seven 'a'</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c[<span class="string">'b'</span>]                      <span class="comment"># remove all 'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'b'</span>]                          <span class="comment"># now there are zero 'b'</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(<span class="string">'simsalabim'</span>)       <span class="comment"># make another counter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.update(d)                     <span class="comment"># add in the second counter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'a'</span>]                          <span class="comment"># now there are nine 'a'</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.clear()                       <span class="comment"># empty the counter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter()</span><br><span class="line"></span><br><span class="line">Note:  If a count <span class="keyword">is</span> set to zero <span class="keyword">or</span> reduced to zero, it will remain</span><br><span class="line"><span class="keyword">in</span> the counter until the entry <span class="keyword">is</span> deleted <span class="keyword">or</span> the counter <span class="keyword">is</span> cleared:</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">'aaabbc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'b'</span>] -= <span class="number">2</span>                     <span class="comment"># reduce the count of 'b' by two</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.most_common()                 <span class="comment"># 'b' is still in, but its count is zero</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">3</span>), (<span class="string">'c'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">0</span>)]</span><br></pre></td></tr></table></figure>

<h1 id="四-OrderedDict"><a href="#四-OrderedDict" class="headerlink" title="四.OrderedDict"></a>四.OrderedDict</h1><p>OrderedDict相对于dict来说也就是有序字典。用法与dict类似，它有如下常用方法：</p>
<ul>
<li>clear<figure class="highlight"><table><tr><td class="code"><pre><span class="line">od.clear() -&gt; None.  Remove all items from od</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">items = (</span><br><span class="line">    (<span class="string">'A'</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">'B'</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">'C'</span>, <span class="number">3</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">regular_dict = dict(items)</span><br><span class="line">ordered_dict = OrderedDict(items)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无序</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> regular_dict.items():</span><br><span class="line">    <span class="keyword">print</span> k, v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有序</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> ordered_dict.items():</span><br><span class="line">    <span class="keyword">print</span> k, v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Result:</span></span><br><span class="line">Regular Dict:</span><br><span class="line">A <span class="number">1</span></span><br><span class="line">C <span class="number">3</span></span><br><span class="line">B <span class="number">2</span></span><br><span class="line">Ordered Dict:</span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">2</span></span><br><span class="line">C <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="五-defaultdict"><a href="#五-defaultdict" class="headerlink" title="五.defaultdict"></a>五.defaultdict</h1><p>Python原生的数据结构dict的时候，如果用 `d[key]<br> 这样的方式访问， 当指定的key不存在时，是会抛出KeyError异常的。如果使用defaultdict，只要你传入一个默认的工厂方法，那么请求一个不存在的key时， 便会调用这个工厂方法使用其结果来作为这个key的默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">members = [</span><br><span class="line">    <span class="comment"># Age, name</span></span><br><span class="line">    [<span class="string">'male'</span>, <span class="string">'John'</span>],</span><br><span class="line">    [<span class="string">'male'</span>, <span class="string">'Jack'</span>],</span><br><span class="line">    [<span class="string">'female'</span>, <span class="string">'Lily'</span>],</span><br><span class="line">    [<span class="string">'male'</span>, <span class="string">'Pony'</span>],</span><br><span class="line">    [<span class="string">'female'</span>, <span class="string">'Lucy'</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">result = defaultdict(list)</span><br><span class="line"><span class="keyword">print</span> result                <span class="comment"># defaultdict(&lt;type 'list'&gt;, &#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sex, name <span class="keyword">in</span> members:</span><br><span class="line">    result[sex].append(name)        <span class="comment"># 将sex做key，value为list类型，append(name)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result                        <span class="comment"># defaultdict(&lt;type 'list'&gt;, &#123;'male': ['John', 'Jack', 'Pony'], 'female': ['Lily', 'Lucy']&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>defaultdict(list)的用法和dict.setdefault(key, [])比较类似</strong>，上述代码使用setdefault实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> sex, name <span class="keyword">in</span> members:</span><br><span class="line">    result.setdefault(sex, []).append(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> result</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title>python模拟生物进化和遗传算法</title>
    <url>/2016-08-21-python-Simulated-biological-evolution.html</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image <span class="keyword">as</span> im  </span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path  </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log  </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint  </span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy  </span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#全局变量  </span></span><br><span class="line">quanju_v = &#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#定义图片预处理函数  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_pic</span><span class="params">(pic_name)</span>:</span>  </span><br><span class="line">    print(<span class="string">"开始预处理图片"</span>)  </span><br><span class="line">    <span class="comment">#获得图片对象  </span></span><br><span class="line">    img = im.open(pic_name)  </span><br><span class="line">    <span class="comment">#获得图片的规格  </span></span><br><span class="line">    img_color = []  </span><br><span class="line">    img_width,img_height = img.size  </span><br><span class="line">    i = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(img_height):  </span><br><span class="line">        img_color_tmp = []  </span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(img_width):  </span><br><span class="line">            <span class="comment">#获得图片像素的rgb信息  </span></span><br><span class="line">            r,g,b = img.getpixel((y,x))[:<span class="number">3</span>]  </span><br><span class="line">            <span class="comment">#将rgb信息转为10进制数字  </span></span><br><span class="line">            img_color_tmp.append((r,g,b,r+g+b))  </span><br><span class="line">        img_color.append(img_color_tmp)  </span><br><span class="line">    print(<span class="string">"预处理图片结束"</span>)  </span><br><span class="line">    <span class="keyword">return</span> img_color,img.size  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#随机基因的函数  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_genes</span><span class="params">(size)</span>:</span>  </span><br><span class="line">    print(<span class="string">"图片规格为:&#123;&#125;"</span>.format(size))  </span><br><span class="line">    print(<span class="string">"正在初始化随机基因"</span>)  </span><br><span class="line">    width,height = size  </span><br><span class="line">    genes = []  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):  </span><br><span class="line">        gene = []  </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(height):  </span><br><span class="line">            row = []  </span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(width):  </span><br><span class="line">                a = randint(<span class="number">0</span>,<span class="number">255</span>)  </span><br><span class="line">                b = randint(<span class="number">0</span>,<span class="number">255</span>)  </span><br><span class="line">                c = randint(<span class="number">0</span>,<span class="number">255</span>)  </span><br><span class="line">                row.append([a,b,c,a+b+c])  </span><br><span class="line">            gene.append(row)  </span><br><span class="line">        genes.append([gene,<span class="number">0</span>])  </span><br><span class="line">    print(<span class="string">"随机基因初始化完成"</span>)  </span><br><span class="line">    <span class="keyword">return</span> genes  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#定义适应度计算函数  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forecast</span><span class="params">(genes)</span>:</span>  </span><br><span class="line">    print(<span class="string">"开始处理基因"</span>)  </span><br><span class="line">    sum_sum = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i,gene <span class="keyword">in</span> enumerate(genes):  </span><br><span class="line">        sum_ = <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">for</span> j,row <span class="keyword">in</span> enumerate(gene[<span class="number">0</span>]):  </span><br><span class="line">            <span class="keyword">for</span> k,col <span class="keyword">in</span> enumerate(row):  </span><br><span class="line">                _a,_b,_c,_d = data[j][k]  </span><br><span class="line">                a,b,c,d = col  </span><br><span class="line">                det_d = abs(_d-d)  </span><br><span class="line">                sum_ += (abs(_a-a) + abs(_b-b) + abs(_c-c))*det_d  </span><br><span class="line">        genes[i][<span class="number">1</span>] = sum_  </span><br><span class="line">        sum_sum += sum_  </span><br><span class="line">    <span class="keyword">for</span> i,gene <span class="keyword">in</span> enumerate(genes):  </span><br><span class="line">        genes[i][<span class="number">1</span>] = genes[i][<span class="number">1</span>]/sum_sum  </span><br><span class="line">    print(<span class="string">"正在排序基因"</span>)  </span><br><span class="line">    genes.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])  </span><br><span class="line">    print(<span class="string">"基因处理完成"</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#基因变异函数  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variation</span><span class="params">(genes,size)</span>:</span>  </span><br><span class="line">    rate = <span class="number">0.5</span>  </span><br><span class="line">    print(<span class="string">"开始变异"</span>)  </span><br><span class="line">    <span class="keyword">for</span> i,gene <span class="keyword">in</span> enumerate(genes):  </span><br><span class="line">        <span class="keyword">for</span> x,row <span class="keyword">in</span> enumerate(gene[<span class="number">0</span>]):  </span><br><span class="line">            <span class="keyword">for</span> y,col <span class="keyword">in</span> enumerate(row):  </span><br><span class="line">                <span class="keyword">if</span> randint(<span class="number">1</span>,<span class="number">100</span>)/<span class="number">100</span> &lt;= rate:  </span><br><span class="line">                    <span class="comment">#图片由 r g b 三种颜色混合而成 变异就是改变他们的值  </span></span><br><span class="line">                    <span class="comment">#a b c 分别对应 r_ g_ b_ 改变的值 可自行修改  </span></span><br><span class="line">                    <span class="comment">#r g b 的最大值为255  </span></span><br><span class="line"><span class="comment">#------------------------------请修改这里-------------------------------------#  </span></span><br><span class="line">                    a = [<span class="number">-1</span>,<span class="number">1</span>][randint(<span class="number">0</span>,<span class="number">1</span>)]*randint(<span class="number">3</span>,<span class="number">10</span>)  </span><br><span class="line">                    b = [<span class="number">-1</span>,<span class="number">1</span>][randint(<span class="number">0</span>,<span class="number">1</span>)]*randint(<span class="number">3</span>,<span class="number">10</span>)  </span><br><span class="line">                    c = [<span class="number">-1</span>,<span class="number">1</span>][randint(<span class="number">0</span>,<span class="number">1</span>)]*randint(<span class="number">3</span>,<span class="number">10</span>)  </span><br><span class="line"><span class="comment">#------------------------------请修改这里-------------------------------------#  </span></span><br><span class="line">                    genes[i][<span class="number">0</span>][x][y][<span class="number">0</span>] += a   </span><br><span class="line">                    genes[i][<span class="number">0</span>][x][y][<span class="number">0</span>] += b  </span><br><span class="line">                    genes[i][<span class="number">0</span>][x][y][<span class="number">0</span>] += c  </span><br><span class="line">                    genes[i][<span class="number">0</span>][x][y][<span class="number">3</span>] += a+b+c  </span><br><span class="line">    print(<span class="string">"变异结束"</span>)  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(gene1,gene2,size)</span>:</span>  </span><br><span class="line">    width,height = size  </span><br><span class="line">    x = randint(<span class="number">0</span>,height<span class="number">-1</span>)  </span><br><span class="line">    y = randint(<span class="number">0</span>,width<span class="number">-1</span>)  </span><br><span class="line">    new_gene = deepcopy(gene1[<span class="number">0</span>][:x])  </span><br><span class="line">    new_gene = [new_gene,<span class="number">0</span>]  </span><br><span class="line">    new_gene[<span class="number">0</span>][x:] = deepcopy(gene2[<span class="number">0</span>][x:])  </span><br><span class="line">    new_gene[<span class="number">0</span>][x][:y] = deepcopy(gene1[<span class="number">0</span>][x][:y])  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> new_gene  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#定义选择函数  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(genes,size)</span>:</span>  </span><br><span class="line">    print(<span class="string">"这是选择环节 我们会选取种群中按适应度排名的前 三分之二"</span>)  </span><br><span class="line">    seek = int(len(genes)*<span class="number">2</span>/<span class="number">3</span>)  </span><br><span class="line">    i = <span class="number">0</span>  </span><br><span class="line">    back_seek = seek+<span class="number">1</span>  </span><br><span class="line">    <span class="keyword">while</span> i&#123;&#125;<span class="string">".format(genes[i][1]))  </span></span><br><span class="line"><span class="string">        genera += 1  </span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">#----------------------------------程序主体-----------------------------------#  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">#---------------------------------程序数据保存模块------------------------------#  </span></span><br><span class="line"><span class="string">#if not path.exists("</span>quanju_v.tmp<span class="string">"):  </span></span><br><span class="line"><span class="string">def save_data():  </span></span><br><span class="line"><span class="string">    global quanju_v  </span></span><br><span class="line"><span class="string">    print("</span>文件存储中<span class="string">")  </span></span><br><span class="line"><span class="string">    with open("</span>quanju_v.tmp<span class="string">","</span>w<span class="string">b") as fd:  </span></span><br><span class="line"><span class="string">        pk.dump(quanju_v,fd)  </span></span><br><span class="line"><span class="string">    print("</span>文件储存完成<span class="string">")  </span></span><br><span class="line"><span class="string">#---------------------------------程序数据保存模块------------------------------#  </span></span><br><span class="line"><span class="string">#main()  </span></span><br><span class="line"><span class="string">try:  </span></span><br><span class="line"><span class="string">    main()  </span></span><br><span class="line"><span class="string">except Exception, err:  </span></span><br><span class="line"><span class="string">    print 'main exception err:'.format(str(err))</span></span><br><span class="line"><span class="string">    save_data()</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的几种设计模式</title>
    <url>/2016-08-11-python-design-patterns.html</url>
    <content><![CDATA[<ol>
<li>单例模式：<br>法一：通过类的<strong>new</strong>()方法，但是个人感觉没有装饰器方便</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwd)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> Singleton.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            Singleton.__instance = object.__new__(cls, *args, **kwd)</span><br><span class="line">        <span class="keyword">return</span> Singleton.__instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    aa = <span class="number">88</span></span><br><span class="line"></span><br><span class="line">instance1 = MyClass()</span><br><span class="line">instance2 = MyClass()</span><br><span class="line"><span class="keyword">print</span> id(instance1)</span><br><span class="line"><span class="keyword">print</span> id(instance2)</span><br><span class="line"><span class="number">139984856635600</span></span><br><span class="line"><span class="number">139984856635600</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用装饰器来实现<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass1</span><span class="params">(object)</span>:</span></span><br><span class="line">    aa = <span class="number">56</span></span><br><span class="line">instance1 = MyClass1()</span><br><span class="line">instance2 = MyClass1()</span><br><span class="line"><span class="keyword">print</span> id(instance1)</span><br><span class="line"><span class="comment">#139764123790288</span></span><br><span class="line"><span class="keyword">print</span> id(instance2)</span><br><span class="line"><span class="comment">#139764123790288</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu14.04安装numpy笔记</title>
    <url>/2016-08-21-ubuntu14-install-numpy.html</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk</span><br><span class="line">sudo apt-get install zip unzip</span><br><span class="line">sudo apt-get install python-numpy</span><br><span class="line">sudo apt-get install python-scipy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Django中获取请求头header</title>
    <url>/2016-08-22-django-get-header.html</url>
    <content><![CDATA[<ul>
<li><p>requests库来模拟请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#test header</span></span><br><span class="line">headers = &#123; <span class="string">"Accept"</span>:<span class="string">"text/html,application/xhtml+xml,application/xml;"</span>,</span><br><span class="line">            <span class="string">"Accept-Encoding"</span>:<span class="string">"gzip"</span>,</span><br><span class="line">            <span class="string">"Accept-Language"</span>:<span class="string">"zh-CN,zh;q=0.8"</span>,</span><br><span class="line">            <span class="string">"Referer"</span>:<span class="string">"http://www.example.com/"</span>,</span><br><span class="line">            <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36"</span>,</span><br><span class="line">            <span class="string">"myuser"</span>: <span class="string">'hello'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">payload = &#123;<span class="string">'user_id'</span>: <span class="number">11</span>, <span class="string">'token'</span>: <span class="string">'token'</span>, <span class="string">'is_reported'</span>: <span class="number">25</span>, <span class="string">'content'</span>: <span class="string">u'不正当经营'</span>, <span class="string">'is_activity'</span>: <span class="literal">True</span>&#125;</span><br><span class="line">r = requests.get(<span class="string">'http://localhost:9000/test/'</span>, data=payload, headers=headers)</span><br><span class="line"><span class="keyword">print</span> r.text</span><br></pre></td></tr></table></figure>
</li>
<li><p>request请求头信息的键会加上HTTP_转换成大写存到request.META中</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="comment"># header = request.get('header', None)</span></span><br><span class="line">        msg = &#123;<span class="string">'code'</span>: <span class="number">200</span>&#125;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'request:'</span>, dir(request)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'meta:'</span>, request.META</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'GET:'</span>, dir(request.GET)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'user:'</span>, request.META.get(<span class="string">'HTTP_MYUSER'</span>, <span class="literal">None</span>)</span><br><span class="line">        fp = open(<span class="string">'out.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">        fp.write(<span class="string">'request:%s\n'</span> % str(request))</span><br><span class="line">        fp.write(<span class="string">'request:%s\n'</span> % str(request.META))</span><br><span class="line">        fp.write(<span class="string">'request:%s\n'</span> % str(request.GET))</span><br><span class="line">        fp.close()</span><br><span class="line">        <span class="comment"># response['X-DJANGO'] = "It's the best."</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(msg), content_type=<span class="string">"application/json"</span>)</span><br></pre></td></tr></table></figure>

<p>django官网的解释：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HttpRequest.META</span><br><span class="line">A standard Python dictionary containing all available HTTP headers. Available headers depend on the client and server, but here are some examples:</span><br><span class="line"></span><br><span class="line">CONTENT_LENGTH – the length of the request body (as a string).</span><br><span class="line"></span><br><span class="line">CONTENT_TYPE – the MIME type of the request body.</span><br><span class="line"></span><br><span class="line">HTTP_ACCEPT_ENCODING – Acceptable encodings for the response.</span><br><span class="line"></span><br><span class="line">HTTP_ACCEPT_LANGUAGE – Acceptable languages for the response.</span><br><span class="line"></span><br><span class="line">HTTP_HOST – The HTTP Host header sent by the client.</span><br><span class="line"></span><br><span class="line">HTTP_REFERER – The referring page, if any.</span><br><span class="line"></span><br><span class="line">HTTP_USER_AGENT – The client’s user-agent string.</span><br><span class="line"></span><br><span class="line">QUERY_STRING – The query string, as a single (unparsed) string.</span><br><span class="line"></span><br><span class="line">REMOTE_ADDR – The IP address of the client.</span><br><span class="line"></span><br><span class="line">REMOTE_HOST – The hostname of the client.</span><br><span class="line"></span><br><span class="line">REMOTE_USER – The user authenticated by the Web server, if any.</span><br><span class="line"></span><br><span class="line">REQUEST_METHOD – A string such as "GET" or "POST".</span><br><span class="line"></span><br><span class="line">SERVER_NAME – The hostname of the server.</span><br><span class="line"></span><br><span class="line">SERVER_PORT – The port of the server (as a string).</span><br><span class="line"></span><br><span class="line">With the exception of CONTENT_LENGTH and CONTENT_TYPE, as given above, any HTTP headers in the request are converted toMETA keys by converting all characters to uppercase, replacing any hyphens with underscores and adding an HTTP_ prefix to the name. So, for example, a header called X-Bender would be mapped to the META key HTTP_X_BENDER.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>django</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装ss客户端</title>
    <url>/2016-08-22-ubuntu-install-ss-client.html</url>
    <content><![CDATA[<h5 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h5><ul>
<li>第一种<ul>
<li>ubuntu安装shadowsocks</li>
<li>启动shadowsocks</li>
</ul>
</li>
<li>第二种</li>
<li>配置浏览器<ul>
<li>安装插件</li>
<li>设置代理地址</li>
<li>设置自动切换</li>
</ul>
</li>
<li>开机后台自动运行ss</li>
</ul>
<p>之前介绍过用<a href="http://aitanlu.com/vps-bandwagonhost-openvpn-shadowsocks-server.html" target="_blank" rel="noopener">搬瓦工的vps</a>可以轻松的搭建shadowsocks服务，然后在windows上和安卓手机平板等上轻松科学上网，只要下载对应的程序即可，当来到ubuntu上怎么配置shadowsocks来科学上网呢？有两种方法可行</p>
<p>1.安装shadowsocks命令行程序，配置命令。<br>2.安装shadowsocks GUI图形界面程序，配置。</p>
<p>个人推荐第一种，配置好后基本不用管。但使用的前提是 你的服务端已经搭建好或者你有别人提供的SS 服务（我也不知道该不该写这文章…）</p>
<h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><h3 id="ubuntu安装shadowsocks"><a href="#ubuntu安装shadowsocks" class="headerlink" title="ubuntu安装shadowsocks"></a>ubuntu安装shadowsocks</h3><p>用PIP安装很简单，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install python-pip  </span><br><span class="line">sudo apt-get install python-setuptools m2crypto</span><br></pre></td></tr></table></figure>

<p>接着安装shadowsocks</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>

<p>如果是ubuntu16.04 直接 (16.04 里可以直接用apt 而不用 apt-get 这是一项改进）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install shadowsocks</span><br></pre></td></tr></table></figure>

<p>当然你在安装时候肯定有提示需要安装一些依赖比如python-setuptools m2crypto ，依照提示安装然后再安装就好。也可以网上搜索有很多教程的。</p>
<h3 id="启动shadowsocks"><a href="#启动shadowsocks" class="headerlink" title="启动shadowsocks"></a>启动shadowsocks</h3><p>安装好后，在本地我们要用到sslocal ，终端输入sslocal –help 可以查看帮助，像这样<br><img src="https://aitanlu.com/wp-content/uploads/2016/04/sslocal.png" alt="sslocal"></p>
<p>通过帮助提示我们知道各个参数怎么配置，比如 sslocal -c 后面加上我们的json配置文件，或者像下面这样直接命令参数写上运行。</p>
<p>比如 sslocal -s 11.22.33.44 -p 50003 -k “123456” -l 1080 -t 600 -m aes-256-cfb</p>
<p>-s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加””）, -t超时默认300,-m是加密方法默认aes-256-cfb，</p>
<p><strong>为了方便我推荐直接用sslcoal -c 配置文件路径 这样的方式，简单好用。</strong></p>
<p>我们可以在/home/mudao/ 下新建个文件shadowsocks.json  (mudao是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"server":"11.22.33.44",  </span><br><span class="line">"server_port":50003,  </span><br><span class="line">"local_port":1080,  </span><br><span class="line">"password":"123456",  </span><br><span class="line">"timeout":600,  </span><br><span class="line">"method":"aes-256-cfb"</span><br></pre></td></tr></table></figure>

<p>server  你服务端的IP  </p>
<p>servier_port  你服务端的端口  </p>
<p>local_port  本地端口，一般默认1080  </p>
<p>passwd  ss服务端设置的密码  </p>
<p>timeout  超时设置 和服务端一样  </p>
<p>method  加密方法 和服务端一样</p>
<p>确定上面的配置文件没有问题，然后我们就可以在终端输入 sslocal -c /home/mudao/shadowsocks.json 回车运行。如果没有问题的话，下面会是这样…</p>
<p><img src="https://aitanlu.com/wp-content/uploads/2016/04/sslocal-1.png" alt="sslocal">（如果继续请不要关闭这个终端）</p>
<p>如果你选择这一种请跳过第二种。你可以去系统的代理设置按照说明设置代理，但一般是全局的，然而我们访问baidu,taobao等着些网站如果用代理就有点绕了，而且还会浪费服务器流量。我们最好配置我们的浏览器让它可以自动切换，该用代理用代理该直接连接自动直接连接。所以请看配置浏览器。</p>
<h2 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h2><p>假如你上面任选一种方式已经开始运行sslocal了，火狐那个代理插件老是订阅不了gfwlist所以配置自动模式的话不好使。这里用的是chrome，你可以在Ubuntu软件中心下载得到。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>我们需要给chrome安装SwitchyOmega插件，但是没有代理之前是不能从谷歌商店安装这个插件的，但是我们可以从Github上直接下载最新版 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases/</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。</p>
<h3 id="设置代理地址"><a href="#设置代理地址" class="headerlink" title="设置代理地址"></a>设置代理地址</h3><p>安装好插件会自动跳到设置选项，有提示你可以跳过。左边新建情景模式-选择代理服务器-比如命名为SS（叫什么无所谓）其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080 。然后保存即应用选项。<br><img src="https://aitanlu.com/wp-content/uploads/2016/04/shadowsocks-0.png" alt="shadowsocks-0"><br><img src="https://aitanlu.com/wp-content/uploads/2016/04/shadowsocks-1.png" alt="shadowsocks-1"></p>
<h3 id="设置自动切换"><a href="#设置自动切换" class="headerlink" title="设置自动切换"></a>设置自动切换</h3><p>接着点击自动切换 ( Auto switch）上面的不用管，在按照规则列表匹配请求后面选择刚才新建的SS，默认情景模式选择直接连接。点击应用选项保存。再往下规则列表设置选择AutoProxy 然后将<strong><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">这个地址</a></strong>填进去，点击下面的立即更新情景模式，会有提示更新成功！<br><img src="https://aitanlu.com/wp-content/uploads/2016/04/shadowsocks-2.png" alt="shadowsocks-2">sorry编辑图片时候少了一步，就是填好规则列表地址后先点击立即更新情景模式 后再应用选项保存<br><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></p>
<p>点击浏览器右上角的SwitchyOmega图标，下面选择自动切换，然后打开google.com试试，其他的就不在这贴图了。</p>
<p><img src="https://aitanlu.com/wp-content/uploads/2016/04/shadowsocks-3.png" alt="shadowsocks-3"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>python下排序总结</title>
    <url>/2016-09-06-python-sort.html</url>
    <content><![CDATA[<p>对字典组成的列表进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">my_list = [&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="string">'ccc'</span>&#125;, &#123;<span class="string">'a'</span>:<span class="number">-1</span>, <span class="string">'b'</span>:<span class="string">'zzz'</span>&#125;]</span><br><span class="line">my_list.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">'a'</span>], reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">print</span> my_list</span><br><span class="line">In [<span class="number">9</span>]:  [&#123;<span class="string">'a'</span>: <span class="number">-1</span>, <span class="string">'b'</span>: <span class="string">'zzz'</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="string">'ccc'</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>python标准库中的有序字典可以对字典进行排序：<br>class collections.OrderedDict([items])</p>
<p>   注意顺序以添加顺序为准，和修改的顺序无关。</p>
<p>   特殊方法：OrderedDict.popitem(last=True) 。last为True是LIFO,即为堆栈，反之是FIFO，即为队列。还支持排序： reversed() .</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中类总结</title>
    <url>/2016-09-01-python-class.html</url>
    <content><![CDATA[<ol>
<li><p>类的继承顺序：<br>a.经典类中继承顺序按照深度优先；<br>b.新式类中继承顺序按照广度优先；<br>新式类中有个<strong>mro</strong>属性可以显示查找顺序</p>
</li>
<li><p><strong>开头的几个类方法：<br>__init</strong>() 构造函数 简单的调用方法: obj = className(args)<br><strong>new</strong>()<br><strong>call</strong>() 表示可调用的实例<br><strong>del</strong>(self) 析构方法, 删除一个对象 简单的调用方法 : del obj ;<br><strong>repr</strong>(self) 转化为供解释器读取的形式 简单的调用方法 : repr(obj);<br><strong>str</strong>(self) 用于将值转化为适于人阅读的形式 简单的调用方法 : str(obj);<br><strong>cmp</strong>(self,x) 对象比较 简单的调用方法 : cmp(obj, x);</p>
</li>
</ol>
<p><strong>开头的类属性：<br>__dict</strong>: 类的属性（包含一个字典，由类的数据属性组成）;<br><strong>slots</strong>: 用于限制类的属性，定义<strong>slots</strong>以后就不会出现<strong>dict</strong>了<br><strong>bases</strong> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）;<br><strong>doc</strong> :类的文档字符串<br><strong>name</strong>: 类名<br>所以，<strong>init</strong> 和 <strong>new</strong> 最主要的区别在于：</p>
<ul>
<li><strong>init</strong> <strong>通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。</strong></li>
<li><strong>new</strong> <strong>通常用于控制生成一个新实例的过程。它是类级别的方法。</strong></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>class</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库相关技巧</title>
    <url>/2016-09-20-mysql-methods.html</url>
    <content><![CDATA[<p>mysql中存储表情符号:<br>聊天的业务中表情的支持比较重要，mysql对表情符号的支持貌似没有postgresql的好，但是历史遗留问题，换库太麻烦，新版本的mysql已经对表情符号支持了，只是需要服务器和客户端设置一下：<br>数据库服务器设置utf8mb4 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[client]</span><br><span class="line">port        = 3306</span><br><span class="line">socket      = /var/run/mysqld/mysqld.sock</span><br><span class="line">default-character-set = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Here is entries for some specific programs</span><br><span class="line"><span class="meta">#</span> The following values assume you have at least 32M ram</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> This was formally known as [safe_mysqld]. Both versions are currently parsed.</span><br><span class="line">[mysqld_safe]</span><br><span class="line">socket      = /var/run/mysqld/mysqld.sock</span><br><span class="line">nice        = 0</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> * Basic Settings</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">user        = mysql</span><br><span class="line">pid-file    = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket      = /var/run/mysqld/mysqld.sock</span><br><span class="line">port        = 3306</span><br><span class="line">basedir     = /usr</span><br><span class="line">datadir     = /var/lib/mysql</span><br><span class="line">tmpdir      = /tmp</span><br><span class="line">lc-messages-dir = /usr/share/mysql</span><br><span class="line">skip-external-locking</span><br><span class="line"></span><br><span class="line">default-storage-engine = innodb</span><br><span class="line">innodb_file_per_table</span><br><span class="line">collation-server = utf8mb4_general_ci</span><br><span class="line">init-connect = 'SET NAMES utf8mb4'</span><br><span class="line">character-set-server = utf8mb4</span><br></pre></td></tr></table></figure>

<p>客户端设置字符编码：<br>mysql connector设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql_con = &apos;mysql+mysqlconnector://%s:%s@%s:%s/%s?charset=utf8mb4&apos; % (mysql_user, mysql_password, mysql_ip, mysql_port, db_name)</span><br><span class="line"></span><br><span class="line">Engine = create_engine(mysql_con, echo=False)</span><br></pre></td></tr></table></figure>

<p>mysql中批量修改指定字段后缀：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">update rp_main set alias=replace(alias, &apos;.files&apos;, &apos;.html&apos;) where alias like &apos;%.files&apos;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mysql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中装饰器，迭代器和生成器</title>
    <url>/2016-10-11-python-use-decrator-generator.html</url>
    <content><![CDATA[<p>Python中的装饰器被用于有切面（AOP）需求的场景，如插入日志、性能测试、事务处理等<br>测试函数的执行时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_runtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">()</span>:</span></span><br><span class="line">        start = time.time()    </span><br><span class="line">        func()  </span><br><span class="line">        end = time.time()       </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'time:'</span>, end-start</span><br><span class="line">    <span class="keyword">return</span> _deco </span><br><span class="line"></span><br><span class="line"><span class="meta">@test_runtime</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'AAAAAAAAAAAAAAAA'</span></span><br><span class="line"></span><br><span class="line">gen()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下安装python连接mysql工具MySQLdb</title>
    <url>/2016-10-25-mac-install-MySQLdb.html</url>
    <content><![CDATA[<h2 id="解决mac升级10-11后，出现的-xcrun-error-invalid-active-developer-path-missing-xcrun-错误"><a href="#解决mac升级10-11后，出现的-xcrun-error-invalid-active-developer-path-missing-xcrun-错误" class="headerlink" title="解决mac升级10.11后，出现的 xcrun: error: invalid active developer path, missing xcrun 错误"></a>解决mac升级10.11后，出现的 xcrun: error: invalid active developer path, missing xcrun 错误</h2><p>前天把小mac升级到了10.11，结果今天在终端里使用git的时候，弹出一行莫名其妙的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">去google了一圈，找到了一个github上homebrew issues里[很老的帖子](https://github.com/Homebrew/homebrew/issues/23500)，按着里面说的，重装了一下xcode command line，结果就正常了……</span><br></pre></td></tr></table></figure>

<p>xcode-select –install</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql命令行数据库的导出和导入</title>
    <url>/2016-11-16-mysql-import-and-export.html</url>
    <content><![CDATA[<p>MAC下用brew安装的mysql，创建my.cnf文件，用以前的linux下的配置总是各种报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR! The server quit without updating PID file (/usr/local/var/mysql/higgsdeMacBook-Pro.local.pid).</span><br></pre></td></tr></table></figure>

<p>解决方法：<br>  用mac下默认的配置文件作为my.cnf的内容，然后修改才会生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /usr/local/opt/mysql/support-files/my-default.cnf /etc/my.cnf</span><br></pre></td></tr></table></figure>

<p>MySQL数据库的导出和导入：<br>导出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p news &gt; news.sql</span><br></pre></td></tr></table></figure>

<p>导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p voice&lt;voice.sql</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mac</tag>
        <tag>数据库导出</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的一些魔法</title>
    <url>/2017-01-23-python-methods.html</url>
    <content><![CDATA[<ol>
<li><p>将多个序列串放在一起遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> chain  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> chain(a, b):  </span><br><span class="line"><span class="meta">... </span>    print(x)  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>python表示昨天的日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-  </span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getYesterday</span><span class="params">()</span>:</span>   <span class="comment">#</span></span><br><span class="line">   today=datetime.date.today()  </span><br><span class="line">   oneday=datetime.timedelta(days=<span class="number">1</span>)  </span><br><span class="line">   yesterday=today-oneday   </span><br><span class="line">   <span class="keyword">return</span> yesterday</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印代码出错信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line">traceback.format_exc()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>traceback.print_exc()跟traceback.format_exc()有什么区别呢？<br>format_exc()返回字符串，print_exc()则直接给打印出来。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Magic</tag>
      </tags>
  </entry>
  <entry>
    <title>js提交数据的headers设置</title>
    <url>/2017-01-03-js-submit-headers-config.html</url>
    <content><![CDATA[<p>JS通过ajax提交post数据有两种方式：Request Payload 和 Form Data，具体的区分可以通过设置请求头的Content-Type来确定：</p>
<p>需要Form Data方式提交数据可以设置headers = {‘Content-Type’:’application/x-www-form-urlencoded’}</p>
<p>需要Request Payload方式提交数据可以设置headers = {‘contentType’:’text/plain;charset=UTF-8’}</p>
]]></content>
      <categories>
        <category>django</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>前端js</tag>
      </tags>
  </entry>
  <entry>
    <title>casperjs截取验证码图片和设置cookies，headers，模拟鼠标点击selected元素</title>
    <url>/2017-04-14-casperjs-get-Verification-code-pic.html</url>
    <content><![CDATA[<p>casperjs设置headers：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var casper = require(<span class="string">'casper'</span>).create(&#123;</span><br><span class="line">    pageSettings: &#123;</span><br><span class="line">     loadImages: true,</span><br><span class="line">     loadPlugins: true,</span><br><span class="line">     // userAgent: <span class="string">'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER'</span></span><br><span class="line">     userAgent: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">     logLevel: <span class="string">"debug"</span>,//日志等级</span><br><span class="line">     verbose: true  // 记录日志到控制台</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var mouse = require(<span class="string">"mouse"</span>).create(casper);</span><br><span class="line"></span><br><span class="line">var url = <span class="string">'http://baidu.com/'</span>;</span><br><span class="line"></span><br><span class="line">casper.start(url);</span><br><span class="line"></span><br><span class="line">// casper.thenClick(<span class="string">'#verify-state'</span>);    //鼠标点击</span><br><span class="line">casper.thenClick(<span class="string">'#btnBeginValidate'</span>);</span><br><span class="line">casper.thenClick(<span class="string">'#btnVRefresh'</span>,function(response)&#123;</span><br><span class="line">    this.echo((response.headers.get(<span class="string">'Set-Cookie'</span>)).split(<span class="string">';'</span>)[<span class="number">0</span>]);   <span class="comment">#获取响应的Set-Cookie信息</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">casper.then(function () &#123;</span><br><span class="line"></span><br><span class="line">    // this.echo(this.)</span><br><span class="line">    // this.querySelector(<span class="string">'img[id="imgPhrase"]'</span>).setAttribute(<span class="string">'style'</span>, <span class="string">"display: block"</span>);</span><br><span class="line">    this.wait(<span class="number">1000</span>, function () &#123;</span><br><span class="line">        img_guid = this.getElementAttribute(<span class="string">'img[id="imgPhrase"]'</span>, <span class="string">'src'</span>);  //获取元素属性值</span><br><span class="line">        // img_name = img_guid + <span class="string">'.png'</span>;</span><br><span class="line">        img_name = <span class="string">'2001.png'</span>;</span><br><span class="line">        this.captureSelector(img_name, <span class="string">'.yz-main'</span>);   <span class="comment"># 根据元素属性截取图片</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>casperjs设置cookies：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var webPage = require(&apos;webpage&apos;);</span><br><span class="line">var page = webPage.create();</span><br><span class="line"></span><br><span class="line">page.customHeaders = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;,</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">if (phantom.addCookie(&#123;</span><br><span class="line">    &apos;name&apos;: &apos;EhireGuid&apos;,</span><br><span class="line">    &apos;value&apos;: &apos;5662e8a3df3c4062aa9edd9ee3e2e36f&apos;,</span><br><span class="line">    &apos;path&apos;: &apos;/&apos;,   //必须</span><br><span class="line">    &apos;domain&apos;: &apos;baidu.com&apos;   //必须</span><br><span class="line">&#125;)) &#123;console.log(&apos;cookie EhireGuid success&apos;)&#125; else &#123;</span><br><span class="line">    console.log(&apos;cookie EhireGuid fail&apos;)       //一直返回失败，但是实际上是成功了，感觉这个是phantomjs的bug 有空提交一下bug</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var selector = &quot;#dropPutDateRange&quot;; // use proper selector</span><br><span class="line"></span><br><span class="line">casper.then(function()&#123;</span><br><span class="line">    // check selectd value</span><br><span class="line">        var selected = this.evaluate(function(selector)&#123;</span><br><span class="line">            var s = document.querySelector(selector);</span><br><span class="line">            var o = s.children[s.selectedIndex];</span><br><span class="line">            return &#123;value: o.value, text: o.innerHTML&#125;;</span><br><span class="line">        &#125;, selector);</span><br><span class="line"></span><br><span class="line">        this.echo(&quot;result: &quot; + JSON.stringify(selected, undefined, 4));   //打印selected的值</span><br><span class="line"></span><br><span class="line">        this.evaluate(function() &#123;</span><br><span class="line">            $(&apos;#dropPutDateRange &apos;).val(&apos;value&apos;).change();   //改变selected的值</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">casper.run();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>casperjs</tag>
        <tag>cookie</tag>
        <tag>截图</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>试着去做一些事儿，让自己成为一个有趣儿的人</title>
    <url>/2016-12-28-try-do-something.html</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2204146-181081d2a2fc7036.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  </p>
<p>不知道从什么时候开始，大家喜欢以是否有趣来评价自己对一个人的印象。在整容风靡，美的价值观判断被颠覆之后，能恒久留存下来的，必定是你读过的书，走过的路，写在脸上的气质和刻在骨子里的趣味。</p>
<p>正如那句话所说：</p>
<p>你现在的气质里，藏着你走过的路，读过的书和爱过的人。</p>
<p>时光流逝之后，你就会知道，一个有趣的人比一个外表美丽的人更讨人喜欢。</p>
<p>有人说，不要把自己置身在模式化的幸福和大规模生产的生活之中，你过着怎样的人生，取决于你用什么角度看待生活。</p>
<p>努力做一些不一样的事儿，让自己成为一个有趣儿的人吧！</p>
<h3 id><a href="#" class="headerlink" title></a></h3><p><strong>挑战自己：做不敢做的事儿</strong></p>
<p>特别喜欢陈意涵，30岁生日的时候，她和闺蜜张钧甯，一起做了好多非常有趣的事儿。到海里裸泳、扎辫子、全世界倒立……</p>
<p>有时候，尝试着去做一些曾经不敢做的事儿，不仅会终身难忘，更会让生活变得有趣。</p>
<p>如果你胆子小，就试着蹦极，到飞机上跳伞；如果你性格腼腆，试着在地铁上，冲着外国人微笑；如果你五音不全，就选择一个空旷的下午，尽情享受一个人的ktv；如果你害怕在大庭广众下演讲，就对着镜子背熟一篇演讲稿，然后跑到无人的地方勇敢演讲一次吧！要知道，你是自己最忠实的观众！</p>
<p>如果你害怕一个人旅行，就随便找个地方，背起行囊，查好攻略，上路吧，相信，你这一路，必定精彩！</p>
<p>还有什么是你害怕做的呢？试着去做做看吧！</p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><p><strong>为自己买花</strong></p>
<p>认识一个男孩，每周都会为自己订一束花，当黑色的周一来临，黑压压的办公室里充斥着紧张的氛围时，一束鲜花，在角落里散发着暗香，无论寒冷的冬日还是燥热的夏日，都能让心情晴朗起来。</p>
<p>有位姐姐告诉我，真正有魅力的女人，是会为自己买花的女人。一束花，带给你的不仅仅是一周的好心情和美丽的惊喜，更是在漫长的工作日里，你对它的那份呵护、关注和照顾，修剪花枝，换水，清理杂物，这个用心的过程，不仅让生活充实，更让精神富足，这是个很动人的过程。</p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><p><strong>幽默有时，欢笑有时</strong></p>
<p>幽默的人有多大的魅力？看黄渤就知道。林志玲曾多次说过，黄渤是她的理想型。幽默的人身上有种天然的吸引力，幽默感，让彼此相处变得容易，用幽默化解尴尬，用幽默化解别人的恶意，是高情商的表现，更是一种宽容。</p>
<p>萧伯纳曾说，幽默就像马车上的弹簧，没有它，一块小石子就让你很颠簸。</p>
<p>幽默是一种达观的生活态度，学着做个幽默的人，因为幽默的人真的很美。与人</p>
<h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><p><strong>欣赏古典音乐</strong></p>
<p>到音乐厅欣赏一场音乐会，无论是小提琴的轻快，大提琴的低沉，钢琴的律动，还是琵琶的婉转，都能让心灵接受一次美的洗礼。站在台上高歌一首流行歌曲，会让人觉得你很帅，如果愿意欣赏一曲古典音乐，还能将心得与人分享，那别人眼睛里的你，必定是高雅和值得尊敬的。</p>
<h3 id="-4"><a href="#-4" class="headerlink" title></a></h3><p><strong>学一门乐器</strong></p>
<p>去年学习了琵琶才知道，琵琶是一门神奇的乐器，有着极其广泛的音域，可以弹出所有乐器能弹奏的音节，甚至夸张一点，一把琵琶可以自成一个演唱会。渐渐地爱上了这门古典民乐，叮咚泉水般的音色，有着天籁般的音乐质感，看着艺术大师们酣畅淋漓的一曲《十面埋伏》，一曲缠绵婉转的《红尘客栈》，才不禁慨叹，白居易所说的”大弦嘈嘈如急雨，小弦切切如私语，嘈嘈切切错杂弹，大珠小珠落玉盘”的壮观，才感受到”千呼万唤始出来，犹抱琵琶半遮面”的美。</p>
<p>尝试着学一门乐器吧，下次一个人到海边，吹着海风，抱着吉他，独自弹唱一曲，你就是浪迹天涯的侠客。</p>
<h3 id="-5"><a href="#-5" class="headerlink" title></a></h3><p><strong>运动会让你很有魅力</strong></p>
<p>曾看过一个女孩分享，过去一年对自己最大的投资，便是办了一张健身卡，经过大半年之后，秀出了棱角分明的马甲线和深深的腰窝，皮肤也变得紧致有型，人也更自信了。</p>
<p>如果健身房让你感觉枯燥，那就试着去骑车、爬山、徒步，在这个过程中，不仅能认识新朋友，更能让自己的身体越来越棒。</p>
<h3 id="-6"><a href="#-6" class="headerlink" title></a></h3><p><strong>读书是最不徒劳无功的事</strong></p>
<p>博尔赫斯曾说，如果有天堂，那应该是图书馆的模样。</p>
<p>某位时尚博主曾说，如果实在不知道做什么，那就读书吧。</p>
<p>在名人传记里，体验不同的人生；在历史中，感受时代的变迁，在文学书籍里，修身养性，在心理学的书里，让自己身心更加健康。当然，还可以阅读一些关于建筑、房屋收纳、宗教等方面的书，无论是旅行还是与朋友聊天，能把这些冷知识头头是道地说出来，还是很洋气的！</p>
<h3 id="-7"><a href="#-7" class="headerlink" title></a></h3><p><strong>来一场说走就走的旅行</strong></p>
<p>旅行的意义，可能就是让原本不耐寒的四肢还能轻易感触空气的细微变化。歌德在《致卡罗琳·冯·赫尔德》里，对旅行有一番解读：人之所以爱旅行，不是为了抵达目的地，而是为了享受旅途中的种种乐趣。</p>
<p>有多少人是看了切·格瓦拉的《摩托车日记》追随他一路到了南美洲？说走就走的旅行不是从你待腻的地方到别人待腻的地方去，而是一个寻找自我，发现自我，探索内心的过程。</p>
<p>走在异国他乡的街头，感受不同的人文，不同的笑脸，不同的饮食，不同的建筑，看着与你擦家而过的背包客们匆匆赶路，看着热衷于享受生活的欧美人们无论到哪里，都一定要在咖啡馆里发个呆，到酒吧狂欢整晚，某片海上的某个游轮里，与来自世界各地的人们，聊聊你我的行程，聊聊彼此国家的风俗习惯，那种独特的人生的体验，会让你更加感恩生命的广阔，自己的渺小。旅途中，你会震撼于不同地方的日出日落，一路跋山涉水，你既能在遥远的北国邂逅鹅毛般的雪片飘飞，也能在南国的暖阳里欣赏凤凰花开两季，旅途中有几米笔下的红色沙漠，有电影里金色的海洋。</p>
<p>所以，去旅行吧，让自己在旅行中成长吧。</p>
<h3 id="-8"><a href="#-8" class="headerlink" title></a></h3><p><strong>不要忽略了你所居住的城市</strong></p>
<p>有多少人，在一个城市工作生活了十几年，活动的空间永远是家和公司附近的地方？给自己一些时间，去感受你所在的那座城市。来到上海一年半的我，很幸运地通过参加city walk ，基本走遍了这座城市最有韵味，最有历史的角角落落。我可以告诉你，上海多伦路上左联名人的故事，跟你讲讲苏州河畔的张爱玲故居；向你推荐武康路上的网红小店；法租界里“流动的盛宴”……</p>
<p>所以，不要忽略你所居住生活的城市，角落里，都是历史留下的瑰宝。</p>
<h3 id="-9"><a href="#-9" class="headerlink" title></a></h3><p><strong>解锁一项新技能</strong></p>
<p>彭于晏是不少人心中的绝对偶像。不仅仅是因为他永远在线的超高颜值，和体脂率3%的完美身材，更重要的是永远在努力的彭于晏，几乎每拍一部电影就解锁一项新技能。现在他体操、手语、泰拳、骑行、海豚训练、冲浪……可谓十八般武艺俱全。</p>
<p>解锁一项新技能，不需要很难，却可以让你更有趣。比如学一些手语、学习下占卜、塔罗，学游泳，学着唱好一首歌，甚至学习魔方也可以哦。</p>
<h3 id="-10"><a href="#-10" class="headerlink" title></a></h3><p><strong>学习一门新语言</strong></p>
<p>语言是一种神奇的东西。掌握一门新语言，不仅可以为技能加分，也是找工作跳槽时闪亮的一点。可以利用闲暇时间试着自学日语五十音图，法语字母发音，或者干脆选一门一直喜欢的语言报个班，但是一定要坚持哦！</p>
<h3 id="-11"><a href="#-11" class="headerlink" title></a></h3><p><strong>跟着电影游世界</strong></p>
<p>大学时代的电影课上，认识了侯孝贤，认识了眷村，迷恋上胡德夫的歌声，吴念真的故事。自此便爱上了台湾。虽然到现在一直未曾去过，但每次打开一部部关于太平洋彼岸那座小岛的电影，心便跟着跳动。</p>
<p>在《一夜台北》里，逛逛24小时的诚品书店；跟着《艋胛》感受那个年代的台湾黑帮；在《练习曲》里欣赏太平洋的绝美风光；在《不能说的秘密》里，跟着周董回到他的学生时代……</p>
<p>跟着电影漫游世界，是件超有趣的事情。在《午夜巴黎》里，跟着主人公的脚步，会晤巴黎名流，沉醉于浪漫巴黎的灯红酒绿；在《午夜巴塞罗那》里，聆听达利的艺术；在《天堂的孩子》里，走进伊朗这个贫穷但却轻声吟唱着美丽故事的国家；在《天空之城》里感受最真实的里约热内卢的贫民窟……</p>
<p>给自己两个小时，打开一部电影，世界就在你眼前了！</p>
<h3 id="-12"><a href="#-12" class="headerlink" title></a></h3><p><strong>爱上听讲座</strong></p>
<p>听讲座是最能赚到的事情。各个行业领域的精英和领袖们，将自己数十年的研究成果，在短短2个小时里，通过一场讲座与你分享。浓缩的全部是知识里最精华的部分。</p>
<p>而很多讲座往往有意料之外的惊喜，比如你苦苦寻找的一些资料，在讲座里恰好可以听到。</p>
<h3 id="-13"><a href="#-13" class="headerlink" title></a></h3><p><strong>到城市看几场展览</strong></p>
<p>2016年，看过最震撼的展览，是10月份上海展览中心的世界摄影展。来自全世界的知名画廊齐聚上海，在这里，我第一次完整地看到了肖全的作品和他镜头之下的窦唯、三毛。一场展览，看到的是整个世界。</p>
<p>在上海博物馆里一场关于日本醍醐寺的展览上，又了解了不为人知的日本文化的另一面。</p>
<p>如果周末无所事事，记得到博物馆里看场展览，它会深入你的气质。</p>
<h3 id="-14"><a href="#-14" class="headerlink" title></a></h3><p><strong>泡泡英语角</strong></p>
<p>虽然我还没有泡过，但是想把它列为今年的梦想清单。英语角里与有趣的外国人交流，自己也会变得有趣。</p>
<h3 id="-15"><a href="#-15" class="headerlink" title></a></h3><p><strong>做志愿者，享受给予的快乐</strong></p>
<p>赠人玫瑰，手留余香。好像自从上大学开始，就一直在尝试着做志愿者。去年，曾在两场公益性心灵课程里做过志愿者，当你敞开心扉，将温暖和爱传递给大家的时候，你收获的信任是一种巨大的能量，那种能量足以温暖你整个人生。</p>
<p>刚刚结束了一场旅行活动的志愿者，虽然天气寒冷，但是想到自己是传递快乐的使者，想到被别人需要着，心就暖暖的。</p>
<p>去做一次志愿者吧，这个世界是这样深深地需要着你。</p>
<h3 id="-16"><a href="#-16" class="headerlink" title></a></h3><p><strong>到咖啡馆里做一次体验店长</strong></p>
<p>如果你和我一样分不清卡布奇诺和拿铁，就试着了解一些吧！豆瓣上常常会有类似的活动哦，选择一天的时间，到咖啡馆里尝试一天的体验店长，感受手作的温度，让咖啡豆在自己的手中慢慢磨成粉末，亲手把牛奶画成一颗心，享受体验不一样的快乐。</p>
<h3 id="-17"><a href="#-17" class="headerlink" title></a></h3><p><strong>给自己放个假，刷一部优质日剧</strong></p>
<p>一直喜欢日剧，因为日剧里总会蕴藏一股特别的能量。有时候看来是一锅浓浓的鸡汤，有时候又是一场热血的战争，但总能让你从中读出一些人生的哲理。周末不妨给自己放个假，刷剧也是一件有趣的事儿。</p>
<p><strong>听广播</strong></p>
<p>夜晚临睡前，听听音乐广播，主播温暖的声线，精心安排的好歌，伴你入眠。还可以在喜马拉雅听一些有意思的课程。感受声音的力量。</p>
<p><strong>教给别人一个你擅长的小技能</strong></p>
<p>这是培养耐心的很好的方法。如果你可以玩转魔方，记得将这门小技能分享出来哦，教会了别人，是一件超有成就感的事情。</p>
<p>如果你对塔罗深有研究，对写作有心得，或者是个健身达人，记得分享出来，相信会有一大波人来喜欢你。</p>
<h3 id="-18"><a href="#-18" class="headerlink" title></a></h3><p><strong>每天坚持做几件无用的事</strong></p>
<p>每天折一颗小星星，每天折一只千纸鹤，每天抄写一首古诗，每天抄写一首心经，坚持每天拍同一片天空……你还能想到哪些无用的事？</p>
<h3 id="-19"><a href="#-19" class="headerlink" title></a></h3><p><strong>坚持每天写下三件感恩的事</strong></p>
<p>坚持了，就会发现生活是那么地不一样。</p>
<h3 id="-20"><a href="#-20" class="headerlink" title></a></h3><p><strong>在网络上听几次课程</strong></p>
<p>知乎、荔枝微课等有各个行业的大师们愿意与你分享，选择一些课程来听，可以是提升自己专业知识的课程，帮助心灵成长的课程。会有特别的收获。</p>
<h3 id="-21"><a href="#-21" class="headerlink" title></a></h3><p><strong>看话剧</strong></p>
<p>话剧的舞台上，有着别的表演形式没有的仪式感和代入感。做个看客，也做个表演者。</p>
<h3 id="-22"><a href="#-22" class="headerlink" title></a></h3><p><strong>留宿在别处</strong></p>
<p>可以试着在城市里住住民宿，感受主人悉心准备的精致餐具，用心布置的精美壁画，感受精致的生活。也可以到别的城市住青旅，认识一些来自世界各地的新朋友，你会发现生活中的无限可能。</p>
<h3 id="-23"><a href="#-23" class="headerlink" title></a></h3><p><strong>看演唱会</strong></p>
<p>如果有你特别喜欢的歌手，可以试着去听几场他的演唱会。感受在每场演唱会上，他唱的歌的变化，造型的变化，看着他成长，你自己也在其中感悟和成长。</p>
<h3 id="-24"><a href="#-24" class="headerlink" title></a></h3><p><strong>享受一个人的时光</strong></p>
<p>当亚当和夏娃偷吃禁果之后，便懂得了羞耻，穿上了衣服，而从这时候开始，人就开始变得孤独了。蒋勋在《孤独六讲》里曾讲到，孤独不是一个贬义词，我们总是害怕承认，我很孤独。</p>
<p>孤独是一种心境，而孤独沉淀后的思维一种清明。所以要学会享受一个人的时光。一个人也要把日子过成诗。</p>
<h3 id="-25"><a href="#-25" class="headerlink" title></a></h3><p><strong>睡前仪式：与自己对话</strong></p>
<p>如果这个仪式成为一种习惯，那相信你可以驾驭生活中的一切困难。在与自己对话中，三省吾身，总结成长。</p>
<h3 id="-26"><a href="#-26" class="headerlink" title></a></h3><p><strong>学习冥想，学习瑜伽</strong></p>
<p>这是一门值得深究的学问。</p>
<h3 id="-27"><a href="#-27" class="headerlink" title></a></h3><p><strong>下厨，为自己做一顿精致的餐点</strong></p>
<p>如果不知道想学习什么，那就学着做饭吧！这绝对是一门受益终身的技能。闲暇时，为自己做一餐精致的餐点，美味和成就感，会让你爱上如此有趣的自己。</p>
<h3 id="-28"><a href="#-28" class="headerlink" title></a></h3><p><strong>学习烘焙</strong></p>
<p>认识一位电台主播，做了妈妈之后，为了能让小孩吃上不含防腐剂的食品，便自己学着做烘焙。看着她做出美丽图案的饼干、蛋糕，真的是非常羡慕，能做出如此美貌烘焙的你，怎么能不美呢？</p>
<h3 id="-29"><a href="#-29" class="headerlink" title></a></h3><p><strong>为父母做几件事儿</strong></p>
<p>陪父母聊天，带父母旅行，常常回家，陪伴父母。对他们来说，你在身边，就是幸福。</p>
<h3 id="-30"><a href="#-30" class="headerlink" title></a></h3><p><strong>去看海</strong></p>
<p>每当你感受孤独和无助的时候，遥望大自然，就会拥有无穷的力量。大海，是无论你快乐还是悲伤的时候都会无比震撼的存在。蒋勋曾说，他非常享受一个人孤独的时光，甚至常常自己一个人到台湾东部的海岸边，吹着太平洋的风，看着激浪拍岸，忍不住唱起歌来。</p>
<p>去看海吧，无论你快乐或者悲伤。</p>
<h3 id="-31"><a href="#-31" class="headerlink" title></a></h3><p><strong>努力去一次西藏</strong></p>
<p>曾经听过lonely planet 中华区品牌总裁李沐泽的一次分享，他有讲到一个细节，你在西藏看到的是珠峰的这一边，当到尼泊尔，看到的是珠峰的另一边。而不少驴友当见识到这宿命般的美景时，竟忍不住泪流满面。</p>
<p>不知道什么时候开始，骑行西藏成了时尚酷炫的潜台词，不知道什么时候开始，墨脱不再是安妮宝贝笔下的莲花秘境，而成了一生追寻的信仰之地。</p>
<p>林夕在《富士山下》写道：爱情就像富士山，你不能期望它走过来，只能自己走过去，而西藏亦是富士山一般的所在。</p>
<p>这辈子一定要去一次西藏，感受雪山下的藏民匍匐朝拜的虔诚和信仰，感受仓央嘉措口中：前世，我翻越十座大山，不为修来世，只为途中与你相见”的诗意与坚持，到拉萨转一次经，在转经中，遗忘了所有的苦难和尘缘，用最纯净的心</p>
<p>张开双臂，去迎接这个纯净的世界。</p>
<h3 id="-32"><a href="#-32" class="headerlink" title></a></h3><p><strong>交换阅读，交换想法</strong></p>
<p>记得把读过的书与朋友分享，在分享的过程中，会有不一样的成长。</p>
<h3 id="-33"><a href="#-33" class="headerlink" title></a></h3><p><strong>跑步，是一件很酷炫的事情</strong></p>
<p>陈意涵每天，持續晨跑，持續倒立，每天十公里，前一段时间，她在微博上po出跑马得奖的奖牌，配文：跑步很像談戀愛，你不知道你的身體什麼時候會背叛你，但你永遠不能放棄他，用耐心，包容，痛苦，來成就最後的美好。</p>
<p>村上春树的标准生活就是，基本凌晨四点左右起床，从来不用闹钟，泡咖啡，吃点心，就立即开始工作。然后，写五、六个小时，到上午十点为止。每天跑步一个小时，村上说，对他来说，每天只有二十三个小时，因为有一个小时给了运动，雷打不动。</p>
<h3 id="-34"><a href="#-34" class="headerlink" title></a></h3><p>“要把自己融入节奏中去，把自己培养成一种习惯动物。”</p>
<p>“决定了就做。不说泄气话，不发牢骚，不找借口。”</p>
<p>“早睡早起，每天跑十公里，坚持每天写十页，要像个傻瓜似的。”</p>
<p>“天黑了就不工作。早晨起来写小说跑步做翻译，下午两点左右结束，接着就随心所欲。”</p>
<p>村上春树称自己是长距离跑者，“今天不想跑，所以才去跑，这才是长距离跑者的思维方式。”</p>
<p>所以，不用花錢的日常，就是一起來運動～大家来跑步吧！</p>
<h3 id="-35"><a href="#-35" class="headerlink" title></a></h3><p>坚持记日记\写博客</p>
<p>记录每天的生活。天长日久，重新看过，曾经生活里的点点滴滴，都像散落在记忆海滩的美丽贝壳，被串成晶莹的项链，闪烁着耀眼的光芒。</p>
<h3 id="-36"><a href="#-36" class="headerlink" title></a></h3><p><strong>为爱付出，不再惧怕</strong></p>
<p>无论你几岁，都要相信爱情。如果此时你还没有等到那个人，就在等待的过程中，努力变成更好的自己吧，相信会有更好的那个人，也在寻找你。</p>
<h3 id="-37"><a href="#-37" class="headerlink" title></a></h3><p><strong>爱自己，是终身要学习的课程</strong></p>
<p>好好吃饭，好好睡觉，好好运动，做自己想做的事，见自己想见的人，走自己想走的路，只有真正爱好了自己，才会去爱别人。</p>
<h3 id="-38"><a href="#-38" class="headerlink" title></a></h3><p><strong>喜欢一个特别优秀的男孩（女孩)</strong></p>
<p>要相信，在喜欢Ta的过程中，你会成为更好的自己。努力追到TA。</p>
<p>前提是，你是真的喜欢他哦！</p>
<p>而追到了他，你就已然成为一个有趣、优秀、美好的人啦！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>casperjs传参</title>
    <url>/2017-04-18-casperjs-pass-args.html</url>
    <content><![CDATA[<p>casperjs传递动态参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var casper = require(<span class="string">'casper'</span>).create(&#123;</span><br><span class="line">    pageSettings: &#123;</span><br><span class="line">     javascriptEnabled: true ,</span><br><span class="line">     loadImages: true,</span><br><span class="line">     loadPlugins: true,</span><br><span class="line">     userAgent: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    // logLevel: <span class="string">"debug"</span>,//日志等级</span><br><span class="line">    // verbose: true,  // 记录日志到控制台</span><br><span class="line">     viewportSize: &#123;width: <span class="number">1024</span>, height: <span class="number">768</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var args2 = casper.cli.args;</span><br><span class="line"></span><br><span class="line">var NET_SessionId = args2[<span class="number">0</span>];</span><br><span class="line">var EhireGuid = args2[<span class="number">1</span>];</span><br><span class="line">var AccessKey = args2[<span class="number">2</span>];</span><br><span class="line">var HRUSERINFO = args2[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>casperjs</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib RuntimeError: Python is not installed as a framework 错误解决方案</title>
    <url>/2017-05-25-matplotlib-runtimeerror-python-is-not-installed-as-a-framework-error.html</url>
    <content><![CDATA[<p>在virtualenv环境下使用matplotlib绘图时遇到了这样的问题：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt<br>Traceback (most recent call last):<br>File “”, line 1, in<br>…</p>
</blockquote>
</blockquote>
</blockquote>
<p>in<br>from matplotlib.backends import _macosx<br>RuntimeError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are Working with Matplotlib in a virtual enviroment see ‘Working with Matplotlib in Virtual environments’ in the Matplotlib FAQ</p>
<p>似乎是因为虚拟环境与默认环境的安装配置不同造成的。</p>
<p>搜索错误信息之后，在STO上找到了解决方案：</p>
<p>1、pip安装matplotlib之后，会在根目录下产生一个.matplotlib的目录:</p>
<p>➜ bin ll ~/.matplotlib<br>total 280<br>-rw-r–r– 1 me staff 78K 10 4 2015 fontList.cache<br>-rw-r–r– 1 me staff 59K 1 17 15:56 fontList.py3k.cache<br>drwxr-xr-x 2 me staff 68B 10 4 2015 tex.cache</p>
<p>2、在这个目录下创建一个名为matplotlibrc的文件，内容是：</p>
<p>backend: TkAgg</p>
<p>然后保存退出，重启Python交互界面或重新运行脚本，import正常执行。</p>
<p>STO答案地址：<a href="http://stackoverflow.com/questions/21784641/installation-issue-with-matplotlib-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/21784641/installation-issue-with-matplotlib-python</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>framework</tag>
        <tag>RuntimeError</tag>
      </tags>
  </entry>
  <entry>
    <title>web站点相关解决方案</title>
    <url>/2017-06-22-website-some-solution.html</url>
    <content><![CDATA[<p>邮箱或手机验证码存储解决方案：</p>
<ol>
<li>使用web框架自带的缓存系统，比如django中自带的cache</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from django.core import cache</span><br><span class="line">cache.set(&apos;key&apos;, &apos;value&apos;, 10)  #键,值和过期时间</span><br><span class="line">cache.get(&apos;key&apos;, &apos;not fount or has expired&apos;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用redis存储:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">redis_db = RedisDB()</span><br><span class="line">redis_db.set(phone=username, val=code, ex=60*10)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django rest framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Python LEGN作用域总结</title>
    <url>/2017-06-19-python-LEGN-summary.html</url>
    <content><![CDATA[<p>LEGB规则</p>
<p>Python2.2开始引入嵌套函数，嵌套函数为python提供了闭包实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">a = 1</span><br><span class="line">def foo():</span><br><span class="line">   a = 2</span><br><span class="line">   def bar():</span><br><span class="line">        print a  //[1]</span><br><span class="line">    return bar</span><br><span class="line"> </span><br><span class="line">func = foo()</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>函数bar和a=2捆包在一起组成一个闭包，因此这里a=2即使脱离了foo所在的local作用域，但调用func的时候（其实就是调用bar）查找名字a的顺序是LEGB规则，这里的E就是enclosing的缩写，代表的“直接外围作用域”这个概念。查找a时，在bar对应的local作用域中没有时，然后在它外围的作用域中查找a。LEGB规定了查找一个名称的顺序为：local–&gt;enclosing–&gt;global–&gt;builtin。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>legn</tag>
      </tags>
  </entry>
  <entry>
    <title>生成PDF文档</title>
    <url>/2017-07-05-generate-pdf-doc.html</url>
    <content><![CDATA[<p>主要使用pdfkit模块：</p>
<ol>
<li>安装pdfkit：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pip install pdfkit</span><br><span class="line">$ sudo apt-get install wkhtmltopdf</span><br></pre></td></tr></table></figure>

<p>使用pdfkit的一些高级功能需要研究wkhtmltopdf的一些功能：<br>Warning! Version in debian/ubuntu repos have reduced functionality (because it compiled without the wkhtmltopdf QT patches), such as adding outlines, headers, footers, TOC etc. To use this options you should install static binary from wkhtmltopdf site or you can use this script.</p>
<p>使用高级功能需要执行以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line">sudo apt-get install -y openssl build-essential xorg libssl-dev</span><br><span class="line">wget http://wkhtmltopdf.googlecode.com/files/wkhtmltopdf-0.10.0_rc2-static-amd64.tar.bz2</span><br><span class="line">tar xvjf wkhtmltopdf-0.10.0_rc2-static-amd64.tar.bz2</span><br><span class="line">sudo chown root:root wkhtmltopdf-amd64</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>基本原理功能：<br>Pdfkit文档链接：<a href="https://pypi.python.org/pypi/pdfkit" target="_blank" rel="noopener">https://pypi.python.org/pypi/pdfkit</a><br>Pdfkit可以渲染url，file，string 成pdf文档，也支持多个file生产一个pdf文档</li>
</ol>
<p>Notices：</p>
<ol>
<li>pdf正文部分字体调整： css部分：@font-face {    }中添加font-family等字体属性；</li>
<li>页脚的添加： views.py中 print_entrust()函数中options{}字典里边添加footer-center等属性；</li>
</ol>
]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7设置ss开机启动</title>
    <url>/2017-08-03-CentOS7-shadowsocks-set-start.html</url>
    <content><![CDATA[<h3 id="CentOS7设置ss开机启动"><a href="#CentOS7设置ss开机启动" class="headerlink" title="CentOS7设置ss开机启动###"></a>CentOS7设置ss开机启动###</h3><ul>
<li><p>配置自启动<br>新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行以下命令启动 shadowsocks 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl enable shadowsocks</span><br><span class="line">$ systemctl start shadowsocks</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kevin ~]# systemctl status ssserver -l</span><br><span class="line">* ssserver.service - Ssserver</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/ssserver.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Thu 2017-08-03 05:56:09 UTC; 23s ago</span><br><span class="line"> Main PID: 691 (ssserver)</span><br><span class="line">   CGroup: /system.slice/ssserver.service</span><br><span class="line">           `-691 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json --log-file /var/log/shadowsocks.log start</span><br><span class="line"></span><br><span class="line">Aug 03 05:56:09 kevin systemd[1]: Started Ssserver.</span><br><span class="line">Aug 03 05:56:09 kevin systemd[1]: Starting Ssserver...</span><br><span class="line">Aug 03 05:56:09 kevin ssserver[691]: INFO: loading config from /etc/shadowsocks.json</span><br><span class="line">Aug 03 05:56:09 kevin ssserver[691]: 2017-08-03 05:56:09 INFO     loading libcrypto from libcrypto.so.10</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title>google开源python代码规范</title>
    <url>/2017-07-31-google-opensourse-python-code-standard.html</url>
    <content><![CDATA[<ul>
<li><p><strong>1. 行长度</strong></p>
<ul>
<li>每行不超过80个字符(例外 a.长的导入模块语句; b. 注释里的url)</li>
<li>Python会将 圆括号, 中括号和花括号中的行隐式的连接起来 ：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: print(<span class="string">'hello'</span></span><br><span class="line">   ...: <span class="string">'world'</span>)</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>2. 文件和sockets</strong></p>
<blockquote>
<p>在文件和sockets结束时, 显式的关闭它.</p>
</blockquote>
<ul>
<li>推荐使用 “with”语句 以管理文件;</li>
<li>对于不支持使用”with”语句的类似文件的对象,使用 contextlib.closing():<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">with</span> contextlib.closing(urllib.urlopen(<span class="string">"http://www.python.org/"</span>)) <span class="keyword">as</span> front_page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> front_page:</span><br><span class="line">        <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>3. todo注释</strong></p>
<blockquote>
<p>为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p>
</blockquote>
</li>
<li><p><strong>4. 导入格式</strong></p>
<blockquote>
<p>每个导入应该独占一行</p>
</blockquote>
<ul>
<li>导入顺序：<ul>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序指定导入</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>5. 命名约定</strong></p>
<ul>
<li>所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.</li>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含).</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有.</li>
<li>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li>
<li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>google</tag>
        <tag>opensourse</tag>
      </tags>
  </entry>
  <entry>
    <title>python for else</title>
    <url>/2017-09-12-python-for-else.html</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hello world"</span>;</span><br><span class="line">输出：hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hello world"</span>;</span><br><span class="line"> </span><br><span class="line">没有输出</span><br><span class="line">-------------------</span><br></pre></td></tr></table></figure>

<p>即在for 循环中，如果没有从任何一个break中退出，则会执行和for对应的else<br>只要从break中退出了，则else部分不执行。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>for</tag>
        <tag>else</tag>
      </tags>
  </entry>
  <entry>
    <title>uwsgi和gunicorn</title>
    <url>/2018-07-26-uwsgi-gunicorn.html</url>
    <content><![CDATA[<h3 id="WSGI-、uwsgi-与-uWSGI-的区别"><a href="#WSGI-、uwsgi-与-uWSGI-的区别" class="headerlink" title="WSGI 、uwsgi 与 uWSGI 的区别"></a>WSGI 、uwsgi 与 uWSGI 的区别</h3><ul>
<li><p>WSGI：只是一种规范，描述web server如何与web application通信的规范，运行在WSGI协议之上的框架有Bottle, Flask, Django ；</p>
</li>
<li><p>uwsgi：是uWSGI服务器的独有通信协议，据说该协议是fcgi协议的10倍快；</p>
</li>
<li><p>uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等；</p>
</li>
</ul>
<h3 id="WSGI规范"><a href="#WSGI规范" class="headerlink" title="WSGI规范"></a>WSGI规范</h3><p>WSGI 其实是定义了一种server与application解耦的规范；</p>
<p>WSGI server： uWSGI、gunicorn ；</p>
<p>WSGI app：bottle、flask、django、tornado<br><img src="/uploads/uwsgi-gunicorn/uwsgi.png" alt="wsgi"></p>
<h3 id="uWSGI支持的并发模型"><a href="#uWSGI支持的并发模型" class="headerlink" title="uWSGI支持的并发模型"></a>uWSGI支持的并发模型</h3><ul>
<li>Multiprocess</li>
<li>Multithreaded</li>
<li>gevent</li>
<li>greenlet + uWSGI async</li>
<li>uWSGI native async api</li>
<li>Coro::AnyEvent</li>
<li>Ruby fibers + uWSGI async</li>
<li>Ruby threads</li>
<li>uGreen + uWSGI async<h3 id="uWSGI常用参数配置"><a href="#uWSGI常用参数配置" class="headerlink" title="uWSGI常用参数配置"></a>uWSGI常用参数配置</h3>socket ： 地址和端口号；<br>http：开启一个http服务和socket服务；<br>processes ： 开启的进程数量；<br>workers ： 开启的进程数量，等同于processes；<br>chdir ： 指定运行目录<br>wsgi-file ： 载入wsgi-file（load .wsgi file）<br>threads ： 运行线程数；<br>http-websockets：websocket支持；<br>master ： 允许主进程存在；<br>module： 指定需要加载的WSGI模块；<br>callable：  指定哪个变量将被调用，默认是名字为“application”的变量；<br>daemonize ： 使进程在后台运行，并将日志打到指定的日志文件；<br>pidfile ： 指定pid文件的位置，记录主进程的pid号；<br>disable-logging ： 不记录请求信息的日志。只记录错误以及uWSGI内部消息到日志中；</li>
</ul>
<h3 id="uWSGI基本命令"><a href="#uWSGI基本命令" class="headerlink" title="uWSGI基本命令"></a>uWSGI基本命令</h3><p>启动： uwsgi -i uwsgi.ini</p>
<p>重启：uwsgi –reload uwsgi.pid</p>
<p>停止：uwsgi –stop uwsgi.pid</p>
<p>更多：uwsgi –help</p>
<h3 id="uwsgi与gunicorn性能对比-先挖个坑，明天再补"><a href="#uwsgi与gunicorn性能对比-先挖个坑，明天再补" class="headerlink" title="uwsgi与gunicorn性能对比 (先挖个坑，明天再补)"></a>uwsgi与gunicorn性能对比 (先挖个坑，明天再补)</h3>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>uwsgi</tag>
        <tag>gunicorn</tag>
      </tags>
  </entry>
  <entry>
    <title>图像识别验证码识别神器Tesseract</title>
    <url>/2018-09-07-.html</url>
    <content><![CDATA[<h3 id="Tesseract简介"><a href="#Tesseract简介" class="headerlink" title="Tesseract简介"></a>Tesseract简介</h3><p>tesseract是一个图像识别库，底层是用C++写的，tesseract支持unicode编码，能够识别100多种语言；<br>Tesseract支持各种输出格式：纯文本，特殊（html），pdf，tsv，仅隐形文本pdf</p>
<ul>
<li>tesseract历史:<br>Tesseract最初是在1985年至1994年间在Hewlett-Packard Laboratories Bristol和Greeley Colorado的Hewlett-Packard Co开发的，1996年又进行了一些更改以移植到Windows，并在1998年开始使用一些C ++。2005年，Tesseract开放了 惠普采购。 自2006年以来，它由谷歌开发。</li>
<li>版本：<br>最新的稳定版本是3.05.01，于2017年6月1日发布。最新的3.05源代码可从GitHub上的3.05分支获得。<br>新的基于LSTM的4.0版本的源代码可从GitHub上的主分支获得。 请注意，该分支正在积极开发中。<br><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">tesseract官网地址</a></li>
<li>tesseract可以用来识别图像和验证码，自带的命令可以识别数字字母等，准确率很高，需要中文和其他语言可以自行下载相关的语言库，如果想要再次提高准确率可以抽取足够多的样本，然后自己训练，本人做的电话号码和邮箱的识别库准确率可以接近99%;</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> mac brew install</span><br><span class="line">sudo brew install tesseract</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> ubuntu </span><br><span class="line">sudo apt update &amp;&amp; sudo apt install tesseract-ocr</span><br><span class="line"><span class="meta">#</span> 安装语言包：</span><br><span class="line">sudo apt-get install tesseract-ocr-[lang] # lang是语言</span><br><span class="line"><span class="meta">#</span> 下载所有语言包:</span><br><span class="line">sudo apt-get install tesseract-ocr-all</span><br></pre></td></tr></table></figure>

<ul>
<li>当然也可以直接到代码库里面直接下载语言库：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">语言库网址</a>, 下载*.traineddata文件放到本地语言库目录，mac下是:/usr/local/share/tessdata，ubuntu下是:/usr/share/tesseract-ocr/4.00/tessdata/</li>
</ul>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>安装成功以后执行tesseract如下图<br><img src="/uploads/tesseract/tesseract-cmd.png" alt="tesseract cmd"></p>
<ul>
<li>注意一下</li>
</ul>
<p>-psm: 参数是指定文本模式，如果是单行文本可以指定为6，<br>-l: 参数指定识别使用的语言库，如eng，</p>
<ul>
<li><p>查看当前可用语言库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ocr git:(develop) tesseract --list-langs                                    </span><br><span class="line">List of available languages (10):</span><br><span class="line">chi_sim         # 简体中文库</span><br><span class="line">live10          # 自己训练的语言库</span><br><span class="line">eng             # 英文库</span><br></pre></td></tr></table></figure>
</li>
<li><p>识别英文例子：<br>![例子图片]](/uploads/tesseract/tesseract-sample.png)<br>识别以后：<br>![识别后]](/uploads/tesseract/tesseract-recognize.png)</p>
</li>
<li><p>识别中文：<br>![例子图片]](/uploads/tesseract/tesseract-ch.png)</p>
</li>
</ul>
<p>![例子图片]](/uploads/tesseract/tesseract-ch-r.png)</p>
<ul>
<li>准确率还是很高的，中文是识别出很多空格，可以自行处理一下</li>
<li>下次会分享如何手动训练自己的语言库，敬请期待</li>
</ul>
]]></content>
      <categories>
        <category>图像识别</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
        <tag>验证码识别</tag>
      </tags>
  </entry>
  <entry>
    <title>PayPal和LinkedIn创始人Reid Hoffman的ABZ理论</title>
    <url>/2017-09-27-Career-ABZ-Plan.html</url>
    <content><![CDATA[<p>我们一向把创业视为一件非常有风险的事。说起来挺矛盾，创业者经常看不起那些职场金领，但是前者在后者眼中也只是一群吃了上顿没下顿的流浪汉而已。所以这里最大的挑战就是：一个人如何让自己勇于拓展机会，但同时又不要冒太大风险，乃至于丢掉饭碗血本无归？讲到成功的把这两点结合在一起的方法，Reid Hoffman应该是最有发言权的。</p>
<p>LinkedIn的经历让他了解了职场万象，按他的说法，渐进式的职业规划和冒险创业是可以两全的。他发明了一套独有的职业规划理论，叫做“A-B-Z 职业规划”法则。这虽然也是在做职业规划，但是却强调试验、鼓励不确定性。而且它也不仅仅适合年轻人，对于三四十岁的“职场老人”来说一样适用。所谓的A、B、和Z分别都是什么意思呢？<br><strong>原文：<a href="https://techcrunch.com/2012/02/14/in-startups-and-life-you-need-plan-a-b-and-z/" target="_blank" rel="noopener">In Startups And Life, You Need Plan A, B, And Z</a></strong></p>
<p><strong>A-B-Z 职业规划</strong><br>A指的是你现在正在做的事情，或者叫主业。比如说它可能是你的专业，是你优势比较集中的领域，你是喜欢它也好不喜欢它也好，现在都得靠它吃饭。用不断的、小小的进步把主业做好当然是属于“敬业”的范畴，不过，当你逐渐的发现你可能需要一个更大的改变的时候，那就是转变到B计划上的时候了。这种转变绝对不是随机的瞎选，而是根据你已经有的经验和知识去看一条新的路径，并且等待这条新的路径逐渐变得清晰。当然，一旦你变完之后，这个B计划就成为新的A计划了。</p>
<p>这个从A到B的过程是最微妙的地方。为了保持决策的合理性，让自己停留在一个安全的轨道上，但同时又不束缚手脚，值得鼓励的方法是去有选择的“赌”一些后果可以收回的小事。既然咱们已经决定要给自己做出些改变了，那走些小弯路是肯定的。不过最好别让他们带来比较永久的损伤。同时我们要想方设法让自己的A计划和B计划逐渐靠拢，让B计划可以帮助到主业上，别变成完全的“不务正业”。</p>
<p>A指的是主业，B自然就是一个潜在的可以去达到自己理想中的目标的另外路径。假如A不管用了，你可以尝试在B上面投入更多的时间。B可以是一个和A同类别的事情，这样的你的技能是可以转移的。也可以是一个新发现的、不同领域的机会。那你怎么知道什么时候应该换什么时候不应该换呢？有些改变比较小，比如说换个部门，但有些改变就比较大了，比如说换工作，甚至完全改变一个行业。说实在，在做出改变之前谁也不知道自己变得对不对。不过，起码在科技领域，一个基本的一般规律是在大潮到来之前行动要比在大潮到来之后行动好。这说明，如果你想去抓住某些机会，就必须得冒你自己很努力的去做，但是结果这个浪头没有来的风险。具体到每件事情的话，该不该跳，什么时候跳都是个人洞察力、直觉、运气等等的融合。</p>
<p>最后，Z是一个保底选项。也就说，假如你的冒险全部都失败了，最差能怎么样？这个问题要想好，因为对于不同年龄不同处境的人保底选项是不一样的。这就是为什么人越年轻他冒险的成本越低。毕竟，我们平常说的所有关于创业的东西，恐怕都是说起来容易做起来难，那是因为他们会带来真正的不确定性，不确定性是最让人害怕的。所以想要解决这一点的方法就是在底下垫一个非常确定的计划。那就是计划Z，计划Z会确保你就算所有其他东西都搞砸了也还不至于露宿街头。它存在的最大意义是让我们对自己能承受多大的失败有个谱，虽然说不管什么样的失败肯定都是让人痛苦的，但是没有计划Z的话可能我们根本就不敢去冒险。</p>
<p><strong>从失败的婚恋网站，到PayPal，再到LinkedIn ，看看 Reid Hoffman这些年</strong></p>
<p>直接启发Reid Hoffman开发出这个ABZ法则的是他自己的职业生涯。值得注意的是，Hoffman和许多硅谷的传奇人物相比恐怕是要“普通”多了。他既没有大学辍学、也不是电脑天才，但是由于他总能敏锐观察自己的职业轨迹，善于辗转腾挪，依然取得了今天的成就。</p>
<p>他在离开学界之后首先创立了个婚恋网站叫socialnet.com。他的朋友Peter Thiel和Max Levchin当时创办了PayPal。出于对好朋友的支持，Hoffman决定把自己的空闲时间都贡献出来，每天在自己的公司工作到半夜，然后给另外俩人打电话去处理PayPal的事情。这种同时做两个创业公司的高强度生活持续了一两年，很快，他的A计划快不行了，网站关门在即，当时他的面前有两个B计划：要不找一份比较安稳的其他的技术工作，要不在第一次创业已经失败的情况下再赌一把，加入PayPal。Hoffman想了想，选了第二个。</p>
<p>PayPal迅速崛起后，后来的故事咱就都知道了。值得注意的是，这个故事还影响到了Reid Hoffman人生的第二次重大决策。2002年PayPal以15亿美元被收购，员工们在发了大财之后都跑去度假了。而他估计是还没从这几年来过山车中的经历中缓过劲来，在澳大利亚的海滩上躺着晒太阳时，突然一拍大腿，发现：“不对！我这些年这么多起起落落而最终不死，就是因为我总是在寻找新机会，并能够灵活的调整方向。现在PayPal刚刚发了大财，但同时也意味着它就完事儿了，现在应该趁着这股劲，利用手上的资源，赶紧再开始一个B计划。”当天晚上他就飞回了硅谷，开始创办LinkedIn。有意思的是，PayPal的好多其他元老们在全世界旅游了一年回来以后，正闲的发慌，结果发现LinkedIn已经在蒸蒸日上了，不禁吃了一惊，后悔他们错过了这一班车…</p>
<p><strong>以下是一些小Tip，让我们在探索自己的航线时尽量提高效率、降低风险：</strong></p>
<p>开始一个兼职小项目（side project）。除非你需要立刻做出一个决定，否则的话一个非常好的开始B计划的方法是给自己一份空闲时间干的事情。比如说，利用晚上和周末的时间来学一个技能，做一份兼职的实习，开一个兼职的咨询服务，等等。我们讲的这个兼职计划和业余爱好等这种完全陶冶情操的活动不一样，它指的是一个有着成为全职工作潜力的事情，只要在时机成熟，你就可以做出转变。就跟Google和3M这样的公司让员工每周花一天的时间在自己觉得有意思的项目上一样，我们完全可以自己个自己也制定一个这样的计划。</p>
<p>人一辈子不管在哪个阶段，都应该把学习作为是对自己最重要的事情。一般来说，世界上大部分人的教育在从学校出来以后就基本上停止了。可能逐渐的他们看电视剧的时间会远远超过充实自己的头脑的时间，人们会投资股票，不会去投资自己。在这个问题上大家可能有不同看法，毕竟人们还是要生活的，钱财也是需要管理的。不过Reid Hoffman建议大家在不管什么时候，应该永远优先选择那些能提高自己能力的活动。（我插一句，这个确实反映了从富兰克林时代就开始的那种美国式的、完全实用主义的勤学价值观）</p>
<p>给自己两个身份，一个人拥有双重身份能带来哪些好处？我见过很多人在做自己的全职商业工作的同时还做一份非营利组织的工作，这两件事情经常能够相互促进。比如说你在一家创业公司工作，然后在空闲时间再组织一个行业协会，协会里遇到的人经常可以给自己的全职工作也带来发展，这是直接第一点比较“有用”的好处。另外，我们也知道这种跨领域的经历是创造力最容易迸发的地方。</p>
<p>还有一个做法，就是试图把完全的“被工作定义的自己”和自己区分开。也就是说，不要用一个工作简历上的描述把自己给定死。比如说，在自己的LinkedIn主页上，大标题一栏可以不要写一个具体的公司的工作，而写自己的职业总体方向和追求。这是因为，如果你只关注某个人现在在做什么工作，那你可能会漏过很多这个人身上其他的价值。比如说某人是大公司高管，但他同时也很有可能是一个天使投资人。自然，我们在对外展示自己的时候也应该努力展示多个方面，因为人们会用同样的方式来看我们。</p>
]]></content>
      <categories>
        <category>职业规划</category>
      </categories>
      <tags>
        <tag>ABZ</tag>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>慕课网免费视频课程</title>
    <url>/2018-10-30.html</url>
    <content><![CDATA[<h3 id="免费学习资源："><a href="#免费学习资源：" class="headerlink" title="免费学习资源："></a>免费学习资源：</h3><p>1、Java工程师 <a href="http://www.imooc.com/course/programdetail/pid/31" target="_blank" rel="noopener">http://www.imooc.com/course/programdetail/pid/31</a><br>2、Web前端工程师 <a href="http://www.imooc.com/course/programdetail/pid/32" target="_blank" rel="noopener">http://www.imooc.com/course/programdetail/pid/32</a><br>3、PHP工程师 <a href="http://www.imooc.com/course/programdetail/pid/34" target="_blank" rel="noopener">http://www.imooc.com/course/programdetail/pid/34</a><br>4、Android工程师 <a href="http://www.imooc.com/course/programdetail/pid/33" target="_blank" rel="noopener">http://www.imooc.com/course/programdetail/pid/33</a><br>5、Linux运维工程师 <a href="http://www.imooc.com/course/programdetail/pid/45" target="_blank" rel="noopener">http://www.imooc.com/course/programdetail/pid/45</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>改善程序员生活质量的 3+10 习惯</title>
    <url>/2017-11-21-improve-quality-of-life.html</url>
    <content><![CDATA[<h3 id="段子背后的真相"><a href="#段子背后的真相" class="headerlink" title="段子背后的真相"></a>段子背后的真相</h3><p>有一则段子是这么描述程序员的职业发展：</p>
<blockquote>
<p>某编程语言入门 -&gt; 某编程语言进阶 -&gt; 某编程语言最佳实践 -&gt; 架构的艺术 -&gt; 颈椎病康复指南.</p>
</blockquote>
<p>  每次看到这个段子，我都只是一笑而过，还偶尔给别人讲起逗逗乐。可如今它不仅是一个段子，更像是一则不那么古老的寓言应验了！或许你会说：腰肌劳损、腰椎盘突出、颈椎弯曲这些在程序员圈子司空见惯了。<br>  真相又是什么呢？因为我身边的例子为数不多，我仍然跟之前一样保持疑问的态度。<br>  可不管真相如何，这封邮件却触动了我，让我想写点东西，来分享我平时在做且自认为很有意义的事情。</p>
<h3 id="认知是一切的基础"><a href="#认知是一切的基础" class="headerlink" title="认知是一切的基础"></a>认知是一切的基础</h3><p>  古人所说知行合一，强调的是认知和行为一致，人们在做一件事情之前首先是要形成一定的认知。比如，我为什么要持续学习？我为什么要花时间去健身？而只有当我的认知中，认识到学习是具备价值，认识到健身是能给我带来益处的时候，我才会自我驱动地去做这些事情，在行动的过程中达到知行合一。<br>  我曾经给一些朋友讲健康饮食、规律作息和运动健身的好处，讲它们对一个人工作生活有多么重要的影响，当他们若有所感地回应我的时候，我会接着告诉他们一些健康的食物、一些规律的作息时间、一些健身的软件和圈子。到最后，我才发现，他们几乎没有改变。一方面，因为他们没有切身体会到这些好处，另一方面，他们目前的生活并没有无法容忍的痛点，偶尔抱怨一下也只是过过嘴瘾。</p>
<blockquote>
<p>根本原因在于认知！</p>
</blockquote>
<p>  最快改变一个人的认知的方式是残酷地摧毁这个人先前的认知。举个真实极端点的例子：某某因为工作长期无节制的饮食和无规律的作息查出胃癌晚期的时候，即便用所有的钱去换回健康也为时过晚，我相信此时ta比任何人都知道健康的重要性，如果可以再来，他一定会摒弃之前所有的不良习惯，好好生活。<br>  另外一种改变认知的方式就是形成一定的基础认知，然后通过身体力行，循序渐进地付出努力去强化自己的认知，最终达到知行合一。<br>  我将从健康饮食、规律作息和健身运动方面去分享一些小知识。一旦形成了这种认知，我们就可以通过养成一些小习惯来不断强化提升，而作为一枚程序员的我也一直在通过这种方式不断地改善自己的工作效率，提升生活质量。</p>
<blockquote>
<p>让行为成为习惯</p>
</blockquote>
<p>  《不抱怨的世界》中介绍了一个21天不抱怨手环，旨在坚持连续21天不抱怨，一旦说出了抱怨的话就将手环从一只手移动到另一只手，并且重新计数。如果你也跟我一样这么想：<br>不就是21天嘛，小case，看我是如何做到的！<br>  你就大错特错了。因为我一开始也是这么想的，结果…! 至于为什么是21天呢，相信大家耳熟能详了。<br>  看似不长的21一天，连续坚持下来却是一个大大的考验。有了21天培养一个习惯的指导方针，我们应该大胆相信自己能将饮食、作息、运动相关的良好行为培养成习惯，从而决定我们身体的命运（习惯决定性格，性格决定命运）<br>  《黄帝内经》中素问上第一章 上古天真论中提到 “食饮有节，起居有常，不妄作劳，故能形与神俱，而尽终其天年，度百岁乃去”。下面我们就来探讨一下食饮有节，起居有常，不妄作劳的奥秘。</p>
<h3 id="食饮有节"><a href="#食饮有节" class="headerlink" title="食饮有节"></a>食饮有节</h3><blockquote>
<p>饮食应该持有节制，切勿暴饮暴食或不吃不喝。</p>
</blockquote>
<p>  不可否认，很多疾病是吃出来的。暴饮暴食和绝食都属于极端的行为。而相比于长期因为营养不足引发营养不良，长期暴饮暴食导致体内毒素积累过度带来的危害更为严重。有人说：我要减肥，必须控制饮食，从而控制体重。<br>  没错，控制饮食是控制体重的最好的方式（另外配合运动更加健康）。也就是经常饿一饿，但饿也是有讲究的，先来看看一些极为不健康的饿法：</p>
<ol>
<li>早起太晚，没时间吃早餐，匆匆忙忙赶到办公室饿着肚子干到中午。</li>
<li>中午外面太阳太热了，外卖已吃腻，两杯咖啡打发下午。</li>
<li>晚上好饿呀，撑不住了，正道人间美味，何不享受今宵。<br>　　再来看看健康的饿法：</li>
<li>早上有点饿感，（空腹练上30分钟左右的瑜伽），喝杯温水，洗漱完给自己做一顿营养早餐（量不大）。</li>
<li>中午饭点了，饿感来袭，去吃一顿7、8分饱的午餐，午休30分钟。</li>
<li>晚上了有点饿，少吃一些杂粮饼干、水果，避免带着饿感入睡（因为很难睡着）。<br>古人云：饿治百病。饭吃到7、8分饱，晚上不给胃添加过大的负担。而且我的经验证明（当然还有受我蛊惑的朋友），晚上少吃能够有效地减到肚子上的赘肉。另外，晚上少吃能够让身体的各个器官能得到充分休息，第二天醒来大脑会很清醒。而伴随着起床困难症的消逝，你会积极的起床为自己准备一份渴望了一晚上的精美早餐（当然，自己做早餐是一件美好的事情）。<br>老饿着也不行，那我们吃些什么呢？俗话说：早上吃得向皇帝，中午吃得香平民，晚上吃得像乞丐。<br>科学研究表明人体每天从三餐摄入的营养比例分别是40%、40%、20%，而保证这些营养的摄入，我们需要每天摄入适量的水果、蔬菜、谷物和蛋白质。<br>以早餐为例，我们可以摄入一定量的谷物，比如面包、包子、燕麦等；以高蛋白饮食为主，比如鸡蛋、牛奶、牛肉等；配合着蔬菜，比如西蓝花、西红柿、黄瓜、青椒等；再搭配上饱含微量元素的干果类，比如核桃、开心果、腰果、松子、葡萄干等。然后饭后搭配上水果，比如猕猴桃、香蕉、苹果。<br>如果你觉得这些东西准备起来比较麻烦，还有一种选择：代餐。比如我最近一直在吃五谷磨房的“八珍元”早餐粉，它使用了八种原材料经过高温烘焙然后研磨成粉，搭配“五谷伴侣”一起饮食，只需要10分钟就可以准备好一顿营养丰富的早餐，当然，奖励自己一个鸡蛋或一勺植物蛋白粉或几块牛肉会让早餐更加美味。<br>我已经给身边的好几位朋友推荐了代餐，而我自己通过长时间的饮食，成功减去内脂和小肚皮上的肉！</li>
</ol>
<h3 id="起居有常"><a href="#起居有常" class="headerlink" title="起居有常"></a>起居有常</h3><p>  日出而作，日落而息描述了淳朴农名的作息规律。记得小时候，父母9点就睡觉了，早上5点多就起床了。<br>  而深居都市的大多数白领，喧嚣的夜生活，睡不起的懒觉，颠倒了自然法则的作息习惯。已经很少有人会去睡子午觉了。何为子午觉：<br>子时：23:00 ~ 01：00；午时：11:00 ~ 13：00；<br>  夜半子时为阴阳大会，水火交泰之际，称为“合阴”，它是一天中阴气最重的时候，也是睡眠的最佳时机，子时之前入睡有利于养阴；日间午时也是阴阳交会的时候，阳气最盛，称为“合阳”，此时午睡有利于养阳。<br>  子午觉的原则是子时大睡，午时小憩，即晚上在子时之前（23:00之前）最好入睡，对于不得不从事熬夜工作的人，与其一直熬到凌晨3、4点，不如在子时这段时间睡上一会儿，因为这段时间的睡眠效率远远超过其他时间段，夸张点说一分钟等于一小时。午觉则只需在午时（11时～13时）休息30分钟左右即可，因为此时阳气盛，工作效率最好，午睡时间过长，不仅浪费宝贵的时间，而且会扰乱人体生物钟，影响晚上睡眠。但是午睡一定要睡，即便睡不着，也要闭目养神，这样有利于人体阴阳之气的正常交接。<br>  在作息中，子午觉对健康极为重要，它还是一种不花钱的养生方法，睡好子午觉，你的身体多了一层保障了。</p>
<h3 id="不妄作劳"><a href="#不妄作劳" class="headerlink" title="不妄作劳"></a>不妄作劳</h3><p>  不妄作劳，结合新时代有不一样的解读，不要忘记劳作，即要保持运动，也不要过于劳作，即不要运动过量。<br>  回到我们文章一开始说的那封离职邮件，因为程序员的工作性质，绝大部分程序员是长时间对着电脑工作的，加上某些公司存在加班文化，久坐的时间就更加延长了。所以导致了很多诸如腰椎盘突出、颈椎病、肩周炎、腰肌劳损、圆肩驼背等职业病。<br>  那么如何缓解这些问题？除了坐姿端正，注意休息，更要加强运动锻炼。因为运动一方面能够加强肌肉的力量和耐力，另一方面能够活动身体的各个关节，能够有效缓解一个长时间保持一个动作导致局部肌肉过劳。</p>
<h3 id="那么问题来了，如何科学地运动呢？"><a href="#那么问题来了，如何科学地运动呢？" class="headerlink" title="那么问题来了，如何科学地运动呢？"></a>那么问题来了，如何科学地运动呢？</h3><p>  我平日里听到最多的是我要减肥，将身体的脂肪减掉。好，我就说一个绝对有效且简单的减脂秘方：每天45分钟动感单车。是不是很简单，只用跟着教练跑上45分钟，体脂一定能够降下来。但是有多少人能够坚持去做好这45分钟呢？所以当有人夸赞我是教练的时候，我会告诉他我如果教学员，秘诀只在于两字：<br>　　坚持!<br>问：花钱办健身卡会不会因为不常去导致浪费？<br>答：已经有很多徒手的运动，比如跑步、HIIT、Tabata、瑜伽、徒手胸肌训练，徒手腹肌、空手拳击、腰背拉伸等；<br>问：缺乏专业教练的指导会不会练不好？<br>答：已经有很多软件提供了免费且科学的指导，比如 移动健身教练：Keep、私人瑜伽教练：Wake。<br>问：有自虐倾向，担心练过火了，身体吃不消？<br>答：运动健身不宜过度，要以自身身体感觉为依据，不能影响正常的食欲、工作和睡眠。<br>　　运动健身无处不在，如果你也有以上三个疑问，不妨利用瑜伽垫 + 4平米 + Keep就可以在家里开创一片健身的空间。当然健身卡能提供更丰富的选择，而能否坚持完全取决于我们自己。坚持两字则包含了深不见底的学问。</p>
<h3 id="习惯的力量"><a href="#习惯的力量" class="headerlink" title="习惯的力量"></a>习惯的力量</h3><blockquote>
<p>食饮有节，起居有常，不妄作劳 ==&gt; 故能形与神俱，而尽终其天年，度百岁乃去。<br>　　饮食、作息、运动三者息息相关，相辅相成。三分练，七分吃，充足睡眠不丢失。如果到这里，你已经对它们的认知更进一步了，接下来我么来枚举一下围绕着这三个方面的10个小习惯：</p>
</blockquote>
<ol>
<li>早起空腹一杯温水，减轻肠胃的负累。</li>
<li>按时吃饭，越忙越要好好吃饭。</li>
<li>吃饭只吃七、八分饱，键肠胃。</li>
<li>切勿暴饮暴食，晚上少吃，尤其是油腻食物。</li>
<li>每天揉3~8分钟足三里穴，可以健脾胃。</li>
<li>中午（午时）午休半小时，夜间23:00（子时）前入睡。</li>
<li>每工作1~2小时，起身走动倒杯水，再忙也要喝水。</li>
<li>将运动融入工作中，每天定时做做运动（平板支撑、颈椎操等），10~30分钟即可。</li>
<li>下班后适量地健身运动，越忙越要保持运动。</li>
<li>坚持做上面9条。<br>将上面的事情坚持做上21天，我相信你一定可以感知到习惯的力量。<br>重点要指出，现在大多数职业都需要久坐，尤其是程序员，要养成定时活动颈椎和腰椎的习惯，保持健身运动，而这些完全可以融入到工作和生活的间隙中。不要为了节省短暂的半小时去拼命工作，也不要吝啬花上15分钟去吃一份有营养的早餐。这些时间终究会通过提升工作效率来弥补上。不可否认，现实中那些工作忙得不可开交、却依然重视饮食且投入1~2小时到健身中的职场精英早已经养成了这些习惯。</li>
</ol>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>生活质量</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中group by和order by解析</title>
    <url>/2018-12-11.html</url>
    <content><![CDATA[<p>###<br>本文就和大家一起深入研究下mysql中group by与order by.下面是我模拟我的内容表<br><img src="/uploads/mysql-groupby/mysql-1.gif" alt="内容表"><br>我现在需要取出每个分类中最新的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from test group by category_id order by `date`</span><br></pre></td></tr></table></figure>

<p>结果如下<br><img src="/uploads/mysql-groupby/mysql-2.gif" alt></p>
<p>明显。这不是我想要的数据，原因是msyql已经的执行顺序是</p>
<p>引用</p>
<p>写的顺序：select … from… where…. group by… having… order by..<br>执行顺序：from… where…group by… having…. select … order by…</p>
<p>所以在order by拿到的结果里已经是分组的完的最后结果。<br>由from到where的结果如下的内容。<br><img src="/uploads/mysql-groupby/mysql-3.gif" alt> </p>
<p>到group by时就得到了根据category_id分出来的多个小组<br><img src="/uploads/mysql-groupby/mysql-4.gif" alt><br><img src="/uploads/mysql-groupby/mysql-5.gif" alt></p>
<p>到了select的时候，只从上面的每个组里取第一条信息结果会如下<br><img src="/uploads/mysql-groupby/mysql-6.gif" alt></p>
<p>即使order by也只是从上面的结果里进行排序。并不是每个分类的最新信息。<br>回到我的目的上 －－分类中最新的信息<br>根据上面的分析，group by到select时只取到分组里的第一条信息。有两个解决方法</p>
<p>1，where+group by（对小组进行排序）<br>2，从form返回的数据下手脚（即用子查询）<br>由where+group by的解决方法<br>对group by里的小组进行排序的函数我只查到group_concat()可以进行排序，但group_concat的作用是将小组里的字段里的值进行串联起来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select group_concat(id order by `date` desc) from `test` group by category_id</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/mysql-groupby/mysql-7.gif" alt> </p>
<p>再改进一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from `test` where id in(select SUBSTRING_INDEX(group_concat(id order by `date` desc),',',1) from `test` group by category_id ) order by `date` desc</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/mysql-groupby/mysql-8.gif" alt> </p>
<p>子查询解决方案</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from (select * from `test` order by `date` desc) `temp`  group by category_id order by `date` desc</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/mysql-groupby/mysql-9.gif" alt></p>
<p>自己例子</p>
<p>复制代码 代码如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT * FROM (SELECT * FROM `ecm_copy_goods_change` ORDER BY `cid` DESC) `ecm_copy_goods_change` GROUP BY goods_id ORDER BY `cid` DESC</span><br></pre></td></tr></table></figure>

<ul>
<li>mysql下试了方法1，不成功，然后用的方法2；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>group by</tag>
        <tag>order by</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL入门指导</title>
    <url>/2018-10-19.html</url>
    <content><![CDATA[<h3 id="什么是GRAPHQL"><a href="#什么是GRAPHQL" class="headerlink" title="什么是GRAPHQL"></a>什么是GRAPHQL</h3><p>GraphQL是API的查询语言和运行时，用于使用现有数据完成这些查询。 GraphQL提供了API中数据的完整且易于理解的描述，使客户能够准确地询问他们需要什么，仅此而已，使API随着时间的推移更容易发展，并支持强大的开发人员工具。</p>
<h3 id="GraphQL-与-RESTful-有什么区别？"><a href="#GraphQL-与-RESTful-有什么区别？" class="headerlink" title="GraphQL 与 RESTful 有什么区别？"></a>GraphQL 与 RESTful 有什么区别？</h3><ul>
<li>首先放上一张来自于 graphql.org 的图片。REST 与 GraphQL 都是服务端所承载的系统对外的服务接口，因此两者肯定是可以共存的，甚至可以共用一套 Authorization 等业务逻辑。<br><img src="/uploads/graphql/graphql-and-restful.png" alt><br>RESTful的一些不足:</li>
<li>扩展性，单个RESTful接口返回数据越来越臃肿<br>比如获取用户信息/users/:id，最初可能只有id、昵称，但随着需求的变化，用户所包含的字段可能会越来越多，年龄、性别、头像、经验、等级，等等等等。</li>
</ul>
<p>而具体到某个前端页面，可能只需要其中一小部分数据，这样就会增加网络传输量，前端获取了大量不必要的数据。</p>
<ul>
<li>某个前端展现，实际需要调用多个独立的RESTful API才能获取到足够的数据<br>比如一个文章详情页，最初可能只需要文章内容，那么前端就调用/articles/:aid获取到文章内容来展现就行了</li>
</ul>
<p>但随着需求的演进，产品可能会希望加上作者信息（昵称、头像等），这时前端又需要在获取文章详情后，根据其中的作者id字段继续获取作者相关的信息，/user/:uid</p>
<p>然后，需求又变化了，产品希望在加上这篇文章的评论，这时前端需要继续调用/comment/:aid来拉取评论列表</p>
<p>对于Web前端而言，由于ajax技术的存在，这种的请求数据方式，也就开发上稍微麻烦些，并不会造成太大的问题；但对于App来说，渲染的方式不同，必须要拉取的全部的数据之后，才能绘制界面，就会导致这个界面必须要等到所有3个RESTful接口的返回数据都拿到，才能进行绘制。</p>
<p>GraphQL的一些优点</p>
<ul>
<li>所见即所得<br>查询的返回结果就是输入的查询结构的精确映射<br>查询：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  books(id: <span class="number">3</span>) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: &#123;</span><br><span class="line">    <span class="string">"user"</span>: &#123;</span><br><span class="line">      <span class="string">"uid"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"xxx"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>减少网络请求次数<br>如果设计的数据结构是从属的（例如，上文中书的作者信息），直接就能在查询语句中指定:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  books(id: <span class="number">3</span>) &#123;</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    author &#123;</span><br><span class="line">      id,</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>即使数据结构是独立的，也可以在查询语句中指定上下文，只需要一次网络请求，就能获得资源和子资源的数据（例如，上文中书和作者信息）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  books(id: <span class="number">3</span>) &#123;</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    author &#123;</span><br><span class="line">      id,</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  allAuthors &#123;</span><br><span class="line">    id,</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>代码即文档<br>GraphQL会把schema定义和相关的注释生成可视化的文档，从而使得代码的变更，直接就反映到最新的文档上，避免RESTful中手工维护可能会造成代码、文档不一致的问题。</p>
</li>
<li><p>参数类型强校验<br>RESTful方案本身没有对参数的类型做规定，往往都需要自行实现参数的校验机制，以确保安全。</p>
</li>
</ul>
<p>但GraphQL提供了强类型的schema机制，从而天然确保了参数类型的合法性。</p>
<h3 id="GraphQL-能做到修改数据吗？"><a href="#GraphQL-能做到修改数据吗？" class="headerlink" title="GraphQL 能做到修改数据吗？"></a>GraphQL 能做到修改数据吗？</h3><p>看了上面的 query 的例子，你肯定很好奇，graphql 这种看上去好像只为查询而存在的语言，是不是有办法做到修改数据呢？</p>
<p>答案是：能。</p>
<p>仅仅为了使得 GraphQL 这个 data platform 变得更加完整，GraphQL 标准中加入了一种操作符，名为 mutation。因为我觉得这种设计确实比较一般，此处就不举例了，详情见：<a href="http://graphql.org/learn/queries/#mutations" target="_blank" rel="noopener">http://graphql.org/learn/queries/#mutations</a></p>
<h3 id="令人期待的-subscription"><a href="#令人期待的-subscription" class="headerlink" title="令人期待的 subscription"></a>令人期待的 subscription</h3><p>如何在浏览器中接受服务端的推送信息是个老生常谈的问题。从最初的轮询，到后来的 WebSocket。如今 GraphQL 也计划引入除了 query, mutation 以外的第三种操作符 subscription，以便于直接接受服务器推送数据。在 2015 年底 GraphQL 官方发布了一篇博文：Subscriptions in GraphQL and Relay 来介绍 subscription 在他们的 iOS 和 Android App 中的应用。可惜的是相关的代码仍未开源，目前开源社区能找到的解决方案目前只有 Apollo 社区为 Node.js 写的 graphql-subscriptions。</p>
<h3 id="GraphQL-有什么缺点？"><a href="#GraphQL-有什么缺点？" class="headerlink" title="GraphQL 有什么缺点？"></a>GraphQL 有什么缺点？</h3><ul>
<li>N + 1 问题<br>以下解决方案仅针对关系型数据库，如果你的项目中使用的是 NoSQL，可能解决方案有较大差别。</li>
</ul>
<p>针对一对一的关系（比如我上面举例中提到的这个 User 与 UserScore 的关系），在从数据库里抓取数据时，就将所需数据 join 到一张表里。别等着 ORM 框架替你懒加载那些你需要的数据。<br>针对多对一或者多对多的关系，你就要用到一个叫做 DataLoader 的工具库了。其中，Facebook 为 Node.js 社区提供了 DataLoader 的实现。DataLoader 的主要功能是 batching &amp; caching，可以将多次数据库查询的请求合并为一个，同时已经加载过的数据可以直接从 DataLoader 的缓存空间中获取到。这个话题要是展开说也得写一篇新的文章了，此处不多赘述。</p>
<h3 id="有什么可以快乐地调试-GraphQL-接口的方法？"><a href="#有什么可以快乐地调试-GraphQL-接口的方法？" class="headerlink" title="有什么可以快乐地调试 GraphQL 接口的方法？"></a>有什么可以快乐地调试 GraphQL 接口的方法？</h3><p>GraphiQL / live demo</p>
<p>使用 GraphiQL 可以很容易地让人感受到“代码即文档”的快乐。</p>
<p>扩展阅读: <a href="https://graphql.org/" target="_blank" rel="noopener">https://graphql.org/</a>  <a href="https://www.howtographql.com/graphql-python/0-introduction/" target="_blank" rel="noopener">https://www.howtographql.com/graphql-python/0-introduction/</a></p>
]]></content>
      <categories>
        <category>graphql</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>graphql</tag>
      </tags>
  </entry>
  <entry>
    <title>python中使用grpc</title>
    <url>/2018-3-27-grpc.html</url>
    <content><![CDATA[<p>###简介<br>gRPC  是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持.</p>
<p>gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p>
<p>###gRPC 是什么？<br>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</p>
<p><img src="/img/in-post/post-grpc/grpc_concept_diagram.png" alt="正则图"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install grpc</span><br><span class="line">pip install grpcio</span><br><span class="line">pip install grpcio-tools</span><br></pre></td></tr></table></figure>

<p>####编写数据data.proto</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">package example;</span><br><span class="line">message Data &#123;</span><br><span class="line">  string text = 1;</span><br><span class="line">&#125;</span><br><span class="line">service FormatData &#123;</span><br><span class="line">  rpc DoFormat(Data) returns (Data)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####生成客户端和服务器端代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I. –python_out=. –grpc_python_out=. data.proto</span><br></pre></td></tr></table></figure>

<p>###客户端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> data_pb2_grpc</span><br><span class="line"><span class="keyword">import</span> data_pb2</span><br><span class="line"></span><br><span class="line">_HOST = <span class="string">'0.0.0.0'</span></span><br><span class="line">_PORT = <span class="string">'8080'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    conn = grpc.insecure_channel(_HOST + <span class="string">':'</span> + _PORT)</span><br><span class="line">    client = data_pb2_grpc.FormatDataStub(channel=conn)</span><br><span class="line">    response = client.DoFormat(data_pb2.Data(text=<span class="string">'hello,world!'</span>))</span><br><span class="line">    print(<span class="string">"received: "</span> + response.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>###服务器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> data_pb2_grpc</span><br><span class="line"><span class="keyword">import</span> data_pb2</span><br><span class="line"></span><br><span class="line">_ONE_DAY_IN_SECONDS = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line">_HOST = <span class="string">'0.0.0.0'</span></span><br><span class="line">_PORT = <span class="string">'8080'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormatData</span><span class="params">(data_pb2_grpc.FormatDataServicer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DoFormat</span><span class="params">(self, request, context)</span>:</span></span><br><span class="line">        str = request.text</span><br><span class="line">        <span class="keyword">return</span> data_pb2.Data(text=str.upper())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">()</span>:</span></span><br><span class="line">    grpcServer = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">4</span>))</span><br><span class="line">    data_pb2_grpc.add_FormatDataServicer_to_server(FormatData(), grpcServer)</span><br><span class="line">    grpcServer.add_insecure_port(_HOST + <span class="string">':'</span> + _PORT)</span><br><span class="line">    grpcServer.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'enter try'</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'enter True'</span></span><br><span class="line">            time.sleep(_ONE_DAY_IN_SECONDS)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'after time.sleep'</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        grpcServer.stop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>grpc</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>google</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>获取http only数据</title>
    <url>/2018-3-28-get_http_only.html</url>
    <content><![CDATA[<p>###nightmare</p>
<p>A Conservative<br>Published<br>November 19, 2016<br>in JavaScript<br>爬虫的终极形态：nightmare<br>nightmare 是一个基于 electron 的自动化库（意思是说它自带浏览器），用于实现爬虫或自动化测试。相较于传统的爬虫框架（scrapy/pyspider），或者dom操作库（cheerio/jsdom），或者基于浏览器的自动化框架（selenium/phantomjs），他的优势在于提供了一个简洁有效 的编程模型。</p>
<p>###安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install init -y </span><br><span class="line">npm install --save-dev spectron</span><br><span class="line">npm install --save nightmare</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>###获取cookie</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">openDevTools: &#123;</span><br><span class="line">      mode: <span class="string">'bottom'</span>,       <span class="comment">// 开发者工具位置：right, bottom, undocked, detach</span></span><br><span class="line">&#125;,</span><br><span class="line">  show: <span class="literal">true</span>,                 <span class="comment">// 要不要显示浏览器</span></span><br><span class="line">  dock: <span class="literal">true</span>,                 <span class="comment">// 要不要在Dock上显示图标</span></span><br><span class="line">  waitTimeout: <span class="number">6000000</span>,         <span class="comment">// .wait() 方法超时时长，单位:ms</span></span><br><span class="line">  executionTimeout: <span class="number">86400000</span>, <span class="comment">// .evaluate() 方法超时时长，单位:ms</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Nightmare = <span class="built_in">require</span>(<span class="string">'nightmare'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nightmare = Nightmare(option);</span><br><span class="line"></span><br><span class="line">nightmare.goto(<span class="string">'https://baidu.com/'</span>)</span><br><span class="line">  .evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.title;</span><br><span class="line">  &#125;)</span><br><span class="line">  .wait(<span class="string">'#MainMenuNew1_m3'</span>)</span><br><span class="line">  <span class="comment">//.cookies.get(&#123; url: null &#125;)</span></span><br><span class="line">  .cookies.get(&#123;</span><br><span class="line">     domain: <span class="string">'baidu.com'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">cookies</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(cookies);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加载完成'</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium python笔记</title>
    <url>/2018-6-13-selenium-python.html</url>
    <content><![CDATA[<h3 id="selenium-python"><a href="#selenium-python" class="headerlink" title="selenium python"></a>selenium python</h3><ul>
<li>最新版selenium 3.x已经不支持phantomjs了，桑心；需要用phantomjs的可以用selenium2.x</li>
<li>selenium调用webdriver可以是本地的浏览器也可以是远程的，本地的webdriver(chrome,firefox)都需要下载driver，远程的需要下载一个selenium-stand，然后java -jar selenium-server-standalone-3.12.0.jar</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line">USER_AGENT = <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36'</span></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">'user-agent=&#123;&#125;'</span>.format(USER_AGENT))</span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line"><span class="comment"># local webdriver</span></span><br><span class="line">driver = webdriver.Firefox(executable_path=<span class="string">'./geckodriver'</span>, firefox_options=chrome_options)</span><br><span class="line"><span class="comment"># remote webdriver</span></span><br><span class="line">dcap = dict(DesiredCapabilities.PHANTOMJS)</span><br><span class="line">dcap[<span class="string">"phantomjs.page.settings.userAgent"</span>] = (</span><br><span class="line">    <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36'</span></span><br><span class="line">)</span><br><span class="line">driver = webdriver.remote.webdriver.WebDriver(command_executor=<span class="string">"http://172.16.56.13:4444/wd/hub"</span>,</span><br><span class="line">                                        desired_capabilities=dcap)</span><br><span class="line"><span class="comment"># set cookie</span></span><br><span class="line">driver.get(<span class="string">'https://baidu.com/'</span>)</span><br><span class="line">driver.delete_all_cookies()</span><br><span class="line">cookie_list = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'hehe'</span>, <span class="string">'value'</span>:<span class="string">'222'</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cookie_list:</span><br><span class="line">    driver.add_cookie(i)</span><br><span class="line">real_url = <span class="string">'https://baidu.com'</span></span><br><span class="line">driver.get(real_url)</span><br><span class="line"><span class="comment"># screenshot</span></span><br><span class="line">driver.get_screenshot_as_file(before_png)</span><br><span class="line"><span class="comment"># save html</span></span><br><span class="line"><span class="keyword">with</span> open(before_html, <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(driver.page_source.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># find selector and click</span></span><br><span class="line">next_step = driver.find_element_by_css_selector(<span class="string">'a[data="guideLayer"]'</span>)</span><br><span class="line">next_step.click()</span><br><span class="line"><span class="comment"># scrop selector</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crop_selector</span><span class="params">(driver, filename, selector, dist)</span>:</span></span><br><span class="line">    <span class="string">""" crop photo through selector. """</span></span><br><span class="line">    element = driver.find_element_by_css_selector(selector)</span><br><span class="line">    left = element.location[<span class="string">'x'</span>]</span><br><span class="line">    top = element.location[<span class="string">'y'</span>]</span><br><span class="line">    right = element.location[<span class="string">'x'</span>] + element.size[<span class="string">'width'</span>]</span><br><span class="line">    bottom = element.location[<span class="string">'y'</span>] + element.size[<span class="string">'height'</span>]</span><br><span class="line"></span><br><span class="line">    im = Image.open(filename)</span><br><span class="line">    im = im.crop((left, top, right, bottom))</span><br><span class="line">    im.save(dist)</span><br><span class="line">crop_selector(driver, full_screen, <span class="string">'img.book'</span>, email)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<ul>
<li>几个小坑</li>
</ul>
<ol>
<li>add_cookie在使用chrome或firefox作为webdriver的时候，必须先get一次目标站点的域名，然后再add，推测可能是driver的问题，使用phantomjs可以直接add之后再get；</li>
<li>remote webdriver使用phantomjs必须使用selenium-server-standalone-2.x.jar<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar selenium-server-standalone-2.53.1.jar  -Dphantomjs.binary.path=/usr/local/bin/phantomjs</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>python调用grpc服务设置headers</title>
    <url>/2018-12-03.html</url>
    <content><![CDATA[<h3 id="python安装grpc相关库"><a href="#python安装grpc相关库" class="headerlink" title="python安装grpc相关库"></a>python安装grpc相关库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install grpc grpcio grpcio-tools</span><br><span class="line">pip install protobuf #注意版本，开发过程中遇到过不同版本的protobuf不兼容的情况</span><br></pre></td></tr></table></figure>

<h3 id="python中引入第三方proto文件"><a href="#python中引入第三方proto文件" class="headerlink" title="python中引入第三方proto文件"></a>python中引入第三方proto文件</h3><p>下载第三方proto文件到你本地proto目录，最好把路径都改到一级目录，省去很多不必要的麻烦<br>生成<em>.pb2.py和</em>.pb2_grpc.py文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. http.proto</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果使用目标pb2文件过程中依赖第三方的pb2文件，可以再次执行上面 python -m 生成第三方的pb2文件。</p>
<h3 id="python设置grpc请求头headers："><a href="#python设置grpc请求头headers：" class="headerlink" title="python设置grpc请求头headers："></a>python设置grpc请求头headers：</h3><p>查阅了网上所有的资料都没有看到定制headers的方法，最终在grpc python example代码中发现了一种使用拦截器的方法，有点麻烦，不过能解决问题，如果你发现更方便的方法，麻烦告知我一下，万分感谢，拦截器方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GenericClientInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="class"><span class="params">        grpc.UnaryUnaryClientInterceptor, grpc.UnaryStreamClientInterceptor,</span></span></span><br><span class="line"><span class="class"><span class="params">        grpc.StreamUnaryClientInterceptor, grpc.StreamStreamClientInterceptor)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interceptor_function)</span>:</span></span><br><span class="line">        self._fn = interceptor_function</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intercept_unary_unary</span><span class="params">(self, continuation, client_call_details, request)</span>:</span></span><br><span class="line">        new_details, new_request_iterator, postprocess = self._fn(</span><br><span class="line">            client_call_details, iter((request,)), <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line">        response = continuation(new_details, next(new_request_iterator))</span><br><span class="line">        <span class="keyword">return</span> postprocess(response) <span class="keyword">if</span> postprocess <span class="keyword">else</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intercept_unary_stream</span><span class="params">(self, continuation, client_call_details,</span></span></span><br><span class="line"><span class="function"><span class="params">                               request)</span>:</span></span><br><span class="line">        new_details, new_request_iterator, postprocess = self._fn(</span><br><span class="line">            client_call_details, iter((request,)), <span class="literal">False</span>, <span class="literal">True</span>)</span><br><span class="line">        response_it = continuation(new_details, next(new_request_iterator))</span><br><span class="line">        <span class="keyword">return</span> postprocess(response_it) <span class="keyword">if</span> postprocess <span class="keyword">else</span> response_it</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intercept_stream_unary</span><span class="params">(self, continuation, client_call_details,</span></span></span><br><span class="line"><span class="function"><span class="params">                               request_iterator)</span>:</span></span><br><span class="line">        new_details, new_request_iterator, postprocess = self._fn(</span><br><span class="line">            client_call_details, request_iterator, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line">        response = continuation(new_details, new_request_iterator)</span><br><span class="line">        <span class="keyword">return</span> postprocess(response) <span class="keyword">if</span> postprocess <span class="keyword">else</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intercept_stream_stream</span><span class="params">(self, continuation, client_call_details,</span></span></span><br><span class="line"><span class="function"><span class="params">                                request_iterator)</span>:</span></span><br><span class="line">        new_details, new_request_iterator, postprocess = self._fn(</span><br><span class="line">            client_call_details, request_iterator, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line">        response_it = continuation(new_details, new_request_iterator)</span><br><span class="line">        <span class="keyword">return</span> postprocess(response_it) <span class="keyword">if</span> postprocess <span class="keyword">else</span> response_it</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(intercept_call)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _GenericClientInterceptor(intercept_call)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ClientCallDetails</span><span class="params">(</span></span></span><br><span class="line"><span class="class"><span class="params">        collections.namedtuple<span class="params">(</span></span></span></span><br><span class="line"><span class="class"><span class="params"><span class="params">            <span class="string">'_ClientCallDetails'</span>,</span></span></span></span><br><span class="line"><span class="class"><span class="params"><span class="params">            <span class="params">(<span class="string">'method'</span>, <span class="string">'timeout'</span>, <span class="string">'metadata'</span>, <span class="string">'credentials'</span>)</span>)</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">        grpc.ClientCallDetails)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">header_adder_interceptor</span><span class="params">(header, value)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intercept_call</span><span class="params">(client_call_details, request_iterator, request_streaming,</span></span></span><br><span class="line"><span class="function"><span class="params">                       response_streaming)</span>:</span></span><br><span class="line">        metadata = []</span><br><span class="line">        <span class="keyword">if</span> client_call_details.metadata <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            metadata = list(client_call_details.metadata)</span><br><span class="line">        metadata.append((</span><br><span class="line">            header,</span><br><span class="line">            value,</span><br><span class="line">        ))</span><br><span class="line">        client_call_details = _ClientCallDetails(</span><br><span class="line">            client_call_details.method, client_call_details.timeout, metadata,</span><br><span class="line">            client_call_details.credentials)</span><br><span class="line">        <span class="keyword">return</span> client_call_details, request_iterator, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> create(intercept_call)</span><br><span class="line"></span><br><span class="line">server_address=<span class="string">'www.example.com:50000'</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'server.pem'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    creds = grpc.ssl_channel_credentials(f.read())</span><br><span class="line">token = <span class="string">'123'</span></span><br><span class="line">header_adder_interceptor = header_adder_interceptor(<span class="string">'authorization'</span>, <span class="string">'token &#123;&#125;'</span>.format(token))</span><br><span class="line">channel = grpc.secure_channel(server_address, creds) <span class="comment">#使用https证书的方法，需要可以参考一下，不需要证书可以使用grpc.insecure_channel()</span></span><br><span class="line">intercept_channel = grpc.intercept_channel(channel, header_adder_interceptor)</span><br><span class="line">stub = resume_pb2_grpc.ResumeStub(intercept_channel)</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体使用过程中可以把header_adder_interceptor抽象出来变成个服务</p>
</li>
<li><p>还有个请求地址的问题，记住https证书只针对域名，不会针对ip，所以地址必须写成域名，本地测试可以把域名到ip的映射写到hosts文件中</p>
</li>
</ul>
]]></content>
      <categories>
        <category>grpc</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Tesseract-training-recognize-lib</title>
    <url>/2018-9-10-tesseract-training.html</url>
    <content><![CDATA[<h3 id="tesseract训练"><a href="#tesseract训练" class="headerlink" title="tesseract训练"></a>tesseract训练</h3><h2 id="采集样本："><a href="#采集样本：" class="headerlink" title="采集样本："></a>采集样本：</h2><ul>
<li>获取足够多的样本数据，必须是能够覆盖所有被识别的字符集，如果字体比较固定比如印刷体或者是网络的字体库，可以尝试采集到每一个字符然后合成字体库，用完整的一套字体库来训练</li>
</ul>
<h3 id="三种训练方法对比"><a href="#三种训练方法对比" class="headerlink" title="三种训练方法对比"></a>三种训练方法对比</h3><ol>
<li>找到需要识别的图片文本的字体，用字体库训练相应的库 (一般验证码很难找到字体库，找到字体的希望很渺茫)；</li>
<li>采集到足够多的样本，然后切割响应字符串，最后组成一套非重复字符的字体集合，然后训练，亲测有效，特点：准确率高，切割和合并字符可能会麻烦一点;</li>
<li>采集到尽可能多的样本，用所有的样本来训练，特点：工作量大，效果不一定好</li>
</ol>
<h3 id="生成tif字体库"><a href="#生成tif字体库" class="headerlink" title="生成tif字体库"></a>生成tif字体库</h3><p>原始需要识别图片转换成tif字体文件，linux有个convert命令可以转换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">convert test.png num.font.exp0.tif</span><br></pre></td></tr></table></figure>

<h3 id="生成训练文件-tr"><a href="#生成训练文件-tr" class="headerlink" title="生成训练文件.tr"></a>生成训练文件.tr</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tesseract num.font.exp2.tif num.font.exp2 batch.nochop makebox -psm 7 digits</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的命令可以更加需求添加相关参数来提高初次识别的准确率<br>下载jTessBoxEditor,运行软件， 然后打开刚刚生成的tif文件来挑战识别有误的字符<br>创建font_properties文件写入：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">font 0 0 0 0 0 # 【语法】：&lt;fontname&gt; &lt;italic&gt; &lt;bold&gt; &lt;fixed&gt; &lt;serif&gt; &lt;fraktur&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>tesseract.exe num.font.exp0.tif num.font.exp0 nobatch box.train </p>
<h3 id="生成训练库并打包到语言包目录"><a href="#生成训练库并打包到语言包目录" class="headerlink" title="生成训练库并打包到语言包目录"></a>生成训练库并打包到语言包目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unicharset_extractor *.box</span><br><span class="line">shapeclustering -F font_properties -U unicharset *.tr</span><br><span class="line">mftraining -F font_properties  -U unicharset *.tr</span><br><span class="line">cntraining *.tr</span><br><span class="line">mv unicharset shouxie.unicharset</span><br><span class="line">mv inttemp shouxie.inttemp</span><br><span class="line">mv normproto shouxie.normproto</span><br><span class="line">mv pffmtable shouxie.pffmtable</span><br><span class="line">mv shapetable shouxie.shapetable</span><br><span class="line">combine_tessdata shouxie.</span><br><span class="line">cp shouxie.traineddata /usr/local/share/tessdata/</span><br></pre></td></tr></table></figure>

<ul>
<li><p>然后就可以使用shouxie语言库了<br>tesseract ../shouji1.png stdout -l shouxie</p>
</li>
<li><p>训练语言库可以两种语言混合，有点类似基因结合，另外还可以用一些图片降噪手段来增加图片的清晰度来提高准确率；tesseract很强大，能做很多事情，期待后面能够找到更多的应用场景；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>验证码识别</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
        <tag>验证码识别</tag>
        <tag>训练</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫利器requests_html</title>
    <url>/2018-8-6-requests_html.html</url>
    <content><![CDATA[<h3 id="requests-html："><a href="#requests-html：" class="headerlink" title="requests_html："></a>requests_html：</h3><ul>
<li>python大神kenneth reitz小哥哥的又一爬虫神器(上次是requests)，官网给出的我这渣渣英语就不翻译了，内容如下：</li>
</ul>
<ul>
<li>Full JavaScript support!</li>
<li>CSS Selectors (a.k.a jQuery-style, thanks to PyQuery).</li>
<li>XPath Selectors, for the faint at heart.</li>
<li>Mocked user-agent (like a real web browser).</li>
<li>Automatic following of redirects.</li>
<li>Connection–pooling and cookie persistence.</li>
<li>The Requests experience you know and love, with magical parsing abilities.</li>
</ul>
<ol>
<li><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install requests-html</span><br><span class="line"><span class="meta">#</span> requests-html必须3.6以上的python版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> requests_html <span class="keyword">import</span> HTMLSession</span><br><span class="line">session = HTMLSession()</span><br><span class="line">r = session.get(<span class="string">'https://python.org/'</span>)</span><br><span class="line"><span class="comment"># 获取页面所有链接</span></span><br><span class="line">r.html.links</span><br><span class="line"><span class="comment"># 获取页面所有链接的绝对地址</span></span><br><span class="line">r.html.absolute_links</span><br><span class="line"><span class="comment"># &#123;'https://github.com/python/pythondotorg/issues', ...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Select an Element with a CSS Selector </span></span><br><span class="line">about = r.html.find(<span class="string">'#about'</span>, first=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Introspect an Element’s attributes (learn more):</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>about.attrs</span><br><span class="line">&#123;<span class="string">'id'</span>: <span class="string">'about'</span>, <span class="string">'class'</span>: (<span class="string">'tier-1'</span>, <span class="string">'element-1'</span>), <span class="string">'aria-haspopup'</span>: <span class="string">'true'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Search for text on the page:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.html.search(<span class="string">'Python is a &#123;&#125; language'</span>)[<span class="number">0</span>]</span><br><span class="line">programming</span><br><span class="line"></span><br><span class="line"><span class="comment"># JavaScript Support</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = session.get(<span class="string">'http://myhuangzhuo.com/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.html.render()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>times = r.html.find(<span class="string">'#busuanzi_value_site_pv'</span>, first=<span class="literal">True</span>)</span><br><span class="line">In [<span class="number">7</span>]: times.text</span><br><span class="line">Out[<span class="number">7</span>]: <span class="string">'270 次'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>requests_html 对css选择器操作和xpath比较强大，加载简单的带js的页面支持很好；</li>
<li>js加载需要下载pyppeteer和相关浏览器支持，目前来看在截图和点击模拟用户行为操作方面没有phantomjs强大，功能有待发掘；</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>requests_html</tag>
      </tags>
  </entry>
  <entry>
    <title>kong中配置支持socketio</title>
    <url>/2019-04-08.html</url>
    <content><![CDATA[<p>###websocket<br>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
<p>###python websocket server实现</p>
<ol>
<li>socketio: flask_socketio <blockquote>
<ol>
<li>跨浏览器、跨平台，多种连接方式自动切换</li>
<li>功能完善，心跳检测，断线自动重连</li>
<li>使用方便，支持room和namespace;</li>
<li>server和client必须配套使用，不能直接用原生WebSocket</li>
</ol>
</blockquote>
</li>
<li>tornado_websocket<blockquote>
<ol>
<li>回掉方式，在异步化之后，并发处理能力应该不错，</li>
<li>因为是原生支持websocket而不像flask需要寻找第三方插件，所以可能更值得信赖</li>
</ol>
</blockquote>
</li>
<li>dwebsocket<blockquote>
<p>没有用过， github上star 100多，比较少</p>
</blockquote>
</li>
</ol>
<h3 id="flask-socketio实现"><a href="#flask-socketio实现" class="headerlink" title="flask_socketio实现"></a>flask_socketio实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> SocketIO, rooms</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">socketio = SocketIO(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ack</span><span class="params">(data)</span>:</span></span><br><span class="line">    print(<span class="string">'push msg success:&#123;&#125;'</span>.format(data)) <span class="comment">#增加推送成功回调</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">active_ws</span><span class="params">()</span>:</span></span><br><span class="line">    r = request.form</span><br><span class="line">    print(<span class="string">'push msg to:&#123;&#125;'</span>.format(r.to_dict()))</span><br><span class="line">    socketio.emit(<span class="string">'server_push'</span>, r.to_dict(), room=r.get(<span class="string">'socket_id'</span>),</span><br><span class="line">                  namespace=<span class="string">'/test'</span>, callback=ack)</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">'status'</span>: <span class="string">'ok'</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('connect', namespace='/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_connect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'client connected websocket: &#123;&#125;'</span>.format(*rooms()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('disconnect', namespace='/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_disconnect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'close websocket: &#123;&#125;'</span>.format(*rooms()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    socketio.run(app=app, port=<span class="number">9000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="kong中配置支持socketio"><a href="#kong中配置支持socketio" class="headerlink" title="kong中配置支持socketio"></a>kong中配置支持socketio</h3><blockquote>
<p>目前kong版本 1.3, 使用kong-dashboard v2;<br>增加api转发 注意upstream_url填ip, 否则可能报502;<br>增加cors插件，origins=* , Credentials=true;</p>
</blockquote>
<h3 id="socketio客户端连接"><a href="#socketio客户端连接" class="headerlink" title="socketio客户端连接"></a>socketio客户端连接</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var socket = io.connect('ws:/</span><span class="regexp">/localhost:9000/</span>test<span class="string">',</span></span><br><span class="line"><span class="string">           &#123;</span></span><br><span class="line"><span class="string">               path: '</span>/path/socket.io<span class="string">',</span></span><br><span class="line"><span class="string">               transport : ['</span>websocket<span class="string">']</span></span><br><span class="line"><span class="string">           &#125;</span></span><br><span class="line"><span class="string">   );</span></span><br><span class="line"><span class="string">   socket.on('</span>connect<span class="string">', function () &#123;</span></span><br><span class="line"><span class="string">       console.log(socket.id);</span></span><br><span class="line"><span class="string">   &#125;, namespace='</span>/wechat<span class="string">');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       socket.on('</span>server_push<span class="string">', function (data, ack) &#123;</span></span><br><span class="line"><span class="string">           console.log(socket.id);</span></span><br><span class="line"><span class="string">           console.log(data);</span></span><br><span class="line"><span class="string">           ack(&#123;'</span>socket_id<span class="string">': socket.id, '</span>status<span class="string">': '</span>ok<span class="string">'&#125;);</span></span><br><span class="line"><span class="string">       &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Socks5代理转Http协议</title>
    <url>/2019-04-12.html</url>
    <content><![CDATA[<p>###privoxy<br>privoxy在http代理服务方面之前跟tor进行合作，老牌值得信赖（tor后来转而跟polipo合作。不过实际使用过程，我发现还是privoxy的配置比较舒服。）。<br>相比proxychains，privoxy相当于直接在本地监听指定的端口，启动一个HTTP的代理服务，任何转发到这个端口的服务相当于使用了这一HTTP代理服务。</p>
<p>##安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install privoxy</span><br></pre></td></tr></table></figure>

<p>##配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/Cellar/privoxy/3.0.26/sbin/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在文档的最后添加如下语句，将接收到的数据转发到对应的ip和端口。</span><br><span class="line"><span class="meta">#</span> 此处，设定的监听端口为8118，数据转发到本地`127.0.0.1`；</span><br><span class="line">listen-address 0.0.0.0:8118</span><br><span class="line"></span><br><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure>

<p>##使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> mac下必须先cd /usr/local/Cellar/privoxy/3.0.26/sbin</span><br><span class="line">/usr/local/Cellar/privoxy/3.0.26/sbin/privoxy</span><br></pre></td></tr></table></figure>

<p>##终端配置代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"><span class="meta">#</span> edit</span><br><span class="line"><span class="meta">#</span> proxy list</span><br><span class="line">alias proxy='export all_proxy=http://127.0.0.1:8118'</span><br><span class="line">alias unproxy='unset all_proxy'</span><br><span class="line"><span class="meta">#</span> end edit</span><br><span class="line"><span class="meta">#</span> 然后shell下运行 proxy和unproxy切换终端是否代理：</span><br><span class="line">proxy</span><br></pre></td></tr></table></figure>

<p> 后面终端就可以使用http代理了</p>
<ul>
<li>另外今天发现了两个代理工具：brook和V2Ray,据说ss会被监听到，有空研究一下这两个工具</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>求最大公约数和最小公倍数</title>
    <url>/2020-03-25.html</url>
    <content><![CDATA[<h3 id="辗转相除法的推导："><a href="#辗转相除法的推导：" class="headerlink" title="辗转相除法的推导："></a>辗转相除法的推导：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">求x和y的最大公约数:</span></span><br><span class="line"><span class="string">假设 k = x / y , b = x % y, 则：</span></span><br><span class="line"><span class="string">1. x = k * y + b;</span></span><br><span class="line"><span class="string">假设 g为x和y的最大公约数: 则：</span></span><br><span class="line"><span class="string">2. x = g * c1 ; </span></span><br><span class="line"><span class="string">3. y = g * c2 ; (c1, c2为某个常数)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">将1带入2，可得：</span></span><br><span class="line"><span class="string">4. k * y + b = g * c1;</span></span><br><span class="line"><span class="string">将3带入4，可得：</span></span><br><span class="line"><span class="string">k * (g * c2) + b = g * c1 ==&gt; b = g * (c1 - k*c2)</span></span><br><span class="line"><span class="string">从而可得: b = g * c3;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">于是求x和y最大公约数函数 f(x, y) = f(y, b),</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x <span class="keyword">if</span> y==<span class="number">0</span> <span class="keyword">else</span> gcd(y, x%y)</span><br></pre></td></tr></table></figure>

<h3 id="辗转相减法："><a href="#辗转相减法：" class="headerlink" title="辗转相减法："></a>辗转相减法：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">求x和y的最大公约数:</span></span><br><span class="line"><span class="string">假设 g为x和y的最大公约数: 则：</span></span><br><span class="line"><span class="string">1. x = g * c1 ; </span></span><br><span class="line"><span class="string">2. y = g * c2 ; (c1, c2为某个常数)</span></span><br><span class="line"><span class="string">1减去2可得：</span></span><br><span class="line"><span class="string">x-y = g * (c1-c2)</span></span><br><span class="line"><span class="string">则可以推导出 y和x-y的最大公约数也是g ：</span></span><br><span class="line"><span class="string">于是：f(x, y) = f(y, x-y)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd_sub</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">while</span>(y):</span><br><span class="line">        <span class="keyword">if</span> y &gt; x:</span><br><span class="line">            x, y = y, x</span><br><span class="line">        x, y = y, x-y</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>python3高阶函数库functools</title>
    <url>/2019-06-12.html</url>
    <content><![CDATA[<p>###python2.7中functools库wrapper,reduce,partial,total_ordering,cmp_to_key</p>
<ul>
<li>cmp_to_key见名知意把cmp比较函数转换成key比较函数，python3中不支持cmp;</li>
<li>total_ordering 这个装饰器是在python2.7的时候加上的，它是针对某个类如果定义了<strong>lt</strong>、le、gt、<strong>ge</strong>这些方法中的至少一个，使用该装饰器，则会自动的把其他几个比较函数也实现在该类中;</li>
<li>reduce 和之前的reduce函数意义相同;</li>
<li>partial局部部分的意思，可以固定函数的部分参数变成定制的函数，看到有些书上翻译成偏函数感觉非常晦涩;</li>
<li>wrapper 装饰器函数，把装饰器函数伪装成被装饰函数，实际调用的是update_wrapper，源码设置了<strong>name</strong>,<strong>doc</strong>,<strong>module</strong>,<strong>dict</strong>属性给装饰器函数；</li>
</ul>
<h3 id="python3-6-5中functools库新增了lru-cache和singledispatch"><a href="#python3-6-5中functools库新增了lru-cache和singledispatch" class="headerlink" title="python3.6.5中functools库新增了lru_cache和singledispatch"></a>python3.6.5中functools库新增了lru_cache和singledispatch</h3><ul>
<li>lru_cache缓存计算结果</li>
<li>singledispatch 有点类似c++中的泛型和多态<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key, total_ordering, reduce, partial, wraps, lru_cache, singledispatch</span><br><span class="line"></span><br><span class="line">a = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_cmp</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; y:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">print(sorted(a, key=cmp_to_key(my_cmp)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@total_ordering #如果去掉 &gt;= 不能使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, first, last)</span>:</span></span><br><span class="line">        self.firstname = first</span><br><span class="line">        self.lastname = last</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ((self.lastname.lower(), self.firstname.lower()) ==</span><br><span class="line">                (other.lastname.lower(), other.firstname.lower()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ((self.lastname.lower(), self.firstname.lower()) &lt;</span><br><span class="line">                (other.lastname.lower(), other.firstname.lower()))</span><br><span class="line"></span><br><span class="line">c = Student(<span class="string">'abc'</span>, <span class="string">'kevin'</span>)</span><br><span class="line">b = Student(<span class="string">'zuang'</span>, <span class="string">'kevin'</span>)</span><br><span class="line">print(b &gt;= c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">three_mul = partial(mul, <span class="number">3</span>)</span><br><span class="line">print(three_mul(<span class="number">9</span>))</span><br><span class="line">print(reduce(mul, a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        t1 = time.perf_counter()</span><br><span class="line">        print(<span class="string">'func:&#123;&#125; args:&#123;&#125; cost:&#123;&#125;'</span>.format(func, args, t1 - t0))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache()</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t0 = time.perf_counter()</span><br><span class="line">print(fib(<span class="number">30</span>))</span><br><span class="line">t1 = time.perf_counter()</span><br><span class="line">print(<span class="string">'total:&#123;&#125;'</span>.format(t1 - t0))</span><br><span class="line">print(fib.__name__)</span><br><span class="line">print(fib.cache_info())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line">p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typecheck</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@typecheck.register(int)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(type(text))</span><br><span class="line">    print(<span class="string">'---int---'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@typecheck.register(str)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(type(text))</span><br><span class="line">    print(<span class="string">'---str---'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@typecheck.register(float)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(type(text))</span><br><span class="line">    print(<span class="string">'---float---'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typecheck(<span class="string">'ring'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>nginx开启gzip压缩</title>
    <url>/2020-04-24.html</url>
    <content><![CDATA[<h3 id="需求场景："><a href="#需求场景：" class="headerlink" title="需求场景："></a>需求场景：</h3><ul>
<li>最近在部署公司angularjs前端项目的时候，发现打包生成的一个main.js特别大达到了10M，感觉前端这边应该有很大的优化空间，试了好几种方式比如:加优化参数–aot, —-build-optimizer等都试过，生成的文件大小基本没有变化，于是就想从压缩静态文件入手；</li>
</ul>
<ol>
<li><p>angularjs项目中引入打包工具gzipper：</p>
</li>
<li><p>将打包命令写入package.json,参考如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ng build --prod &amp;&amp; gzipper --verbose --level 9 ./dist/my-app //level表示压缩级别：1-9(压缩率依次变高)</span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx配置支持gzip压缩:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在nginx配置http/server/location中加入如下配置:</span></span><br><span class="line">    gzip  on; //开启gzip</span><br><span class="line">    gzip_proxied no-cache no-store private expired auth; //代理的情况</span><br><span class="line">    gzip_min_length 1k; //gzip最小压缩大小</span><br><span class="line">    gzip_buffers 4 16k; </span><br><span class="line">    gzip_comp_level 5; //gzip压缩级别(1-9)</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript image/jpeg image/gif image/png; //支持压缩的文件类型</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_disable "MSIE [1-6]\."; //ie 1-6下禁用压缩</span><br><span class="line">    gzip_static on; //开启本地gzip文件的压缩，要求事先生成gzip文件</span><br><span class="line">    gzip_http_version   1.0; //gzip压缩版本，在多级代理的情况下默认可能会有坑</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包配置上线验证：<br>响应header中包含这个说明压缩成功：Content-Encoding:gzip<br>下图是对比<br><img src="/uploads/nginx-gzip/gzip-vs.png" alt><br><a href="https://medium.com/@subodhkumarjc/angular-build-optimization-part-2-compression-b866dd0593c3" target="_blank" rel="noopener">Angular Build貌似还可以用其他的压缩方式</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>leetcode第32题解题报告</title>
    <url>/2020-08-19.html</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><ol start="32">
<li>Longest Valid Parentheses</li>
</ol>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<ul>
<li><p>Example 1:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"(()"</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The longest valid parentheses substring <span class="keyword">is</span> <span class="string">"()"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Example 2:</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">")()())"</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: The longest valid parentheses substring <span class="keyword">is</span> <span class="string">"()()"</span></span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>符号对的匹配首先想到的是用栈来解决，左括号压栈，右括号匹配和出栈</li>
</ul>
<h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1:"></a>解法1:</h1><ul>
<li>用栈stack存储左括号的索引，start标记栈中最底部左括号索引，遇到右括号判断stack，若为空，则记录当前位置的下一个索引为start；若非空, 则出栈一个元素，再次判断栈是否为空，为空则 max(res, index-start+1), 否则 max(res, index-stack[-1]) ;<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    res, start, stack = <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">for</span> index, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">"("</span>:</span><br><span class="line">            stack.append(index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                stack.pop()</span><br><span class="line">                res = max(res, index-stack[<span class="number">-1</span>]) <span class="keyword">if</span> stack <span class="keyword">else</span> max(res, index-start+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = index+<span class="number">1</span> <span class="comment"># next ( position</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2:"></a>解法2:</h1><ul>
<li>使用动态规划<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    length = len(s)</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * length</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length):</span><br><span class="line">            <span class="comment">#当遇到右括号时，尝试向前匹配左括号</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">            pre = i - dp[i<span class="number">-1</span>] <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">#如果是左括号，则更新匹配长度</span></span><br><span class="line">            <span class="keyword">if</span> pre&gt;=<span class="number">0</span> <span class="keyword">and</span> s[pre] == <span class="string">'('</span>:</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="comment">#处理独立的括号对的情形 类似()()、()(())</span></span><br><span class="line">                <span class="keyword">if</span> pre&gt;<span class="number">0</span>:</span><br><span class="line">                    dp[i] += dp[pre<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> max(dp);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>or</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i+1]表示前i+1个索引最长括号对</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    dp, stack = [<span class="number">0</span>]*(len(s) + <span class="number">1</span>), []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                dp[i + <span class="number">1</span>] = dp[p] + i - p + <span class="number">1</span> <span class="comment"># </span></span><br><span class="line">    <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Chrome浏览器插件精选：开启高效上网的新纪元</title>
    <url>/2023-11-07.html</url>
    <content><![CDATA[<h1 id="Chrome浏览器插件精选：开启高效上网的新纪元"><a href="#Chrome浏览器插件精选：开启高效上网的新纪元" class="headerlink" title="Chrome浏览器插件精选：开启高效上网的新纪元"></a>Chrome浏览器插件精选：开启高效上网的新纪元</h1><p>在这个信息爆炸的时代，有效地管理您的在线活动已经变得至关重要。作为全球最受欢迎的浏览器之一，Chrome的功能可以通过一系列强大的插件来扩展。今天，我将向您介绍几个精选的Chrome插件，这些插件将帮助您打造一个更快、更智能、更个性化的上网体验。</p>
<h2 id="Adblock-屏蔽网页和视频广告"><a href="#Adblock-屏蔽网页和视频广告" class="headerlink" title="Adblock - 屏蔽网页和视频广告"></a>Adblock - 屏蔽网页和视频广告</h2><p><img src="/uploads/chrome-ext/abs-ext.jpeg" alt="Adblock"><br>当您浏览网页时，<strong>Adblock</strong> 插件可以帮助您屏蔽一切网页和视频广告。这不仅能为您提供一个更加清洁、无打扰的阅读环境，而且还能减少数据的消耗，加快页面加载速度。想象一下，在没有广告打断的情况下观看您最爱的视频或阅读文章，Adblock让这一切变为可能。</p>
<h2 id="GoFullPage-自动翻页截取整个网页内容"><a href="#GoFullPage-自动翻页截取整个网页内容" class="headerlink" title="GoFullPage - 自动翻页截取整个网页内容"></a>GoFullPage - 自动翻页截取整个网页内容</h2><p><img src="/uploads/chrome-ext/gofullpage1.jpeg" alt="GoFullPage1"><br><img src="/uploads/chrome-ext/gofullpage2.jpeg" alt="GoFullPage2"></p>
<p>对于需要保存网页信息的用户来说，<strong>GoFullPage - Full Page Screen Capture</strong> 插件是一个必备工具。它可以自动翻页并截取整个网页内容，保存为单一的图片文件。无论是整个网页的长篇文章还是丰富的教程内容，这个插件都可以帮您一键截图保存，简化您的工作流程。</p>
<h2 id="Google-翻译-最好用的翻译神器"><a href="#Google-翻译-最好用的翻译神器" class="headerlink" title="Google 翻译 - 最好用的翻译神器"></a>Google 翻译 - 最好用的翻译神器</h2><p><img src="/uploads/chrome-ext/googletranslate.jpeg" alt="googletranslate"></p>
<p>在遇到外语网页时，有了<strong>Google 翻译</strong> 插件，您可以即刻将网页翻译成您熟悉的语言。它不仅提供了便捷的页面翻译功能，还允许您对选定的文本进行即时翻译，这无疑是探索全球内容的最佳工具。</p>
<h2 id="Proxy-SwitchyOmega-支持http和socks的自动代理工具"><a href="#Proxy-SwitchyOmega-支持http和socks的自动代理工具" class="headerlink" title="Proxy SwitchyOmega - 支持http和socks的自动代理工具"></a>Proxy SwitchyOmega - 支持http和socks的自动代理工具</h2><p><img src="/uploads/chrome-ext/SwitchyOmega.jpeg" alt="SwitchyOmega"></p>
<p><strong>Proxy SwitchyOmega</strong> 插件是一种灵活的网络代理工具，它支持HTTP和SOCKS代理。它让您可以根据需要快速切换代理，不仅方便访问地区限制内容，也为您的网络安全提供了一层额外的保护。</p>
<h2 id="沙拉查词-聚合词典划词翻译的网页查词神器"><a href="#沙拉查词-聚合词典划词翻译的网页查词神器" class="headerlink" title="沙拉查词 - 聚合词典划词翻译的网页查词神器"></a>沙拉查词 - 聚合词典划词翻译的网页查词神器</h2><p><img src="/uploads/chrome-ext/sala.jpeg" alt="沙拉查词"></p>
<p>当您在阅读外语网页或学习新单词时，<strong>沙拉查词-聚合词典划词翻译</strong>插件能够迅速提供单词释义和用例。这是一个非常实用的工具，特别是对于语言学习者和多语种阅读者，它提供了一个即刻的查词和学习体验。</p>
<h2 id="启用右键-解除网站复制拷贝的限制"><a href="#启用右键-解除网站复制拷贝的限制" class="headerlink" title="启用右键 - 解除网站复制拷贝的限制"></a>启用右键 - 解除网站复制拷贝的限制</h2><p><img src="/uploads/chrome-ext/allowcopy.jpeg" alt="启用右键"></p>
<p>遇到限制右键菜单或者限制复制拷贝的网站时，<strong>启用右键 - 允许复制和选择</strong> 插件能帮助您解锁这一限制。这对于研究人员和学生来说非常有用，甚至可以在如飞书文档这样的平台上，轻松地选择和复制需要的文本。</p>
<h2 id="篡改猴-改变网络，用户脚本自由定制"><a href="#篡改猴-改变网络，用户脚本自由定制" class="headerlink" title="篡改猴 - 改变网络，用户脚本自由定制"></a>篡改猴 - 改变网络，用户脚本自由定制</h2><p><img src="/uploads/chrome-ext/chuangai.jpeg" alt="篡改猴"></p>
<p><strong>篡改猴</strong> 插件允许用户通过脚本自定义网站的功能和外观，它甚至能支持解除包括爱奇艺、哔哩哔哩、腾讯视频、优酷等在内的视频网站VIP限制。这是一个为高级用户提供极大自由度的工具，通过脚本可以实现网站的个性化修改。</p>
<h2 id="Similarweb-网站流量排名和分析"><a href="#Similarweb-网站流量排名和分析" class="headerlink" title="Similarweb - 网站流量排名和分析"></a>Similarweb - 网站流量排名和分析</h2><p><img src="/uploads/chrome-ext/Similarweb.jpeg" alt="Similarweb"></p>
<p>对于市场研究人员和网站运营者，<strong>Similarweb - 流量排名和网站分析</strong> 插件提供了丰富的网站分析数据。它展示网站排名、网站流量、来源和地理位置等关键指标，帮助您更好地理解竞争格局和用户行为。</p>
<p>这些Chrome插件将极大地提高您的工作效率和网络体验。他们是您数字工具箱中的宝贵资产，无论您是在研究、学习、工作还是娱乐，都会发现他们的巨大价值。立即尝试这些插件，让您的浏览体验更上一层楼！</p>
]]></content>
      <tags>
        <tag>chrome插件精选</tag>
        <tag>网页解除复制限制</tag>
      </tags>
  </entry>
</search>
